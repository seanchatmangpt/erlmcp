# erlmcp v1.3.0 Technical Decisions Matrix

**Date**: January 27, 2026
**Status**: SPECIFICATION PHASE
**Audience**: Architects, Tech Leads, Agent Coordinators

---

## 1. TRANSPORT OPTIMIZATION STRATEGY (Agent 1)

### Decision: Vectorized vs Single-Message Operations

**Context**: Current transport sends messages one-at-a-time. Throughput target is 95K msg/sec on 4KB payloads.

**Options**:

| Option | Approach | Throughput Potential | Complexity | Risk |
|--------|----------|---------------------|-----------|------|
| A: Batch vectorization | Group N messages, send vectorized | +25-40% | Medium | Latency variance |
| B: TCP_NODELAY + buffer | Optimize TCP stack settings | +10-15% | Low | Platform-dependent |
| C: Lock-free queues | Replace message queues | +20-30% | High | Correctness issues |
| D: Zero-copy transport | Memory-mapped buffers | +35-50% | Very High | GC issues |

**DECISION**: Option B (TCP_NODELAY + buffer tuning)
- **Rationale**: Lowest risk, high ROI, already proven in Erlang ecosystem
- **Implementation**:
  - Add `{nodelay, true}` to gun/ranch socket options
  - Tune `+sbwt` scheduler busy wait threshold (vm.args)
  - Profile with and without to validate 10-15% gain
- **Fallback**: If <10K improvement, investigate Option A (batch ops)
- **Evidence Required**: Before/after benchmark, CPU profile, latency histogram

**Config Addition**:
```erlang
{erlmcp, [
    {transport_opts, [
        {tcp_nodelay, true},
        {tcp_send_buf, 65536},  % 64KB send buffer
        {tcp_recv_buf, 65536}   % 64KB recv buffer
    ]}
]}
```

---

## 2. QUEUE BACKPRESSURE STRATEGY (Agent 2)

### Decision: Queue Capacity & Flow Control Signal

**Context**: Prevent OOM crashes from slow clients. Current baseline has no queue limits.

**Options**:

| Option | Queue Cap | Signal | Recovery | Complexity |
|--------|-----------|--------|----------|-----------|
| A: Hard cap + drop | 500 msgs | Error on overflow | Manual restart | Low |
| B: Hard cap + backoff | 1000 msgs | Slow to send | Auto-recovery | Medium |
| C: Soft cap + warn | 2000 msgs | Warn at 80% | Gradual backoff | Medium |
| D: Per-client pool | 500-5000 msgs | Pool signal | Per-client backoff | High |

**DECISION**: Option B (Hard cap with exponential backoff)
- **Rationale**: Deterministic behavior, simple recovery, doesn't require per-client state
- **Implementation**:
  - Default cap: 1000 messages per connection
  - Backoff: exponential (1ms → 2ms → 4ms → 8ms) up to 100ms
  - Recovery: auto-resume when queue <50% full
  - Config: `{backpressure_enabled, true}`, `{max_queue_size, 1000}`
- **Evidence Required**: Queue size never exceeds cap (property test), memory stable curve

**Backpressure State Machine**:
```erlang
-type bp_state() ::
    active |                      % Queue <50%
    warning |                     % Queue 50-90%
    congested |                   % Queue >90%
    overloaded.                   % Queue at cap

%% Transitions:
%% active --[queue>50%]--> warning
%% warning --[queue>90%]--> congested
%% congested --[send fails]--> overloaded
%% overloaded --[wait & retry]--> congested --[recover]--> active
```

---

## 3. CIRCUIT BREAKER STRATEGY (Agent 3)

### Decision: Failure Detection & Recovery Algorithm

**Context**: Prevent retry storms when remote service is failing. Need fast fail-fast + eventual recovery.

**Options**:

| Option | Algorithm | TTL | Fail-Fast | Recovery Speed |
|--------|-----------|-----|-----------|-----------------|
| A: Simple counter | N failures in 30s window | 30s | Good | 30s wait |
| B: Exponential backoff | Failure rate + exp backoff | Adaptive | Excellent | Slow (starts 2m) |
| C: Token bucket | Rate-limited tokens | Configurable | Good | Smooth |
| D: Google SRE pattern | Circuit + half-open + reset | 60s default | Excellent | Fast (60s) |

**DECISION**: Option D (Google SRE pattern - standard Erlang circuit_breaker)
- **Rationale**: Proven pattern, matches industry standard (AWS, GCP), easy to understand
- **Implementation**:
  - States: CLOSED (normal) → OPEN (fail-fast) → HALF_OPEN (test) → CLOSED
  - CLOSED→OPEN: After 5 failures within 30s window
  - OPEN→HALF_OPEN: After 60s idle time
  - HALF_OPEN→CLOSED: On 1 success
  - HALF_OPEN→OPEN: On 1 failure
- **Evidence Required**: Retry count metrics, recovery time histogram, no retry storms >5/30s

**Configuration**:
```erlang
{erlmcp, [
    {circuit_breaker, [
        {enabled, true},
        {failure_threshold, 5},        % failures before open
        {failure_window_ms, 30000},    % 30s window
        {timeout_ms, 60000},           % 60s in OPEN before HALF_OPEN
        {half_open_max_calls, 3}       % max requests in HALF_OPEN
    ]}
]}
```

---

## 4. BULKHEAD ISOLATION STRATEGY (Agent 4)

### Decision: Bulkhead Architecture (Fixed vs Dynamic)

**Context**: Prevent single bad connection from crashing entire system. Need deterministic failure domains.

**Options**:

| Option | Approach | Isolation Level | Complexity | Scalability |
|--------|----------|-----------------|-----------|------------|
| A: Fixed bulkheads | 8 fixed supervisors | Per-group (125K/bulkhead) | Low | Limited to 8 domains |
| B: Dynamic per-conn | 1 supervisor per connection | Per-connection (1K/domain) | Very High | Excellent but risky |
| C: Hybrid (8 + sharding) | Fixed 8, with internal sharding | Moderate | High | Good (8x + internal hash) |
| D: Process group limits | Use OTP process groups | Soft isolation | Medium | Flexible |

**DECISION**: Option A (Fixed 8 bulkheads)
- **Rationale**: Deterministic, simple, matches supervision tree philosophy
- **Implementation**:
  - Create 8 named bulkhead supervisors at startup (bulkhead_1 → bulkhead_8)
  - Hash connection ID to bulkhead (erlang:phash2(ConnId, 8) + 1)
  - Each bulkhead: one_for_one supervisor
  - Monitor bulkhead health (crashes, restart rate)
- **Scalability**: 100K connections ÷ 8 bulkheads = 12.5K per bulkhead
- **Evidence Required**: Zero crash propagation tests, bulkhead restart metrics

**Supervision Tree**:
```
erlmcp_sup (one_for_all)
├── erlmcp_registry
├── [8 bulkhead supervisors]
│   ├── bulkhead_sup_1 (simple_one_for_one)
│   │   └── [client/server processes for ConnectionId % 8 == 0]
│   ├── bulkhead_sup_2
│   │   └── [client/server processes for ConnectionId % 8 == 1]
│   └── ... (bulkhead_8)
└── erlmcp_transport_sup
```

**Configuration**:
```erlang
{erlmcp, [
    {bulkhead_count, 8},
    {bulkhead_restart_intensity, 5},    % max 5 restarts
    {bulkhead_restart_period, 60},      % within 60s
    {bulkhead_max_wait_for_cleanup, 5000}  % 5s cleanup timeout
]}
```

---

## 5. REGISTRY SCALING STRATEGY (Agent 5)

### Decision: Registry Architecture at 100K Scale

**Context**: Current registry handles 15K connections well. Need to scale to 100K with <1ms p99 lookup.

**Options**:

| Option | Architecture | p99 Lookup | Memory Overhead | Complexity |
|--------|--------------|-----------|-----------------|-----------|
| A: Monolithic ETS | Single table | 1-2ms at 100K | ~50MB | Very Low |
| B: Sharded ETS | 16 shards (hash-based) | 0.2-0.5ms | ~50MB | Medium |
| C: Hierarchical | Tree structure | 0.5-1ms | ~40MB | High |
| D: Distributed | Multi-node | <0.1ms | ~50MB per node | Very High |

**DECISION**: Option B (Sharded ETS with 16 shards)
- **Rationale**: Sub-millisecond p99, moderate complexity, proven in erlmcp already (registry_sharded.erl exists)
- **Implementation**:
  - Use existing `erlmcp_registry_sharded.erl`
  - 16 shards (power of 2 for fast modulo: `hash(Key) band 15`)
  - Each shard: separate ETS table (less contention)
  - Atomic operations at shard level
- **Scalability**: 100K connections ÷ 16 shards = 6.25K per shard
- **Evidence Required**: p99 lookup <1ms at 100K, ETS lock time <100us, linear memory scaling

**Configuration**:
```erlang
{erlmcp, [
    {registry, [
        {type, sharded},
        {shard_count, 16},
        {table_type, set},  % or bag if duplicates needed
        {ets_options, [compressed, {read_concurrency, true}]}
    ]}
]}
```

---

## 6. PROTOCOL SAFETY STRATEGY (Agent 6)

### Decision: Initialization State Machine Enforcement

**Context**: MCP protocol requires initialize() before operations. Current implementation may be lenient.

**Options**:

| Option | Approach | Strictness | Backward Compat | Complexity |
|--------|----------|-----------|-----------------|-----------|
| A: Lenient | Warn if not initialized | Low | 100% | Low |
| B: Strict after V1.2 | Reject pre-init ops | Medium | 90% | Low |
| C: Very Strict | Reject everything pre-init | High | 70% | Very Low |
| D: Configurable | Mode per client | Variable | 100% | Medium |

**DECISION**: Option B (Strict after V1.2, with deprecation path)
- **Rationale**: Production safety + backward compatibility
- **Implementation**:
  - Phase enforcement in `erlmcp_client` state machine (already exists)
  - Phases: `pre_initialization` → `initializing` → `initialized` → `error|closed`
  - Pre-init operations: ERROR with phase info
  - Timeout: initialize() must complete within 30s (default, configurable)
  - Add deprecation notice: v1.2 warns, v1.3+ rejects
- **Evidence Required**: 100% pre-init call rejection, timeout enforcement ±5%

**Protocol State Machine**:
```erlang
%% Client phases:
%% pre_initialization: Just created, no initialize() called
%% initializing: initialize() in progress, waiting for server response
%% initialized: Ready for operations (list_tools, call_tool, etc.)
%% error: initialize() failed, must reconnect
%% closed: Explicitly closed or transport died

%% Enforcement rules:
%% list_tools, call_tool, list_resources: ONLY in initialized state
%% list_prompts, get_prompt: ONLY in initialized state
%% initialize: ONLY in pre_initialization state (idempotent guard)
%% stop: Valid in any state
```

---

## 7. LIFECYCLE CLEANUP STRATEGY (Agent 7)

### Decision: Resource Disposal & TTL Enforcement

**Context**: Subscriptions and tasks may leak if not cleaned up. Need deterministic cleanup.

**Options**:

| Option | Cleanup Method | Leak Risk | Latency | Complexity |
|--------|----------------|-----------|---------|-----------|
| A: Manual only | Client must unsub | High | N/A | Very Low |
| B: TTL + batch cleanup | Background job, 5min TTL | Very Low | Batch | Medium |
| C: Reference counting | Track refs, cleanup on 0 | Medium | Immediate | High |
| D: Hybrid (explicit + TTL) | Unsub explicit, TTL fallback | Very Low | Immediate | Medium |

**DECISION**: Option D (Hybrid - explicit + TTL fallback)
- **Rationale**: Production-safe (no leaks), explicit fast path, automatic fallback
- **Implementation**:
  - Explicit unsubscribe() call removes handler immediately
  - Background cleanup job runs every 60s
  - Handler TTL: 5 minutes (configurable)
  - Task TTL: 1 hour (configurable)
  - Cleanup: Delete expired handlers + tasks from ETS
- **Evidence Required**: Zero handler leaks after unsub(), task cleanup 100% within TTL

**Configuration**:
```erlang
{erlmcp, [
    {lifecycle, [
        {cleanup_enabled, true},
        {cleanup_interval_ms, 60000},    % 60s cleanup job
        {subscription_ttl_ms, 300000},   % 5 minutes default
        {task_ttl_ms, 3600000},          % 1 hour default
        {cleanup_batch_size, 1000}       % process 1000 at a time
    ]}
]}
```

**Cleanup Process**:
```erlang
%% Every 60s, cleanup job:
%% 1. Query all subscriptions with timestamp < now - 5min
%% 2. Query all tasks with status = completed AND timestamp < now - 1hr
%% 3. Delete in batches of 1000
%% 4. Log cleanup events to OTEL
%% 5. Emit metrics (subscriptions_cleaned, tasks_cleaned)
```

---

## 8. SECURITY HARDENING STRATEGY (Agent 8)

### Decision: URI Validation & Attack Prevention

**Context**: Prevent path traversal, header injection, URI overflow attacks.

**Options**:

| Option | Validation Level | Performance | False Positives | Complexity |
|--------|------------------|-------------|-----------------|-----------|
| A: Minimal | Basic length check | High | Very Low | Very Low |
| B: Standard | RFC 3986 conformance | High | Low | Low |
| C: Strict | Whitelist + canonicalization | Medium | None | Medium |
| D: Very Strict | Sandboxed parser | Low | None | Very High |

**DECISION**: Option C (Strict with canonicalization)
- **Rationale**: Blocks known attacks, acceptable performance, industry standard
- **Implementation**:
  - URI canonicalization (remove `..`, `/./`, etc.)
  - Check for path traversal patterns: `../`, `..%2f`, null bytes
  - Validate URI length <8KB
  - Validate header values: no CRLF, max 4KB per header
  - Whitelist URI schemes: `file://`, `http://`, `https://`, `mcp://`
  - Block reserved paths: `/dev/`, `/proc/`, `/sys/`, `/etc/`
- **Evidence Required**: 100/100 attack patterns blocked, 0 crashes on fuzz, <100us latency

**Implementation Modules**:
```erlang
%% src/erlmcp_uri_validator.erl
-export([validate_uri/1, canonicalize_uri/1]).

%% src/erlmcp_header_validator.erl
-export([validate_header_name/1, validate_header_value/1]).

%% Usage in erlmcp_server.erl:
%% {ok, CanonUri} = erlmcp_uri_validator:canonicalize_uri(Uri),
%% case erlmcp_uri_validator:validate_uri(CanonUri) of
%%     ok -> handle_resource(CanonUri);
%%     {error, Reason} -> reject_with_error(Reason)
%% end.
```

**Configuration**:
```erlang
{erlmcp, [
    {security, [
        {uri_validation_enabled, true},
        {max_uri_length, 8192},
        {max_header_value_length, 4096},
        {reserved_paths, ["/dev/", "/proc/", "/sys/", "/etc/"]},
        {allowed_schemes, ["file://", "http://", "https://", "mcp://"]}
    ]}
]}
```

---

## 9. SUPPLY-CHAIN SECURITY STRATEGY (Agent 9)

### Decision: SBOM Format & Vulnerability Scanning

**Context**: Generate supply-chain evidence for stakeholders. Choose format and scanning approach.

**Options**:

| Option | Format | Tooling | Adoption | Standards |
|--------|--------|---------|----------|-----------|
| A: SPDX | JSON/RDF | pip-audit, syft | High | Linux Foundation |
| B: CycloneDX | JSON/XML | syft, snyk | Very High | OWASP |
| C: Custom | JSON | Internal script | Low | None |
| D: Multiple | SPDX + CycloneDX | Multiple tools | Excellent | Multiple standards |

**DECISION**: Option B (CycloneDX JSON)
- **Rationale**: OWASP standard, syft already available, works with snyk for scanning
- **Implementation**:
  - Generate SBOM using syft or manual rebar3 dependency tree
  - Output format: CycloneDX 1.4 JSON
  - Include: name, version, license, commit hash, build timestamp
  - Scan with snyk or free Grype scanner
  - Include scan results in SBOM metadata
- **Evidence Required**: SBOM valid against schema, 0 HIGH/CRITICAL vulnerabilities

**SBOM Structure**:
```json
{
  "bomFormat": "CycloneDX",
  "specVersion": "1.4",
  "serialNumber": "urn:uuid:...",
  "version": 1,
  "metadata": {
    "timestamp": "2026-02-03T00:00:00Z",
    "tools": [{"name": "syft", "version": "..."}],
    "component": {
      "bom-ref": "erlmcp-1.3.0",
      "name": "erlmcp",
      "version": "1.3.0",
      "type": "application",
      "licenses": [{"license": {"name": "Apache-2.0"}}],
      "commit": "abc123def456",
      "vcs": {"url": "https://github.com/USER/erlmcp.git"}
    }
  },
  "components": [
    {
      "bom-ref": "jsx-3.1.0",
      "name": "jsx",
      "version": "3.1.0",
      "type": "library",
      "licenses": [{"license": {"name": "MIT"}}]
    }
    // ... other dependencies
  ]
}
```

**Vulnerability Scan**:
```bash
# Option 1: Grype (free)
grype sbom:docs/v1.3.0-SBOM.cyclonedx

# Option 2: Snyk (requires account)
snyk sbom --format=cyclonedx > docs/v1.3.0-SBOM.cyclonedx
snyk test --sbom=docs/v1.3.0-SBOM.cyclonedx
```

---

## 10. EVIDENCE AGGREGATION STRATEGY (Agent 10)

### Decision: Evidence Bundle Format & Presentation

**Context**: Package all evidence for stakeholders. Need machine-readable + human-readable formats.

**Options**:

| Option | Format | Tool | Readability | Automation |
|--------|--------|------|-------------|-----------|
| A: Markdown | .md files | Static gen | Very High | Low |
| B: JSON Schema | .json files | Validation | Medium | Very High |
| C: HTML Dashboard | Interactive | Static gen | High | Medium |
| D: Multi-format | All of above | Build pipeline | Excellent | Excellent |

**DECISION**: Option D (Multi-format)
- **Rationale**: Support different audiences (engineers read JSON, execs read PDF)
- **Implementation**:
  - JSON schema file: `docs/v1.3.0-EVIDENCE-BUNDLE.json` (machine-readable)
  - Markdown summary: `docs/v1.3.0-RELEASE-NOTES.md` (human-readable)
  - PDF whitepaper: `docs/v1.3.0-CTO-WHITEPAPER.pdf` (executive summary)
  - HTML dashboard: `docs/v1.3.0-evidence/index.html` (interactive)
- **Evidence Required**: All artifacts present, bundle validates against schema

**Evidence Bundle Schema**:
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "erlmcp v1.3.0 Evidence Bundle",
  "type": "object",
  "required": ["version", "release_date", "evidence", "sbom", "test_coverage"],
  "properties": {
    "version": {"type": "string", "pattern": "^1\\.3\\.0"},
    "release_date": {"type": "string", "format": "date-time"},
    "evidence": {
      "type": "object",
      "required": ["performance", "reliability", "security"],
      "properties": {
        "performance": {
          "type": "object",
          "required": ["throughput_4kb", "latency_p99"],
          "properties": {
            "throughput_4kb": {
              "type": "object",
              "properties": {
                "value": {"type": "number"},
                "unit": {"type": "string"},
                "target": {"type": "number"},
                "status": {"enum": ["PASS", "FAIL"]}
              }
            }
          }
        }
      }
    }
  }
}
```

---

## CROSS-CUTTING CONCERNS

### Configuration Management

All decisions use `config/sys.config` as single source of truth:

```erlang
{erlmcp, [
    %% Agent 1: Transport
    {transport_opts, [
        {tcp_nodelay, true},
        {tcp_send_buf, 65536},
        {tcp_recv_buf, 65536}
    ]},

    %% Agent 2: Backpressure
    {backpressure_enabled, true},
    {max_queue_size, 1000},

    %% Agent 3: Circuit Breaker
    {circuit_breaker, [
        {enabled, true},
        {failure_threshold, 5},
        {failure_window_ms, 30000},
        {timeout_ms, 60000}
    ]},

    %% Agent 4: Bulkheads
    {bulkhead_count, 8},
    {bulkhead_restart_intensity, 5},
    {bulkhead_restart_period, 60},

    %% Agent 5: Registry
    {registry, [
        {type, sharded},
        {shard_count, 16},
        {ets_options, [compressed, {read_concurrency, true}]}
    ]},

    %% Agent 6: Protocol Safety
    {protocol_safety, [
        {strict_initialization, true},
        {init_timeout_ms, 30000}
    ]},

    %% Agent 7: Lifecycle
    {lifecycle, [
        {cleanup_enabled, true},
        {cleanup_interval_ms, 60000},
        {subscription_ttl_ms, 300000},
        {task_ttl_ms, 3600000}
    ]},

    %% Agent 8: Security
    {security, [
        {uri_validation_enabled, true},
        {max_uri_length, 8192},
        {max_header_value_length, 4096}
    ]},

    %% OTEL Tracing (all agents)
    {otel_tracing, [
        {enabled, true},
        {exporter, jaeger},
        {service_name, "erlmcp"}
    ]}
]}.
```

### OTEL Instrumentation (Cross-Cutting)

Every agent must emit standardized OTEL spans:

```erlang
%% src/erlmcp_otel.erl
-export([
    start_span/2,        % (operation_name, attributes)
    end_span/2,          % (span_ctx, result)
    record_metric/3,     % (metric_name, value, unit)
    record_event/3       % (event_type, status, details)
]).

%% Example usage in Agent 1 throughput test:
SpanCtx = erlmcp_otel:start_span(<<"transport.send">>, #{
    payload_size => 4096,
    batch_size => 100
}),
ResultsAfter = send_batch(Batch),
erlmcp_otel:end_span(SpanCtx, #{
    messages_sent => 100,
    latency_us => Latency
}).
```

---

## DECISION APPROVAL MATRIX

| Decision | Owner | Approval | Timeline |
|----------|-------|----------|----------|
| Transport optimization (TCP_NODELAY) | Agent 1 | Tech Lead | Day 1 AM |
| Queue cap = 1000 messages | Agent 2 | Tech Lead | Day 1 AM |
| Circuit breaker = SRE pattern | Agent 3 | Tech Lead | Day 1 AM |
| Bulkheads = Fixed 8 | Agent 4 | Tech Lead | Day 1 AM |
| Registry = 16 shards | Agent 5 | Tech Lead | Day 1 AM |
| Protocol safety = Strict | Agent 6 | Tech Lead | Day 1 AM |
| Lifecycle = Hybrid explicit+TTL | Agent 7 | Tech Lead | Day 1 AM |
| Security = Strict validation | Agent 8 | Security Lead | Day 1 AM |
| SBOM = CycloneDX | Agent 9 | Compliance Lead | Day 1 AM |
| Evidence = Multi-format | Agent 10 | Product Lead | Day 1 AM |

**All decisions require approval before agent spawning.**

---

## APPENDIX: RATIONALE SUMMARY

| Agent | Decision | Why This Choice |
|-------|----------|-----------------|
| 1 | TCP_NODELAY | Proven in Erlang, low risk, 10-15% gain |
| 2 | Hard cap 1000 | Deterministic, simple recovery, no per-client state |
| 3 | SRE pattern | Industry standard, proven, familiar |
| 4 | Fixed 8 bulkheads | Deterministic, simple, scales to 100K |
| 5 | 16 shards | Sub-ms p99, moderate complexity, proven |
| 6 | Strict init | Production safety, backward compat path |
| 7 | Hybrid cleanup | No leaks + fast path + automatic fallback |
| 8 | Strict URI validation | Blocks known attacks, acceptable perf |
| 9 | CycloneDX | OWASP standard, tooling available |
| 10 | Multi-format | Different audiences, automation-ready |
