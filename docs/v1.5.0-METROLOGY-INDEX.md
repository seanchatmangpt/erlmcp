# erlmcp v1.5.0 Metrology Validation System - Navigation Index

**Version:** 1.5.0
**Agent:** erlang-architect
**Status:** Design Complete
**Date:** 2026-01-27

---

## Quick Start

**I need to...**

- **Understand the system** → [System Summary](#system-summary)
- **Validate an artifact** → [Schema File](#schema-file)
- **Look up a term** → [Glossary](#glossary)
- **Implement validation** → [Architecture Document](#architecture)
- **Migrate legacy artifacts** → [Migration Guide (in Architecture)](#migration)
- **Fix a violation** → [Glossary - Disambiguation Rules](#disambiguation)

---

## Core Documents

### 1. System Summary (START HERE)

**File:** `/Users/sac/erlmcp/docs/v1.5.0-metrology-system-summary.md`

**What it covers:**
- 10-minute overview of entire system
- What was delivered (3 files)
- Example valid measurement
- Example violations detected
- Canonical metric registry (18 metrics)
- Implementation plan (6 weeks, 5 phases)
- Success metrics and risks

**Read this first** to understand what the metrology system does and why it exists.

**Key takeaways:**
- Eliminates 7 stop-the-line conditions
- JSON Schema validation with jesse
- 4-stage validation (build → test → CI → release)
- Backwards compatible (parallel structure v1.3.0/v1.4.0/v1.5.0)

---

### 2. Schema File

**File:** `/Users/sac/erlmcp/shapes/metrology.schema.json`

**What it is:**
- JSON Schema Draft-07 definition
- Canonical metric name registry (18 metrics)
- Unit definitions (time, rate, bytes, bandwidth, percentage, count)
- Scope definitions (per_process, per_connection, per_node, per_cluster)
- Quality gate thresholds
- Violation rules (maps to 7 stop-line conditions)

**Use this for:**
- Validating artifacts with jesse
- Understanding required fields
- Checking allowed values (enums)

**Key sections:**
```json
{
  "properties": {
    "schema_version": "1.5.0",
    "artifact_type": ["plan", "evidence", "baseline", "comparison"],
    "measurements": [/* array of measurement objects */],
    "quality_gates": {/* thresholds */},
    "violations": [/* detected errors */]
  },
  "definitions": {
    "measurement": {/* metric structure */},
    "unit": {/* dimension + symbol */}
  }
}
```

---

### 3. Architecture Document (DETAILED DESIGN)

**File:** `/Users/sac/erlmcp/docs/v1.5.0-metrology-validation-architecture.md`

**What it covers (80 pages):**
1. Executive summary
2. Schema file design
3. Validation architecture (4 stages)
4. Canonical definitions structure
5. Fail-fast quality gates
6. Implementation plan (6 weeks)
7. Supervision tree impact
8. Rationale & tradeoffs
9. Testing strategy
10. Documentation deliverables
11. Success metrics
12. Risks & mitigations
13. Next steps

**Appendices:**
- A: Stop-line condition examples (7 violations with before/after)
- B: Quality gate configuration

**Read this for:**
- Implementation details (gen_server API, rebar3 provider, CT hook)
- Validation logic (jesse integration)
- Migration strategy (legacy artifacts)
- CI integration (GitHub Actions)

**Key components:**

**A. erlmcp_metrology_validator (gen_server)**
```erlang
-spec validate_measurement(map()) -> ok | {error, [violation()]}.
-spec validate_artifact(binary()) -> {ok, map()} | {error, [violation()]}.
-spec validate_directory(binary()) -> {ok, report()}.
-spec check_quality_gates(map(), map()) -> pass | {fail, [gate_violation()]}.
```

**B. rebar3 provider**
```bash
rebar3 tcps metrology_validate
rebar3 tcps metrology_validate --file=path/to/artifact.json
rebar3 tcps metrology_validate --report=path/to/report.md
```

**C. CT hook (erlmcp_metrology_ct_hook)**
- Validates artifacts after each test
- Fails test on ERROR-severity violations
- Opt-in (v1.5.0), mandatory later (v1.6.0)

---

### 4. Glossary (REFERENCE)

**File:** `/Users/sac/erlmcp/docs/metrology-glossary.md`

**What it covers (40 pages):**
- A-Z canonical definitions (15 core terms)
- Disambiguation rules (7 rules matching stop-line conditions)
- Quick reference table (metric → unit → scope → required fields)
- Before/after examples for each violation

**Core terms defined:**
1. **Connection** vs **Session** (transport vs protocol)
2. **Message** vs **Request** (frames vs operations)
3. **Throughput** (msg/s vs req/s)
4. **Latency** (transport, protocol, application)
5. **Memory** (heap, process, ETS, total)
6. **Payload Size** (wire bytes, pre-TLS)
7. **Scope** (per_process, per_connection, per_node, per_cluster)
8. **Duration** (time window for rates)
9. **Sample Size** (statistical significance)
10. **Workload** (constant, burst, ramp, sawtooth, random)
11. **Transport** (stdio, tcp, http, websocket, sse)
12. **Unit** (dimension + symbol)
13. **JSON-RPC Operation** (initialize, tools/*, resources/*, etc.)
14. **Artifact Type** (plan, evidence, baseline, comparison)
15. **Quality Gates** (thresholds for automated validation)

**Use this when:**
- Unsure about metric terminology
- Fixing a violation
- Adding new metrics to schema
- Reviewing artifacts for clarity

**Quick lookup:**
```
Connection? → Transport-level link (per_connection scope)
Session? → Protocol-level conversation (may be 1:1 or N:1 with connection)
msg/s? → All JSON-RPC frames (requests + responses + notifications)
req/s? → Client requests only (subset of msg/s)
memory_heap? → Process heap only (per_process scope)
memory_total? → OS RSS (per_node scope)
```

---

## Validation Workflow

### Stage 1: Build-Time

**When:** `make compile` (rebar3 pre_compile hook)
**What:** Validate shapes/metrology.schema.json is valid JSON Schema
**Failure:** Exit code 1, compilation blocked

### Stage 2: Test Execution

**When:** `rebar3 ct` (CT hook: post_end_per_testcase)
**What:** Validate artifacts emitted by tests
**Failure:** Test fails with violation report

### Stage 3: CI Gate

**When:** `.github/workflows/ci.yml` (after all tests pass)
**What:** `rebar3 tcps metrology_validate` on dist/evidence/v1.5.0/
**Failure:** CI job fails, PR blocked

### Stage 4: Release Validation

**When:** Pre-release hook
**What:** Generate metrology_compliance_report.md
**Failure:** Manual review required before release

---

## Canonical Metric Registry

| Metric Name | Unit | Scope | Required Fields | Description |
|-------------|------|-------|-----------------|-------------|
| throughput | msg/s, req/s, ops/s | per_node, per_cluster | duration_seconds, workload_details | Operations per second |
| latency_p50 | ms | per_connection, per_node | sample_size, percentile, duration_seconds | 50th percentile latency |
| latency_p95 | ms | per_connection, per_node | sample_size, percentile, duration_seconds | 95th percentile latency |
| latency_p99 | ms | per_connection, per_node | sample_size, percentile, duration_seconds | 99th percentile latency |
| latency_p99_9 | ms | per_connection, per_node | sample_size, percentile, duration_seconds | 99.9th percentile latency |
| memory_heap | MiB | per_process | - | Erlang process heap only |
| memory_process | MiB | per_process | - | Heap + stack + mailbox |
| memory_ets | MiB | per_node | - | ETS table memory |
| memory_total | MiB, GiB | per_node | - | OS-reported RSS |
| cpu_utilization | % | per_node | duration_seconds | CPU usage percentage |
| gc_pause_avg | ms | per_process, per_node | sample_size | Average GC pause |
| gc_pause_max | ms | per_process, per_node | sample_size | Maximum GC pause |
| gc_count | count | per_process, per_node | duration_seconds | GC execution count |
| connection_count | count | per_node | - | Active connections |
| message_queue_len | count | per_process | - | Process mailbox depth |
| error_rate | % | per_node, per_connection | sample_size, duration_seconds | Operation error rate |
| success_rate | % | per_node, per_connection | sample_size, duration_seconds | Operation success rate |
| bandwidth | Mbps, MiB/s | per_connection, per_node | duration_seconds | Network throughput |
| payload_size | B, KiB | dimensionless | - | Message body size |

---

## 7 Stop-Line Conditions (Quick Reference)

| # | Condition | Rule | Schema Field | Fix |
|---|-----------|------|--------------|-----|
| 1 | Naked numbers | missing_unit | `unit` | Add `{dimension: "rate", symbol: "msg/s"}` |
| 2 | Ambiguous metrics | ambiguous_metric | `workload_details.json_rpc_operations` | Clarify msg/s vs req/s + add operations |
| 3 | Undefined scope | undefined_scope | `scope` | Add `per_process`, `per_connection`, `per_node`, or `per_cluster` |
| 4 | Unanchored duration | unanchored_duration | `duration_seconds` | Add time window (e.g., 60.0) |
| 5 | Mixed context | mixed_context | `scope` + `transport` + `notes` | Clarify connection vs session |
| 6 | Unlabeled memory | unlabeled_memory | `metric_name` | Use specific metric (memory_heap, memory_process, memory_ets, memory_total) |
| 7 | Zero sample size | zero_sample_size | `sample_size` + `percentile` | Add N samples + percentile value |

---

## Example Artifacts

### Valid Artifact

```json
{
  "schema_version": "1.5.0",
  "artifact_type": "evidence",
  "workload_id": "throughput_baseline_tcp",
  "metadata": {
    "timestamp": "2026-01-27T20:51:45Z",
    "environment": "ci",
    "erlang_version": "25.3"
  },
  "measurements": [
    {
      "metric_name": "throughput",
      "value": 150000,
      "unit": {"dimension": "rate", "symbol": "req/s"},
      "scope": "per_node",
      "transport": "tcp",
      "duration_seconds": 60.0,
      "sample_size": 1000,
      "workload_details": {
        "concurrent_connections": 1000,
        "message_size_bytes": 4096,
        "request_pattern": "constant"
      }
    }
  ],
  "status": "PASS"
}
```

### Invalid Artifact (Violations)

```json
{
  "schema_version": "1.5.0",
  "artifact_type": "evidence",
  "workload_id": "bad_example",
  "measurements": [
    {
      "metric_name": "throughput",
      "value": 150000
      // ❌ Missing: unit, scope, transport, duration_seconds
    }
  ],
  "status": "FAIL",
  "violations": [
    {"rule": "missing_unit", "severity": "ERROR", "message": "..."},
    {"rule": "undefined_scope", "severity": "ERROR", "message": "..."},
    {"rule": "unanchored_duration", "severity": "ERROR", "message": "..."}
  ]
}
```

---

## Implementation Timeline

### Phase 1: Core Validation (Week 1)
- ✅ shapes/metrology.schema.json (DONE)
- src/erlmcp_metrology_validator.erl
- test/erlmcp_metrology_validator_tests.erl
- ✅ docs/metrology-glossary.md (DONE)

### Phase 2: CI Integration (Week 2)
- src/rebar3_tcps_metrology.erl
- test/erlmcp_metrology_ct_hook.erl
- .github/workflows/validate_metrology.sh
- Update .github/workflows/ci.yml

### Phase 3: Migration (Week 3)
- scripts/migrate_metrology_artifacts.escript
- Create dist/evidence/v1.5.0/ structure
- Migrate v1.4.0 artifacts
- Generate compliance report

### Phase 4: Test Migration (Week 4-6)
- test/metrology_helpers.erl
- Migrate 10 test suites
- Update documentation

### Phase 5: Full Enforcement (v1.6.0)
- Switch CT hook to fail-on-violation
- Archive legacy directories
- Update CLAUDE.md

---

## Quality Gates (Default Thresholds)

```json
{
  "quality_gates": {
    "throughput_min_req_s": 95000,
    "latency_p99_max_ms": 5.0,
    "memory_max_mb": 512,
    "error_rate_max_percent": 0.01,
    "regression_tolerance_percent": 5.0
  }
}
```

---

## Backwards Compatibility

### Parallel Structure (Transition)

```
dist/evidence/
├── v1.3.0/          # Legacy (unchanged)
├── v1.4.0/          # Legacy (unchanged)
└── v1.5.0/          # NEW: Schema-compliant
    ├── benchmarks/
    ├── chaos/
    └── metrology_compliance_report.md
```

### Migration Script

**File:** `scripts/migrate_metrology_artifacts.escript`

**Usage:**
```bash
./scripts/migrate_metrology_artifacts.escript \
  --input=dist/evidence/v1.4.0 \
  --output=dist/evidence/v1.5.0 \
  --strict=false
```

**Function:**
1. Parse legacy JSON
2. Transform to v1.5.0 schema (heuristics for ambiguous fields)
3. Validate migrated artifacts
4. Log warnings for unresolvable cases

### Test Migration (Helper API)

**File:** `test/metrology_helpers.erl`

**Usage in test:**
```erlang
metrology_helpers:emit_measurement(throughput, 150000, #{
    unit => #{dimension => rate, symbol => 'req/s'},
    scope => per_node,
    transport => tcp,
    duration_seconds => 60.0,
    sample_size => 1000,
    workload_details => #{
        concurrent_connections => 1000,
        message_size_bytes => 4096,
        request_pattern => constant
    }
}).
```

---

## Commands Reference

### Build & Compile
```bash
make compile                  # Includes Stage 1 validation
```

### Test Execution
```bash
rebar3 ct                     # Includes Stage 2 validation (CT hook)
rebar3 eunit                  # No metrology validation (opt-in)
```

### Manual Validation
```bash
# Validate single artifact
rebar3 tcps metrology_validate --file=path/to/artifact.json

# Validate directory
rebar3 tcps metrology_validate --dir=dist/evidence/v1.5.0/

# Generate report
rebar3 tcps metrology_validate --report=dist/evidence/v1.5.0/metrology_compliance_report.md
```

### Migration
```bash
# Migrate legacy artifacts
./scripts/migrate_metrology_artifacts.escript \
  --input=dist/evidence/v1.4.0 \
  --output=dist/evidence/v1.5.0

# Validate migrated artifacts
rebar3 tcps metrology_validate --dir=dist/evidence/v1.5.0/
```

### CI Integration
```bash
# In .github/workflows/ci.yml
- name: Validate Metrology Artifacts
  run: |
    rebar3 tcps metrology_validate
    if [ $? -ne 0 ]; then
      echo "❌ Metrology validation failed"
      exit 1
    fi
```

---

## Troubleshooting

### Violation: missing_unit

**Error:**
```
[ERROR] missing_unit: Metric 'throughput' has no unit field
```

**Fix:**
```json
{
  "metric_name": "throughput",
  "value": 150000,
  "unit": {"dimension": "rate", "symbol": "msg/s"}  // ← Add this
}
```

### Violation: undefined_scope

**Error:**
```
[ERROR] undefined_scope: Metric 'memory_heap' has no scope field
```

**Fix:**
```json
{
  "metric_name": "memory_heap",
  "value": 24,
  "scope": "per_process"  // ← Add this
}
```

### Violation: unanchored_duration

**Error:**
```
[ERROR] unanchored_duration: Metric 'throughput' has no duration_seconds field
```

**Fix:**
```json
{
  "metric_name": "throughput",
  "value": 150000,
  "duration_seconds": 60.0  // ← Add this
}
```

### Violation: zero_sample_size

**Error:**
```
[ERROR] zero_sample_size: Metric 'latency_p99' has no sample_size field
```

**Fix:**
```json
{
  "metric_name": "latency_p99",
  "value": 2.1,
  "sample_size": 10000,  // ← Add this
  "percentile": 99.0     // ← Add this
}
```

---

## FAQ

### Q: Why not use SHACL instead of JSON Schema?
**A:** Better Erlang ecosystem support (jesse is mature), developer familiarity, performance (<1ms per artifact).

### Q: Can I add custom metrics?
**A:** Yes, but they must conform to schema structure (metric_name, value, unit, scope, transport). Update shapes/metrology.schema.json enum.

### Q: What if my measurement doesn't fit the schema?
**A:** Use `notes` field for clarifications. If truly incompatible, file an issue to extend schema.

### Q: How do I validate artifacts locally before CI?
**A:** Run `rebar3 tcps metrology_validate --file=path/to/artifact.json`

### Q: What happens to legacy artifacts (v1.3.0, v1.4.0)?
**A:** They coexist in parallel until v2.0.0. Migration script transforms them to v1.5.0 format.

### Q: Is validation mandatory in v1.5.0?
**A:** Opt-in for tests (CT hook warns), mandatory for CI (blocks PR). Full enforcement in v1.6.0.

---

## Resources

### Design Documents
- [System Summary](v1.5.0-metrology-system-summary.md) - 10-minute overview
- [Architecture](v1.5.0-metrology-validation-architecture.md) - 80-page detailed design
- [Glossary](metrology-glossary.md) - 40-page canonical definitions

### Schema & Config
- [metrology.schema.json](../shapes/metrology.schema.json) - JSON Schema validation
- [Quality Gates Config](../config/metrology_gates.config) - Threshold configuration

### Code (To Be Implemented)
- erlmcp_metrology_validator.erl - Core validator
- rebar3_tcps_metrology.erl - Rebar3 provider
- erlmcp_metrology_ct_hook.erl - CT hook
- metrology_helpers.erl - Test helper API
- migrate_metrology_artifacts.escript - Migration script

### External References
- [MCP Spec](https://spec.modelcontextprotocol.io/) - Model Context Protocol
- [JSON Schema Draft-07](https://json-schema.org/specification-links.html#draft-7)
- [jesse (Erlang validator)](https://github.com/for-GET/jesse)
- [IEEE 1541-2021](https://standards.ieee.org/standard/1541-2021.html) - Binary prefixes

---

## Next Actions

1. **Review design** with stakeholders:
   - plan-designer (workflow coordination)
   - erlang-otp-developer (implementation)
   - erlang-test-engineer (test migration)

2. **Approve deliverables:**
   - ✅ shapes/metrology.schema.json
   - ✅ docs/v1.5.0-metrology-validation-architecture.md
   - ✅ docs/metrology-glossary.md

3. **Begin Phase 1:**
   - Implement erlmcp_metrology_validator.erl
   - Write comprehensive unit tests
   - Validate PoC (migrate 1 test suite)

4. **Iterate:**
   - Collect feedback
   - Adjust schema/validator
   - Roll out Phases 2-5

---

**Status:** Design Complete - Ready for Implementation
**Version:** 1.5.0
**Agent:** erlang-architect
**Date:** 2026-01-27

For questions, refer to the [Glossary](metrology-glossary.md) or the [Architecture Document](v1.5.0-metrology-validation-architecture.md).
