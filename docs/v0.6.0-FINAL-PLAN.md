# erlmcp v0.6.0 FINAL PLAN - Standard MCP Transports with Library Integration

## Executive Summary

**Project**: erlmcp - Erlang MCP SDK for Standard Transports
**Version**: 0.6.0
**Focus**: Phase 3 Transport Standardization + Production Library Integration
**Transports**: stdio, TCP, HTTP (standard MCP protocol)

### Core Objective
Replace custom implementations with production-grade Erlang libraries while maintaining full compatibility with the MCP specification.

---

## Strategic Decision: Library-First Architecture

Moving from custom implementations to battle-tested libraries:

| Component | Current | New Library | Benefit |
|-----------|---------|-------------|---------|
| **Registry** | 411 LOC custom gen_server | **gproc 0.9.0** | Distributed registry, auto-cleanup |
| **HTTP Transport** | 461 LOC inets wrapper | **gun 2.0.1** | HTTP/1.1, HTTP/2, better error handling |
| **TCP Transport** | 349 LOC custom gen_tcp | **ranch 2.1.0** | Connection pooling, supervisor integration |
| **Connection Pooling** | None | **poolboy 1.5.2** | Better resource management under load |

**Result**: ~770 LOC of custom code replaced with proven libraries → Better reliability

---

## v0.6.0 Implementation Scope

### Phase 3.0: Library Foundation & Transport Interface (8-10h)

#### Step 1: Add Dependencies
```erlang
{deps, [
    {jsx, "3.1.0"},
    {jesse, "1.8.1"},
    {gproc, "0.9.0"},      % Process registry
    {gun, "2.0.1"},         % HTTP/1.1 HTTP/2 client
    {ranch, "2.1.0"},       % TCP connection handler
    {poolboy, "1.5.2"}      % Connection pooling
]}.
```
- **Effort**: 1h
- **Status**: ✅ DONE

#### Step 2: Enhance erlmcp_transport Behavior Interface
**File**: `src/erlmcp_transport.erl`

**Current**: 23 LOC
**Changes**:
```erlang
%% Core callbacks (required)
-callback init(TransportId :: atom(), Config :: map()) ->
    {ok, State :: term()} | {error, Reason :: term()}.

-callback send(State :: term(), Data :: iodata()) ->
    ok | {error, Reason :: term()}.

-callback close(State :: term()) -> ok.

%% Optional callbacks for advanced features
-callback get_info(State :: term()) ->
    #{type => atom(), status => atom(), peer => term()}.

-callback handle_transport_call(Request :: term(), State :: term()) ->
    {reply, Reply :: term(), NewState :: term()} |
    {error, Reason :: term()}.

-optional_callbacks([get_info/1, handle_transport_call/2]).

%% Standard message formats
-type transport_message() ::
    {transport_data, Data :: binary()} |
    {transport_connected, Info :: map()} |
    {transport_disconnected, Reason :: term()} |
    {transport_error, Type :: atom(), Reason :: term()}.
```

**Benefits**:
- Clear, standardized interface for all transports
- Consistent callback patterns
- Better error handling framework

**Effort**: 2h

### Phase 3.1: Replace Registry with gproc (3-4h)

**File**: `src/erlmcp_registry.erl`

**Current State**: 411 LOC custom gen_server
**New State**: ~120 LOC using gproc

**Key Changes**:
```erlang
%% Register servers using gproc
register_server(ServerId, ServerPid, Config) ->
    %% gproc handles monitoring automatically
    gproc:add_local_name({mcp, server, ServerId}),
    %% Store config
    gproc:reg({p, l, {mcp_server_config, ServerId}}, Config).

%% Register transports similarly
register_transport(TransportId, TransportPid, Config) ->
    gproc:add_local_name({mcp, transport, TransportId}),
    gproc:reg({p, l, {mcp_transport_config, TransportId}}, Config).

%% Server-transport binding still in maps (minimal state)
```

**Benefits**:
- Automatic process monitoring and cleanup
- Distributed registry support if needed
- Proven, widely-used library
- Reduces code complexity by 70%

**API Compatibility**: ✅ Fully backward compatible

**Effort**: 3h

### Phase 3.2: Refactor HTTP Transport with gun (4-6h)

**File**: `src/erlmcp_transport_http.erl`

**Current State**: 461 LOC using inets:httpc
**New State**: ~180 LOC using gun

**Key Changes**:
```erlang
-module(erlmcp_transport_http).
-behaviour(gen_server).
-behaviour(erlmcp_transport).

-record(state, {
    transport_id :: atom(),
    server_id :: atom(),
    config :: map(),
    gun_pid :: pid() | undefined,
    gun_monitor :: reference() | undefined,
    pending_requests = #{} :: #{reference() => {pid(), reference()}},
    url :: string(),
    headers :: [{string(), string()}]
}).

%% gun callback pattern
handle_info({gun_response, GunPid, StreamRef, IsFin, Status, Headers}, State) ->
    %% Simplified response handling
    {noreply, State}.

handle_info({gun_data, GunPid, StreamRef, IsFin, Data}, State) ->
    %% Route data through registry
    erlmcp_registry:route_to_server(State#state.server_id,
                                     State#state.transport_id, Data),
    {noreply, State}.
```

**Benefits**:
- HTTP/2 support out-of-box
- Better connection reuse and pooling
- Cleaner async message handling
- Better error handling

**Features**:
- ✅ HTTP/1.1 support
- ✅ HTTP/2 support (automatic)
- ✅ Keep-alive connections
- ✅ Timeout handling
- ✅ TLS/SSL support

**Effort**: 5h

### Phase 3.3: Refactor TCP Transport with ranch (4-6h)

**File**: `src/erlmcp_transport_tcp.erl`

**Current State**: 349 LOC custom gen_tcp wrapper
**New State**: ~150 LOC using ranch

**Key Changes**:
```erlang
-module(erlmcp_transport_tcp).
-behaviour(gen_server).
-behaviour(erlmcp_transport).
-behaviour(ranch_protocol).

-record(state, {
    transport_id :: atom(),
    server_id :: atom(),
    config :: map(),
    socket :: gen_tcp:socket() | undefined,
    ranch_ref :: atom() | undefined,
    buffer = <<>> :: binary(),
    connected = false :: boolean()
}).

%% ranch_protocol callback
start_link(Ref, Socket, Transport, Opts) ->
    %% ranch handles socket lifecycle
    {ok, spawn_link(?MODULE, init, [Ref, Socket, Transport, Opts])}.

%% Standard initialization
init([TransportId, Config]) ->
    process_flag(trap_exit, true),

    case maps:get(mode, Config, client) of
        server ->
            %% Use ranch for accepting connections
            ranch:start_listener(list_to_atom(TransportId),
                                ranch_tcp,
                                #{port => maps:get(port, Config)},
                                ?MODULE, [TransportId, Config]);
        client ->
            %% Connect as client
            Host = maps:get(host, Config),
            Port = maps:get(port, Config),
            gen_tcp:connect(Host, Port, [binary, {active, true}])
    end.
```

**Benefits**:
- Built-in connection pooling
- Supervisor integration (ranch handles restarts)
- Better socket lifecycle management
- TCP_NODELAY and keepalive built-in
- Used by EMQX, Cowboy

**Features**:
- ✅ Accepting connections (server mode)
- ✅ Outgoing connections (client mode)
- ✅ Connection pooling
- ✅ Backpressure handling
- ✅ Graceful shutdown

**Effort**: 5h

### Phase 3.4: Standardize STDIO Transport (2-3h)

**File**: `src/erlmcp_transport_stdio_new.erl`

**Current State**: 230 LOC
**Changes**: Ensure full behavior compliance

```erlang
%% Add missing optional callbacks
get_info(State) ->
    #{
        type => stdio,
        status => connected,
        peer => standard_io
    }.

%% Ensure registry integration
handle_info(register, State) ->
    erlmcp_registry:register_transport(
        State#state.transport_id,
        self(),
        #{type => stdio}
    ),
    {noreply, State}.

%% Standardize error handling
handle_info({error, Reason}, State) ->
    logger:error("STDIO transport error: ~p", [Reason]),
    {noreply, State}.
```

**Benefits**:
- Consistent with other transports
- Better error handling and logging
- Full behavior interface compliance

**Effort**: 2h

### Phase 3.5: Enhance Transport Supervisor (2-3h)

**File**: `src/erlmcp_transport_sup.erl`

**Current State**: 49 LOC
**New State**: ~70 LOC

**Changes**:
```erlang
%% Library-aware child specifications
start_child(TransportId, Type, Config) ->
    Module = transport_module(Type),

    ChildSpec = #{
        id => TransportId,
        start => {Module, start_link, [TransportId, Config]},
        restart => permanent,        % Libraries handle recovery
        shutdown => 5000,            % Give libraries time to cleanup
        type => worker,
        modules => [Module]
    },

    case supervisor:start_child(?MODULE, ChildSpec) of
        {ok, TransportPid} ->
            logger:info("Started ~p transport ~p", [Type, TransportId]),
            {ok, TransportPid};
        {error, Reason} ->
            logger:error("Failed to start transport: ~p", [Reason]),
            {error, Reason}
    end.

%% Resolve transport module
transport_module(stdio) -> erlmcp_transport_stdio_new;
transport_module(tcp) -> erlmcp_transport_tcp;
transport_module(http) -> erlmcp_transport_http.
```

**Benefits**:
- Better integration with libraries
- Clearer supervision strategy
- Better error reporting

**Effort**: 2h

### Phase 3.6: Configuration Validation (2-3h)

**File**: `src/erlmcp.erl` (enhancements)

**Changes**:
```erlang
%% Validate transport configuration
validate_transport_config(#{type := tcp} = Config) ->
    RequiredFields = [type, host, port],
    OptionalFields = [server_id, keepalive, connect_timeout, max_reconnect_attempts],
    validate_fields(Config, RequiredFields, OptionalFields);

validate_transport_config(#{type := http} = Config) ->
    RequiredFields = [type, url],
    OptionalFields = [server_id, method, headers, timeout],
    validate_fields(Config, RequiredFields, OptionalFields);

validate_transport_config(#{type := stdio} = Config) ->
    RequiredFields = [type],
    OptionalFields = [server_id],
    validate_fields(Config, RequiredFields, OptionalFields).

%% Helper for poolboy integration
setup_connection_pool(Type, PoolConfig) ->
    PoolName = pool_name(Type),
    WorkerModule = worker_module(Type),

    poolboy:start_link([
        {name, {local, PoolName}},
        {worker_module, WorkerModule},
        {size, maps:get(pool_size, PoolConfig, 10)},
        {max_overflow, maps:get(max_overflow, PoolConfig, 5)}
    ]).
```

**Benefits**:
- Clear configuration requirements per transport
- Better error messages
- Connection pooling support

**Effort**: 2h

### Phase 3.7: Comprehensive Testing (8-10h)

**Test Files**:
- `test/erlmcp_registry_SUITE.erl` - gproc integration
- `test/erlmcp_transport_http_SUITE.erl` - gun integration
- `test/erlmcp_transport_tcp_SUITE.erl` - ranch integration
- `test/erlmcp_transport_stdio_SUITE.erl` - standardization
- `test/erlmcp_transport_pooling_SUITE.erl` - poolboy integration

**Coverage Targets**:
- [x] Unit tests for each transport
- [x] Integration tests with registry
- [x] Supervisor integration tests
- [x] Configuration validation tests
- [x] Connection pooling tests
- [x] Error handling and recovery tests
- [x] Performance baseline tests

**Target Coverage**: >90% for all modules

**Effort**: 8h

### Phase 3.8: Documentation Updates (3-4h)

**Files to Update**:
- `docs/architecture.md` - Explain library usage
- `docs/otp-patterns.md` - Add library patterns
- `docs/api-reference.md` - Document new APIs
- `CLAUDE.md` - Update developer guide
- `README.md` - Highlight library improvements
- New: `docs/library-migration-guide.md`

**Content**:
- Why each library was chosen
- How to use each transport
- Performance characteristics
- Configuration examples
- Troubleshooting guide

**Effort**: 3h

---

## File-by-File Summary

| File | Current | New | Change | Effort |
|------|---------|-----|--------|--------|
| rebar.config | - | - | Add 4 deps | 1h |
| erlmcp_transport.erl | 23 | 50 | Enhance interface | 2h |
| erlmcp_registry.erl | 411 | 120 | Replace with gproc | 3h |
| erlmcp_transport_tcp.erl | 349 | 150 | Refactor with ranch | 5h |
| erlmcp_transport_http.erl | 461 | 180 | Refactor with gun | 5h |
| erlmcp_transport_stdio_new.erl | 230 | 240 | Standardize | 2h |
| erlmcp_transport_sup.erl | 49 | 70 | Enhance | 2h |
| erlmcp.erl | 573 | 650 | Add validation | 2h |
| test/* | - | +2000 | Add tests | 8h |
| docs/* | - | - | Update docs | 3h |
| **TOTAL** | **2496** | **1650** | **-846 LOC** | **33h** |

---

## Testing Strategy

### Unit Tests
- Each transport in isolation
- Registry operations with gproc
- Configuration validation
- Error conditions

### Integration Tests
- Registry ↔ Transports ↔ Servers
- Supervisor restart scenarios
- Message routing
- Connection pooling

### Performance Tests
- Registry lookup performance
- Transport throughput (TCP, HTTP)
- Memory usage with pooling
- Connection reuse metrics

### Compatibility Tests
- OTP 25+ compatibility
- All transport combinations
- Configuration variations
- Error recovery

---

## Success Criteria

### Technical Success ✅
- [x] Dependencies added to rebar.config
- [ ] gproc registry fully operational
- [ ] gun HTTP transport passes all tests
- [ ] ranch TCP transport passes all tests
- [ ] poolboy pooling functional
- [ ] All transports standardized
- [ ] >90% test coverage achieved

### Functional Success ✅
- [ ] Full MCP protocol support
- [ ] All existing functionality preserved
- [ ] Better error handling
- [ ] Configuration validation working
- [ ] Supervisor integration robust

### Performance Success ✅
- [ ] No performance regression
- [ ] Better resource usage under load
- [ ] Connection pooling working
- [ ] Library overhead minimal

### Quality Success ✅
- [ ] All tests passing
- [ ] Clean code with libraries
- [ ] Comprehensive documentation
- [ ] Production-ready

---

## Known Dependencies & Compatibility

### Library Versions
- **gproc 0.9.0**: Stable, used by many projects
- **gun 2.0.1**: Latest stable, HTTP/2 ready
- **ranch 2.1.0**: Current version, EMQX uses it
- **poolboy 1.5.2**: Mature, widely used

### OTP Requirements
- **Minimum**: OTP 25+ (project requirement)
- **Tested**: OTP 25, 26
- **Features**: Maybe expressions enabled

### Breaking Changes
- ⚠️ None for public APIs
- ⚠️ Internal implementation changes only
- ⚠️ Backward compatible with v0.5.x

---

## Rollback Plan

If issues occur with any library:
1. Revert rebar.config changes
2. Keep custom implementations as fallback
3. All public APIs remain unchanged
4. Incremental rollback per library

---

## Timeline

| Phase | Task | Hours | Status |
|-------|------|-------|--------|
| 3.0 | Library foundation & interfaces | 10 | In Progress |
| 3.1 | Registry with gproc | 3 | Pending |
| 3.2 | HTTP with gun | 5 | Pending |
| 3.3 | TCP with ranch | 5 | Pending |
| 3.4 | STDIO standardization | 2 | Pending |
| 3.5 | Supervisor enhancement | 2 | Pending |
| 3.6 | Configuration validation | 2 | Pending |
| 3.7 | Testing | 8 | Pending |
| 3.8 | Documentation | 3 | Pending |
| **Total** | | **40h** | ~1 week intensive |

---

## Deliverables at v0.6.0

1. ✅ rebar.config with gproc, gun, ranch, poolboy
2. ✅ Enhanced erlmcp_transport.erl behavior interface
3. ✅ New gproc-based erlmcp_registry.erl
4. ✅ Refactored erlmcp_transport_http.erl (gun)
5. ✅ Refactored erlmcp_transport_tcp.erl (ranch)
6. ✅ Standardized erlmcp_transport_stdio_new.erl
7. ✅ Enhanced erlmcp_transport_sup.erl
8. ✅ Enhanced erlmcp.erl with validation
9. ✅ Comprehensive test suite (8h of tests)
10. ✅ Updated documentation
11. ✅ Migration guide from v0.5.x
12. ✅ CHANGELOG.md for v0.6.0

---

## Post v0.6.0 Phases

### Phase 4: Examples & Documentation
- Update all examples for library patterns
- Create best practices guide
- Add performance tuning guide
- Transport selection guide

### Phase 5: Legacy Removal
- Remove erlmcp_stdio_server
- Remove erlmcp_stdio
- Remove old erlmcp_transport_stdio
- Clean deprecated APIs

### Phase 6: Final Polish
- Rename erlmcp_transport_stdio_new → erlmcp_transport_stdio
- Performance tuning
- Final optimization
- v1.0.0 release readiness

---

## Conclusion

v0.6.0 is a **library-first refactoring** that replaces ~846 LOC of custom code with proven, production-tested libraries. This improves:

✅ **Reliability**: Proven libraries vs custom code
✅ **Maintainability**: Less custom code to maintain
✅ **Features**: HTTP/2, pooling, better error handling
✅ **Performance**: Library-specific optimizations
✅ **Scalability**: Built-in pooling and supervision

**Result**: erlmcp becomes production-ready with better architecture, fewer bugs, and reduced maintenance burden.
