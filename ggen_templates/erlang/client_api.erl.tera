{#
  Erlang MCP Client API Method Generator

  Generates client API methods for the MCP protocol including:
  - Function exports
  - Type specifications
  - Documentation comments
  - Public API functions
  - gen_server handle_call callbacks
  - Phase checking
  - Capability validation
  - Request ID generation with overflow protection
  - Pending request tracking
  - Timeout support
  - Error handling

  Context Variables:
    - methods: array - List of MCP methods to generate
      Each method should have:
      - function_name: string - Erlang function name (e.g., "list_resources")
      - method: string - MCP protocol method name (e.g., "resources/list")
      - description: string - Method documentation
      - params: array - List of parameters [{name, type, required, description}]
      - return_type: string - Erlang return type
      - requires_phase: string - Required client phase ("pre_initialization", "initializing", "initialized")
      - requires_capability: string - Required capability ("resources", "tools", "prompts", etc.) or null
      - timeout_ms: integer - Optional timeout in milliseconds (default: 5000)
      - arity: integer - Number of required parameters
      - has_optional_params: boolean - Whether method has optional parameters
      - request_params: array - Parameters to include in JSON-RPC request
#}
%%% -*- mode: erlang; erlang-indent-level: 4; indent-tabs-mode: nil -*-
%%%-------------------------------------------------------------------
%%% @doc
%%% Generated MCP Client API Methods
%%%
%%% WARNING: This file is auto-generated by ggen.
%%% DO NOT EDIT MANUALLY - Changes will be overwritten.
%%% Edit the SPARQL ontology and regenerate using ggen.
%%%
%%% Generated: {{ timestamp | default(value="") }}
%%% Generator: ggen v{{ generator_version | default(value="1.0.0") }}
%%% Source: MCP Protocol Specification {{ mcp_version | default(value="2025-11-25") }}
%%% @end
%%%-------------------------------------------------------------------

%%%===================================================================
%%% Function Exports
%%%===================================================================

-export([
{% for method in methods -%}
{% if method.has_optional_params -%}
    {{ method.function_name }}/{{ method.arity }}, {{ method.function_name }}/{{ method.arity + 1 }}{% if not loop.last %},{% endif %}
{% else -%}
    {{ method.function_name }}/{{ method.arity }}{% if not loop.last %},{% endif %}
{% endif -%}
{% endfor %}
]).

%%%===================================================================
%%% Type Specifications
%%%===================================================================

{% for method in methods -%}
{% if method.has_optional_params -%}
-spec {{ method.function_name }}(client(){% for param in method.params %}{% if param.required %}, {{ param.type }}{% endif %}{% endfor %}) ->
    {{ method.return_type }}.
-spec {{ method.function_name }}(client(){% for param in method.params %}, {{ param.type }}{% endfor %}) ->
    {{ method.return_type }}.
{% else -%}
-spec {{ method.function_name }}({% if method.arity == 1 %}client(){% else %}client(){% for param in method.params %}, {{ param.type }}{% endfor %}{% endif %}) ->
    {{ method.return_type }}.
{% endif -%}

{% endfor %}

%%%===================================================================
%%% API Functions
%%%===================================================================

{% for method in methods -%}
%% @doc {{ method.description | default(value="Generated API method") }}
%%
{% if method.requires_phase -%}
%% Requires client phase: {{ method.requires_phase }}
{% endif -%}
{% if method.requires_capability -%}
%% Requires capability: {{ method.requires_capability }}
{% endif -%}
%%
%% MCP Method: {{ method.method }}
%%
{% if method.params -%}
%% Parameters:
{% for param in method.params -%}
%%   - {{ param.name }} ({{ param.type }}): {{ param.description | default(value="") }}{% if param.required %} [REQUIRED]{% else %} [OPTIONAL]{% endif %}
{% endfor -%}
{% endif -%}
%%
%% Returns:
%%   - {ok, Result} on success
%%   - {error, Reason} on failure
%%     Possible errors:
%%       - {not_initialized, Phase, Message} - Client not in required phase
{% if method.requires_capability -%}
%%       - {capability_not_supported, Message} - Required capability not available
{% endif -%}
%%       - {request_id_overflow, Message} - Request ID space exhausted
%%       - {request_id_collision, Message} - Internal error
%%       - timeout - Request timeout
%%
%% @end
{{ method.function_name }}(Client{% for param in method.params %}{% if param.required %}, {{ param.name | capitalize }}{% endif %}{% endfor %}) ->
{% if method.has_optional_params -%}
    {{ method.function_name }}(Client{% for param in method.params %}{% if param.required %}, {{ param.name | capitalize }}{% else %}, {{ param.default_value | default(value="#{}") }}{% endif %}{% endfor %}).

{{ method.function_name }}(Client{% for param in method.params %}, {{ param.name | capitalize }}{% endfor %}) ->
{% endif -%}
{% if method.timeout_ms -%}
    gen_server:call(Client, {{"{"}}{{ method.function_name }}{% for param in method.params %}, {{ param.name | capitalize }}{% endfor %}{{"}"}}, {{ method.timeout_ms }}).
{% else -%}
    gen_server:call(Client, {{"{"}}{{ method.function_name }}{% for param in method.params %}, {{ param.name | capitalize }}{% endfor %}{{"}"}}{% if method.arity == 0 %}{% endif %}).
{% endif -%}

{% endfor %}

%%%===================================================================
%%% gen_server Callbacks (for inclusion in erlmcp_client.erl)
%%%===================================================================

%% Add these handle_call clauses to erlmcp_client:handle_call/3

{% for method in methods -%}
{% if method.requires_phase == "initialized" -%}
%% Handle {{ method.function_name }} - requires initialized phase
handle_call({{"{"}}{{ method.function_name }}{% for param in method.params %}, {{ param.name | capitalize }}{% endfor %}{{"}"}}, From, #state{phase = initialized} = State) ->
{% if method.requires_capability -%}
    case ?CHECK_CAPABILITY(State, {{ method.requires_capability }}) of
        do_request ->
{% endif -%}
{% if method.request_params -%}
            Params = #{
{% for rparam in method.request_params -%}
                <<"{{ rparam.json_name }}">> => {{ rparam.value }}{% if not loop.last %},{% endif %}
{% endfor -%}
            },
{% else -%}
            Params = #{},
{% endif -%}
            {ok, NewState} = send_request(State, <<"{{ method.method }}">>, Params, {{"{"}}{{ method.function_name }}, From{{"}"}}),
            {noreply, NewState}{% if method.requires_capability %};
        {error, _} = ErrorTuple ->
            {reply, ErrorTuple, State}
    end{% endif %};

handle_call({{"{"}}{{ method.function_name }}{% for param in method.params %}, _{{ param.name | capitalize }}{% endfor %}{{"}"}}, From, #state{phase = Phase} = State) ->
    gen_server:reply(From, {error, {not_initialized, Phase, <<"Client not initialized">>}}),
    {noreply, State};

{% elif method.requires_phase == "pre_initialization" -%}
%% Handle {{ method.function_name }} - requires pre_initialization phase
handle_call({{"{"}}{{ method.function_name }}{% for param in method.params %}, {{ param.name | capitalize }}{% endfor %}{{"}"}}, From, #state{phase = pre_initialization} = State) ->
{% if method.request_params -%}
    Params = #{
{% for rparam in method.request_params -%}
        <<"{{ rparam.json_name }}">> => {{ rparam.value }}{% if not loop.last %},{% endif %}
{% endfor -%}
    },
{% else -%}
    Params = #{},
{% endif -%}
    NewState = State#state{phase = {{ method.next_phase | default(value="initializing") }}},
    {ok, NewState2} = send_request(NewState, <<"{{ method.method }}">>, Params, {{"{"}}{{ method.function_name }}, From{{"}"}}),
    {noreply, NewState2};

handle_call({{"{"}}{{ method.function_name }}{% for param in method.params %}, _{{ param.name | capitalize }}{% endfor %}{{"}"}}, From, #state{phase = Phase} = State) ->
    gen_server:reply(From, {error, {invalid_phase, Phase, <<"{{ method.function_name }} must be called in {{ method.requires_phase }} phase">>}}),
    {noreply, State};

{% else -%}
%% Handle {{ method.function_name }} - no phase requirement
handle_call({{"{"}}{{ method.function_name }}{% for param in method.params %}, {{ param.name | capitalize }}{% endfor %}{{"}"}}, From, State) ->
{% if method.requires_capability -%}
    case ?CHECK_CAPABILITY(State, {{ method.requires_capability }}) of
        do_request ->
{% endif -%}
{% if method.request_params -%}
            Params = #{
{% for rparam in method.request_params -%}
                <<"{{ rparam.json_name }}">> => {{ rparam.value }}{% if not loop.last %},{% endif %}
{% endfor -%}
            },
{% else -%}
            Params = #{},
{% endif -%}
            {ok, NewState} = send_request(State, <<"{{ method.method }}">>, Params, {{"{"}}{{ method.function_name }}, From{{"}"}}),
            {noreply, NewState}{% if method.requires_capability %};
        {error, _} = ErrorTuple ->
            {reply, ErrorTuple, State}
    end{% endif %};

{% endif -%}
{% endfor %}

%%%===================================================================
%%% Internal Functions (for reference - already in erlmcp_client.erl)
%%%===================================================================

%% send_request/4
%% Handles:
%%   - Request ID generation with overflow protection (erlmcp_request_id:safe_increment/1)
%%   - Threshold checking (warning/critical/reserved levels)
%%   - Collision detection
%%   - Pending request tracking
%%   - Message sending via transport
%%   - Error handling
%%
%% Returns:
%%   - {ok, NewState} on success
%%   - {error, Reason} on failure (also sends error reply to caller)

%% validate_capability/2
%% Checks if server supports required capability
%% Only enforced when State#state.strict_mode == true
%%
%% Returns:
%%   - ok if capability is supported or strict_mode is false
%%   - {error, capability_not_supported} if capability missing in strict mode

%%%===================================================================
%%% Usage Example
%%%===================================================================

%% Example: List resources
%% {ok, Client} = erlmcp_client:start_link({stdio, []}),
%% {ok, _InitResult} = erlmcp_client:initialize(Client, #mcp_client_capabilities{}),
%% {ok, Resources} = erlmcp_client:list_resources(Client),
%% io:format("Resources: ~p~n", [Resources]).

%% Example: Call tool with timeout
%% {ok, Result} = erlmcp_client:call_tool(Client, <<"my_tool">>, #{<<"arg">> => <<"value">>}),
%% io:format("Tool result: ~p~n", [Result]).

%% Example: Get prompt with optional arguments
%% {ok, Prompt1} = erlmcp_client:get_prompt(Client, <<"greeting">>),
%% {ok, Prompt2} = erlmcp_client:get_prompt(Client, <<"greeting">>, #{<<"name">> => <<"Alice">>}),
%% io:format("Prompts: ~p, ~p~n", [Prompt1, Prompt2]).

%%%===================================================================
%%% Error Handling Reference
%%%===================================================================

%% Common error tuples returned by generated methods:
%%
%% Phase errors:
%%   {error, {not_initialized, Phase, Message}}
%%   {error, {invalid_phase, Phase, Message}}
%%
%% Capability errors:
%%   {error, capability_not_supported}
%%   {error, no_server_capabilities}
%%
%% Request ID errors:
%%   {error, {request_id_overflow, Message}}
%%   {error, {request_id_collision, Message}}
%%
%% Transport errors:
%%   {error, transport_error}
%%   {error, timeout}
%%
%% MCP protocol errors (from server):
%%   {error, #{
%%       <<"code">> => ErrorCode,
%%       <<"message">> => ErrorMessage,
%%       <<"data">> => ErrorData  % optional
%%   }}

%%%===================================================================
%%% Request ID Overflow Protection
%%%===================================================================

%% All generated methods use erlmcp_request_id:safe_increment/1 which:
%%   - Enforces MAX_SAFE_REQUEST_ID (2^60 - 1) limit
%%   - Returns {error, overflow} when limit reached
%%   - Prevents wraparound and collision
%%
%% Threshold monitoring:
%%   - Warning: 80% (922337203685477580)
%%   - Critical: 90% (1037629354146165277)
%%   - Reserved: 96% (1106804644422573050)
%%
%% When overflow occurs:
%%   - Method returns {error, {request_id_overflow, Message}}
%%   - Client must reconnect to reset request ID counter
%%   - Logged at error level with request ID value

%%%===================================================================
%%% Timeout Configuration
%%%===================================================================

%% Default timeout: 5000ms (State#state.timeout)
%% Configure via client_opts:
%%   erlmcp_client:start_link(TransportOpts, #{timeout => 10000})
%%
%% Special cases:
%%   - initialize/2: Uses infinity timeout (protocol requirement)
%%   - Custom timeouts: Specified in method definition

%%%===================================================================
%%% Capability Checking
%%%===================================================================

%% Capability validation uses ?CHECK_CAPABILITY macro:
%%   - Skipped if State#state.strict_mode == false (default)
%%   - Enforced if State#state.strict_mode == true
%%   - Checks State#state.capabilities (from server initialize response)
%%
%% Enable strict mode:
%%   erlmcp_client:start_link(TransportOpts, #{strict_mode => true})

%% END OF GENERATED FILE
