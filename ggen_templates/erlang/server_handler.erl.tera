{#
  MCP Server Handler Code Generator Template

  Generates production-ready Erlang MCP server message handlers with:
  - Phase validation (initialization state machine)
  - Capability validation (negotiated capabilities check)
  - Schema validation (JSON Schema from ontology)
  - Progress notification support
  - Cancellation token checking
  - Error handling with proper MCP error codes
  - Tracing and logging integration
  - Helper functions for validation

  Context Variables (from SPARQL results):
    - module_name: string - Generated module name (e.g., "mcp_handler_tools_call")
    - method: string - MCP method name (e.g., "tools/call")
    - method_const: string - Constant name (e.g., "MCP_METHOD_TOOLS_CALL")
    - requires_phase: string - Required phase ("initialized" | "initialization" | "any")
    - capability: string - Required capability name (e.g., "tools", "resources", "prompts")
    - capability_record: string - Capability record field (e.g., "tools", "resources")
    - validate_schema: boolean - Whether to validate params against JSON Schema
    - schema: map - JSON Schema definition if validate_schema is true
    - handler_function: string - Name of the handler function to call
    - params_required: list - Required parameter names
    - supports_progress: boolean - Whether this handler supports progress notifications
    - supports_cancellation: boolean - Whether this handler supports cancellation
    - timeout_ms: integer - Operation timeout in milliseconds (default 5000)
    - description: string - Handler description for documentation
    - timestamp: string - Generation timestamp
    - generator_version: string - ggen version
#}
%%% -*- mode: erlang; erlang-indent-level: 4; indent-tabs-mode: nil -*-
%%%-------------------------------------------------------------------
%%% @doc
%%% Generated MCP Server Handler: {{ method }}
%%%
%%% {{ description | default(value="MCP protocol handler implementation.") }}
%%%
%%% WARNING: This file is auto-generated by ggen.
%%% DO NOT EDIT MANUALLY - Changes will be overwritten.
%%% Edit the ontology source files instead and regenerate.
%%%
%%% Generated: {{ timestamp }}
%%% Method: {{ method }}
%%% Phase: {{ requires_phase }}
{% if capability -%}
%%% Capability: {{ capability }}
{% endif -%}
%%% Generator: ggen v{{ generator_version }}
%%% @end
%%%-------------------------------------------------------------------
-module({{ module_name }}).
-behaviour(erlmcp_handler).

%% Include MCP protocol definitions
-include("erlmcp.hrl").

%% Exports
-export([
    handle/4,
    validate_phase/1,
    validate_capability/2,
    validate_params/1
]).

{% if supports_progress -%}
%% Progress notification support
-export([report_progress/3]).
{% endif %}

{% if supports_cancellation -%}
%% Cancellation support
-export([check_cancellation/1]).
{% endif %}

%%%===================================================================
%%% API - Handler Entry Point
%%%===================================================================

%% @doc Main handler entry point called by erlmcp_server.
%% Performs validation and delegates to business logic.
-spec handle(json_rpc_id(), map(), atom(), term()) ->
    {reply, map()} | {error, integer(), binary()} | {error, integer(), binary(), map()}.
handle(Id, Params, TransportId, State) ->
    %% Start tracing span for observability
    SpanCtx = erlmcp_tracing:start_server_span(
        <<"handler.{{ method }}">>,
        element(2, State)  %% Extract server_id from state tuple
    ),

    try
        erlmcp_tracing:set_attributes(SpanCtx, #{
            <<"request_id">> => Id,
            <<"method">> => <<"{{ method }}">>,
            <<"transport_id">> => TransportId,
            <<"params_count">> => maps:size(Params)
        }),

        %% Step 1: Phase Validation
        case validate_phase(State) of
            ok ->
                erlmcp_tracing:add_event(SpanCtx, <<"phase_validated">>),

                %% Step 2: Capability Validation
{% if capability -%}
                case validate_capability(State, {{ capability }}) of
                    ok ->
                        erlmcp_tracing:add_event(SpanCtx, <<"capability_validated">>),
{% else -%}
                %% No capability required for this method
                begin
{% endif -%}

                        %% Step 3: Parameter Validation
                        case validate_params(Params) of
                            ok ->
                                erlmcp_tracing:add_event(SpanCtx, <<"params_validated">>),

{% if validate_schema -%}
                                %% Step 4: Schema Validation
                                case validate_schema(Params) of
                                    ok ->
                                        erlmcp_tracing:add_event(SpanCtx, <<"schema_validated">>),

{% endif -%}
                                        %% Step 5: Execute Handler
                                        execute_handler(Id, Params, TransportId, State, SpanCtx)
{% if validate_schema -%}
                                    ;
                                    {error, SchemaErrors} ->
                                        erlmcp_tracing:record_error_details(
                                            SpanCtx,
                                            schema_validation_failed,
                                            SchemaErrors
                                        ),
                                        {error,
                                         ?MCP_ERROR_VALIDATION_FAILED,
                                         ?MCP_MSG_VALIDATION_FAILED,
                                         #{<<"schema_errors">> => SchemaErrors}}
                                end
{% endif -%}
                            ;
                            {error, MissingParam} ->
                                erlmcp_tracing:record_error_details(
                                    SpanCtx,
                                    missing_parameter,
                                    MissingParam
                                ),
                                {error,
                                 ?JSONRPC_INVALID_PARAMS,
                                 iolist_to_binary([<<"Missing required parameter: ">>, MissingParam])}
                        end
{% if capability -%}
                    ;
                    {error, not_supported} ->
                        erlmcp_tracing:record_error_details(
                            SpanCtx,
                            capability_not_supported,
                            <<"{{ capability }}">>
                        ),
                        {error,
                         ?MCP_ERROR_CAPABILITY_NOT_SUPPORTED,
                         ?MCP_MSG_CAPABILITY_NOT_SUPPORTED}
                end
{% else -%}
                end
{% endif -%}
            ;
            {error, Phase, RequiredPhase} ->
                erlmcp_tracing:record_error_details(
                    SpanCtx,
                    phase_violation,
                    #{current => Phase, required => RequiredPhase}
                ),
                {error,
                 ?MCP_ERROR_NOT_INITIALIZED,
                 phase_error_message(Phase, RequiredPhase)}
        end
    catch
        Class:Reason:Stacktrace ->
            erlmcp_tracing:record_exception(SpanCtx, Class, Reason, Stacktrace),
            logger:error("Handler ~s crashed: ~p:~p~n~p",
                        [<<"{{ method }}">>, Class, Reason, Stacktrace]),
            {error, ?JSONRPC_INTERNAL_ERROR, ?JSONRPC_MSG_INTERNAL_ERROR}
    after
        erlmcp_tracing:end_span(SpanCtx)
    end.

%%%===================================================================
%%% Validation Functions
%%%===================================================================

%% @doc Validate that the server is in the required phase.
-spec validate_phase(term()) -> ok | {error, atom(), atom()}.
validate_phase(State) ->
    CurrentPhase = element(3, State),  %% #state.phase field position
    RequiredPhase = {{ requires_phase }},

    case RequiredPhase of
        any ->
            %% Method allowed in any phase
            ok;
        initialization when CurrentPhase =:= initialization ->
            ok;
        initialized when CurrentPhase =:= initialized ->
            ok;
        _ ->
            {error, CurrentPhase, RequiredPhase}
    end.

{% if capability -%}
%% @doc Validate that the required capability is enabled.
-spec validate_capability(term(), atom()) -> ok | {error, not_supported}.
validate_capability(State, RequiredCapability) ->
    Capabilities = element(6, State),  %% #state.capabilities field position

    case RequiredCapability of
        resources ->
            check_capability_enabled(
                Capabilities#mcp_server_capabilities.{{ capability_record | default(value=capability) }}
            );
        tools ->
            check_capability_enabled(
                Capabilities#mcp_server_capabilities.{{ capability_record | default(value=capability) }}
            );
        prompts ->
            check_capability_enabled(
                Capabilities#mcp_server_capabilities.{{ capability_record | default(value=capability) }}
            );
        logging ->
            %% Logging capability is always enabled if record exists
            ok;
        sampling ->
            check_capability_enabled(
                Capabilities#mcp_server_capabilities.{{ capability_record | default(value=capability) }}
            );
        roots ->
            check_capability_enabled(
                Capabilities#mcp_server_capabilities.{{ capability_record | default(value=capability) }}
            );
        _ ->
            {error, not_supported}
    end.

%% @doc Check if a capability record indicates the capability is enabled.
-spec check_capability_enabled(term()) -> ok | {error, not_supported}.
check_capability_enabled(#mcp_resources_capability{}) ->
    %% Resources capability exists and is enabled
    ok;
check_capability_enabled(#mcp_tools_capability{}) ->
    ok;
check_capability_enabled(#mcp_prompts_capability{}) ->
    ok;
check_capability_enabled(#mcp_logging_capability{}) ->
    ok;
check_capability_enabled(#mcp_sampling_capability{}) ->
    ok;
check_capability_enabled(#mcp_roots_capability{}) ->
    ok;
check_capability_enabled(undefined) ->
    {error, not_supported};
check_capability_enabled(_) ->
    {error, not_supported}.
{% endif %}

%% @doc Validate that all required parameters are present.
-spec validate_params(map()) -> ok | {error, binary()}.
validate_params(Params) ->
{% if params_required and params_required | length > 0 -%}
    RequiredParams = [
        {% for param in params_required -%}
        <<"{{ param }}">>{% if not loop.last %},{% endif %}
        {% endfor %}
    ],

    case find_missing_param(RequiredParams, Params) of
        undefined ->
            ok;
        MissingParam ->
            {error, MissingParam}
    end.

%% @doc Find the first missing required parameter.
-spec find_missing_param([binary()], map()) -> binary() | undefined.
find_missing_param([], _Params) ->
    undefined;
find_missing_param([Param | Rest], Params) ->
    case maps:is_key(Param, Params) of
        true ->
            find_missing_param(Rest, Params);
        false ->
            Param
    end.
{% else -%}
    %% No required parameters for this method
    ok.
{% endif %}

{% if validate_schema -%}
%% @doc Validate parameters against JSON Schema.
-spec validate_schema(map()) -> ok | {error, list()}.
validate_schema(Params) ->
    Schema = get_json_schema(),

    case jesse:validate_with_schema(Schema, Params, [{allowed_errors, infinity}]) of
        {ok, _ValidatedParams} ->
            ok;
        {error, ValidationErrors} ->
            %% Convert jesse errors to readable format
            Errors = format_schema_errors(ValidationErrors),
            {error, Errors}
    end.

%% @doc Get the JSON Schema for parameter validation.
-spec get_json_schema() -> map().
get_json_schema() ->
    {{ schema | json_encode }}.

%% @doc Format JSON Schema validation errors.
-spec format_schema_errors(list()) -> list().
format_schema_errors(Errors) when is_list(Errors) ->
    [format_schema_error(E) || E <- Errors];
format_schema_errors(Error) ->
    [format_schema_error(Error)].

-spec format_schema_error(term()) -> map().
format_schema_error({data_invalid, Schema, Wrong, Path}) ->
    #{
        <<"path">> => format_path(Path),
        <<"schema">> => Schema,
        <<"value">> => Wrong,
        <<"error">> => <<"data_invalid">>
    };
format_schema_error(Error) ->
    #{
        <<"error">> => iolist_to_binary(io_lib:format("~p", [Error]))
    }.

-spec format_path(list()) -> binary().
format_path([]) ->
    <<"/">>;
format_path(Path) ->
    iolist_to_binary([<<"/">>, lists:join(<<"/">>, [to_binary(P) || P <- Path])]).

-spec to_binary(term()) -> binary().
to_binary(Atom) when is_atom(Atom) ->
    atom_to_binary(Atom, utf8);
to_binary(Int) when is_integer(Int) ->
    integer_to_binary(Int);
to_binary(Bin) when is_binary(Bin) ->
    Bin;
to_binary(Other) ->
    iolist_to_binary(io_lib:format("~p", [Other])).
{% endif %}

%%%===================================================================
%%% Handler Execution
%%%===================================================================

%% @doc Execute the actual handler logic with progress and cancellation support.
-spec execute_handler(json_rpc_id(), map(), atom(), term(), term()) ->
    {reply, map()} | {error, integer(), binary()} | {error, integer(), binary(), map()}.
execute_handler(Id, Params, TransportId, State, SpanCtx) ->
    HandlerSpanCtx = erlmcp_tracing:start_span(<<"handler.execute">>),

{% if supports_progress -%}
    %% Generate progress token for this operation
    ProgressToken = erlmcp_progress:generate_token(),
    ServerPid = self(),
    _ = erlmcp_progress:track_operation(ProgressToken, <<"{{ method }}">>, ServerPid),

    erlmcp_tracing:set_attributes(HandlerSpanCtx, #{
        <<"progress_token">> => ProgressToken
    }),
{% endif -%}

    %% Extract server_id for CPU quota tracking
    ServerId = element(2, State),
    ClientId = case ServerId of
        {_, SessionId} when is_binary(SessionId) -> SessionId;
        SId when is_binary(SId) -> SId;
        _ -> <<"unknown_client">>
    end,

    try
        %% Execute with CPU protection (quota + timeout)
        TimeoutMs = {{ timeout_ms | default(value=5000) }},

{% if supports_cancellation -%}
        %% Check for cancellation before execution
        case check_cancellation(Id) of
            false ->
{% endif -%}
                case erlmcp_cpu_guard:execute_with_protection(
                    ClientId,
                    handler_call,
                    fun() -> {{ handler_function }}(Params, State) end,
                    [],
                    TimeoutMs
                ) of
                    {ok, Result, CpuTime} ->
                        erlmcp_tracing:set_attributes(HandlerSpanCtx, #{
                            <<"cpu_time_ms">> => CpuTime
                        }),

{% if supports_progress -%}
                        %% Cleanup progress tracking
                        erlmcp_progress:cleanup_completed(ProgressToken),

{% endif -%}
                        %% Format successful response
                        Response = format_response(Result{% if supports_progress %}, ProgressToken{% endif %}),
                        erlmcp_tracing:set_status(HandlerSpanCtx, ok),
                        {reply, Response};

                    {error, quota_exceeded, cpu_time} ->
                        erlmcp_tracing:record_error_details(
                            HandlerSpanCtx,
                            cpu_quota_exceeded,
                            cpu_time
                        ),
                        logger:warning("CPU quota exceeded for {{ method }}", []),
{% if supports_progress -%}
                        erlmcp_progress:cleanup_completed(ProgressToken),
{% endif -%}
                        {error,
                         ?JSONRPC_INTERNAL_ERROR,
                         <<"CPU quota exceeded. Please retry later.">>};

                    {error, quota_exceeded, operations} ->
                        erlmcp_tracing:record_error_details(
                            HandlerSpanCtx,
                            ops_quota_exceeded,
                            operations
                        ),
                        logger:warning("Operations quota exceeded for {{ method }}", []),
{% if supports_progress -%}
                        erlmcp_progress:cleanup_completed(ProgressToken),
{% endif -%}
                        {error,
                         ?JSONRPC_INTERNAL_ERROR,
                         <<"Operation rate limit exceeded. Please retry later.">>};

                    {error, timeout} ->
                        erlmcp_tracing:record_error_details(
                            HandlerSpanCtx,
                            timeout,
                            TimeoutMs
                        ),
                        logger:error("Handler {{ method }} timed out after ~pms", [TimeoutMs]),
{% if supports_progress -%}
                        erlmcp_progress:cleanup_completed(ProgressToken),
{% endif -%}
                        {error,
                         ?MCP_ERROR_TIMEOUT,
                         <<"Operation timeout. Execution took too long.">>};

                    {error, Reason} ->
                        erlmcp_tracing:record_error_details(
                            HandlerSpanCtx,
                            execution_error,
                            Reason
                        ),
                        logger:error("Handler {{ method }} error: ~p", [Reason]),
{% if supports_progress -%}
                        erlmcp_progress:cleanup_completed(ProgressToken),
{% endif -%}
                        {error, ?JSONRPC_INTERNAL_ERROR, ?JSONRPC_MSG_INTERNAL_ERROR}
                end
{% if supports_cancellation -%}
            ;
            true ->
                %% Request was cancelled
                erlmcp_tracing:add_event(HandlerSpanCtx, <<"cancelled">>),
                logger:info("Request ~p cancelled for {{ method }}", [Id]),
{% if supports_progress -%}
                erlmcp_progress:cleanup_completed(ProgressToken),
{% endif -%}
                {error, ?MCP_ERROR_TOOL_CANCELLED, <<"Operation cancelled by client.">>}
        end
{% endif -%}
    catch
        Class:Reason:Stacktrace ->
            erlmcp_tracing:record_exception(HandlerSpanCtx, Class, Reason, Stacktrace),
            logger:error("Handler {{ method }} crashed: ~p:~p~n~p",
                        [Class, Reason, Stacktrace]),
{% if supports_progress -%}
            erlmcp_progress:cleanup_completed(ProgressToken),
{% endif -%}
            {error, ?JSONRPC_INTERNAL_ERROR, ?JSONRPC_MSG_INTERNAL_ERROR}
    after
        erlmcp_tracing:end_span(HandlerSpanCtx)
    end.

%%%===================================================================
%%% Response Formatting
%%%===================================================================

%% @doc Format the handler result into a proper MCP response.
-spec format_response(term(){% if supports_progress %}, binary(){% endif %}) -> map().
format_response(Result{% if supports_progress %}, ProgressToken{% endif %}) ->
    BaseResponse = normalize_result(Result),
{% if supports_progress -%}

    %% Include progress token in metadata
    BaseResponse#{
        <<"_meta">> => #{
            ?MCP_PARAM_PROGRESS_TOKEN => ProgressToken
        }
    }.
{% else -%}
    BaseResponse.
{% endif %}

%% @doc Normalize handler result to MCP response format.
-spec normalize_result(term()) -> map().
normalize_result(Result) when is_map(Result) ->
    %% Already a map, return as-is
    Result;
normalize_result(Result) when is_binary(Result) ->
    %% Binary result - wrap in content
    #{?MCP_PARAM_CONTENT => [#{
        <<"type">> => ?MCP_CONTENT_TYPE_TEXT,
        <<"text">> => Result
    }]};
normalize_result(Result) when is_list(Result) ->
    %% List result - check if it's content list or convert
    case is_content_list(Result) of
        true ->
            #{?MCP_PARAM_CONTENT => Result};
        false ->
            %% Convert to text content
            #{?MCP_PARAM_CONTENT => [#{
                <<"type">> => ?MCP_CONTENT_TYPE_TEXT,
                <<"text">> => iolist_to_binary(io_lib:format("~p", [Result]))
            }]}
    end;
normalize_result(Result) ->
    %% Other types - convert to text
    #{?MCP_PARAM_CONTENT => [#{
        <<"type">> => ?MCP_CONTENT_TYPE_TEXT,
        <<"text">> => iolist_to_binary(io_lib:format("~p", [Result]))
    }]}.

%% @doc Check if a list is a valid MCP content list.
-spec is_content_list(list()) -> boolean().
is_content_list([]) ->
    false;
is_content_list([H | _]) when is_map(H) ->
    maps:is_key(<<"type">>, H);
is_content_list(_) ->
    false.

{% if supports_progress -%}
%%%===================================================================
%%% Progress Notification Support
%%%===================================================================

%% @doc Report progress for this operation.
-spec report_progress(binary(), number(), number()) -> ok.
report_progress(ProgressToken, Progress, Total) ->
    erlmcp_progress:report(ProgressToken, Progress, Total).
{% endif %}

{% if supports_cancellation -%}
%%%===================================================================
%%% Cancellation Support
%%%===================================================================

%% @doc Check if the request has been cancelled.
-spec check_cancellation(json_rpc_id()) -> boolean().
check_cancellation(RequestId) ->
    erlmcp_cancellation:is_cancelled(RequestId).
{% endif %}

%%%===================================================================
%%% Helper Functions
%%%===================================================================

%% @doc Generate error message for phase violations.
-spec phase_error_message(atom(), atom()) -> binary().
phase_error_message(_Current, initialization) ->
    <<"Operation only allowed during initialization phase">>;
phase_error_message(_Current, initialized) ->
    <<"Server not initialized. Call initialize first.">>;
phase_error_message(Current, Required) ->
    iolist_to_binary(io_lib:format(
        "Phase violation: current=~p, required=~p",
        [Current, Required]
    )).

%%%===================================================================
%%% Business Logic (IMPLEMENT THIS)
%%%===================================================================

%% @doc Actual business logic implementation.
%% This function should be implemented with the domain-specific logic.
-spec {{ handler_function }}(map(), term()) -> term().
{{ handler_function }}(_Params, _State) ->
    %% TODO: Implement actual business logic here
    %% This is a placeholder that should be replaced with real implementation
    erlang:error({not_implemented, {{ handler_function }}}).
