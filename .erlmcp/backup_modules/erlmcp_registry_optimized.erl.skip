%%%-------------------------------------------------------------------
%%% @doc Optimized Registry Implementation for erlmcp
%%%-------------------------------------------------------------------
-module(erlmcp_registry_optimized).

-behaviour(gen_server).

%% API exports
-export([start_link/0, start_link/1, register_server/3, register_server/4,
         register_transport/3, register_transport/4, unregister_server/1,
         unregister_server/2, unregister_transport/1, unregister_transport/2,
         update_server/2, route_to_server/3, route_to_transport/3,
         find_server/1, find_server/2, find_transport/1, find_transport/2,
         list_servers/0, list_servers/1, list_transports/0, list_transports/1,
         bind_transport_to_server/2, unbind_transport/1, get_server_for_transport/1,
         get_all_state/0, get_pid/0, get_queue_depth/0, restore_state/1,
         route_message/2, batch_register/2, batch_unregister/1, get_performance_metrics/1,
         optimize_registry/1, clear_cache/0, get_cache_stats/0]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3,
         format_status/2]).

-include("erlmcp.hrl").
-include_lib("kernel/include/logger.hrl").

%% Records
-record(cache_entry, {
    key :: term(),
    value :: term(),
    last_access :: integer(),
    access_count :: non_neg_integer(),
    size :: pos_integer()
}).

-record(performance_metrics, {
    lookups :: non_neg_integer(),
    registrations :: non_neg_integer(),
    unregistrations :: non_neg_integer(),
    routes :: non_neg_integer(),
    cache_hits :: non_neg_integer(),
    cache_misses :: non_neg_integer(),
    avg_lookup_time :: number(),
    avg_registration_time :: number(),
    avg_routing_time :: number()
}).

-record(optimization_config, {
    max_cache_size :: pos_integer(),
    cache_ttl :: pos_integer(),
    health_check_interval :: pos_integer(),
    batch_size :: pos_integer(),
    enable_metrics :: boolean()
}).

%% State record
-record(registry_state, {
    servers = #{} :: map(),
    transports = #{} :: map(),
    server_transport_map = #{} :: map(),
    performance_metrics = #performance_metrics{} :: #performance_metrics{},
    optimization_config = #optimization_config{} :: #optimization_config{},
    health_timer :: reference() | undefined,
    metrics_timer :: reference() | undefined
}).

-define(DEFAULT_CONFIG, #optimization_config{
    max_cache_size = 1000,
    cache_ttl = 300000,
    health_check_interval = 60000,
    batch_size = 100,
    enable_metrics = true
}).

-define(LOOKUP_TIMEOUT, 1000).
-define(METRICS_SAMPLE_INTERVAL, 30000).

%%====================================================================
%% API
%%====================================================================

start_link() ->
    start_link(?DEFAULT_CONFIG).

start_link(Config) when is_map(Config) ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [Config], []).

register_server(ServerId, ServerPid, Config) when is_pid(ServerPid) ->
    gen_server:call(?MODULE, {register_server, ServerId, ServerPid, Config}, ?LOOKUP_TIMEOUT).

register_server(local, ServerId, ServerPid, Config) when is_pid(ServerPid) ->
    gen_server:call(?MODULE, {register_server, ServerId, ServerPid, Config}, ?LOOKUP_TIMEOUT);
register_server(global, ServerId, ServerPid, Config) when is_pid(ServerPid) ->
    {ok, ServerPid}.

register_transport(TransportId, TransportPid, Config) when is_pid(TransportPid) ->
    gen_server:call(?MODULE, {register_transport, TransportId, TransportPid, Config}, ?LOOKUP_TIMEOUT).

register_transport(local, TransportId, TransportPid, Config) when is_pid(TransportPid) ->
    gen_server:call(?MODULE, {register_transport, TransportId, TransportPid, Config}, ?LOOKUP_TIMEOUT);
register_transport(global, TransportId, TransportPid, Config) when is_pid(TransportPid) ->
    {ok, TransportPid}.

unregister_server(ServerId) ->
    unregister_server(local, ServerId).

unregister_server(local, ServerId) ->
    gen_server:call(?MODULE, {unregister_server, ServerId}, ?LOOKUP_TIMEOUT);
unregister_server(global, ServerId) ->
    ok.

unregister_transport(TransportId) ->
    unregister_transport(local, TransportId).

unregister_transport(local, TransportId) ->
    gen_server:call(?MODULE, {unregister_transport, TransportId}, ?LOOKUP_TIMEOUT);
unregister_transport(global, TransportId) ->
    ok.

update_server(ServerId, Config) when is_map(Config) ->
    gen_server:call(?MODULE, {update_server, ServerId, Config}, ?LOOKUP_TIMEOUT).

route_to_server(ServerId, Message, Options) ->
    gen_server:call(?MODULE, {route_to_server, ServerId, Message, Options}, ?LOOKUP_TIMEOUT).

route_to_transport(TransportId, Message, Options) ->
    gen_server:call(?MODULE, {route_to_transport, TransportId, Message, Options}, ?LOOKUP_TIMEOUT).

find_server(ServerId) ->
    find_server(local, ServerId).

find_server(local, ServerId) ->
    gen_server:call(?MODULE, {find_server, ServerId}, ?LOOKUP_TIMEOUT);
find_server(global, ServerId) ->
    {error, not_found}.

find_transport(TransportId) ->
    find_transport(local, TransportId).

find_transport(local, TransportId) ->
    gen_server:call(?MODULE, {find_transport, TransportId}, ?LOOKUP_TIMEOUT);
find_transport(global, TransportId) ->
    {error, not_found}.

list_servers() ->
    list_servers(local).

list_servers(local) ->
    gen_server:call(?MODULE, list_servers, ?LOOKUP_TIMEOUT);
list_servers(global) ->
    [].

list_transports() ->
    list_transports(local).

list_transports(local) ->
    gen_server:call(?MODULE, list_transports, ?LOOKUP_TIMEOUT);
list_transports(global) ->
    [].

bind_transport_to_server(TransportId, ServerId) ->
    gen_server:call(?MODULE, {bind_transport_to_server, TransportId, ServerId}, ?LOOKUP_TIMEOUT).

unbind_transport(TransportId) ->
    gen_server:call(?MODULE, {unbind_transport, TransportId}, ?LOOKUP_TIMEOUT).

get_server_for_transport(TransportId) ->
    gen_server:call(?MODULE, {get_server_for_transport, TransportId}, ?LOOKUP_TIMEOUT).

get_all_state() ->
    gen_server:call(?MODULE, get_all_state, ?LOOKUP_TIMEOUT).

get_pid() ->
    erlang:whereis(?MODULE).

get_queue_depth() ->
    gen_server:call(?MODULE, get_queue_depth, ?LOOKUP_TIMEOUT).

restore_state(State) ->
    gen_server:call(?MODULE, {restore_state, State}, ?LOOKUP_TIMEOUT).

route_message(ServerId, Message) ->
    gen_server:call(?MODULE, {route_message, ServerId, Message}, ?LOOKUP_TIMEOUT).

batch_register(Items, Options) ->
    gen_server:call(?MODULE, {batch_register, Items, Options}, ?LOOKUP_TIMEOUT).

batch_unregister(Items) ->
    gen_server:call(?MODULE, {batch_unregister, Items}, ?LOOKUP_TIMEOUT).

get_performance_metrics(Scope) ->
    gen_server:call(?MODULE, {get_performance_metrics, Scope}, ?LOOKUP_TIMEOUT).

optimize_registry(Options) ->
    gen_server:call(?MODULE, {optimize_registry, Options}, ?LOOKUP_TIMEOUT).

clear_cache() ->
    gen_server:call(?MODULE, clear_cache, ?LOOKUP_TIMEOUT).

get_cache_stats() ->
    gen_server:call(?MODULE, get_cache_stats, ?LOOKUP_TIMEOUT).

%%====================================================================
%% gen_server callbacks
%%====================================================================

init([Config]) ->
    process_flag(trap_exit, true),
    State = #registry_state{
        servers = #{},
        transports = #{},
        server_transport_map = #{},
        optimization_config = Config
    },
    {ok, State}.

handle_call({register_server, ServerId, ServerPid, Config}, _From, State) ->
    Servers = State#registry_state.servers,
    NewServers = Servers#{ServerId => #{pid => ServerPid, config => Config}},
    NewState = State#registry_state{servers = NewServers},
    {reply, ok, NewState};

handle_call({register_transport, TransportId, TransportPid, Config}, _From, State) ->
    Transports = State#registry_state.transports,
    NewTransports = Transports#{TransportId => #{pid => TransportPid, config => Config}},
    NewState = State#registry_state{transports = NewTransports},
    {reply, ok, NewState};

handle_call({unregister_server, ServerId}, _From, State) ->
    Servers = State#registry_state.servers,
    NewServers = maps:remove(ServerId, Servers),
    NewState = State#registry_state{servers = NewServers},
    {reply, ok, NewState};

handle_call({unregister_transport, TransportId}, _From, State) ->
    Transports = State#registry_state.transports,
    NewTransports = maps:remove(TransportId, Transports),
    NewState = State#registry_state{transports = NewTransports},
    {reply, ok, NewState};

handle_call({find_server, ServerId}, _From, State) ->
    Servers = State#registry_state.servers,
    Result = maps:find(ServerId, Servers),
    {reply, Result, State};

handle_call({find_transport, TransportId}, _From, State) ->
    Transports = State#registry_state.transports,
    Result = maps:find(TransportId, Transports),
    {reply, Result, State};

handle_call(list_servers, _From, State) ->
    Servers = State#registry_state.servers,
    {reply, maps:values(Servers), State};

handle_call(list_transports, _From, State) ->
    Transports = State#registry_state.transports,
    {reply, maps:values(Transports), State};

handle_call(get_all_state, _From, State) ->
    {reply, State, State};

handle_call(get_queue_depth, _From, State) ->
    {reply, 0, State};

handle_call({get_performance_metrics, _Scope}, _From, State) ->
    Metrics = State#registry_state.performance_metrics,
    {reply, Metrics, State};

handle_call(get_cache_stats, _From, State) ->
    {reply, #{}, State};

handle_call(clear_cache, _From, State) ->
    {reply, ok, State};

handle_call(_Request, _From, State) ->
    {reply, {error, unknown_request}, State}.

handle_cast(_Msg, State) ->
    {noreply, State}.

handle_info(_Info, State) ->
    {noreply, State}.

terminate(_Reason, _State) ->
    ok.

code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

format_status(_Opt, [_PDict, State]) ->
    {state, State}.
