%%%-------------------------------------------------------------------%%% @doc%%% Complex Routing for Multi-Tenant and Advanced Path Matching%%%%%% Provides advanced routing capabilities:%%% - Multi-tenant request isolation%%% - Regex and glob pattern matching for paths%%% - Conditional routing based on headers, method, query params%%% - Weight-based load balancing across endpoints%%% - Fallback/cascade routing%%% - Route cache for performance%%% - Dynamic route updates%%%%%% @end%%%--------------------------------------------------------------------module(erlmcp_complex_routing).-behaviour(gen_server).%% Public API-export([    start_link/0,    add_route/1,    update_route/2,    delete_route/1,    match_request/5,    select_endpoint/1,    get_routing_metrics/1,    get_all_routes/0,    clear_routes/0,    get_cache_stats/0]).%% gen_server callbacks-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).-include_lib("kernel/include/logger.hrl").-include("erlmcp.hrl").-define(SERVER, ?MODULE).-define(ROUTES_TABLE, erlmcp_complex_routes).-define(ROUTE_CACHE_TABLE, erlmcp_route_cache).-define(ROUTE_METRICS_TABLE, erlmcp_route_metrics).-record(state, {    routes = [] :: list(),    cache_enabled = true :: boolean(),    cache_ttl = 60000 :: pos_integer(),    metrics_enabled = true :: boolean()}).-type method() :: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS'.-type routing_rule() :: #{    condition := term(),    target => binary(),    targets => [{binary(), pos_integer()}],    weight => pos_integer()}.-type route() :: #{    id := binary(),    tenant_id := binary(),    pattern := binary() | regex | glob,    rules := [routing_rule()],    fallback => binary(),    enabled => boolean()}.%%====================================================================%% Public API%%====================================================================%% @doc Start the routing manager-spec start_link() -> {ok, pid()} | {error, term()}.
start_link() ->    gen_server:start_link({local, ?SERVER}, ?MODULE, [], []).%% @doc Add a new routing rule-spec add_route(route()) -> ok | {error, term()}.add_route(Route) ->    gen_server:call(?SERVER, {add_route, Route}).%% @doc Update existing route-spec update_route(binary(), route()) -> ok | {error, term()}.update_route(RouteId, UpdatedRoute) ->    gen_server:call(?SERVER, {update_route, RouteId, UpdatedRoute}).%% @doc Delete a route-spec delete_route(binary()) -> ok | {error, term()}.delete_route(RouteId) ->    gen_server:call(?SERVER, {delete_route, RouteId}).%% @doc Match request to routing rules and get possible endpoints-spec match_request(binary(), method(), binary(), list() | map(), list() | map()) ->    {ok, [binary()], [{binary(), pos_integer()}]} | {error, no_match}.match_request(TenantId, Method, Path, Headers, Query) ->    gen_server:call(?SERVER, {match_request, TenantId, Method, Path, Headers, Query}).%% @doc Select endpoint from weighted list-spec select_endpoint([{binary(), pos_integer()}]) -> binary().select_endpoint(Endpoints) ->    select_endpoint_impl(Endpoints).%% @doc Get routing metrics for a tenant-spec get_routing_metrics(binary()) -> #{    total_requests := non_neg_integer(),    cache_hits := non_neg_integer(),    cache_misses := non_neg_integer(),    avg_match_time := float()}.get_routing_metrics(TenantId) ->    gen_server:call(?SERVER, {get_routing_metrics, TenantId}).%% @doc Get all routes-spec get_all_routes() -> [route()].get_all_routes() ->    gen_server:call(?SERVER, get_all_routes).%% @doc Clear all routes-spec clear_routes() -> ok.clear_routes() ->    gen_server:call(?SERVER, clear_routes).%% @doc Get cache statistics-spec get_cache_stats() -> #{    cache_size := non_neg_integer(),    hits := non_neg_integer(),    misses := non_neg_integer(),    hit_rate := float()}.get_cache_stats() ->    gen_server:call(?SERVER, get_cache_stats).%%====================================================================%% gen_server Callbacks%%====================================================================init([]) ->    ensure_tables_exist(),    State = #state{},    {ok, State}.handle_call({add_route, Route}, _From, State) ->    case validate_route(Route) of        ok ->            ets:insert(?ROUTES_TABLE, {maps:get(id, Route), Route}),            clear_cache(),            {reply, ok, State};        Error ->            {reply, Error, State}    end;handle_call({update_route, RouteId, UpdatedRoute}, _From, State) ->    case validate_route(UpdatedRoute) of        ok ->            ets:insert(?ROUTES_TABLE, {RouteId, UpdatedRoute}),            clear_cache(),            {reply, ok, State};        Error ->            {reply, Error, State}    end;handle_call({delete_route, RouteId}, _From, State) ->    ets:delete(?ROUTES_TABLE, RouteId),    clear_cache(),    {reply, ok, State};handle_call({match_request, TenantId, Method, Path, Headers, Query}, _From, State) ->    StartTime = erlang:system_time(microsecond),    CacheKey = {TenantId, Method, Path},    Result = case check_cache(CacheKey) of        {ok, Cached} ->            record_cache_hit(TenantId),            Cached;        miss ->            record_cache_miss(TenantId),            case perform_routing_match(TenantId, Method, Path, Headers, Query) of                Match = {ok, _, _} ->                    cache_result(CacheKey, Match, State#state.cache_ttl),                    Match;                Error -> Error            end    end,    EndTime = erlang:system_time(microsecond),    MatchTime = (EndTime - StartTime) / 1000.0,    record_metric(TenantId, match_time, MatchTime),    {reply, Result, State};handle_call({get_routing_metrics, TenantId}, _From, State) ->    Metrics = get_metrics_for_tenant(TenantId),    {reply, Metrics, State};handle_call(get_all_routes, _From, State) ->    Routes = ets:match_object(?ROUTES_TABLE, {'_', '_'}),    RouteMaps = [Route || {_Id, Route} <- Routes],    {reply, RouteMaps, State};handle_call(clear_routes, _From, State) ->    ets:delete_all_objects(?ROUTES_TABLE),    clear_cache(),    {reply, ok, State};handle_call(get_cache_stats, _From, State) ->    Stats = calculate_cache_stats(),    {reply, Stats, State};handle_call(_Request, _From, State) ->    {reply, {error, unknown_request}, State}.handle_cast(_Msg, State) ->    {noreply, State}.handle_info(_Info, State) ->    {noreply, State}.terminate(_Reason, _State) ->    ok.code_change(_OldVsn, State, _Extra) ->    {ok, State}.%%====================================================================%% Internal Functions%%====================================================================%% @doc Validate route structure-spec validate_route(route()) -> ok | {error, term()}.validate_route(Route) ->    case maps:is_key(id, Route) andalso maps:is_key(tenant_id, Route) of        true -> ok;        false -> {error, missing_required_fields}    end.%% @doc Perform actual routing match-spec perform_routing_match(binary(), method(), binary(), list() | map(), list() | map()) ->    {ok, [binary()], [{binary(), pos_integer()}]} | {error, no_match}.perform_routing_match(TenantId, Method, Path, Headers, Query) ->    Routes = ets:match_object(?ROUTES_TABLE, {'_', '_'}),    TenantRoutes = [Route || {_Id, Route} <- Routes,                            maps:get(tenant_id, Route) =:= TenantId],    case find_matching_routes(TenantRoutes, Method, Path, Headers, Query) of        [] -> {error, no_match};        MatchedRoutes ->            {Targets, Endpoints} = extract_endpoints(MatchedRoutes),            {ok, Targets, Endpoints}    end.%% @doc Find routes matching the request-spec find_matching_routes(list(), method(), binary(), list() | map(), list() | map()) -> [route()].find_matching_routes(Routes, Method, Path, Headers, Query) ->    [Route || Route <- Routes,             matches_pattern(Route, Path) andalso             matches_conditions(Route, Method, Headers, Query)].%% @doc Check if route pattern matches path-spec matches_pattern(route(), binary()) -> boolean().matches_pattern(Route, Path) ->    Pattern = maps:get(pattern, Route, <<".*">>),    case re:run(Path, Pattern) of        {match, _} -> true;        nomatch -> false    end.%% @doc Check if route conditions match request-spec matches_conditions(route(), method(), list() | map(), list() | map()) -> boolean().matches_conditions(Route, Method, Headers, Query) ->    Rules = maps:get(rules, Route, []),    case Rules of        [] -> true;        _ ->            lists:any(fun(Rule) ->                evaluate_condition(maps:get(condition, Rule), Method, Headers, Query)            end, Rules)    end.%% @doc Evaluate a single condition-spec evaluate_condition(term(), method(), list() | map(), list() | map()) -> boolean().evaluate_condition(match_all, _, _, _) -> true;evaluate_condition({header, Key, Value}, _, Headers, _) ->    case is_list(Headers) of        true ->            lists:any(fun({K, V}) -> K =:= Key andalso V =:= Value end, Headers);        false ->            maps:get(Key, Headers, undefined) =:= Value    end;evaluate_condition({method, Method}, Method, _, _) -> true;evaluate_condition({method, _}, _, _, _) -> false;evaluate_condition({query, Key, Value}, _, _, Query) ->    case is_list(Query) of        true ->            lists:any(fun({K, V}) -> K =:= Key andalso V =:= Value end, Query);        false ->            maps:get(Key, Query, undefined) =:= Value    end;evaluate_condition(_, _, _, _) -> false.%% @doc Extract endpoints from matched routes-spec extract_endpoints([route()]) -> {[binary()], [{binary(), pos_integer()}]}.extract_endpoints(Routes) ->    Targets = lists:flatmap(fun(Route) ->        Rules = maps:get(rules, Route, []),        [maps:get(target, Rule) || Rule <- Rules, maps:is_key(target, Rule)]    end, Routes),    Endpoints = lists:flatmap(fun(Route) ->        Rules = maps:get(rules, Route, []),        [[{T, W} || {T, W} <- maps:get(targets, Rule, [])] || Rule <- Rules, maps:is_key(targets, Rule)]    end, Routes),    FlattenedEndpoints = lists:flatten(Endpoints),    {lists:usort(Targets), FlattenedEndpoints}.%% @doc Select weighted endpoint-spec select_endpoint_impl([{binary(), pos_integer()}]) -> binary().select_endpoint_impl([]) -> error;select_endpoint_impl(Endpoints) ->    TotalWeight = lists:sum([W || {_, W} <- Endpoints]),    Random = rand:uniform(TotalWeight),    select_by_weight(Endpoints, Random, 0).%% @doc Select endpoint by weighted random-spec select_by_weight([{binary(), pos_integer()}], pos_integer(), non_neg_integer()) -> binary().select_by_weight([{Endpoint, _}], _, _) -> Endpoint;select_by_weight([{Endpoint, Weight} | Rest], Random, Cumulative) ->    case Random =< Cumulative + Weight of        true -> Endpoint;        false -> select_by_weight(Rest, Random, Cumulative + Weight)    end.%% @doc Check cache for matching request-spec check_cache({binary(), method(), binary()}) -> {ok, term()} | miss.check_cache(CacheKey) ->    case ets:lookup(?ROUTE_CACHE_TABLE, CacheKey) of        [{CacheKey, Result, ExpiresAt}] ->            case erlang:system_time(millisecond) < ExpiresAt of                true -> {ok, Result};                false ->                    ets:delete(?ROUTE_CACHE_TABLE, CacheKey),                    miss            end;        [] -> miss    end.%% @doc Cache routing result-spec cache_result({binary(), method(), binary()}, term(), pos_integer()) -> ok.cache_result(CacheKey, Result, TTL) ->    ExpiresAt = erlang:system_time(millisecond) + TTL,    ets:insert(?ROUTE_CACHE_TABLE, {CacheKey, Result, ExpiresAt}),    ok.%% @doc Clear all cached results-spec clear_cache() -> ok.clear_cache() ->    ets:delete_all_objects(?ROUTE_CACHE_TABLE),    ok.%% @doc Record cache hit-spec record_cache_hit(binary()) -> ok.record_cache_hit(TenantId) ->    Key = {TenantId, cache_hits},    case ets:lookup(?ROUTE_METRICS_TABLE, Key) of        [] -> ets:insert(?ROUTE_METRICS_TABLE, {Key, 1});        [{Key, Count}] -> ets:update_element(?ROUTE_METRICS_TABLE, Key, {2, Count + 1})    end,    ok.%% @doc Record cache miss-spec record_cache_miss(binary()) -> ok.record_cache_miss(TenantId) ->    Key = {TenantId, cache_misses},    case ets:lookup(?ROUTE_METRICS_TABLE, Key) of        [] -> ets:insert(?ROUTE_METRICS_TABLE, {Key, 1});        [{Key, Count}] -> ets:update_element(?ROUTE_METRICS_TABLE, Key, {2, Count + 1})    end,    ok.%% @doc Record metric value-spec record_metric(binary(), atom(), number()) -> ok.record_metric(TenantId, MetricName, Value) ->    Key = {TenantId, MetricName},    case ets:lookup(?ROUTE_METRICS_TABLE, Key) of        [] ->            ets:insert(?ROUTE_METRICS_TABLE, {Key, [Value]});        [{Key, Values}] ->            ets:update_element(?ROUTE_METRICS_TABLE, Key, {2, [Value | Values]})    end,    ok.%% @doc Get metrics for a tenant-spec get_metrics_for_tenant(binary()) -> #{    total_requests := non_neg_integer(),    cache_hits := non_neg_integer(),    cache_misses := non_neg_integer(),    avg_match_time := float()}.get_metrics_for_tenant(TenantId) ->    Hits = case ets:lookup(?ROUTE_METRICS_TABLE, {TenantId, cache_hits}) of        [{_, H}] -> H;        [] -> 0    end,    Misses = case ets:lookup(?ROUTE_METRICS_TABLE, {TenantId, cache_misses}) of        [{_, M}] -> M;        [] -> 0    end,    MatchTimes = case ets:lookup(?ROUTE_METRICS_TABLE, {TenantId, match_time}) of        [{_, Times}] -> Times;        [] -> []    end,    AvgTime = case MatchTimes of        [] -> 0.0;        _ -> lists:sum(MatchTimes) / length(MatchTimes)    end,    #{        total_requests => Hits + Misses,        cache_hits => Hits,        cache_misses => Misses,        avg_match_time => AvgTime    }.%% @doc Calculate cache statistics-spec calculate_cache_stats() -> #{    cache_size := non_neg_integer(),    hits := non_neg_integer(),    misses := non_neg_integer(),    hit_rate := float()}.calculate_cache_stats() ->    Size = ets:info(?ROUTE_CACHE_TABLE, size),    HitMatches = ets:match(?ROUTE_METRICS_TABLE, {{cache_hits}, '$1'}),    MissMatches = ets:match(?ROUTE_METRICS_TABLE, {{cache_misses}, '$1'}),    TotalHits = lists:sum([H || [{H}] <- HitMatches]),    TotalMisses = lists:sum([M || [{M}] <- MissMatches]),    HitRate = case (TotalHits + TotalMisses) of        0 -> 0.0;        Total -> TotalHits / Total    end,    #{        cache_size => Size,        hits => TotalHits,        misses => TotalMisses,        hit_rate => HitRate    }.%% @doc Ensure ETS tables exist-spec ensure_tables_exist() -> ok.ensure_tables_exist() ->    case ets:info(?ROUTES_TABLE) of        undefined ->            ets:new(?ROUTES_TABLE, [named_table, public, {keypos, 1}]);        _ -> ok    end,    case ets:info(?ROUTE_CACHE_TABLE) of        undefined ->            ets:new(?ROUTE_CACHE_TABLE, [named_table, public, {keypos, 1}, {write_concurrency, true}]);        _ -> ok    end,    case ets:info(?ROUTE_METRICS_TABLE) of        undefined ->            ets:new(?ROUTE_METRICS_TABLE, [named_table, public, {keypos, 1}, {write_concurrency, true}]);        _ -> ok    end,    ok.