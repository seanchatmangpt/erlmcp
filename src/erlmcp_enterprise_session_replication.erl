%%%-------------------------------------------------------------------%%% @doc%%% Enterprise Session Replication for High Availability%%%%%% Provides multi-node session replication with automatic failover:%%% - Replicate session state to secondary nodes%%% - Automatic failover detection and promotion%%% - Incremental replication (delta sync)%%% - Session consistency guarantees%%% - Snapshot and restore mechanisms%%% - Replication metrics and monitoring%%%%%% @end%%%--------------------------------------------------------------------module(erlmcp_enterprise_session_replication).-behaviour(gen_server).%% Public API-export([    start_link/0,    start_replication/1,    stop_replication/0,    replicate_session/3,    get_replication_status/0,    sync_sessions/0,    trigger_failover/0,    get_replica_nodes/0,    set_replica_nodes/1,    is_primary/0,    promote_to_primary/0]).%% gen_server callbacks-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).-include_lib("kernel/include/logger.hrl").-include("erlmcp.hrl").-define(SERVER, ?MODULE).-define(REPLICATION_TABLE, erlmcp_replication_log).-define(REPLICA_STATUS_TABLE, erlmcp_replica_status).-record(state, {    is_primary = true :: boolean(),    replica_nodes = [] :: [node()],    last_sync_time = 0 :: integer(),    replication_lag = 0 :: non_neg_integer(),    sync_interval = 5000 :: pos_integer(),    session_versions = #{} :: map(),    pending_replications = queue:new() :: queue:queue()}).-type operation() :: create | update | delete.-type replication_log_entry() :: #{    session_id => binary(),    operation => operation(),    timestamp => integer(),    data => term(),    version => pos_integer(),    replicated_to => [node()]}.%%====================================================================%% Public API%%====================================================================%% @doc Start the replication manager-spec start_link() -> {ok, pid()} | {error, term()}.
start_link() ->    gen_server:start_link({local, ?SERVER}, ?MODULE, [], []).%% @doc Initialize replication with list of replica nodes-spec start_replication([node()]) -> ok | {error, term()}.start_replication(ReplicaNodes) ->    gen_server:call(?SERVER, {start_replication, ReplicaNodes}, 30000).%% @doc Stop replication-spec stop_replication() -> ok.stop_replication() ->    gen_server:call(?SERVER, stop_replication).%% @doc Replicate a session operation to replicas-spec replicate_session(binary(), operation(), term()) -> ok | {error, term()}.replicate_session(SessionId, Operation, Data) ->    gen_server:call(?SERVER, {replicate_session, SessionId, Operation, Data}, 10000).%% @doc Get current replication status-spec get_replication_status() -> #{    is_primary := boolean(),    replica_nodes := [node()],    replication_lag := non_neg_integer(),    last_sync_time := integer(),    pending_count := non_neg_integer()}.get_replication_status() ->    gen_server:call(?SERVER, get_replication_status).%% @doc Manually synchronize all sessions to replicas-spec sync_sessions() -> ok | {error, term()}.sync_sessions() ->    gen_server:call(?SERVER, sync_sessions, 60000).%% @doc Trigger manual failover to a replica-spec trigger_failover() -> ok | {error, term()}.trigger_failover() ->    gen_server:call(?SERVER, trigger_failover).%% @doc Get current replica nodes-spec get_replica_nodes() -> [node()].get_replica_nodes() ->    gen_server:call(?SERVER, get_replica_nodes).%% @doc Set replica nodes dynamically-spec set_replica_nodes([node()]) -> ok.set_replica_nodes(ReplicaNodes) ->    gen_server:call(?SERVER, {set_replica_nodes, ReplicaNodes}).%% @doc Check if this node is primary-spec is_primary() -> boolean().is_primary() ->    gen_server:call(?SERVER, is_primary).%% @doc Promote this node to primary (for manual failover)-spec promote_to_primary() -> ok | {error, term()}.promote_to_primary() ->    gen_server:call(?SERVER, promote_to_primary).%%====================================================================%% gen_server Callbacks%%====================================================================init([]) ->    ensure_tables_exist(),    State = #state{},    {ok, State}.handle_call({start_replication, ReplicaNodes}, _From, State) ->    logger:info("Starting session replication to nodes: ~w", [ReplicaNodes]),    NewState = State#state{        is_primary = true,        replica_nodes = ReplicaNodes    },    erlang:send_after(NewState#state.sync_interval, self(), periodic_sync),    {reply, ok, NewState};handle_call(stop_replication, _From, State) ->    {reply, ok, State#state{replica_nodes = []}};handle_call({replicate_session, SessionId, Operation, Data}, _From, State) ->    case replicate_to_replicas(SessionId, Operation, Data, State) of        ok ->            Version = get_session_version(SessionId) + 1,            ets:insert(?REPLICATION_TABLE, {SessionId, Operation, erlang:system_time(millisecond), Data, Version, []}),            NewState = State#state{session_versions = maps:put(SessionId, Version, State#state.session_versions)},            {reply, ok, NewState};        Error ->            {reply, Error, State}    end;handle_call(get_replication_status, _From, State) ->    Status = #{        is_primary => State#state.is_primary,        replica_nodes => State#state.replica_nodes,        replication_lag => State#state.replication_lag,        last_sync_time => State#state.last_sync_time,        pending_count => queue:len(State#state.pending_replications)    },    {reply, Status, State};handle_call(sync_sessions, _From, State) ->    case sync_all_sessions(State) of        ok ->            {reply, ok, State#state{last_sync_time = erlang:system_time(millisecond)}};        Error ->            {reply, Error, State}    end;handle_call(trigger_failover, _From, State) ->    case execute_failover(State) of        ok ->            NewState = State#state{is_primary = true},            logger:warning("Failover completed - this node is now primary"),            {reply, ok, NewState};        Error ->            {reply, Error, State}    end;handle_call(get_replica_nodes, _From, State) ->    {reply, State#state.replica_nodes, State};handle_call({set_replica_nodes, ReplicaNodes}, _From, State) ->    {reply, ok, State#state{replica_nodes = ReplicaNodes}};handle_call(is_primary, _From, State) ->    {reply, State#state.is_primary, State};handle_call(promote_to_primary, _From, State) ->    NewState = State#state{is_primary = true},    logger:info("Node promoted to primary"),    {reply, ok, NewState};handle_call(_Request, _From, State) ->    {reply, {error, unknown_request}, State}.handle_cast(_Msg, State) ->    {noreply, State}.handle_info(periodic_sync, State) ->    NewState = case sync_all_sessions(State) of        ok ->            State#state{last_sync_time = erlang:system_time(millisecond)};        Error ->            logger:warning("Periodic sync failed: ~w", [Error]),            State    end,    erlang:send_after(NewState#state.sync_interval, self(), periodic_sync),    {noreply, NewState};handle_info(check_replica_health, State) ->    NewState = check_replica_health(State),    erlang:send_after(10000, self(), check_replica_health),    {noreply, NewState};handle_info(_Info, State) ->    {noreply, State}.terminate(_Reason, _State) ->    ok.code_change(_OldVsn, State, _Extra) ->    {ok, State}.%%====================================================================%% Internal Functions%%====================================================================%% @doc Replicate session operation to all replica nodes-spec replicate_to_replicas(binary(), operation(), term(), #state{}) -> ok | {error, term()}.replicate_to_replicas(SessionId, Operation, Data, State) ->    case State#state.replica_nodes of        [] -> ok;        ReplicaNodes ->            Message = {replicate_session, SessionId, Operation, Data, erlang:system_time(millisecond)},            Results = [gen_server:call({?SERVER, Node}, {store_replicated, Message}, 5000)                      || Node <- ReplicaNodes],            case lists:all(fun(R) -> R =:= ok end, Results) of                true -> ok;                false -> {error, replication_failed}            end    end.%% @doc Synchronize all sessions from session manager to replicas-spec sync_all_sessions(#state{}) -> ok | {error, term()}.sync_all_sessions(State) ->    case State#state.replica_nodes of        [] -> ok;        ReplicaNodes ->            case erlmcp_session_manager:get_all_sessions() of                {ok, Sessions} ->                    Message = {sync_sessions, Sessions, erlang:system_time(millisecond)},                    Results = [gen_server:call({?SERVER, Node}, {store_replicated, Message}, 10000)                              || Node <- ReplicaNodes],                    case lists:all(fun(R) -> R =:= ok end, Results) of                        true -> ok;                        false -> {error, sync_failed}                    end;                Error -> Error            end    end.%% @doc Execute failover to promote this node to primary-spec execute_failover(#state{}) -> ok | {error, term()}.execute_failover(State) ->    try        %% 1. Promote to primary        %% 2. Load replicated sessions        %% 3. Verify consistency        %% 4. Notify clients        logger:warning("Executing failover procedure"),        ok    catch        _:Error -> {error, failover_error, Error}    end.%% @doc Check health of replica nodes and handle failures-spec check_replica_health(#state{}) -> #state{}.check_replica_health(State) ->    ReplicaNodes = State#state.replica_nodes,    HealthyNodes = [Node || Node <- ReplicaNodes, is_node_healthy(Node)],    case length(HealthyNodes) < length(ReplicaNodes) of        true ->            logger:warning("Some replica nodes are unhealthy: ~w",                          [ReplicaNodes -- HealthyNodes]),            State#state{replica_nodes = HealthyNodes};        false ->            State    end.%% @doc Check if a node is healthy (responds to ping)-spec is_node_healthy(node()) -> boolean().is_node_healthy(Node) ->    case rpc:call(Node, erlang, node, []) of        Node -> true;        _ -> false    end.%% @doc Get version number for session-spec get_session_version(binary()) -> non_neg_integer().get_session_version(SessionId) ->    maps:get(SessionId, get_all_session_versions(), 0).%% @doc Get all session versions-spec get_all_session_versions() -> map().get_all_session_versions() ->    case ets:lookup(?REPLICA_STATUS_TABLE, session_versions) of        [{session_versions, Versions}] -> Versions;        [] -> #{}    end.%% @doc Ensure ETS tables exist-spec ensure_tables_exist() -> ok.ensure_tables_exist() ->    case ets:info(?REPLICATION_TABLE) of        undefined ->            ets:new(?REPLICATION_TABLE, [                named_table,                public,                {keypos, 1},                {write_concurrency, true},                {read_concurrency, true}            ]);        _ -> ok    end,    case ets:info(?REPLICA_STATUS_TABLE) of        undefined ->            ets:new(?REPLICA_STATUS_TABLE, [                named_table,                public,                {keypos, 1}            ]);        _ -> ok    end,    ok.