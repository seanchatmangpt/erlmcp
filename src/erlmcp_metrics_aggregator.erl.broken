%% @doc Metrics aggregation and time-windowing functions
%% Provides statistical aggregations, time-based windowing, and metric analysis
-module(erlmcp_metrics_aggregator).

-export([
    aggregate/3, aggregate/4,
    time_window/3,
    statistical_summary/2,
    percentiles/3,
    rate_calculation/3,
    moving_average/3,
    trend_analysis/2,
    anomaly_detection/2,
    create_report/2
]).

-include_lib("kernel/include/logger.hrl").

-define(DEFAULT_PERCENTILES, [50, 90, 95, 99]).

%% @doc Aggregate metrics by function over time window
aggregate(MetricName, Function, TimeWindowSecs) ->
    aggregate(MetricName, Function, TimeWindowSecs, []).

aggregate(MetricName, Function, TimeWindowSecs, Labels) ->
    EndTime = erlang:system_time(microsecond),
    StartTime = EndTime - (TimeWindowSecs * 1000000),
    
    % Get metrics in time window
    Metrics = erlmcp_metrics:get_metrics(),
    FilteredMetrics = filter_metrics_by_time_and_name(Metrics, MetricName, StartTime, EndTime, Labels),
    
    % Extract values
    Values = [Value || {_, #metric{value = Value}} <- FilteredMetrics],
    
    % Apply aggregation function
    case Values of
        [] -> undefined;
        _ -> apply_aggregation(Function, Values)
    end.

%% @doc Get metrics within a specific time window
time_window(MetricName, StartTime, EndTime) ->
    Metrics = erlmcp_metrics:get_metrics(),
    filter_metrics_by_time_and_name(Metrics, MetricName, StartTime, EndTime, []).

%% @doc Generate statistical summary for a metric
statistical_summary(MetricName, TimeWindowSecs) ->
    Values = case aggregate(MetricName, all_values, TimeWindowSecs) of
        undefined -> [];
        Vals -> Vals
    end,
    
    case Values of
        [] -> #{count => 0};
        _ ->
            SortedValues = lists:sort(Values),
            #{
                count => length(Values),
                min => lists:min(Values),
                max => lists:max(Values),
                mean => lists:sum(Values) / length(Values),
                median => percentile(SortedValues, 50),
                std_dev => standard_deviation(Values),
                percentiles => calculate_percentiles(SortedValues, ?DEFAULT_PERCENTILES)
            }
    end.

%% @doc Calculate specific percentiles
percentiles(MetricName, TimeWindowSecs, PercentileList) ->
    case aggregate(MetricName, all_values, TimeWindowSecs) of
        undefined -> #{};
        Values ->
            SortedValues = lists:sort(Values),
            calculate_percentiles(SortedValues, PercentileList)
    end.

%% @doc Calculate rate of change
rate_calculation(MetricName, TimeWindowSecs, RateType) ->
    EndTime = erlang:system_time(microsecond),
    StartTime = EndTime - (TimeWindowSecs * 1000000),
    
    Metrics = erlmcp_metrics:get_metrics(),
    FilteredMetrics = filter_metrics_by_time_and_name(Metrics, MetricName, StartTime, EndTime, []),
    
    case length(FilteredMetrics) of
        0 -> 0.0;
        1 -> 0.0;
        _ ->
            SortedMetrics = lists:sort(fun({_, A}, {_, B}) ->
                A#metric.timestamp =< B#metric.timestamp
            end, FilteredMetrics),
            
            calculate_rate(SortedMetrics, RateType)
    end.

%% @doc Calculate moving average
moving_average(MetricName, WindowSize, TimeWindowSecs) ->
    case aggregate(MetricName, all_values, TimeWindowSecs) of
        undefined -> [];
        Values when length(Values) < WindowSize -> Values;
        Values ->
            calculate_moving_average(Values, WindowSize)
    end.

%% @doc Analyze trends in metric data
trend_analysis(MetricName, TimeWindowSecs) ->
    EndTime = erlang:system_time(microsecond),
    StartTime = EndTime - (TimeWindowSecs * 1000000),
    
    Metrics = erlmcp_metrics:get_metrics(),
    FilteredMetrics = filter_metrics_by_time_and_name(Metrics, MetricName, StartTime, EndTime, []),
    
    case length(FilteredMetrics) of
        0 -> #{trend => no_data};
        N when N < 3 -> #{trend => insufficient_data, count => N};
        _ ->
            SortedMetrics = lists:sort(fun({_, A}, {_, B}) ->
                A#metric.timestamp =< B#metric.timestamp
            end, FilteredMetrics),
            
            analyze_trend(SortedMetrics)
    end.

%% @doc Detect anomalies in metric data
anomaly_detection(MetricName, TimeWindowSecs) ->
    Summary = statistical_summary(MetricName, TimeWindowSecs),
    
    case maps:get(count, Summary, 0) of
        0 -> #{anomalies => [], status => no_data};
        Count when Count < 10 -> #{anomalies => [], status => insufficient_data};
        _ ->
            Mean = maps:get(mean, Summary),
            StdDev = maps:get(std_dev, Summary),
            
            % Define anomaly thresholds (values beyond 2 standard deviations)
            UpperThreshold = Mean + (2 * StdDev),
            LowerThreshold = Mean - (2 * StdDev),
            
            % Get recent values
            RecentValues = case aggregate(MetricName, all_values, 300) of % Last 5 minutes
                undefined -> [];
                Vals -> Vals
            end,
            
            Anomalies = lists:filter(fun(Value) ->
                Value > UpperThreshold orelse Value < LowerThreshold
            end, RecentValues),
            
            #{
                anomalies => Anomalies,
                count => length(Anomalies),
                thresholds => #{upper => UpperThreshold, lower => LowerThreshold},
                status => case length(Anomalies) of
                    0 -> normal;
                    N when N < 3 -> minor_anomalies;
                    _ -> significant_anomalies
                end
            }
    end.

%% @doc Create comprehensive metrics report
create_report(MetricNames, TimeWindowSecs) ->
    ReportTime = erlang:system_time(microsecond),
    
    MetricReports = lists:map(fun(MetricName) ->
        #{
            name => MetricName,
            summary => statistical_summary(MetricName, TimeWindowSecs),
            trend => trend_analysis(MetricName, TimeWindowSecs),
            anomalies => anomaly_detection(MetricName, TimeWindowSecs),
            rate => rate_calculation(MetricName, TimeWindowSecs, per_second)
        }
    end, MetricNames),
    
    #{
        report_time => ReportTime,
        time_window_seconds => TimeWindowSecs,
        metrics => MetricReports,
        system_summary => erlmcp_metrics:get_summary()
    }.

%% Internal helper functions

filter_metrics_by_time_and_name(Metrics, MetricName, StartTime, EndTime, Labels) ->
    lists:filter(fun({{Type, Name, MetricLabels}, Metric}) ->
        #metric{timestamp = Timestamp} = Metric,
        NameMatches = (Name =:= MetricName orelse 
                      (is_list(MetricName) andalso string:find(atom_to_list(Name), MetricName) =/= nomatch)),
        TimeInRange = Timestamp >= StartTime andalso Timestamp =< EndTime,
        LabelsMatch = case Labels of
            [] -> true;
            _ -> lists:all(fun(Label) -> lists:member(Label, MetricLabels) end, Labels)
        end,
        NameMatches andalso TimeInRange andalso LabelsMatch
    end, Metrics).

apply_aggregation(sum, Values) -> lists:sum(Values);
apply_aggregation(avg, Values) -> lists:sum(Values) / length(Values);
apply_aggregation(mean, Values) -> lists:sum(Values) / length(Values);
apply_aggregation(min, Values) -> lists:min(Values);
apply_aggregation(max, Values) -> lists:max(Values);
apply_aggregation(count, Values) -> length(Values);
apply_aggregation(all_values, Values) -> Values;
apply_aggregation(last, Values) -> lists:last(Values);
apply_aggregation(first, Values) -> hd(Values).

calculate_percentiles([], _) -> #{};
calculate_percentiles(SortedValues, Percentiles) ->
    lists:foldl(fun(P, Acc) ->
        maps:put(P, percentile(SortedValues, P), Acc)
    end, #{}, Percentiles).

percentile([], _) -> undefined;
percentile(SortedValues, Percentile) ->
    N = length(SortedValues),
    K = (Percentile / 100) * (N - 1) + 1,
    Ki = trunc(K),
    Kf = K - Ki,
    
    if
        Ki >= N -> lists:last(SortedValues);
        Ki < 1 -> hd(SortedValues);
        true ->
            V1 = lists:nth(Ki, SortedValues),
            V2 = lists:nth(Ki + 1, SortedValues),
            V1 + Kf * (V2 - V1)
    end.

standard_deviation([]) -> 0;
standard_deviation([_]) -> 0;
standard_deviation(Values) ->
    Mean = lists:sum(Values) / length(Values),
    Variance = lists:sum([math:pow(X - Mean, 2) || X <- Values]) / length(Values),
    math:sqrt(Variance).

calculate_rate(SortedMetrics, per_second) ->
    {_, FirstMetric} = hd(SortedMetrics),
    {_, LastMetric} = lists:last(SortedMetrics),
    
    TimeDiff = (LastMetric#metric.timestamp - FirstMetric#metric.timestamp) / 1000000, % Convert to seconds
    ValueDiff = LastMetric#metric.value - FirstMetric#metric.value,
    
    case TimeDiff of
        0 -> 0.0;
        _ -> ValueDiff / TimeDiff
    end;

calculate_rate(SortedMetrics, per_minute) ->
    calculate_rate(SortedMetrics, per_second) * 60;

calculate_rate(SortedMetrics, per_hour) ->
    calculate_rate(SortedMetrics, per_second) * 3600.

calculate_moving_average(Values, WindowSize) ->
    calculate_moving_average(Values, WindowSize, []).

calculate_moving_average(Values, WindowSize, Acc) when length(Values) < WindowSize ->
    lists:reverse(Acc);
calculate_moving_average([H|T] = Values, WindowSize, Acc) ->
    Window = lists:sublist(Values, WindowSize),
    Average = lists:sum(Window) / WindowSize,
    calculate_moving_average(T, WindowSize, [Average|Acc]).

analyze_trend(SortedMetrics) ->
    Values = [Metric#metric.value || {_, Metric} <- SortedMetrics],
    Times = [Metric#metric.timestamp || {_, Metric} <- SortedMetrics],
    
    % Simple linear regression
    N = length(Values),
    SumX = lists:sum(Times),
    SumY = lists:sum(Values),
    SumXY = lists:sum([X * Y || {X, Y} <- lists:zip(Times, Values)]),
    SumX2 = lists:sum([X * X || X <- Times]),
    
    % Calculate slope (trend direction)
    Denominator = N * SumX2 - SumX * SumX,
    case Denominator of
        0 -> #{trend => no_trend, slope => 0};
        _ ->
            Slope = (N * SumXY - SumX * SumY) / Denominator,
            Intercept = (SumY - Slope * SumX) / N,
            
            % Calculate correlation coefficient
            MeanX = SumX / N,
            MeanY = SumY / N,
            
            Numerator = lists:sum([(X - MeanX) * (Y - MeanY) || {X, Y} <- lists:zip(Times, Values)]),
            DenomX = math:sqrt(lists:sum([math:pow(X - MeanX, 2) || X <- Times])),
            DenomY = math:sqrt(lists:sum([math:pow(Y - MeanY, 2) || Y <- Values])),
            
            Correlation = case DenomX * DenomY of
                0 -> 0;
                Denom -> Numerator / Denom
            end,
            
            TrendDirection = if
                Slope > 0.001 -> increasing;
                Slope < -0.001 -> decreasing;
                true -> stable
            end,
            
            #{
                trend => TrendDirection,
                slope => Slope,
                intercept => Intercept,
                correlation => Correlation,
                strength => case abs(Correlation) of
                    C when C > 0.8 -> strong;
                    C when C > 0.5 -> moderate;
                    C when C > 0.2 -> weak;
                    _ -> very_weak
                end
            }
    end.