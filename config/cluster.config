%% ===================================================================
%% ERLMCP CLUSTER CONFIGURATION - 4 Node, 100K Concurrent Connections
%% ===================================================================
%% This configuration enables distributed Erlang clustering with optimized
%% settings for handling 100,000 concurrent connections across 4 nodes
%% (25,000 connections per node).
%%
%% Usage:
%%   Node 1: erl -sname erlmcp1 -config cluster -pa _build/default/lib/*/ebin
%%   Node 2: erl -sname erlmcp2 -config cluster -pa _build/default/lib/*/ebin
%%   Node 3: erl -sname erlmcp3 -config cluster -pa _build/default/lib/*/ebin
%%   Node 4: erl -sname erlmcp4 -config cluster -pa _build/default/lib/*/ebin
%% ===================================================================

[
    %% ERLMCP Application Configuration
    {erlmcp, [
        %% Logging configuration
        {log_level, info},

        %% Client defaults
        {client_defaults, #{
            timeout => 5000,
            strict_mode => false,
            max_pending_requests => 100
        }},

        %% Server defaults with cluster awareness
        {server_defaults, #{
            max_subscriptions_per_resource => 1000,
            max_progress_tokens => 10000,
            %% Enable inter-node replication for critical state
            enable_state_replication => true,
            replication_mode => async  % async or sync
        }},

        %% Cluster Configuration
        {cluster, [
            %% Enable cluster mode
            {enabled, true},

            %% This node's cluster role: 'primary' or 'replica'
            %% Set dynamically based on node startup order
            {node_role, primary},

            %% Inter-node heartbeat interval (milliseconds)
            {heartbeat_interval => 5000},

            %% Node timeout before declaring dead (milliseconds)
            {node_timeout => 15000},

            %% Synchronization strategy: 'eager' or 'lazy'
            %% 'eager' = sync on every state change (slower, consistent)
            %% 'lazy' = batch sync periodically (faster, eventual consistency)
            {sync_strategy => lazy},

            %% Lazy sync interval in milliseconds
            {sync_interval => 1000},

            %% Maximum message queue size per inter-node link
            {max_message_queue => 10000},

            %% Enable auto-clustering (nodes auto-discover each other)
            {auto_clustering => true},

            %% List of known cluster nodes (for static topology)
            %% Format: [{'erlmcp1@localhost', 'erlmcp2@localhost', ...}]
            {known_nodes, [
                'erlmcp1@localhost',
                'erlmcp2@localhost',
                'erlmcp3@localhost',
                'erlmcp4@localhost'
            ]},

            %% Connection pooling between nodes
            {inter_node_pool_size => 4},
            {inter_node_pool_timeout => 5000}
        ]},

        %% Message routing configuration for cluster
        {message_routing, [
            %% Hash function for connection routing: 'murmur3' or 'xxhash'
            {hash_function => murmur3},

            %% Connection sticky routing (keep client on same node)
            {sticky_routing => true},

            %% Global message routing table update interval (ms)
            {routing_table_update_interval => 5000}
        ]},

        %% Message Size Limits
        {message_size_limits, #{
            default => 16777216,          % 16 MB
            http_body => 16777216,
            sse_event => 16777216,
            websocket => 16777216,
            tcp => 16777216,
            stdio => 16777216
        }},

        %% Transport settings optimized for clustering
        {transport_defaults, #{
            tcp => #{
                connect_timeout => 5000,
                keepalive => true,
                nodelay => true,
                %% TCP tuning for high concurrency
                send_buf_size => 2097152,    % 2 MB
                recv_buf_size => 2097152,    % 2 MB
                backlog => 2048
            },
            http => #{
                connect_timeout => 5000,
                request_timeout => 30000,
                max_connections => 25000,    % 25K per node
                %% Connection pooling
                pool_size => 100,
                pool_queue_size => 1000
            }
        }},

        %% Connection Limits per node (for 25K concurrent)
        {connection_limits, #{
            %% Max concurrent TCP connections per transport
            tcp_max_connections => 25000,

            %% Max concurrent HTTP connections per transport
            http_max_connections => 25000,

            %% Max concurrent WebSocket connections per transport
            websocket_max_connections => 25000,

            %% Global limit across all nodes
            %% Set to 100000 to allow 25K * 4 nodes
            global_max_connections => 100000,

            %% Connection timeout (connections idle > this are closed)
            idle_timeout_ms => 300000,     % 5 minutes

            %% Rate limiting to prevent connection bombing
            max_new_connections_per_sec => 500  % 500 new conn/sec per node
        ]},

        %% HTTP Security Configuration
        {http_security, [
            {allowed_origins, [
                "http://localhost",
                "http://localhost:*",
                "https://localhost",
                "https://localhost:*",
                "http://127.0.0.1",
                "http://127.0.0.1:*",
                "https://127.0.0.1",
                "https://127.0.0.1:*"
            ]},
            {session_timeout, 1800},
            {require_https, false},
            {http_redirect_to_https, true},
            {http_bind_address, "0.0.0.0"},    % Cluster: bind to all interfaces
            {https_bind_address, "0.0.0.0"}
        ]},

        %% Localhost Binding Security
        {localhost_binding, [
            {enforce_localhost_only, false},   % Cluster: allow all interfaces
            {http_bind_address, "0.0.0.0"},
            {http_bind_ipv6, "::"},
            {security_policy, "cluster"}
        ]},

        %% HTTPS/TLS Configuration
        {https_config, [
            {enabled, false},
            {certfile, "priv/cert.pem"},
            {keyfile, "priv/key.pem"},
            {cacertfile, undefined},
            {min_tls_version, 'tlsv1.2'},
            {ciphers, [
                "ECDHE-RSA-AES256-GCM-SHA384",
                "ECDHE-RSA-AES128-GCM-SHA256",
                "ECDHE-RSA-CHACHA20-POLY1305",
                "DHE-RSA-AES256-GCM-SHA384",
                "DHE-RSA-AES128-GCM-SHA256"
            ]},
            {enable_hsts, true},
            {hsts_max_age, 31536000},
            {hsts_include_subdomains, false},
            {verify_mode, 'verify_peer'},
            {sni_enabled, true},
            {verify_hostname, true},
            {verify_depth, 3},
            {pinned_certs, undefined}
        ]},

        %% Session Manager Configuration
        {session_manager, [
            {timeout, 1800},
            {cleanup_interval, 300000}
        ]}
    ]},

    %% KERNEL Configuration - Distributed Erlang Settings
    {kernel, [
        %% Logger configuration
        {logger_level, info},
        {logger, [
            {handler, default, logger_std_h, #{
                config => #{
                    type => standard_io,
                    sync_mode_qlen => 100,
                    drop_mode_qlen => 1000,
                    flush_qlen => 2000
                },
                formatter => {logger_formatter, #{
                    template => [time, " [", level, "] ", pid, " ", mfa, ":", line, " ", msg, "\n"],
                    time_offset => "",
                    time_designator => $T,
                    single_line => false,
                    max_size => 4096
                }},
                filters => [
                    {progress_reports, {fun logger_filters:progress/2, stop}},
                    {sasl_reports, {fun logger_filters:domain/2, {stop, sub, [otp, sasl]}}}
                ],
                level => info
            }},
            {handler, file_log, logger_std_h, #{
                config => #{
                    file => "logs/erlmcp.log",
                    max_no_bytes => 10485760,  % 10 MB
                    max_no_files => 5,
                    compress_on_rotate => true
                },
                formatter => {logger_formatter, #{
                    template => [time, " [", level, "] ", pid, " ", mfa, ":", line, " ", msg, "\n"]
                }},
                level => debug
            }}
        ]},

        %% Distributed Erlang Configuration
        %% Inter-node communication timeout (milliseconds)
        {net_ticktime, 15},

        %% Erlang distributed environment variables
        {distributed, [
            {erlmcp, 5000, [
                'erlmcp1@localhost',
                'erlmcp2@localhost',
                'erlmcp3@localhost',
                'erlmcp4@localhost'
            ]}
        ]}
    ]},

    %% SASL Configuration
    {sasl, [
        {sasl_error_logger, false},
        {errlog_type, error},
        {error_logger_format_depth, 20}
    ]},

    %% OpenTelemetry Configuration
    {opentelemetry, [
        {span_processor, batch},
        {traces_exporter, otlp}
    ]},

    {opentelemetry_exporter, [
        {otlp_protocol, http_protobuf},
        {otlp_endpoint, "http://localhost:4318"}
    ]},

    %% TCPS Health Monitoring
    {tcps_health, [
        {otel_endpoint, "http://localhost:4318"},
        {service_name, "tcps-erlmcp-cluster"},
        {service_version, "0.7.0"},
        {environment, "cluster"},
        {check_interval, 30000},
        {alert_check_interval, 10000},
        {metrics_port, 9090},
        {metrics_retention_days, 7},
        {alert_channels, [slack, email]},
        {enable_auto_remediation, true},
        {slack_webhook, {env, "ERLMCP_SLACK_WEBHOOK"}},
        {slack_channel, "#tcps-alerts"},
        {slack_username, "TCPS Cluster Monitor"},
        {email_smtp, "smtp.example.com:587"},
        {email_from, "tcps-alerts@example.com"},
        {email_to, ["ops-team@example.com"]},
        {email_username, "alerts@example.com"},
        {email_password, {env, "ERLMCP_EMAIL_PASSWORD"}},
        {trace_sample_rate, 0.1},       % 10% sampling in cluster
        {dashboard_enabled, true},
        {dashboard_port, 8080},
        {dashboard_refresh_interval, 5000},
        {debug_mode, false},
        {verbose_logging, false}
    ]},

    %% OAuth 2.0 Configuration
    {oauth, [
        {enabled, true},
        {client_id, {env, "OAUTH_CLIENT_ID"}},
        {client_secret, {env, "OAUTH_CLIENT_SECRET"}},
        {token_endpoint, {env, "OAUTH_TOKEN_ENDPOINT", "https://oauth.example.com/token"}},
        {resource_indicator, {env, "OAUTH_RESOURCE_INDICATOR", "https://mcp.example.com"}},
        {cache_ttl, 3600}
    ]},

    %% WebSocket Configuration
    {websocket, [
        {enabled, true},
        {port, 8080},
        {path, "/mcp/ws"},
        {ping_interval, 30000},
        {idle_timeout, 300000},
        {max_connections, 25000},      % 25K per node
        {connect_timeout, 5000},
        {frame_buffer_size, 102400},
        {buffer_drain_threshold, 0.5},
        {backpressure_timeout, 5000}
    ]},

    %% SSE Configuration
    {sse, [
        {enabled, true},
        {port, 8081},
        {path, "/mcp/sse"},
        {keepalive_interval, 30000},
        {stream_timeout, 300000},
        {retry_timeout, 5000}
    ]},

    %% Roots Enforcement
    {roots, [
        {allowed_paths, {env, "ERLMCP_ALLOWED_PATHS", ["/tmp"]}},
        {symlink_follow, false},
        {canonicalize_paths, true},
        {watch_changes, true}
    ]},

    %% Job Queue Configuration
    {jobs, [
        {queues, [
            {mcp_tasks, [
                {regulators, [{counter, [{limit, 10}]}]},
                {max_time, 300000}
            ]}
        ]}
    ]},

    %% Elicitation Configuration
    {elicitation, [
        {enabled, true},
        {form_timeout, 600000},
        {max_concurrent_forms, 100},
        {sandbox_enabled, true},
        {require_user_confirmation, true}
    ]},

    %% Icon Metadata Configuration
    {icons, [
        {enabled, true},
        {max_data_uri_size, 102400},
        {cache_enabled, true},
        {cache_ttl_ms, 3600000}
    ]},

    {icon_cache_ttl_ms, 3600000},

    %% Initialization Timeout
    {init_timeout_ms, 30000},

    %% Rate Limiting Configuration
    {rate_limiting, #{
        max_messages_per_sec => 100,
        max_connections_per_sec => 10,
        global_max_messages_per_sec => 10000,
        max_tool_calls_per_sec => 50,
        max_subscriptions_per_sec => 20,
        bucket_refill_interval_ms => 100,
        ddos_violation_threshold => 100,
        ddos_block_duration_ms => 300000,
        enabled => true
    }}
].
