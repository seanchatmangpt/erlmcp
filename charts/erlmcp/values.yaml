# Global settings
global:
  # Registry settings
  registry: ghcr.io
  repository: your-org/erlmcp
  imagePullSecrets:
    - name: erlmcp-regcred

  # Domain settings
  domain: erlmcp.com
  subdomain: api

  # TLS settings
  tls:
    enabled: true
    issuer: letsencrypt-prod

  # Logging
  logging:
    level: info
    format: json
    enabled: true

# Common configuration
common:
  # Environment
  environment: staging

  # Resource requests/limits
  resources:
    requests:
      cpu: "100m"
      memory: "256Mi"
    limits:
      cpu: "500m"
      memory: "1Gi"

  # Security context
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
    capabilities:
      drop: ["ALL"]
      add: ["NET_BIND_SERVICE"]

  # Probes
  livenessProbe:
    httpGet:
      path: /mcp/health
      port: http
    initialDelaySeconds: 30
    periodSeconds: 10
    failureThreshold: 3
    timeoutSeconds: 5
  readinessProbe:
    httpGet:
      path: /mcp/health?ready=1
      port: http
    initialDelaySeconds: 10
    periodSeconds: 5
    failureThreshold: 3
    timeoutSeconds: 3

# Main application configuration
erlmcp:
  enabled: true
  replicaCount: 2

  # Image settings
  image:
    tag: "latest"
    pullPolicy: IfNotPresent

  # Service settings
  service:
    type: LoadBalancer
    port: 8080
    annotations:
      service.beta.kubernetes.io/aws-load-balancer-type: nlb
      service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp
      external-dns.alpha.kubernetes.io/hostname: api.erlmcp.com

  # Ingress settings
  ingress:
    enabled: true
    className: "nginx"
    annotations:
      nginx.ingress.kubernetes.io/rewrite-target: /
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
      cert-manager.io/cluster-issuer: "letsencrypt-prod"
    hosts:
      - host: api.erlmcp.com
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: erlmcp
                port:
                  number: 8080
    tls:
      - secretName: erlmcp-tls
        hosts:
          - api.erlmcp.com

  # Deployment configuration
  deployment:
    strategy:
      type: RollingUpdate
      rollingUpdate:
        maxSurge: 1
        maxUnavailable: 1
    revisionHistoryLimit: 10

  # Environment variables
  env:
    - name: ENVIRONMENT
      value: {{ .Values.global.common.environment }}
    - name: LOG_LEVEL
      value: {{ .Values.global.common.logging.level }}
    - name: METRICS_ENABLED
      value: "true"
    - name: HEALTH_CHECK_PATH
      value: "/mcp/health"
    - name: DATABASE_URL
      valueFrom:
        secretKeyRef:
          name: erlmcp-db-secret
          key: url
    - name: REDIS_URL
      valueFrom:
        secretKeyRef:
          name: erlmcp-redis-secret
          key: url
    - name: OTEL_EXPORTER_OTLP_ENDPOINT
      value: "http://otlp-collector.monitoring.svc.cluster.local:4317"

  # Volumes
  volumes:
    - name: config
      configMap:
        name: erlmcp-config
    - name: certs
      secret:
        secretName: erlmcp-certs
    - name: logs
      emptyDir: {}

  # Volume mounts
  volumeMounts:
    - name: config
      mountPath: /etc/erlmcp
      readOnly: true
    - name: certs
      mountPath: /etc/erlmcp/certs
      readOnly: true
    - name: logs
      mountPath: /var/log/erlmcp

  # Node affinity
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
            - key: node-role.kubernetes.io/erlmcp
              operator: Exists
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                    - erlmcp
            topologyKey: kubernetes.io/hostname

  # Tolerations
  tolerations:
    - key: "node-role.kubernetes.io/control-plane"
      operator: "Exists"
      effect: "NoSchedule"

# Canary deployment
canary:
  enabled: false
  percentage: 10
  annotations:
    argoproj.io/canary: "true"
    rollouts.argoproj.io/canary: "true"
    rollouts.argoproj.io/traffic-weight: "10"

  # Environment
  env:
    - name: CANARY_ENABLED
      value: "true"
    - name: TRAFFIC_PERCENT
      value: "10"

  # Resources (scaled down)
  resources:
    requests:
      cpu: "50m"
      memory: "128Mi"
    limits:
      cpu: "250m"
      memory: "512Mi"

# Horizontal Pod Autoscaler
hpa:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 50
          periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
        - type: Percent
          value: 100
          periodSeconds: 15

# Prometheus monitoring
monitoring:
  enabled: true
  serviceMonitor:
    enabled: true
    interval: 30s
    path: /metrics
    port: http
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "http"
    prometheus.io/path: "/metrics"

# Resource management
resources:
  limits:
    cpu: "500m"
    memory: "1Gi"
  requests:
    cpu: "100m"
    memory: "256Mi"

# Node selector
nodeSelector:
  node-role.kubernetes.io/erlmcp: "true"

# Security settings
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000
  capabilities:
    drop: ["ALL"]
    add: ["NET_BIND_SERVICE"]
  seccompProfile:
    type: RuntimeDefault

# Network policies
networkPolicy:
  enabled: true
  egress:
    - to: []
      ports:
        - protocol: TCP
          port: 80
        - protocol: TCP
          port: 443
        - protocol: TCP
          port: 5432
        - protocol: TCP
          port: 6379
        - protocol: TCP
          port: 8080
  ingress: []

# Service account
serviceAccount:
  create: true
  name: erlmcp
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT:role/erlmcp-role