name: Deploy to Staging

on:
  push:
    branches:
      - develop
      - main
    paths:
      - 'src/**'
      - 'config/**'
      - 'Dockerfile'
      - '.github/workflows/deploy-staging.yml'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy'
        required: false
        default: 'latest'

env:
  GCP_REGION: us-central1
  GCP_PROJECT_ID: taiea-dev
  GKE_CLUSTER: taiea-staging-cluster
  GKE_ZONE: us-central1-a
  ARTIFACT_REGISTRY: us-central1-docker.pkg.dev
  ARTIFACT_REGISTRY_REPO: erlmcp-tai-repo
  APP_NAME: erlmcp

jobs:
  # Job 1: Build Docker image
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.image.outputs.tag }}
      image_url: ${{ steps.image.outputs.url }}

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure Docker authentication
        run: |
          gcloud auth configure-docker ${{ env.ARTIFACT_REGISTRY }}

      - name: Determine image tag
        id: image
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TAG="${{ github.event.inputs.version }}"
          else
            TAG="${{ github.sha }}"
          fi
          URL="${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY_REPO }}/${{ env.APP_NAME }}:${TAG}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "url=${URL}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.image.outputs.url }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.image.outputs.tag }}

      - name: Image digest
        run: |
          echo "Pushed image: ${{ steps.image.outputs.url }}"

  # Job 2: Run automated tests
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: build

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry
        uses: actions/cache@v3
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-registry-

      - name: Cache cargo index
        uses: actions/cache@v3
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-git-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-git-

      - name: Cache cargo build
        uses: actions/cache@v3
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-build-target-

      - name: Run unit tests
        run: cargo test --lib --verbose

      - name: Run integration tests
        run: cargo test --test '*' --verbose
        timeout-minutes: 30

      - name: Run linting
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: Format check
        run: cargo fmt -- --check

  # Job 3: Security scanning
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build

    permissions:
      contents: read
      security-events: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Scan container image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build.outputs.image_url }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Run Trivy vulnerability scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build.outputs.image_url }}
          format: 'table'
          exit-code: '0'  # Don't fail on vulnerabilities, just report

  # Job 4: Deploy to Staging
  deploy:
    name: Deploy to Staging GKE
    runs-on: ubuntu-latest
    needs: [build, test, security-scan]

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
            --zone ${{ env.GKE_ZONE }} \
            --project ${{ env.GCP_PROJECT_ID }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Create/update Kubernetes secrets
        run: |
          kubectl create namespace taiea-staging --dry-run=client -o yaml | kubectl apply -f -

          # Load environment variables
          kubectl create secret generic taiea-staging-env \
            --from-env-file=config/staging.env \
            --namespace=taiea-staging \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to GKE
        run: |
          # Create deployment manifest
          cat > /tmp/deployment.yaml << 'EOF'
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: taiea-staging
            namespace: taiea-staging
            labels:
              app: erlmcp
              environment: staging
              version: ${{ needs.build.outputs.image_tag }}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: erlmcp
                environment: staging
            strategy:
              type: RollingUpdate
              rollingUpdate:
                maxSurge: 1
                maxUnavailable: 0
            template:
              metadata:
                labels:
                  app: erlmcp
                  environment: staging
                  version: ${{ needs.build.outputs.image_tag }}
                annotations:
                  prometheus.io/scrape: "true"
                  prometheus.io/port: "8080"
                  prometheus.io/path: "/metrics"
              spec:
                serviceAccountName: taiea-staging
                securityContext:
                  runAsNonRoot: true
                  runAsUser: 1000
                  fsGroup: 1000

                containers:
                - name: erlmcp
                  image: ${{ needs.build.outputs.image_url }}
                  imagePullPolicy: Always

                  ports:
                  - name: http
                    containerPort: 8080
                    protocol: TCP
                  - name: metrics
                    containerPort: 9090
                    protocol: TCP

                  envFrom:
                  - secretRef:
                      name: taiea-staging-env

                  resources:
                    requests:
                      cpu: 250m
                      memory: 512Mi
                    limits:
                      cpu: 500m
                      memory: 1Gi

                  livenessProbe:
                    httpGet:
                      path: /health
                      port: http
                    initialDelaySeconds: 30
                    periodSeconds: 10
                    timeoutSeconds: 5
                    failureThreshold: 3

                  readinessProbe:
                    httpGet:
                      path: /health
                      port: http
                    initialDelaySeconds: 10
                    periodSeconds: 5
                    timeoutSeconds: 3
                    failureThreshold: 2

                  securityContext:
                    allowPrivilegeEscalation: false
                    readOnlyRootFilesystem: true
                    capabilities:
                      drop:
                      - ALL

                  volumeMounts:
                  - name: tmp
                    mountPath: /tmp
                  - name: logs
                    mountPath: /var/logs

                volumes:
                - name: tmp
                  emptyDir: {}
                - name: logs
                  emptyDir: {}

                affinity:
                  podAntiAffinity:
                    preferredDuringSchedulingIgnoredDuringExecution:
                    - weight: 100
                      podAffinityTerm:
                        labelSelector:
                          matchExpressions:
                          - key: app
                            operator: In
                            values:
                            - erlmcp
                        topologyKey: kubernetes.io/hostname
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: taiea-staging
            namespace: taiea-staging
            labels:
              app: erlmcp
              environment: staging
          spec:
            type: LoadBalancer
            selector:
              app: erlmcp
              environment: staging
            ports:
            - name: http
              port: 80
              targetPort: http
              protocol: TCP
            - name: metrics
              port: 9090
              targetPort: metrics
              protocol: TCP
          ---
          apiVersion: autoscaling/v2
          kind: HorizontalPodAutoscaler
          metadata:
            name: taiea-staging
            namespace: taiea-staging
          spec:
            scaleTargetRef:
              apiVersion: apps/v1
              kind: Deployment
              name: taiea-staging
            minReplicas: 2
            maxReplicas: 4
            metrics:
            - type: Resource
              resource:
                name: cpu
                target:
                  type: Utilization
                  averageUtilization: 70
            - type: Resource
              resource:
                name: memory
                target:
                  type: Utilization
                  averageUtilization: 80
          EOF

          # Apply deployment
          kubectl apply -f /tmp/deployment.yaml

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/taiea-staging \
            --namespace=taiea-staging \
            --timeout=300s

      - name: Get service endpoint
        id: service
        run: |
          SERVICE_IP=$(kubectl get service taiea-staging \
            --namespace=taiea-staging \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}' \
            2>/dev/null || echo "pending")
          echo "endpoint=${SERVICE_IP}" >> $GITHUB_OUTPUT
          echo "Service endpoint: ${SERVICE_IP}"

  # Job 5: Run smoke tests
  smoke-tests:
    name: Run Smoke Tests
    runs-on: ubuntu-latest
    needs: deploy

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
            --zone ${{ env.GKE_ZONE }} \
            --project ${{ env.GCP_PROJECT_ID }}

      - name: Wait for service IP
        run: |
          echo "Waiting for service to get external IP..."
          for i in {1..60}; do
            SERVICE_IP=$(kubectl get service taiea-staging \
              --namespace=taiea-staging \
              -o jsonpath='{.status.loadBalancer.ingress[0].ip}' \
              2>/dev/null || echo "")
            if [[ -n "$SERVICE_IP" ]]; then
              echo "Service IP: ${SERVICE_IP}"
              echo "SERVICE_IP=${SERVICE_IP}" >> $GITHUB_ENV
              break
            fi
            echo "Attempt $i: Service IP not ready yet, waiting..."
            sleep 10
          done

      - name: Health check
        run: |
          for i in {1..10}; do
            if curl -sf "http://${SERVICE_IP}:80/health"; then
              echo "Health check passed"
              exit 0
            fi
            echo "Attempt $i: Health check failed, retrying..."
            sleep 10
          done
          echo "Health check failed after all retries"
          exit 1

      - name: Basic API test
        run: |
          # Test basic connectivity
          curl -v "http://${SERVICE_IP}:80/health"

      - name: Metrics endpoint test
        run: |
          # Verify metrics endpoint accessible
          curl -s "http://${SERVICE_IP}:9090/metrics" | head -20

  # Job 6: Integration tests
  integration-tests:
    name: Run Integration Tests
    runs-on: ubuntu-latest
    needs: deploy

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
            --zone ${{ env.GKE_ZONE }} \
            --project ${{ env.GCP_PROJECT_ID }}

      - name: Get service endpoint
        run: |
          SERVICE_IP=$(kubectl get service taiea-staging \
            --namespace=taiea-staging \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}' \
            2>/dev/null || echo "")
          echo "STAGING_SERVICE_URL=http://${SERVICE_IP}:80" >> $GITHUB_ENV

      - name: Run integration tests
        run: |
          cargo test --test '*' --verbose -- --ignored \
            --test-threads=1 \
            --nocapture
        env:
          STAGING_SERVICE_URL: ${{ env.STAGING_SERVICE_URL }}
        timeout-minutes: 30

  # Job 7: Performance baseline
  performance-baseline:
    name: Performance Baseline
    runs-on: ubuntu-latest
    needs: deploy

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
            --zone ${{ env.GKE_ZONE }} \
            --project ${{ env.GCP_PROJECT_ID }}

      - name: Get service endpoint
        run: |
          SERVICE_IP=$(kubectl get service taiea-staging \
            --namespace=taiea-staging \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}' \
            2>/dev/null || echo "")
          echo "STAGING_SERVICE_URL=http://${SERVICE_IP}:80" >> $GITHUB_ENV

      - name: Install k6 (load testing tool)
        run: |
          sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3232A
          echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install -y k6

      - name: Run basic load test
        run: |
          cat > /tmp/load_test.js << 'EOF'
          import http from 'k6/http';
          import { check, sleep } from 'k6';

          export const options = {
            vus: 10,
            duration: '30s',
            thresholds: {
              http_req_duration: ['p(95)<500', 'p(99)<1000'],
              http_req_failed: ['rate<0.1'],
            },
          };

          export default function() {
            let response = http.get(`${__ENV.STAGING_SERVICE_URL}/health`);
            check(response, {
              'status is 200': (r) => r.status === 200,
              'response time < 500ms': (r) => r.timings.duration < 500,
            });
            sleep(1);
          }
          EOF

          k6 run /tmp/load_test.js
        env:
          STAGING_SERVICE_URL: ${{ env.STAGING_SERVICE_URL }}

  # Job 8: Notify on completion
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [build, test, deploy, smoke-tests, integration-tests]
    if: always()

    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [[ "${{ needs.build.result }}" == "success" && \
                "${{ needs.test.result }}" == "success" && \
                "${{ needs.deploy.result }}" == "success" && \
                "${{ needs.smoke-tests.result }}" == "success" && \
                "${{ needs.integration-tests.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=Staging deployment successful" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=Staging deployment failed" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        if: env.SLACK_WEBHOOK_URL != ''
        uses: slackapi/slack-github-action@v1
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Staging Deployment: ${{ steps.status.outputs.status }}\n${{ steps.status.outputs.message }}"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Repository*\n${{ github.repository }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Branch*\n${{ github.ref_name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Commit*\n${{ github.sha }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Author*\n${{ github.actor }}"
                    }
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Workflow"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }

      - name: Post deployment summary
        run: |
          cat > /tmp/summary.md << 'EOF'
          ## Staging Deployment Summary

          - **Status**: ${{ steps.status.outputs.status }}
          - **Build**: ${{ needs.build.result }}
          - **Tests**: ${{ needs.test.result }}
          - **Deploy**: ${{ needs.deploy.result }}
          - **Smoke Tests**: ${{ needs.smoke-tests.result }}
          - **Integration Tests**: ${{ needs.integration-tests.result }}
          - **Commit**: ${{ github.sha }}
          - **Author**: ${{ github.actor }}

          [View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          cat /tmp/summary.md
