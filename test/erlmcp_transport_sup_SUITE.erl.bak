%%%-------------------------------------------------------------------
%%% @doc
%%% Transport Supervisor Test Suite
%%% 
%%% Comprehensive tests for the Transport Supervisor focusing on:
%%% - One-for-one restart strategy validation
%%% - Independent transport failures
%%% - Transport hot-swapping
%%% - Resource cleanup
%%% - Dynamic transport management
%%% - Performance under load
%%% @end
%%%-------------------------------------------------------------------
-module(erlmcp_transport_sup_SUITE).

-compile(export_all).

-include_lib("common_test/include/ct.hrl").
-include_lib("eunit/include/eunit.hrl").
-include("erlmcp.hrl").

%%--------------------------------------------------------------------
%% CT Callbacks
%%--------------------------------------------------------------------

suite() ->
    [{timetrap, {seconds, 30}}].

all() ->
    [
        {group, supervisor_behavior},
        {group, restart_strategy},
        {group, dynamic_management},
        {group, failure_isolation},
        {group, hot_swapping},
        {group, resource_management},
        {group, performance_tests},
        {group, integration_tests}
    ].

groups() ->
    [
        {supervisor_behavior, [parallel], [
            test_one_for_one_strategy,
            test_supervisor_initialization,
            test_child_spec_generation,
            test_transport_module_resolution
        ]},
        {restart_strategy, [sequence], [
            test_independent_transport_failures,
            test_restart_intensity_limits,
            test_supervisor_resilience,
            test_cascading_failure_prevention
        ]},
        {dynamic_management, [parallel], [
            test_dynamic_transport_addition,
            test_dynamic_transport_removal,
            test_transport_lifecycle_management,
            test_duplicate_transport_handling
        ]},
        {failure_isolation, [parallel], [
            test_transport_crash_isolation,
            test_multiple_transport_crashes,
            test_different_transport_types,
            test_concurrent_failure_handling
        ]},
        {hot_swapping, [sequence], [
            test_transport_hot_swap_stdio,
            test_transport_hot_swap_tcp,
            test_transport_hot_swap_http,
            test_configuration_updates
        ]},
        {resource_management, [sequence], [
            test_resource_cleanup_on_termination,
            test_memory_leak_detection,
            test_health_monitoring,
            test_registry_integration
        ]},
        {performance_tests, [parallel], [
            test_transport_startup_performance,
            test_bulk_operations_performance,
            test_concurrent_transport_management,
            test_sustained_load_performance
        ]},
        {integration_tests, [sequence], [
            test_integration_with_main_supervisor,
            test_integration_with_registry,
            test_full_system_coordination,
            test_multi_transport_scenarios
        ]}
    ].

%%--------------------------------------------------------------------
%% Test Case Setup/Teardown
%%--------------------------------------------------------------------

init_per_suite(Config) ->
    application:ensure_all_started(erlmcp),
    meck:new([erlmcp_transport_stdio_new, erlmcp_transport_tcp_new, 
              erlmcp_transport_http_new], [passthrough]),
    [{test_start_time, erlang:system_time(millisecond)} | Config].

end_per_suite(Config) ->
    meck:unload([erlmcp_transport_stdio_new, erlmcp_transport_tcp_new, 
                 erlmcp_transport_http_new]),
    application:stop(erlmcp),
    Config.

init_per_group(Group, Config) ->
    ct:pal("Starting transport supervisor test group: ~p", [Group]),
    [{group, Group} | Config].

end_per_group(Group, Config) ->
    ct:pal("Completed transport supervisor test group: ~p", [Group]),
    cleanup_test_transports(),
    Config.

init_per_testcase(TestCase, Config) ->
    ct:pal("Starting transport supervisor test case: ~p", [TestCase]),
    % Ensure clean slate
    cleanup_test_transports(),
    
    % Start the application supervisor first
    {ok, _AppSupPid} = erlmcp_sup:start_link(),
    
    [{test_case, TestCase}, {start_memory, get_memory_usage()} | Config].

end_per_testcase(TestCase, Config) ->
    StartMemory = proplists:get_value(start_memory, Config, 0),
    EndMemory = get_memory_usage(),
    MemoryDiff = EndMemory - StartMemory,
    ct:pal("Transport supervisor test case ~p completed. Memory diff: ~p bytes", 
           [TestCase, MemoryDiff]),
    
    % Cleanup
    cleanup_test_transports(),
    case whereis(erlmcp_sup) of
        undefined -> ok;
        Pid when is_pid(Pid) ->
            supervisor:terminate_child(erlmcp_sup, erlmcp_sup)
    end,
    timer:sleep(100),
    Config.

%%--------------------------------------------------------------------
%% Supervisor Behavior Tests
%%--------------------------------------------------------------------

test_one_for_one_strategy(Config) ->
    TransportSupPid = whereis(erlmcp_transport_sup),
    ?assert(is_pid(TransportSupPid)),
    
    % Verify supervisor is running with correct strategy
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual([], Children), % Should start empty
    
    % Add multiple transports
    {ok, TransportPid1} = erlmcp_transport_sup:start_child(test_transport_1, stdio, #{test_mode => true}),
    {ok, TransportPid2} = erlmcp_transport_sup:start_child(test_transport_2, stdio, #{test_mode => true}),
    ?assert(is_pid(TransportPid1)),
    ?assert(is_pid(TransportPid2)),
    
    % Kill one transport
    exit(TransportPid1, kill),
    timer:sleep(200),
    
    % Supervisor should survive, other transport should survive
    ?assert(is_process_alive(TransportSupPid)),
    ?assert(is_process_alive(TransportPid2)),
    ?assertNot(is_process_alive(TransportPid1)),
    
    % First transport should be restarted (one_for_one with permanent restart)
    UpdatedChildren = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(2, length(UpdatedChildren)),
    
    % Find the new PID for test_transport_1
    {test_transport_1, NewTransportPid1, worker, _} = 
        lists:keyfind(test_transport_1, 1, UpdatedChildren),
    ?assert(is_pid(NewTransportPid1)),
    ?assertNotEqual(TransportPid1, NewTransportPid1).

test_supervisor_initialization(Config) ->
    TransportSupPid = whereis(erlmcp_transport_sup),
    
    % Verify supervisor is properly registered
    ?assertEqual(TransportSupPid, whereis(erlmcp_transport_sup)),
    
    % Verify supervisor is alive
    ?assert(is_process_alive(TransportSupPid)),
    
    % Test supervisor info
    SupInfo = supervisor:count_children(erlmcp_transport_sup),
    ?assertMatch([{specs, 0}, {active, 0}, {supervisors, 0}, {workers, 0}], 
                 lists:sort(SupInfo)),
    
    % Verify supervisor flags
    {status, _, _, [_, _, _, _, StatusData]} = sys:get_status(TransportSupPid),
    ?assertNotEqual(undefined, StatusData).

test_child_spec_generation(Config) ->
    % Test child spec generation for different transport types
    TransportTypes = [stdio, tcp, http],
    
    lists:foreach(fun(Type) ->
        TransportId = list_to_atom("spec_test_" ++ atom_to_list(Type)),
        Config = #{test_mode => true, port => 8080},
        
        {ok, TransportPid} = erlmcp_transport_sup:start_child(TransportId, Type, Config),
        ?assert(is_pid(TransportPid)),
        
        % Verify child is in supervisor
        Children = supervisor:which_children(erlmcp_transport_sup),
        ?assert(lists:keymember(TransportId, 1, Children)),
        
        % Cleanup
        ok = erlmcp_transport_sup:stop_child(TransportId)
    end, TransportTypes).

test_transport_module_resolution(Config) ->
    % Test that transport modules are correctly resolved
    ?assertEqual(erlmcp_transport_stdio_new, 
                 erlmcp_transport_sup:transport_module(stdio)),
    ?assertEqual(erlmcp_transport_tcp_new, 
                 erlmcp_transport_sup:transport_module(tcp)),
    ?assertEqual(erlmcp_transport_http_new, 
                 erlmcp_transport_sup:transport_module(http)),
    
    % Test unknown transport type
    ?assertError({unknown_transport_type, unknown}, 
                 erlmcp_transport_sup:transport_module(unknown)).

%%--------------------------------------------------------------------
%% Restart Strategy Tests
%%--------------------------------------------------------------------

test_independent_transport_failures(Config) ->
    % Create multiple transports
    TransportConfigs = [
        {transport_indep_1, stdio, #{test_mode => true}},
        {transport_indep_2, stdio, #{test_mode => true}},
        {transport_indep_3, stdio, #{test_mode => true}}
    ],
    
    TransportPids = lists:map(fun({TransportId, Type, TransportConfig}) ->
        {ok, Pid} = erlmcp_transport_sup:start_child(TransportId, Type, TransportConfig),
        {TransportId, Pid}
    end, TransportConfigs),
    
    % Kill middle transport
    {transport_indep_2, MiddlePid} = lists:keyfind(transport_indep_2, 1, TransportPids),
    exit(MiddlePid, kill),
    
    timer:sleep(500),
    
    % Other transports should be unaffected
    {transport_indep_1, Pid1} = lists:keyfind(transport_indep_1, 1, TransportPids),
    {transport_indep_3, Pid3} = lists:keyfind(transport_indep_3, 1, TransportPids),
    
    ?assert(is_process_alive(Pid1)),
    ?assert(is_process_alive(Pid3)),
    ?assertNot(is_process_alive(MiddlePid)),
    
    % Middle transport should be restarted
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(3, length(Children)),
    
    {transport_indep_2, NewMiddlePid, worker, _} = 
        lists:keyfind(transport_indep_2, 1, Children),
    ?assert(is_pid(NewMiddlePid)),
    ?assertNotEqual(MiddlePid, NewMiddlePid).

test_restart_intensity_limits(Config) ->
    TransportId = restart_intensity_test,
    
    % Create transport
    {ok, _TransportPid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
    
    % Rapidly crash the transport multiple times
    crash_transport_repeatedly(TransportId, 15), % Exceed intensity (10)
    
    % Supervisor should kill the transport permanently after intensity limit
    timer:sleep(2000),
    
    % Transport should not be in children list
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertNot(lists:keymember(TransportId, 1, Children)),
    
    % Supervisor itself should survive
    ?assert(is_process_alive(whereis(erlmcp_transport_sup))).

test_supervisor_resilience(Config) ->
    TransportSupPid = whereis(erlmcp_transport_sup),
    
    % Test supervisor resilience under various conditions
    {ok, TransportPid1} = erlmcp_transport_sup:start_child(resilience_1, stdio, #{test_mode => true}),
    {ok, TransportPid2} = erlmcp_transport_sup:start_child(resilience_2, stdio, #{test_mode => true}),
    
    % Test various exit reasons
    ExitReasons = [kill, shutdown, normal, {error, test_reason}, timeout],
    
    lists:foreach(fun(Reason) ->
        TempId = list_to_atom("temp_" ++ atom_to_list(Reason)),
        {ok, TempPid} = erlmcp_transport_sup:start_child(TempId, stdio, #{test_mode => true}),
        exit(TempPid, Reason),
        timer:sleep(200),
        
        % Supervisor should survive
        ?assertEqual(TransportSupPid, whereis(erlmcp_transport_sup)),
        ?assert(is_process_alive(TransportSupPid))
    end, ExitReasons),
    
    % Original transports should still be alive
    ?assert(is_process_alive(TransportPid1)),
    ?assert(is_process_alive(TransportPid2)).

test_cascading_failure_prevention(Config) ->
    % Test that transport failures don't cascade
    NumTransports = 10,
    
    TransportPids = lists:map(fun(N) ->
        TransportId = list_to_atom("cascade_test_" ++ integer_to_list(N)),
        {ok, Pid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
        {TransportId, Pid}
    end, lists:seq(1, NumTransports)),
    
    % Kill half simultaneously
    HalfCount = NumTransports div 2,
    {ToCrash, ToKeep} = lists:split(HalfCount, TransportPids),
    
    % Crash them all at once
    lists:foreach(fun({_TransportId, Pid}) ->
        exit(Pid, kill)
    end, ToCrash),
    
    timer:sleep(1000),
    
    % Supervisor should survive
    ?assert(is_process_alive(whereis(erlmcp_transport_sup))),
    
    % Remaining transports should be alive
    lists:foreach(fun({_TransportId, Pid}) ->
        ?assert(is_process_alive(Pid))
    end, ToKeep),
    
    % Crashed transports should be restarted
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(NumTransports, length(Children)).

%%--------------------------------------------------------------------
%% Dynamic Management Tests
%%--------------------------------------------------------------------

test_dynamic_transport_addition(Config) ->
    % Test adding transports dynamically with different configurations
    TransportConfigs = [
        {dyn_stdio, stdio, #{test_mode => true, buffer_size => 1024}},
        {dyn_tcp, tcp, #{test_mode => true, port => 8081, host => "localhost"}},
        {dyn_http, http, #{test_mode => true, port => 8082, path => "/mcp"}}
    ],
    
    TransportPids = lists:map(fun({TransportId, Type, TransportConfig}) ->
        {ok, Pid} = erlmcp_transport_sup:start_child(TransportId, Type, TransportConfig),
        {TransportId, Type, Pid}
    end, TransportConfigs),
    
    % Verify all transports are running
    ?assertEqual(3, length(TransportPids)),
    
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(3, length(Children)),
    
    % Verify each transport is properly configured and running
    lists:foreach(fun({TransportId, Type, TransportPid}) ->
        ?assert(is_pid(TransportPid)),
        ?assert(is_process_alive(TransportPid)),
        
        % Find in children list
        ?assertMatch({TransportId, TransportPid, worker, _},
                     lists:keyfind(TransportId, 1, Children)),
        
        % Verify transport status
        ?assertMatch({ok, running}, 
                     erlmcp_transport_sup:get_child_status(TransportId))
    end, TransportPids).

test_dynamic_transport_removal(Config) ->
    % Add several transports
    TransportIds = [transport_rem_1, transport_rem_2, transport_rem_3],
    
    TransportPids = lists:map(fun(TransportId) ->
        {ok, Pid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
        {TransportId, Pid}
    end, TransportIds),
    
    ?assertEqual(3, length(supervisor:which_children(erlmcp_transport_sup))),
    
    % Remove middle transport
    {transport_rem_2, TransportPid2} = lists:keyfind(transport_rem_2, 1, TransportPids),
    ok = erlmcp_transport_sup:stop_child(transport_rem_2),
    
    % Verify removal
    timer:sleep(200),
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(2, length(Children)),
    ?assertNot(is_process_alive(TransportPid2)),
    
    % Verify other transports still running
    RemainingIds = [Id || {Id, _Pid, _Type, _Modules} <- Children],
    ?assertEqual([transport_rem_1, transport_rem_3], lists:sort(RemainingIds)),
    
    % Verify status query for removed transport
    ?assertMatch({error, not_found}, 
                 erlmcp_transport_sup:get_child_status(transport_rem_2)).

test_transport_lifecycle_management(Config) ->
    TransportId = lifecycle_test_transport,
    
    % Test full lifecycle: start -> run -> stop -> restart
    
    % Start
    {ok, TransportPid1} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
    ?assert(is_process_alive(TransportPid1)),
    ?assertMatch({ok, running}, erlmcp_transport_sup:get_child_status(TransportId)),
    
    % Stop
    ok = erlmcp_transport_sup:stop_child(TransportId),
    ?assertNot(is_process_alive(TransportPid1)),
    ?assertMatch({error, not_found}, erlmcp_transport_sup:get_child_status(TransportId)),
    
    % Restart with different config
    {ok, TransportPid2} = erlmcp_transport_sup:start_child(TransportId, tcp, #{
        test_mode => true, 
        port => 8083,
        config => #{new_setting => true}
    }),
    
    ?assert(is_process_alive(TransportPid2)),
    ?assertNotEqual(TransportPid1, TransportPid2),
    ?assertMatch({ok, running}, erlmcp_transport_sup:get_child_status(TransportId)).

test_duplicate_transport_handling(Config) ->
    TransportId = duplicate_test_transport,
    
    % Start first transport
    {ok, TransportPid1} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
    
    % Try to start duplicate - should fail appropriately
    ?assertMatch({error, {already_started, TransportPid1}}, 
                 erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true})),
    
    % Verify only one instance exists
    Children = supervisor:which_children(erlmcp_transport_sup),
    DuplicateChildren = [Child || {Id, _Pid, _Type, _Modules} = Child <- Children, 
                                  Id =:= TransportId],
    ?assertEqual(1, length(DuplicateChildren)).

%%--------------------------------------------------------------------
%% Failure Isolation Tests
%%--------------------------------------------------------------------

test_transport_crash_isolation(Config) ->
    % Start multiple transports of different types
    TransportConfigs = [
        {crash_iso_stdio, stdio, #{test_mode => true}},
        {crash_iso_tcp, tcp, #{test_mode => true, port => 8084}},
        {crash_iso_http, http, #{test_mode => true, port => 8085}}
    ],
    
    TransportPids = lists:map(fun({TransportId, Type, TransportConfig}) ->
        {ok, Pid} = erlmcp_transport_sup:start_child(TransportId, Type, TransportConfig),
        {TransportId, Type, Pid}
    end, TransportConfigs),
    
    % Kill one transport
    {crash_iso_tcp, tcp, CrashPid} = lists:keyfind(crash_iso_tcp, 2, TransportPids),
    exit(CrashPid, kill),
    
    timer:sleep(300),
    
    % Verify supervisor is still alive
    ?assert(is_process_alive(whereis(erlmcp_transport_sup))),
    
    % Verify other transports are still alive
    {crash_iso_stdio, stdio, Pid1} = lists:keyfind(crash_iso_stdio, 2, TransportPids),
    {crash_iso_http, http, Pid3} = lists:keyfind(crash_iso_http, 2, TransportPids),
    
    ?assert(is_process_alive(Pid1)),
    ?assert(is_process_alive(Pid3)),
    
    % Verify crashed transport is gone (but should be restarted)
    ?assertNot(is_process_alive(CrashPid)),
    
    % Check supervisor children list
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(3, length(Children)), % All 3 should be there (one restarted)
    
    % Find the restarted transport
    {crash_iso_tcp, NewCrashPid, worker, _} = 
        lists:keyfind(crash_iso_tcp, 1, Children),
    ?assert(is_pid(NewCrashPid)),
    ?assertNotEqual(CrashPid, NewCrashPid).

test_multiple_transport_crashes(Config) ->
    % Start many transports
    NumTransports = 8,
    TransportPids = lists:map(fun(N) ->
        TransportId = list_to_atom("multi_crash_" ++ integer_to_list(N)),
        {ok, Pid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
        {TransportId, Pid}
    end, lists:seq(1, NumTransports)),
    
    % Kill several rapidly
    CrashIds = [multi_crash_2, multi_crash_4, multi_crash_6],
    CrashPids = [Pid || {Id, Pid} <- TransportPids, lists:member(Id, CrashIds)],
    
    lists:foreach(fun(Pid) -> exit(Pid, kill) end, CrashPids),
    
    timer:sleep(700),
    
    % Verify supervisor survived
    ?assert(is_process_alive(whereis(erlmcp_transport_sup))),
    
    % Verify non-crashed transports survived
    SurvivingIds = [Id || {Id, _Pid} <- TransportPids, not lists:member(Id, CrashIds)],
    SurvivingPids = [Pid || {Id, Pid} <- TransportPids, lists:member(Id, SurvivingIds)],
    
    lists:foreach(fun(Pid) ->
        ?assert(is_process_alive(Pid))
    end, SurvivingPids),
    
    % Verify crashed transports are gone
    lists:foreach(fun(Pid) ->
        ?assertNot(is_process_alive(Pid))
    end, CrashPids),
    
    % Check final children count (all should be restarted)
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(NumTransports, length(Children)).

test_different_transport_types(Config) ->
    % Test isolation between different transport types
    {ok, StdioPid} = erlmcp_transport_sup:start_child(type_test_stdio, stdio, #{test_mode => true}),
    {ok, TcpPid} = erlmcp_transport_sup:start_child(type_test_tcp, tcp, #{test_mode => true, port => 8086}),
    {ok, HttpPid} = erlmcp_transport_sup:start_child(type_test_http, http, #{test_mode => true, port => 8087}),
    
    % Crash TCP transport
    exit(TcpPid, kill),
    timer:sleep(200),
    
    % Other types should be unaffected
    ?assert(is_process_alive(StdioPid)),
    ?assert(is_process_alive(HttpPid)),
    ?assertNot(is_process_alive(TcpPid)),
    
    % TCP should be restarted
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(3, length(Children)),
    
    {type_test_tcp, NewTcpPid, worker, _} = lists:keyfind(type_test_tcp, 1, Children),
    ?assert(is_pid(NewTcpPid)),
    ?assertNotEqual(TcpPid, NewTcpPid).

test_concurrent_failure_handling(Config) ->
    NumTransports = 6,
    Parent = self(),
    
    % Create transports
    TransportPids = lists:map(fun(N) ->
        TransportId = list_to_atom("concurrent_fail_" ++ integer_to_list(N)),
        {ok, Pid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
        {TransportId, Pid}
    end, lists:seq(1, NumTransports)),
    
    % Crash them concurrently
    Workers = lists:map(fun({TransportId, TransportPid}) ->
        spawn_link(fun() ->
            timer:sleep(rand:uniform(100)), % Stagger slightly
            exit(TransportPid, kill),
            Parent ! {crashed, TransportId}
        end)
    end, TransportPids),
    
    % Collect crash notifications
    CrashResults = collect_crash_results(NumTransports, []),
    ?assertEqual(NumTransports, length(CrashResults)),
    
    % Wait for restarts
    timer:sleep(1000),
    
    % Verify supervisor survived and all transports restarted
    ?assert(is_process_alive(whereis(erlmcp_transport_sup))),
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(NumTransports, length(Children)),
    
    % Wait for workers
    lists:foreach(fun(Worker) -> wait_for_worker(Worker) end, Workers).

%%--------------------------------------------------------------------
%% Hot Swapping Tests
%%--------------------------------------------------------------------

test_transport_hot_swap_stdio(Config) ->
    TransportId = hot_swap_stdio,
    
    % Start initial stdio transport
    {ok, OldPid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{
        test_mode => true,
        buffer_size => 1024
    }),
    
    % Verify initial state
    ?assert(is_process_alive(OldPid)),
    InitialChildren = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(1, length(InitialChildren)),
    
    % Hot swap with new configuration
    ok = erlmcp_transport_sup:stop_child(TransportId),
    {ok, NewPid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{
        test_mode => true,
        buffer_size => 2048,
        enhanced_mode => true
    }),
    
    % Verify swap
    ?assertNot(is_process_alive(OldPid)),
    ?assert(is_process_alive(NewPid)),
    ?assertNotEqual(OldPid, NewPid),
    
    FinalChildren = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(1, length(FinalChildren)),
    
    {TransportId, NewPid, worker, _} = hd(FinalChildren).

test_transport_hot_swap_tcp(Config) ->
    TransportId = hot_swap_tcp,
    
    % Start initial TCP transport
    {ok, OldPid} = erlmcp_transport_sup:start_child(TransportId, tcp, #{
        test_mode => true,
        port => 8088,
        host => "127.0.0.1"
    }),
    
    ?assert(is_process_alive(OldPid)),
    
    % Hot swap with different port
    ok = erlmcp_transport_sup:stop_child(TransportId),
    {ok, NewPid} = erlmcp_transport_sup:start_child(TransportId, tcp, #{
        test_mode => true,
        port => 8089,
        host => "0.0.0.0",
        backlog => 128
    }),
    
    % Verify swap
    ?assertNot(is_process_alive(OldPid)),
    ?assert(is_process_alive(NewPid)),
    ?assertNotEqual(OldPid, NewPid).

test_transport_hot_swap_http(Config) ->
    TransportId = hot_swap_http,
    
    % Start initial HTTP transport
    {ok, OldPid} = erlmcp_transport_sup:start_child(TransportId, http, #{
        test_mode => true,
        port => 8090,
        path => "/api/v1"
    }),
    
    ?assert(is_process_alive(OldPid)),
    
    % Hot swap with different configuration
    ok = erlmcp_transport_sup:stop_child(TransportId),
    {ok, NewPid} = erlmcp_transport_sup:start_child(TransportId, http, #{
        test_mode => true,
        port => 8091,
        path => "/api/v2",
        ssl_enabled => true
    }),
    
    % Verify swap
    ?assertNot(is_process_alive(OldPid)),
    ?assert(is_process_alive(NewPid)),
    ?assertNotEqual(OldPid, NewPid).

test_configuration_updates(Config) ->
    TransportId = config_update_test,
    
    % Start with basic configuration
    BasicConfig = #{test_mode => true, setting_a => value1},
    {ok, Pid1} = erlmcp_transport_sup:start_child(TransportId, stdio, BasicConfig),
    
    % Update configuration multiple times
    Configs = [
        #{test_mode => true, setting_a => value2, setting_b => new_value},
        #{test_mode => true, setting_a => value3, setting_c => another_value},
        #{test_mode => true, setting_d => final_value}
    ],
    
    lists:foldl(fun(NewConfig, OldPid) ->
        ok = erlmcp_transport_sup:stop_child(TransportId),
        {ok, NewPid} = erlmcp_transport_sup:start_child(TransportId, stdio, NewConfig),
        
        ?assertNot(is_process_alive(OldPid)),
        ?assert(is_process_alive(NewPid)),
        ?assertNotEqual(OldPid, NewPid),
        
        NewPid
    end, Pid1, Configs),
    
    % Verify final state
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(1, length(Children)).

%%--------------------------------------------------------------------
%% Resource Management Tests
%%--------------------------------------------------------------------

test_resource_cleanup_on_termination(Config) ->
    InitialMemory = get_memory_usage(),
    TransportId = resource_cleanup_test,
    
    % Create transport with some resource usage
    {ok, TransportPid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{
        test_mode => true,
        config => #{large_buffer => lists:duplicate(1000, test_data)}
    }),
    
    % Verify transport is using memory
    MemoryAfterCreate = get_memory_usage(),
    ?assert(MemoryAfterCreate > InitialMemory),
    
    % Terminate transport
    ok = erlmcp_transport_sup:stop_child(TransportId),
    
    % Force garbage collection
    erlang:garbage_collect(),
    timer:sleep(500),
    
    % Memory should be cleaned up
    FinalMemory = get_memory_usage(),
    MemoryIncrease = FinalMemory - InitialMemory,
    
    ct:pal("Memory usage - Initial: ~p, After create: ~p, Final: ~p", 
           [InitialMemory, MemoryAfterCreate, FinalMemory]),
    
    % Should not leak significant memory
    ?assert(MemoryIncrease < 200000), % 200KB threshold
    
    % Transport should be gone
    ?assertNot(is_process_alive(TransportPid)).

test_memory_leak_detection(Config) ->
    InitialMemory = get_memory_usage(),
    
    % Perform repeated create/destroy cycles
    lists:foreach(fun(N) ->
        TransportId = list_to_atom("leak_test_" ++ integer_to_list(N)),
        {ok, TransportPid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
        
        % Do some work to create state
        timer:sleep(10),
        
        % Stop it
        ok = erlmcp_transport_sup:stop_child(TransportId),
        
        % Force GC every 10 iterations
        case N rem 10 of
            0 -> erlang:garbage_collect();
            _ -> ok
        end
    end, lists:seq(1, 100)),
    
    % Final cleanup and measurement
    erlang:garbage_collect(),
    timer:sleep(1000),
    FinalMemory = get_memory_usage(),
    
    MemoryGrowth = FinalMemory - InitialMemory,
    ct:pal("Memory growth after 100 create/destroy cycles: ~p bytes", [MemoryGrowth]),
    
    % Should not grow significantly
    ?assert(MemoryGrowth < 1048576), % 1MB threshold
    
    % No transports should remain
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual([], Children).

test_health_monitoring(Config) ->
    TransportId = health_monitor_test,
    
    % Start transport
    {ok, TransportPid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
    
    % Verify initial health status
    ?assertMatch({ok, running}, erlmcp_transport_sup:get_child_status(TransportId)),
    
    % Kill transport and check health monitoring detects it
    exit(TransportPid, kill),
    timer:sleep(300),
    
    % Transport should be restarted and healthy again
    ?assertMatch({ok, running}, erlmcp_transport_sup:get_child_status(TransportId)),
    
    % New PID should be different
    Children = supervisor:which_children(erlmcp_transport_sup),
    {TransportId, NewPid, worker, _} = lists:keyfind(TransportId, 1, Children),
    ?assertNotEqual(TransportPid, NewPid).

test_registry_integration(Config) ->
    % Test integration with registry for transport management
    TransportId = registry_integration_test,
    
    % Create transport
    {ok, TransportPid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
    
    % Transport should be automatically registered
    timer:sleep(100), % Allow time for registration
    ?assertMatch({ok, {TransportPid, _Config}}, erlmcp_registry:find_transport(TransportId)),
    
    % Terminate transport
    ok = erlmcp_transport_sup:stop_child(TransportId),
    
    % Transport should be automatically unregistered
    timer:sleep(100),
    ?assertMatch({error, not_found}, erlmcp_registry:find_transport(TransportId)).

%%--------------------------------------------------------------------
%% Performance Tests
%%--------------------------------------------------------------------

test_transport_startup_performance(Config) ->
    NumTests = 10,
    
    StartupTimes = lists:map(fun(N) ->
        TransportId = list_to_atom("perf_test_" ++ integer_to_list(N)),
        
        StartTime = erlang:system_time(microsecond),
        {ok, TransportPid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
        EndTime = erlang:system_time(microsecond),
        
        % Cleanup
        ok = erlmcp_transport_sup:stop_child(TransportId),
        
        EndTime - StartTime
    end, lists:seq(1, NumTests)),
    
    AvgTime = lists:sum(StartupTimes) / length(StartupTimes),
    MaxTime = lists:max(StartupTimes),
    MinTime = lists:min(StartupTimes),
    
    ct:pal("Transport startup performance - Avg: ~p μs, Min: ~p μs, Max: ~p μs", 
           [AvgTime, MinTime, MaxTime]),
    
    % Performance requirements
    ?assert(AvgTime < 15000), % 15ms average
    ?assert(MaxTime < 50000), % 50ms max
    ?assert(MinTime > 0).

test_bulk_operations_performance(Config) ->
    NumTransports = 20,
    
    % Bulk creation
    StartTime = erlang:system_time(microsecond),
    
    TransportIds = lists:map(fun(N) ->
        TransportId = list_to_atom("bulk_test_" ++ integer_to_list(N)),
        {ok, _Pid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
        TransportId
    end, lists:seq(1, NumTransports)),
    
    CreationEndTime = erlang:system_time(microsecond),
    CreationTime = CreationEndTime - StartTime,
    
    % Bulk termination
    TerminationStartTime = erlang:system_time(microsecond),
    
    lists:foreach(fun(TransportId) ->
        ok = erlmcp_transport_sup:stop_child(TransportId)
    end, TransportIds),
    
    TerminationEndTime = erlang:system_time(microsecond),
    TerminationTime = TerminationEndTime - TerminationStartTime,
    
    ct:pal("Bulk operations - Creation: ~p μs (~p μs/transport), Termination: ~p μs (~p μs/transport)", 
           [CreationTime, CreationTime/NumTransports, TerminationTime, TerminationTime/NumTransports]),
    
    % Performance requirements
    ?assert(CreationTime / NumTransports < 7000), % 7ms per transport creation
    ?assert(TerminationTime / NumTransports < 5000). % 5ms per transport termination

test_concurrent_transport_management(Config) ->
    NumWorkers = 15,
    Parent = self(),
    
    % Spawn concurrent workers
    Workers = lists:map(fun(N) ->
        spawn_link(fun() ->
            TransportId = list_to_atom("concurrent_mgmt_" ++ integer_to_list(N)),
            try
                % Random operations
                case rand:uniform(3) of
                    1 -> % Create transport
                        {ok, TransportPid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
                        Parent ! {success, N, created, TransportPid};
                    2 -> % Create then terminate
                        {ok, TransportPid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
                        timer:sleep(rand:uniform(100)),
                        ok = erlmcp_transport_sup:stop_child(TransportId),
                        Parent ! {success, N, created_and_terminated, TransportPid};
                    3 -> % Just status check
                        _ = erlmcp_transport_sup:get_child_status(TransportId),
                        Parent ! {success, N, status_check, undefined}
                end
            catch
                Class:Reason:Stacktrace ->
                    Parent ! {error, N, Class, Reason, Stacktrace}
            end
        end)
    end, lists:seq(1, NumWorkers)),
    
    % Collect results
    Results = collect_worker_results(NumWorkers, []),
    SuccessCount = length([R || {success, _, _, _} <- Results]),
    ErrorCount = length([R || {error, _, _, _, _} <- Results]),
    
    ct:pal("Concurrent management: ~p successes, ~p errors", [SuccessCount, ErrorCount]),
    
    % Most operations should succeed
    ?assert(SuccessCount >= NumWorkers * 0.8), % 80% success rate minimum
    
    % Wait for workers to finish
    lists:foreach(fun(Worker) -> wait_for_worker(Worker) end, Workers).

test_sustained_load_performance(Config) ->
    Duration = 3000, % 3 seconds
    StartTime = erlang:system_time(millisecond),
    
    % Sustained load test
    FinalCount = sustained_transport_load_loop(StartTime, Duration, 0),
    
    ActualDuration = erlang:system_time(millisecond) - StartTime,
    OperationsPerSecond = (FinalCount * 1000) / ActualDuration,
    
    ct:pal("Sustained transport load: ~p operations in ~p ms (~p ops/sec)", 
           [FinalCount, ActualDuration, OperationsPerSecond]),
    
    % Should handle reasonable load
    ?assert(OperationsPerSecond > 5), % At least 5 ops/sec
    ?assert(FinalCount > 15). % At least 15 operations total

%%--------------------------------------------------------------------
%% Integration Tests
%%--------------------------------------------------------------------

test_integration_with_main_supervisor(Config) ->
    MainSupPid = whereis(erlmcp_sup),
    TransportSupPid = whereis(erlmcp_transport_sup),
    
    ?assert(is_pid(MainSupPid)),
    ?assert(is_pid(TransportSupPid)),
    
    % Kill transport supervisor - should be restarted by main supervisor
    exit(TransportSupPid, kill),
    
    timer:sleep(1000),
    
    % Main supervisor should restart transport supervisor
    ?assert(is_process_alive(MainSupPid)),
    
    NewTransportSupPid = whereis(erlmcp_transport_sup),
    ?assert(is_pid(NewTransportSupPid)),
    ?assertNotEqual(TransportSupPid, NewTransportSupPid),
    
    % New transport supervisor should be functional
    {ok, TestPid} = erlmcp_transport_sup:start_child(integration_test, stdio, #{test_mode => true}),
    ?assert(is_process_alive(TestPid)).

test_integration_with_registry(Config) ->
    % Test transport supervisor + registry coordination
    TransportId = registry_coord_test,
    
    % Verify registry is available
    ?assertMatch({ok, _}, erlmcp_registry:list_transports()),
    
    % Create transport
    {ok, TransportPid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
    
    % Should be in registry
    timer:sleep(100),
    ?assertMatch({ok, {TransportPid, _}}, erlmcp_registry:find_transport(TransportId)),
    
    % Stop transport
    ok = erlmcp_transport_sup:stop_child(TransportId),
    timer:sleep(100),
    
    % Should be removed from registry
    ?assertMatch({error, not_found}, erlmcp_registry:find_transport(TransportId)).

test_full_system_coordination(Config) ->
    % Test full system with multiple transports and servers
    NumTransports = 4,
    
    % Create transports
    TransportIds = lists:map(fun(N) ->
        TransportId = list_to_atom("sys_transport_" ++ integer_to_list(N)),
        Type = case N rem 3 of
            0 -> stdio;
            1 -> tcp;
            2 -> http
        end,
        Config = #{test_mode => true, port => 8090 + N},
        {ok, _Pid} = erlmcp_transport_sup:start_child(TransportId, Type, Config),
        TransportId
    end, lists:seq(1, NumTransports)),
    
    timer:sleep(200),
    
    % Verify system state
    {ok, Transports} = erlmcp_registry:list_transports(),
    ?assertEqual(NumTransports, length(Transports)),
    
    % System should be fully functional
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(NumTransports, length(Children)).

test_multi_transport_scenarios(Config) ->
    % Test complex scenarios with multiple transport types
    
    % Create mixed transport environment
    {ok, StdioPid1} = erlmcp_transport_sup:start_child(multi_stdio_1, stdio, #{test_mode => true}),
    {ok, StdioPid2} = erlmcp_transport_sup:start_child(multi_stdio_2, stdio, #{test_mode => true}),
    {ok, TcpPid1} = erlmcp_transport_sup:start_child(multi_tcp_1, tcp, #{test_mode => true, port => 8092}),
    {ok, HttpPid1} = erlmcp_transport_sup:start_child(multi_http_1, http, #{test_mode => true, port => 8093}),
    
    % Verify all are running
    AllPids = [StdioPid1, StdioPid2, TcpPid1, HttpPid1],
    lists:foreach(fun(Pid) -> ?assert(is_process_alive(Pid)) end, AllPids),
    
    % Kill one of each type
    exit(StdioPid1, kill),
    exit(TcpPid1, kill),
    
    timer:sleep(500),
    
    % Remaining should be unaffected
    ?assert(is_process_alive(StdioPid2)),
    ?assert(is_process_alive(HttpPid1)),
    
    % Killed ones should be restarted
    Children = supervisor:which_children(erlmcp_transport_sup),
    ?assertEqual(4, length(Children)),
    
    % Find restarted transports
    {multi_stdio_1, NewStdioPid1, worker, _} = lists:keyfind(multi_stdio_1, 1, Children),
    {multi_tcp_1, NewTcpPid1, worker, _} = lists:keyfind(multi_tcp_1, 1, Children),
    
    ?assert(is_pid(NewStdioPid1)),
    ?assert(is_pid(NewTcpPid1)),
    ?assertNotEqual(StdioPid1, NewStdioPid1),
    ?assertNotEqual(TcpPid1, NewTcpPid1).

%%--------------------------------------------------------------------
%% Helper Functions
%%--------------------------------------------------------------------

get_memory_usage() ->
    erlang:memory(total).

cleanup_test_transports() ->
    Children = supervisor:which_children(erlmcp_transport_sup),
    lists:foreach(fun({Id, _Pid, _Type, _Modules}) ->
        case atom_to_list(Id) of
            "test_" ++ _ ->
                erlmcp_transport_sup:stop_child(Id);
            _ -> ok
        end
    end, Children).

crash_transport_repeatedly(TransportId, Times) ->
    crash_transport_repeatedly(TransportId, Times, 0).

crash_transport_repeatedly(_TransportId, Times, Times) ->
    ok;
crash_transport_repeatedly(TransportId, Times, Current) ->
    Children = supervisor:which_children(erlmcp_transport_sup),
    case lists:keyfind(TransportId, 1, Children) of
        {TransportId, Pid, worker, _} when is_pid(Pid) ->
            exit(Pid, kill),
            timer:sleep(50),
            crash_transport_repeatedly(TransportId, Times, Current + 1);
        _ ->
            ok % Transport no longer exists
    end.

collect_crash_results(0, Acc) ->
    Acc;
collect_crash_results(N, Acc) ->
    receive
        {crashed, TransportId} ->
            collect_crash_results(N-1, [{crashed, TransportId} | Acc])
    after 5000 ->
        ?assert(false, "Timeout collecting crash results")
    end.

collect_worker_results(0, Acc) ->
    Acc;
collect_worker_results(N, Acc) ->
    receive
        {success, WorkerId, Operation, Pid} ->
            collect_worker_results(N-1, [{success, WorkerId, Operation, Pid} | Acc]);
        {error, WorkerId, Class, Reason, Stacktrace} ->
            ct:pal("Worker ~p error: ~p:~p~n~p", [WorkerId, Class, Reason, Stacktrace]),
            collect_worker_results(N-1, [{error, WorkerId, Class, Reason, Stacktrace} | Acc])
    after 10000 ->
        ?assert(false, "Timeout collecting worker results")
    end.

wait_for_worker(Worker) ->
    Ref = monitor(process, Worker),
    receive
        {'DOWN', Ref, process, Worker, _Reason} ->
            ok
    after 5000 ->
        exit(Worker, kill),
        ok
    end.

sustained_transport_load_loop(StartTime, Duration, Count) ->
    case erlang:system_time(millisecond) - StartTime of
        Elapsed when Elapsed > Duration ->
            Count;
        _ ->
            try
                % Perform operation
                TransportId = list_to_atom("sustained_" ++ integer_to_list(Count)),
                {ok, _Pid} = erlmcp_transport_sup:start_child(TransportId, stdio, #{test_mode => true}),
                ok = erlmcp_transport_sup:stop_child(TransportId),
                sustained_transport_load_loop(StartTime, Duration, Count + 1)
            catch
                _:_ ->
                    sustained_transport_load_loop(StartTime, Duration, Count)
            end
    end.