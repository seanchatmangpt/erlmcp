%%% @doc
%%% Comprehensive test suite for erlmcp_registry using TDD London School methodology
%%% 
%%% London School TDD focuses on:
%%% - Outside-in development with mocks
%%% - Behavior verification over state testing
%%% - Interaction testing between collaborators
%%% - Contract-driven design through mock expectations
%%%
%%% Test structure:
%%% - Registration behavior tests
%%% - Routing interaction tests
%%% - Discovery contract tests
%%% - Failure recovery coordination tests
%%% - Property-based edge case testing
%%% @end
-module(erlmcp_registry_SUITE).

-compile(export_all).

-include_lib("common_test/include/ct.hrl").
-include_lib("eunit/include/eunit.hrl").
-include_lib("proper/include/proper.hrl").
-include("../include/erlmcp.hrl").

%%% Common Test callbacks
-export([
    all/0,
    groups/0,
    init_per_suite/1,
    end_per_suite/1,
    init_per_group/2,
    end_per_group/2,
    init_per_testcase/2,
    end_per_testcase/2
]).

%%% Test exports
-export([
    %% Registration group
    register_server_success/1,
    register_server_duplicate_rejection/1,
    register_transport_success/1,
    register_transport_duplicate_rejection/1,
    register_transport_auto_bind/1,
    unregister_server_cleanup/1,
    unregister_transport_cleanup/1,
    
    %% Routing group
    route_to_server_successful_delivery/1,
    route_to_server_unknown_destination/1,
    route_to_transport_successful_delivery/1,
    route_to_transport_unknown_destination/1,
    concurrent_routing_stress/1,
    
    %% Discovery group
    find_server_by_id/1,
    find_transport_by_id/1,
    list_all_servers/1,
    list_all_transports/1,
    bind_transport_to_server/1,
    unbind_transport/1,
    get_server_for_transport/1,
    capability_queries/1,
    
    %% Failure handling group
    server_crash_detection_and_cleanup/1,
    transport_crash_detection_and_cleanup/1,
    registry_restart_recovery/1,
    monitor_cleanup_on_terminate/1,
    multiple_crash_handling/1,
    
    %% Property-based tests
    prop_registration_invariants/1,
    prop_routing_consistency/1,
    prop_crash_recovery_completeness/1
]).

%%% Mock helpers
-record(mock_config, {
    server_pids = [] :: [pid()],
    transport_pids = [] :: [pid()],
    message_log = [] :: [term()]
}).

%%====================================================================
%% Common Test Callbacks
%%====================================================================

all() ->
    [
        {group, registration_behavior},
        {group, routing_interactions},
        {group, discovery_contracts},
        {group, failure_recovery},
        {group, property_based_tests}
    ].

groups() ->
    [
        {registration_behavior, [parallel], [
            register_server_success,
            register_server_duplicate_rejection,
            register_transport_success,
            register_transport_duplicate_rejection,
            register_transport_auto_bind,
            unregister_server_cleanup,
            unregister_transport_cleanup
        ]},
        {routing_interactions, [parallel], [
            route_to_server_successful_delivery,
            route_to_server_unknown_destination,
            route_to_transport_successful_delivery,
            route_to_transport_unknown_destination,
            concurrent_routing_stress
        ]},
        {discovery_contracts, [parallel], [
            find_server_by_id,
            find_transport_by_id,
            list_all_servers,
            list_all_transports,
            bind_transport_to_server,
            unbind_transport,
            get_server_for_transport,
            capability_queries
        ]},
        {failure_recovery, [sequence], [
            server_crash_detection_and_cleanup,
            transport_crash_detection_and_cleanup,
            registry_restart_recovery,
            monitor_cleanup_on_terminate,
            multiple_crash_handling
        ]},
        {property_based_tests, [], [
            prop_registration_invariants,
            prop_routing_consistency,
            prop_crash_recovery_completeness
        ]}
    ].

init_per_suite(Config) ->
    ct:pal("Starting erlmcp_registry test suite with London School TDD approach"),
    application:ensure_all_started(erlmcp),
    Config.

end_per_suite(_Config) ->
    application:stop(erlmcp),
    ok.

init_per_group(GroupName, Config) ->
    ct:pal("Initializing test group: ~p", [GroupName]),
    [{group, GroupName} | Config].

end_per_group(_GroupName, _Config) ->
    ok.

init_per_testcase(TestCase, Config) ->
    ct:pal("Starting test case: ~p", [TestCase]),
    %% Start fresh registry for each test
    {ok, RegistryPid} = erlmcp_registry:start_link(),
    MockConfig = #mock_config{},
    [{registry_pid, RegistryPid}, {mock_config, MockConfig} | Config].

end_per_testcase(TestCase, Config) ->
    ct:pal("Ending test case: ~p", [TestCase]),
    RegistryPid = ?config(registry_pid, Config),
    case is_process_alive(RegistryPid) of
        true -> 
            unlink(RegistryPid),
            exit(RegistryPid, kill);
        false -> ok
    end,
    cleanup_mock_processes(Config),
    ok.

%%====================================================================
%% Registration Behavior Tests (London School - Mock-driven)
%%====================================================================

%% @doc Test successful server registration with capability verification
%% London School: Focus on the interaction pattern between registry and server
register_server_success(Config) ->
    MockServerPid = create_mock_server(),
    ServerConfig = #{
        capabilities => #mcp_server_capabilities{
            resources = #mcp_capability{enabled = true},
            tools = #mcp_capability{enabled = true}
        },
        options => #{timeout => 5000}
    },
    
    %% Test the registration interaction
    Result = erlmcp_registry:register_server(test_server, MockServerPid, ServerConfig),
    
    %% Verify successful registration
    ?assertEqual(ok, Result),
    
    %% Verify the registry now knows about our server (behavior verification)
    {ok, {RegisteredPid, RegisteredConfig}} = erlmcp_registry:find_server(test_server),
    ?assertEqual(MockServerPid, RegisteredPid),
    ?assertEqual(ServerConfig, RegisteredConfig),
    
    %% Verify server appears in server list
    Servers = erlmcp_registry:list_servers(),
    ?assert(lists:keymember(test_server, 1, Servers)),
    
    cleanup_mock_process(MockServerPid),
    ok.

%% @doc Test duplicate server registration rejection
%% London School: Test the conversation flow when conflicts occur
register_server_duplicate_rejection(Config) ->
    MockServerPid1 = create_mock_server(),
    MockServerPid2 = create_mock_server(),
    ServerConfig = #{capabilities => #mcp_server_capabilities{}},
    
    %% First registration should succeed
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid1, ServerConfig)),
    
    %% Second registration with same ID should fail
    Result = erlmcp_registry:register_server(test_server, MockServerPid2, ServerConfig),
    ?assertEqual({error, already_registered}, Result),
    
    %% Verify original registration is preserved
    {ok, {RegisteredPid, _}} = erlmcp_registry:find_server(test_server),
    ?assertEqual(MockServerPid1, RegisteredPid),
    
    cleanup_mock_process(MockServerPid1),
    cleanup_mock_process(MockServerPid2),
    ok.

%% @doc Test successful transport registration
%% London School: Focus on transport-registry interaction pattern
register_transport_success(Config) ->
    MockTransportPid = create_mock_transport(),
    TransportConfig = #{
        type => stdio,
        config => #{buffer_size => 1024}
    },
    
    %% Test the registration interaction
    Result = erlmcp_registry:register_transport(test_transport, MockTransportPid, TransportConfig),
    
    %% Verify successful registration
    ?assertEqual(ok, Result),
    
    %% Verify behavior: registry knows about transport
    {ok, {RegisteredPid, RegisteredConfig}} = erlmcp_registry:find_transport(test_transport),
    ?assertEqual(MockTransportPid, RegisteredPid),
    ?assertEqual(TransportConfig, RegisteredConfig),
    
    %% Verify transport appears in transport list
    Transports = erlmcp_registry:list_transports(),
    ?assert(lists:keymember(test_transport, 1, Transports)),
    
    cleanup_mock_process(MockTransportPid),
    ok.

%% @doc Test transport auto-binding during registration
%% London School: Test the coordination between transport and server binding
register_transport_auto_bind(Config) ->
    %% First register a server
    MockServerPid = create_mock_server(),
    ServerConfig = #{capabilities => #mcp_server_capabilities{}},
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid, ServerConfig)),
    
    %% Register transport with server_id in config (auto-bind)
    MockTransportPid = create_mock_transport(),
    TransportConfig = #{
        type => stdio,
        server_id => test_server,
        config => #{}
    },
    
    Result = erlmcp_registry:register_transport(test_transport, MockTransportPid, TransportConfig),
    ?assertEqual(ok, Result),
    
    %% Verify auto-binding behavior
    {ok, BoundServerId} = erlmcp_registry:get_server_for_transport(test_transport),
    ?assertEqual(test_server, BoundServerId),
    
    cleanup_mock_process(MockServerPid),
    cleanup_mock_process(MockTransportPid),
    ok.

%% @doc Test server unregistration cleanup behavior
%% London School: Verify all related cleanup interactions
unregister_server_cleanup(Config) ->
    MockServerPid = create_mock_server(),
    MockTransportPid = create_mock_transport(),
    
    %% Setup server and bound transport
    ServerConfig = #{capabilities => #mcp_server_capabilities{}},
    TransportConfig = #{type => stdio, server_id => test_server},
    
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid, ServerConfig)),
    ?assertEqual(ok, erlmcp_registry:register_transport(test_transport, MockTransportPid, TransportConfig)),
    
    %% Verify binding exists
    {ok, test_server} = erlmcp_registry:get_server_for_transport(test_transport),
    
    %% Unregister server
    ?assertEqual(ok, erlmcp_registry:unregister_server(test_server)),
    
    %% Verify cleanup behavior:
    %% 1. Server should be gone
    ?assertEqual({error, not_found}, erlmcp_registry:find_server(test_server)),
    
    %% 2. Transport binding should be cleaned up
    ?assertEqual({error, not_found}, erlmcp_registry:get_server_for_transport(test_transport)),
    
    %% 3. Transport should still exist (only binding removed)
    ?assertMatch({ok, _}, erlmcp_registry:find_transport(test_transport)),
    
    cleanup_mock_process(MockServerPid),
    cleanup_mock_process(MockTransportPid),
    ok.

%% @doc Test transport unregistration cleanup
%% London School: Focus on cleanup interaction patterns
unregister_transport_cleanup(Config) ->
    MockTransportPid = create_mock_transport(),
    MockServerPid = create_mock_server(),
    
    %% Setup with binding
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid, #{})),
    ?assertEqual(ok, erlmcp_registry:register_transport(test_transport, MockTransportPid, 
                     #{type => stdio, server_id => test_server})),
    
    %% Verify binding exists
    {ok, test_server} = erlmcp_registry:get_server_for_transport(test_transport),
    
    %% Unregister transport
    ?assertEqual(ok, erlmcp_registry:unregister_transport(test_transport)),
    
    %% Verify cleanup behavior:
    %% 1. Transport should be gone
    ?assertEqual({error, not_found}, erlmcp_registry:find_transport(test_transport)),
    
    %% 2. Binding should be removed
    ?assertEqual({error, not_found}, erlmcp_registry:get_server_for_transport(test_transport)),
    
    %% 3. Server should remain unaffected
    ?assertMatch({ok, _}, erlmcp_registry:find_server(test_server)),
    
    cleanup_mock_process(MockTransportPid),
    cleanup_mock_process(MockServerPid),
    ok.

%%====================================================================
%% Routing Interaction Tests (London School - Message Flow Verification)
%%====================================================================

%% @doc Test successful message routing to server
%% London School: Verify the message delivery interaction
route_to_server_successful_delivery(Config) ->
    MockServerPid = create_mock_server_with_mailbox(),
    MockTransportPid = create_mock_transport(),
    
    %% Setup registry state
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid, #{})),
    
    TestMessage = #{method => <<"test">>, params => #{}},
    
    %% Test routing behavior
    Result = erlmcp_registry:route_to_server(test_server, test_transport, TestMessage),
    ?assertEqual(ok, Result),
    
    %% Verify message delivery interaction
    receive
        {mock_message, MockServerPid, {mcp_message, test_transport, TestMessage}} ->
            ok
    after 1000 ->
        ct:fail("Message was not delivered to server")
    end,
    
    cleanup_mock_process(MockServerPid),
    cleanup_mock_process(MockTransportPid),
    ok.

%% @doc Test routing to unknown server
%% London School: Test error handling behavior
route_to_server_unknown_destination(Config) ->
    TestMessage = #{method => <<"test">>, params => #{}},
    
    %% Should handle unknown server gracefully
    Result = erlmcp_registry:route_to_server(unknown_server, test_transport, TestMessage),
    ?assertEqual(ok, Result), % cast returns ok even if server not found
    
    %% No message should be delivered (verified by absence of delivery)
    receive
        {mock_message, _, _} ->
            ct:fail("Unexpected message delivery")
    after 100 ->
        ok % Expected - no delivery to unknown server
    end,
    
    ok.

%% @doc Test successful message routing to transport
%% London School: Verify transport message delivery pattern
route_to_transport_successful_delivery(Config) ->
    MockTransportPid = create_mock_transport_with_mailbox(),
    MockServerPid = create_mock_server(),
    
    %% Setup registry state
    ?assertEqual(ok, erlmcp_registry:register_transport(test_transport, MockTransportPid, #{})),
    
    TestMessage = #{result => <<"success">>},
    
    %% Test routing behavior
    Result = erlmcp_registry:route_to_transport(test_transport, test_server, TestMessage),
    ?assertEqual(ok, Result),
    
    %% Verify message delivery interaction
    receive
        {mock_message, MockTransportPid, {mcp_response, test_server, TestMessage}} ->
            ok
    after 1000 ->
        ct:fail("Message was not delivered to transport")
    end,
    
    cleanup_mock_process(MockTransportPid),
    cleanup_mock_process(MockServerPid),
    ok.

%% @doc Test routing to unknown transport
route_to_transport_unknown_destination(Config) ->
    TestMessage = #{result => <<"success">>},
    
    %% Should handle unknown transport gracefully
    Result = erlmcp_registry:route_to_transport(unknown_transport, test_server, TestMessage),
    ?assertEqual(ok, Result), % cast returns ok even if transport not found
    
    %% No message should be delivered
    receive
        {mock_message, _, _} ->
            ct:fail("Unexpected message delivery")
    after 100 ->
        ok % Expected - no delivery to unknown transport
    end,
    
    ok.

%% @doc Test concurrent routing stress
%% London School: Verify routing behavior under concurrent load
concurrent_routing_stress(Config) ->
    %% Setup multiple servers and transports
    NumServers = 10,
    NumTransports = 5,
    NumMessages = 100,
    
    %% Create mock servers and transports
    Servers = [{list_to_atom("server_" ++ integer_to_list(I)), 
                create_mock_server_with_mailbox()} || I <- lists:seq(1, NumServers)],
    Transports = [{list_to_atom("transport_" ++ integer_to_list(I)), 
                   create_mock_transport_with_mailbox()} || I <- lists:seq(1, NumTransports)],
    
    %% Register all entities
    [?assertEqual(ok, erlmcp_registry:register_server(Id, Pid, #{})) || {Id, Pid} <- Servers],
    [?assertEqual(ok, erlmcp_registry:register_transport(Id, Pid, #{})) || {Id, Pid} <- Transports],
    
    %% Spawn concurrent routing processes
    Parent = self(),
    RoutingPids = [spawn_link(fun() ->
        lists:foreach(fun(MsgNum) ->
            ServerIdx = (MsgNum rem NumServers) + 1,
            TransportIdx = (MsgNum rem NumTransports) + 1,
            ServerId = list_to_atom("server_" ++ integer_to_list(ServerIdx)),
            TransportId = list_to_atom("transport_" ++ integer_to_list(TransportIdx)),
            
            Message = #{method => <<"test">>, seq => MsgNum},
            erlmcp_registry:route_to_server(ServerId, TransportId, Message),
            erlmcp_registry:route_to_transport(TransportId, ServerId, #{result => MsgNum})
        end, lists:seq(1, NumMessages div 4)),
        Parent ! {routing_complete, self()}
    end) || _ <- lists:seq(1, 4)],
    
    %% Wait for all routing to complete
    [receive {routing_complete, Pid} -> ok end || Pid <- RoutingPids],
    
    %% Allow message processing
    timer:sleep(100),
    
    %% Verify no crashes occurred
    ?assert(is_process_alive(?config(registry_pid, Config))),
    
    %% Cleanup
    [cleanup_mock_process(Pid) || {_, Pid} <- Servers],
    [cleanup_mock_process(Pid) || {_, Pid} <- Transports],
    ok.

%%====================================================================
%% Discovery Contract Tests (London School - Query Behavior)
%%====================================================================

%% @doc Test finding server by ID
find_server_by_id(Config) ->
    MockServerPid = create_mock_server(),
    ServerConfig = #{capabilities => #mcp_server_capabilities{}},
    
    %% Test not found behavior
    ?assertEqual({error, not_found}, erlmcp_registry:find_server(test_server)),
    
    %% Register and test found behavior
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid, ServerConfig)),
    {ok, {FoundPid, FoundConfig}} = erlmcp_registry:find_server(test_server),
    
    ?assertEqual(MockServerPid, FoundPid),
    ?assertEqual(ServerConfig, FoundConfig),
    
    cleanup_mock_process(MockServerPid),
    ok.

%% @doc Test finding transport by ID
find_transport_by_id(Config) ->
    MockTransportPid = create_mock_transport(),
    TransportConfig = #{type => stdio},
    
    %% Test not found behavior
    ?assertEqual({error, not_found}, erlmcp_registry:find_transport(test_transport)),
    
    %% Register and test found behavior
    ?assertEqual(ok, erlmcp_registry:register_transport(test_transport, MockTransportPid, TransportConfig)),
    {ok, {FoundPid, FoundConfig}} = erlmcp_registry:find_transport(test_transport),
    
    ?assertEqual(MockTransportPid, FoundPid),
    ?assertEqual(TransportConfig, FoundConfig),
    
    cleanup_mock_process(MockTransportPid),
    ok.

%% @doc Test listing all servers
list_all_servers(Config) ->
    %% Empty list behavior
    ?assertEqual([], erlmcp_registry:list_servers()),
    
    %% Register multiple servers
    Servers = [
        {server1, create_mock_server(), #{type => server1}},
        {server2, create_mock_server(), #{type => server2}},
        {server3, create_mock_server(), #{type => server3}}
    ],
    
    [?assertEqual(ok, erlmcp_registry:register_server(Id, Pid, Config)) 
     || {Id, Pid, Config} <- Servers],
    
    %% Verify listing behavior
    ServerList = erlmcp_registry:list_servers(),
    ?assertEqual(3, length(ServerList)),
    
    %% Verify all servers are present
    ServerIds = [Id || {Id, _} <- ServerList],
    ?assert(lists:member(server1, ServerIds)),
    ?assert(lists:member(server2, ServerIds)),
    ?assert(lists:member(server3, ServerIds)),
    
    %% Cleanup
    [cleanup_mock_process(Pid) || {_, Pid, _} <- Servers],
    ok.

%% @doc Test listing all transports
list_all_transports(Config) ->
    %% Empty list behavior
    ?assertEqual([], erlmcp_registry:list_transports()),
    
    %% Register multiple transports
    Transports = [
        {transport1, create_mock_transport(), #{type => stdio}},
        {transport2, create_mock_transport(), #{type => tcp}},
        {transport3, create_mock_transport(), #{type => http}}
    ],
    
    [?assertEqual(ok, erlmcp_registry:register_transport(Id, Pid, Config)) 
     || {Id, Pid, Config} <- Transports],
    
    %% Verify listing behavior
    TransportList = erlmcp_registry:list_transports(),
    ?assertEqual(3, length(TransportList)),
    
    %% Verify all transports are present
    TransportIds = [Id || {Id, _} <- TransportList],
    ?assert(lists:member(transport1, TransportIds)),
    ?assert(lists:member(transport2, TransportIds)),
    ?assert(lists:member(transport3, TransportIds)),
    
    %% Cleanup
    [cleanup_mock_process(Pid) || {_, Pid, _} <- Transports],
    ok.

%% @doc Test explicit transport to server binding
bind_transport_to_server(Config) ->
    MockServerPid = create_mock_server(),
    MockTransportPid = create_mock_transport(),
    
    %% Register both entities
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid, #{})),
    ?assertEqual(ok, erlmcp_registry:register_transport(test_transport, MockTransportPid, #{})),
    
    %% Test binding behavior
    ?assertEqual(ok, erlmcp_registry:bind_transport_to_server(test_transport, test_server)),
    
    %% Verify binding
    {ok, BoundServer} = erlmcp_registry:get_server_for_transport(test_transport),
    ?assertEqual(test_server, BoundServer),
    
    %% Test error cases
    ?assertEqual({error, server_not_found}, 
                 erlmcp_registry:bind_transport_to_server(test_transport, unknown_server)),
    ?assertEqual({error, transport_not_found}, 
                 erlmcp_registry:bind_transport_to_server(unknown_transport, test_server)),
    
    cleanup_mock_process(MockServerPid),
    cleanup_mock_process(MockTransportPid),
    ok.

%% @doc Test transport unbinding
unbind_transport(Config) ->
    MockServerPid = create_mock_server(),
    MockTransportPid = create_mock_transport(),
    
    %% Setup with binding
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid, #{})),
    ?assertEqual(ok, erlmcp_registry:register_transport(test_transport, MockTransportPid, #{})),
    ?assertEqual(ok, erlmcp_registry:bind_transport_to_server(test_transport, test_server)),
    
    %% Verify binding exists
    {ok, test_server} = erlmcp_registry:get_server_for_transport(test_transport),
    
    %% Test unbinding behavior
    ?assertEqual(ok, erlmcp_registry:unbind_transport(test_transport)),
    
    %% Verify binding is removed
    ?assertEqual({error, not_found}, erlmcp_registry:get_server_for_transport(test_transport)),
    
    %% Should be idempotent
    ?assertEqual(ok, erlmcp_registry:unbind_transport(test_transport)),
    
    cleanup_mock_process(MockServerPid),
    cleanup_mock_process(MockTransportPid),
    ok.

%% @doc Test getting server for transport
get_server_for_transport(Config) ->
    MockServerPid = create_mock_server(),
    MockTransportPid = create_mock_transport(),
    
    %% Test not found behavior
    ?assertEqual({error, not_found}, erlmcp_registry:get_server_for_transport(test_transport)),
    
    %% Setup with binding
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid, #{})),
    ?assertEqual(ok, erlmcp_registry:register_transport(test_transport, MockTransportPid, #{})),
    ?assertEqual(ok, erlmcp_registry:bind_transport_to_server(test_transport, test_server)),
    
    %% Test found behavior
    {ok, FoundServer} = erlmcp_registry:get_server_for_transport(test_transport),
    ?assertEqual(test_server, FoundServer),
    
    cleanup_mock_process(MockServerPid),
    cleanup_mock_process(MockTransportPid),
    ok.

%% @doc Test capability queries
capability_queries(Config) ->
    MockServerPid = create_mock_server(),
    
    %% Register server with specific capabilities
    Capabilities = #mcp_server_capabilities{
        resources = #mcp_capability{enabled = true},
        tools = #mcp_capability{enabled = true},
        prompts = #mcp_capability{enabled = false}
    },
    ServerConfig = #{capabilities => Capabilities},
    
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid, ServerConfig)),
    
    %% Query and verify capabilities
    {ok, {_Pid, Config}} = erlmcp_registry:find_server(test_server),
    RetrievedCapabilities = maps:get(capabilities, Config),
    
    ?assertEqual(Capabilities, RetrievedCapabilities),
    ?assertEqual(true, (RetrievedCapabilities#mcp_server_capabilities.resources)#mcp_capability.enabled),
    ?assertEqual(true, (RetrievedCapabilities#mcp_server_capabilities.tools)#mcp_capability.enabled),
    ?assertEqual(false, (RetrievedCapabilities#mcp_server_capabilities.prompts)#mcp_capability.enabled),
    
    cleanup_mock_process(MockServerPid),
    ok.

%%====================================================================
%% Failure Recovery Tests (London School - Crash Coordination)
%%====================================================================

%% @doc Test server crash detection and cleanup
server_crash_detection_and_cleanup(Config) ->
    MockServerPid = create_mock_server(),
    MockTransportPid = create_mock_transport(),
    
    %% Setup server with transport binding
    ServerConfig = #{capabilities => #mcp_server_capabilities{}},
    TransportConfig = #{type => stdio, server_id => test_server},
    
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid, ServerConfig)),
    ?assertEqual(ok, erlmcp_registry:register_transport(test_transport, MockTransportPid, TransportConfig)),
    
    %% Verify initial state
    ?assertMatch({ok, _}, erlmcp_registry:find_server(test_server)),
    ?assertMatch({ok, test_server}, erlmcp_registry:get_server_for_transport(test_transport)),
    
    %% Simulate server crash
    exit(MockServerPid, simulated_crash),
    
    %% Allow monitor processing time
    timer:sleep(100),
    
    %% Verify crash cleanup behavior:
    %% 1. Server should be removed
    ?assertEqual({error, not_found}, erlmcp_registry:find_server(test_server)),
    
    %% 2. Transport binding should be cleaned up
    ?assertEqual({error, not_found}, erlmcp_registry:get_server_for_transport(test_transport)),
    
    %% 3. Transport should still exist
    ?assertMatch({ok, _}, erlmcp_registry:find_transport(test_transport)),
    
    %% 4. Registry should still be functional
    ?assert(is_process_alive(?config(registry_pid, Config))),
    
    cleanup_mock_process(MockTransportPid),
    ok.

%% @doc Test transport crash detection and cleanup
transport_crash_detection_and_cleanup(Config) ->
    MockServerPid = create_mock_server(),
    MockTransportPid = create_mock_transport(),
    
    %% Setup with binding
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid, #{})),
    ?assertEqual(ok, erlmcp_registry:register_transport(test_transport, MockTransportPid, #{})),
    ?assertEqual(ok, erlmcp_registry:bind_transport_to_server(test_transport, test_server)),
    
    %% Verify initial state
    ?assertMatch({ok, _}, erlmcp_registry:find_transport(test_transport)),
    ?assertMatch({ok, test_server}, erlmcp_registry:get_server_for_transport(test_transport)),
    
    %% Simulate transport crash
    exit(MockTransportPid, simulated_crash),
    
    %% Allow monitor processing time
    timer:sleep(100),
    
    %% Verify crash cleanup behavior:
    %% 1. Transport should be removed
    ?assertEqual({error, not_found}, erlmcp_registry:find_transport(test_transport)),
    
    %% 2. Binding should be cleaned up
    ?assertEqual({error, not_found}, erlmcp_registry:get_server_for_transport(test_transport)),
    
    %% 3. Server should still exist
    ?assertMatch({ok, _}, erlmcp_registry:find_server(test_server)),
    
    %% 4. Registry should still be functional
    ?assert(is_process_alive(?config(registry_pid, Config))),
    
    cleanup_mock_process(MockServerPid),
    ok.

%% @doc Test registry restart and recovery
registry_restart_recovery(Config) ->
    MockServerPid = create_mock_server(),
    MockTransportPid = create_mock_transport(),
    OldRegistryPid = ?config(registry_pid, Config),
    
    %% Setup initial state
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid, #{})),
    ?assertEqual(ok, erlmcp_registry:register_transport(test_transport, MockTransportPid, #{})),
    
    %% Kill registry process
    exit(OldRegistryPid, kill),
    timer:sleep(50),
    
    %% Start new registry
    {ok, NewRegistryPid} = erlmcp_registry:start_link(),
    
    %% Verify clean state after restart
    ?assertEqual([], erlmcp_registry:list_servers()),
    ?assertEqual([], erlmcp_registry:list_transports()),
    ?assertEqual({error, not_found}, erlmcp_registry:find_server(test_server)),
    ?assertEqual({error, not_found}, erlmcp_registry:find_transport(test_transport)),
    
    %% Update config for cleanup
    Config2 = lists:keyreplace(registry_pid, 1, Config, {registry_pid, NewRegistryPid}),
    
    cleanup_mock_process(MockServerPid),
    cleanup_mock_process(MockTransportPid),
    ok.

%% @doc Test monitor cleanup on registry termination
monitor_cleanup_on_terminate(Config) ->
    MockServerPid = create_mock_server(),
    MockTransportPid = create_mock_transport(),
    RegistryPid = ?config(registry_pid, Config),
    
    %% Setup monitoring state
    ?assertEqual(ok, erlmcp_registry:register_server(test_server, MockServerPid, #{})),
    ?assertEqual(ok, erlmcp_registry:register_transport(test_transport, MockTransportPid, #{})),
    
    %% Get monitor references (simulate registry internal state access)
    MonitorsBefore = erlang:process_info(RegistryPid, monitors),
    ?assertMatch({monitors, [_|_]}, MonitorsBefore),
    
    %% Terminate registry gracefully
    unlink(RegistryPid),
    gen_server:stop(RegistryPid),
    
    %% Verify monitors are cleaned up (mock processes should not receive DOWN messages)
    timer:sleep(50),
    
    %% Mock processes should still be alive (no monitor cleanup should kill them)
    ?assert(is_process_alive(MockServerPid)),
    ?assert(is_process_alive(MockTransportPid)),
    
    cleanup_mock_process(MockServerPid),
    cleanup_mock_process(MockTransportPid),
    ok.

%% @doc Test handling multiple simultaneous crashes
multiple_crash_handling(Config) ->
    %% Create multiple servers and transports
    Servers = [{list_to_atom("server_" ++ integer_to_list(I)), create_mock_server()} 
               || I <- lists:seq(1, 5)],
    Transports = [{list_to_atom("transport_" ++ integer_to_list(I)), create_mock_transport()} 
                  || I <- lists:seq(1, 3)],
    
    %% Register all
    [?assertEqual(ok, erlmcp_registry:register_server(Id, Pid, #{})) || {Id, Pid} <- Servers],
    [?assertEqual(ok, erlmcp_registry:register_transport(Id, Pid, #{})) || {Id, Pid} <- Transports],
    
    %% Bind some transports to servers
    ?assertEqual(ok, erlmcp_registry:bind_transport_to_server(transport_1, server_1)),
    ?assertEqual(ok, erlmcp_registry:bind_transport_to_server(transport_2, server_2)),
    
    %% Crash multiple processes simultaneously
    [exit(Pid, simulated_mass_crash) || {_, Pid} <- lists:sublist(Servers, 3)],
    [exit(Pid, simulated_mass_crash) || {_, Pid} <- lists:sublist(Transports, 2)],
    
    %% Allow processing time
    timer:sleep(200),
    
    %% Verify registry survived and cleaned up correctly
    ?assert(is_process_alive(?config(registry_pid, Config))),
    
    %% Verify crashed servers are removed
    ?assertEqual({error, not_found}, erlmcp_registry:find_server(server_1)),
    ?assertEqual({error, not_found}, erlmcp_registry:find_server(server_2)),
    ?assertEqual({error, not_found}, erlmcp_registry:find_server(server_3)),
    
    %% Verify crashed transports are removed
    ?assertEqual({error, not_found}, erlmcp_registry:find_transport(transport_1)),
    ?assertEqual({error, not_found}, erlmcp_registry:find_transport(transport_2)),
    
    %% Verify surviving entities still exist
    ?assertMatch({ok, _}, erlmcp_registry:find_server(server_4)),
    ?assertMatch({ok, _}, erlmcp_registry:find_server(server_5)),
    ?assertMatch({ok, _}, erlmcp_registry:find_transport(transport_3)),
    
    %% Verify bindings are cleaned up
    ?assertEqual({error, not_found}, erlmcp_registry:get_server_for_transport(transport_1)),
    ?assertEqual({error, not_found}, erlmcp_registry:get_server_for_transport(transport_2)),
    
    %% Cleanup remaining processes
    [{_, Pid4}, {_, Pid5}] = lists:sublist(Servers, 4, 2),
    [{_, TPid3}] = lists:sublist(Transports, 3, 1),
    cleanup_mock_process(Pid4),
    cleanup_mock_process(Pid5),
    cleanup_mock_process(TPid3),
    ok.

%%====================================================================
%% Property-Based Tests (London School - Contract Verification)
%%====================================================================

%% @doc Property-based test for registration invariants
prop_registration_invariants(Config) ->
    ?assert(proper:quickcheck(
        ?FORALL({ServerId, ServerConfig}, {server_id_gen(), server_config_gen()},
            begin
                MockServerPid = create_mock_server(),
                
                %% Register server
                RegisterResult = erlmcp_registry:register_server(ServerId, MockServerPid, ServerConfig),
                
                %% Property: Registration should succeed for valid inputs
                RegisterOk = RegisterResult =:= ok,
                
                %% Property: Registered server should be findable
                {FindResult, FindData} = case erlmcp_registry:find_server(ServerId) of
                    {ok, Data} -> {true, Data};
                    _ -> {false, undefined}
                end,
                
                %% Property: Found data should match registered data
                DataMatches = case FindData of
                    {MockServerPid, ServerConfig} -> true;
                    _ -> false
                end,
                
                %% Property: Duplicate registration should fail
                DuplicateResult = erlmcp_registry:register_server(ServerId, MockServerPid, ServerConfig),
                DuplicateFails = DuplicateResult =:= {error, already_registered},
                
                %% Cleanup
                erlmcp_registry:unregister_server(ServerId),
                cleanup_mock_process(MockServerPid),
                
                RegisterOk andalso FindResult andalso DataMatches andalso DuplicateFails
            end
        ),
        [{numtests, 50}, {on_output, fun(S, _) -> ct:pal("~s", [S]) end}]
    )).

%% @doc Property-based test for routing consistency
prop_routing_consistency(Config) ->
    ?assert(proper:quickcheck(
        ?FORALL({ServerId, TransportId, Message}, 
                {server_id_gen(), transport_id_gen(), message_gen()},
            begin
                MockServerPid = create_mock_server_with_mailbox(),
                
                %% Register server
                erlmcp_registry:register_server(ServerId, MockServerPid, #{}),
                
                %% Route message
                RouteResult = erlmcp_registry:route_to_server(ServerId, TransportId, Message),
                
                %% Property: Routing should always return ok (cast)
                RouteOk = RouteResult =:= ok,
                
                %% Property: Message should be delivered to registered server
                MessageDelivered = receive
                    {mock_message, MockServerPid, {mcp_message, TransportId, Message}} -> true
                after 100 -> false
                end,
                
                %% Cleanup
                erlmcp_registry:unregister_server(ServerId),
                cleanup_mock_process(MockServerPid),
                
                RouteOk andalso MessageDelivered
            end
        ),
        [{numtests, 30}, {on_output, fun(S, _) -> ct:pal("~s", [S]) end}]
    )).

%% @doc Property-based test for crash recovery completeness
prop_crash_recovery_completeness(Config) ->
    ?assert(proper:quickcheck(
        ?FORALL(ServerConfigs, list({server_id_gen(), server_config_gen()}),
            begin
                %% Setup multiple servers
                MockServers = [{ServerId, create_mock_server(), ServerConfig} 
                               || {ServerId, ServerConfig} <- ServerConfigs],
                
                %% Register all servers
                RegisterResults = [erlmcp_registry:register_server(ServerId, Pid, Config) 
                                   || {ServerId, Pid, Config} <- MockServers],
                AllRegistered = lists:all(fun(R) -> R =:= ok end, RegisterResults),
                
                %% Crash random subset
                NumToCrash = length(MockServers) div 2,
                ToCrash = lists:sublist(MockServers, NumToCrash),
                ToSurvive = lists:sublist(MockServers, NumToCrash + 1, length(MockServers)),
                
                %% Crash selected servers
                [exit(Pid, test_crash) || {_, Pid, _} <- ToCrash],
                
                %% Allow cleanup time
                timer:sleep(50),
                
                %% Property: Crashed servers should be removed
                CrashedCleanedUp = lists:all(fun({ServerId, _, _}) ->
                    erlmcp_registry:find_server(ServerId) =:= {error, not_found}
                end, ToCrash),
                
                %% Property: Surviving servers should remain
                SurvivorsRemain = lists:all(fun({ServerId, Pid, Config}) ->
                    case erlmcp_registry:find_server(ServerId) of
                        {ok, {Pid, Config}} -> true;
                        _ -> false
                    end
                end, ToSurvive),
                
                %% Property: Registry should still be alive
                RegistryAlive = is_process_alive(?config(registry_pid, Config)),
                
                %% Cleanup survivors
                [cleanup_mock_process(Pid) || {_, Pid, _} <- ToSurvive],
                
                AllRegistered andalso CrashedCleanedUp andalso SurvivorsRemain andalso RegistryAlive
            end
        ),
        [{numtests, 20}, {on_output, fun(S, _) -> ct:pal("~s", [S]) end}]
    )).

%%====================================================================
%% Mock Helper Functions (London School - Test Double Creation)
%%====================================================================

%% @doc Create a basic mock server process
create_mock_server() ->
    spawn_link(fun mock_server_loop/0).

%% @doc Create a mock server that forwards messages to test process
create_mock_server_with_mailbox() ->
    TestPid = self(),
    spawn_link(fun() -> mock_server_with_mailbox_loop(TestPid) end).

%% @doc Create a basic mock transport process
create_mock_transport() ->
    spawn_link(fun mock_transport_loop/0).

%% @doc Create a mock transport that forwards messages to test process
create_mock_transport_with_mailbox() ->
    TestPid = self(),
    spawn_link(fun() -> mock_transport_with_mailbox_loop(TestPid) end).

%% @doc Mock server loop
mock_server_loop() ->
    receive
        {mcp_message, _TransportId, _Message} = Msg ->
            %% Log message reception
            ct:pal("Mock server received: ~p", [Msg]),
            mock_server_loop();
        stop ->
            ok;
        _ ->
            mock_server_loop()
    end.

%% @doc Mock server loop with message forwarding
mock_server_with_mailbox_loop(TestPid) ->
    receive
        {mcp_message, _TransportId, _Message} = Msg ->
            TestPid ! {mock_message, self(), Msg},
            mock_server_with_mailbox_loop(TestPid);
        stop ->
            ok;
        _ ->
            mock_server_with_mailbox_loop(TestPid)
    end.

%% @doc Mock transport loop
mock_transport_loop() ->
    receive
        {mcp_response, _ServerId, _Message} = Msg ->
            %% Log message reception
            ct:pal("Mock transport received: ~p", [Msg]),
            mock_transport_loop();
        stop ->
            ok;
        _ ->
            mock_transport_loop()
    end.

%% @doc Mock transport loop with message forwarding
mock_transport_with_mailbox_loop(TestPid) ->
    receive
        {mcp_response, _ServerId, _Message} = Msg ->
            TestPid ! {mock_message, self(), Msg},
            mock_transport_with_mailbox_loop(TestPid);
        stop ->
            ok;
        _ ->
            mock_transport_with_mailbox_loop(TestPid)
    end.

%% @doc Cleanup a single mock process
cleanup_mock_process(Pid) ->
    case is_process_alive(Pid) of
        true -> 
            Pid ! stop,
            timer:sleep(10);
        false -> 
            ok
    end.

%% @doc Cleanup all mock processes from config
cleanup_mock_processes(Config) ->
    MockConfig = ?config(mock_config, Config),
    AllPids = MockConfig#mock_config.server_pids ++ MockConfig#mock_config.transport_pids,
    [cleanup_mock_process(Pid) || Pid <- AllPids].

%%====================================================================
%% Property-Based Test Generators
%%====================================================================

%% @doc Generator for server IDs
server_id_gen() ->
    oneof([
        atom(),
        binary()
    ]).

%% @doc Generator for transport IDs
transport_id_gen() ->
    oneof([
        atom(),
        binary()
    ]).

%% @doc Generator for server configurations
server_config_gen() ->
    ?LET({HasCapabilities, HasOptions}, {boolean(), boolean()},
        maps:from_list(
            (case HasCapabilities of
                true -> [{capabilities, #mcp_server_capabilities{
                    resources = #mcp_capability{enabled = boolean()},
                    tools = #mcp_capability{enabled = boolean()}
                }}];
                false -> []
            end) ++
            (case HasOptions of
                true -> [{options, #{timeout => choose(1000, 10000)}}];
                false -> []
            end)
        )
    ).

%% @doc Generator for MCP messages
message_gen() ->
    ?LET({Method, HasParams}, {binary(), boolean()},
        maps:from_list(
            [{method, Method}] ++
            (case HasParams of
                true -> [{params, #{test => atom()}}];
                false -> []
            end)
        )
    ).