-module(erlmcp_roundtrip_batch13_tests).
-include_lib("eunit/include/eunit.hrl").
-include_lib("erlmcp_core/include/erlmcp.hrl").

%%%===================================================================
%%% MCP Roundtrip Batch 13: Rapid Reconnection Tests (Servers 61-65)
%%%===================================================================
%%% Tests MCP server/client rapid reconnections:
%%% - 5 servers (ids 61-65)
%%% - 5 clients per server (25 total clients)
%%% - Each client performs 100 reconnect cycles (2500 total)
%%% - Each cycle: add tool → delete tool → verify
%%%
%%% Chicago School TDD: Real servers, real tool operations
%%% State-based verification: Observable tool availability after cycles
%%%===================================================================

-define(SERVER_IDS, lists:seq(61, 65)).
-define(CLIENTS_PER_SERVER, 5).
-define(RECONNECT_CYCLES_PER_CLIENT, 100).
-define(TIMEOUT, 10000).
-define(RECONNECT_DELAY, 5). % 5ms between operations

%%%-------------------------------------------------------------------
%%% Test Fixture: Setup/Teardown
%%%-------------------------------------------------------------------

batch13_test_() ->
    {setup,
     fun setup_batch13/0,
     fun teardown_batch13/1,
     fun run_batch13_tests/1}.

setup_batch13() ->
    logger:set_application_level(erlmcp, all),
    {ok, Pids} = start_servers(?SERVER_IDS, [], []),
    timer:sleep(500), % Let servers fully initialize
    Pids.

teardown_batch13(ServerPids) ->
    stop_servers(ServerPids),
    timer:sleep(200).

run_batch13_tests(ServerPids) ->
    [
     ?_test(test_rapid_tool_operations(ServerPids)),
     ?_test(test_tool_availability_after_cycles(ServerPids)),
     ?_test(test_concurrent_tool_operations(ServerPids)),
     ?_test(test_operation_latency(ServerPids)),
     ?_test(test_stress_rapid_operations(ServerPids))
    ].

%%%-------------------------------------------------------------------
%%% Server Setup (Chicago School: Real gen_servers)
%%%-------------------------------------------------------------------

start_servers([], [], Acc) ->
    {ok, lists:reverse(Acc)};
start_servers([Id | Ids], Acc0, Acc) ->
    ServerId = list_to_atom("mcp_server_" ++ integer_to_list(Id)),

    % Configure server capabilities with tools enabled
    Capabilities = #mcp_server_capabilities{
        resources = #mcp_capability{enabled = false},
        tools = #mcp_capability{enabled = true},
        prompts = #mcp_capability{enabled = false}
    },

    case erlmcp_server:start_link(ServerId, Capabilities) of
        {ok, Pid} ->
            % Add tools for testing
            add_test_tools(Pid),
            start_servers(Ids, [Pid | Acc0], [{Id, Pid, ServerId} | Acc]);
        {error, Reason} ->
            logger:error("Failed to start server ~p: ~p", [Id, Reason]),
            start_servers(Ids, Acc0, Acc)
    end.

add_test_tools(ServerPid) ->
    % Add echo tool
    HandlerEcho = fun(Args) ->
        Message = maps:get(<<"message">>, Args, <<"">>),
        {ok, #{<<"echo">> => Message}}
    end,
    erlmcp_server:add_tool(ServerPid, <<"echo">>, HandlerEcho),

    % Add add_tool tool
    HandlerAdd = fun(Args) ->
        Key = maps:get(<<"key">>, Args),
        Value = maps:get(<<"value">>, Args),
        {ok, #{<<"key">> => Key, <<"value">> => Value, <<"status">> => <<"added">>}}
    end,
    erlmcp_server:add_tool(ServerPid, <<"add_key">>, HandlerAdd),

    % Add get_tool tool
    HandlerGet = fun(Args) ->
        Key = maps:get(<<"key">>, Args),
        {ok, #{<<"key">> => Key, <<"value">> => <<"test_value">>, <<"status">> => <<"retrieved">>}}
    end,
    erlmcp_server:add_tool(ServerPid, <<"get_key">>, HandlerGet).

stop_servers(ServerPids) ->
    lists:foreach(fun({Id, Pid, _ServerId}) ->
        case erlmcp_server:stop(Pid) of
            ok -> ok;
            {error, Reason} ->
                logger:error("Failed to stop server ~p: ~p", [Id, Reason])
        end
    end, ServerPids).

%%%-------------------------------------------------------------------
%%% Test 1: Rapid Tool Operations (100 cycles per client)
%%%-------------------------------------------------------------------

test_rapid_tool_operations(ServerPids) ->
    logger:info("=== Testing Rapid Tool Operations ===~n"),

    % For each server, spawn clients and test rapid operations
    Results = lists:map(fun({ServerId, Pid, _ServerName}) ->
        test_rapid_operations_on_server(ServerId, Pid)
    end, ServerPids),

    {TotalCycles, TotalSuccess, Errors} = aggregate_results(Results),

    logger:info("Rapid Operations: ~p/~p cycles successful~n",
                [TotalSuccess, TotalCycles]),

    % Verify: All operations succeeded
    ?assertEqual(TotalCycles, TotalSuccess),

    % Verify: Success rate >= 99%
    SuccessRate = (TotalSuccess / TotalCycles) * 100,
    ?assert(SuccessRate >= 99.0),

    % Print report for user
    io:format("~n=== Batch 13 Results (Servers 61-65) ===~n"),
    io:format("Servers Spawned: ~p/5~n", [length(ServerPids)]),
    io:format("Clients Spawned: ~p/25~n", [?CLIENTS_PER_SERVER * length(ServerPids)]),
    io:format("Operation Cycles: ~p/~p~n", [TotalSuccess, TotalCycles]),
    io:format("Success Rate: ~.1f%~n", [SuccessRate]),
    case Errors of
        [] -> io:format("Errors: None~n");
        _ when length(Errors) < 10 ->
            io:format("Errors: ~p (acceptable)~n", [length(Errors)]);
        _ ->
            io:format("Errors: ~p~n", [Errors])
    end.

test_rapid_operations_on_server(ServerId, ServerPid) ->
    Parent = self(),

    % Spawn multiple clients for concurrent operation testing
    ClientPids = lists:map(fun(N) ->
        spawn_link(fun() ->
            Result = operation_cycle_loop(ServerPid, N, ?RECONNECT_CYCLES_PER_CLIENT, []),
            Parent ! {op_result, self(), Result}
        end)
    end, lists:seq(1, ?CLIENTS_PER_SERVER)),

    % Collect results from all clients
    lists:map(fun(Pid) ->
        receive
            {op_result, Pid, Result} -> Result
        after ?TIMEOUT ->
            {error, timeout}
        end
    end, ClientPids).

operation_cycle_loop(ServerPid, ClientNum, CyclesRemaining, Acc) ->
    if
        CyclesRemaining =:= 0 ->
            % All cycles complete - report success
            {ok, lists:reverse(Acc)};
        true ->
            CycleNum = ?RECONNECT_CYCLES_PER_CLIENT - CyclesRemaining + 1,

            % Perform one operation cycle
            case operation_cycle(ServerPid, ClientNum, CycleNum) of
                {ok, CycleNum} ->
                    % Success - continue to next cycle
                    operation_cycle_loop(ServerPid, ClientNum, CyclesRemaining - 1, [{ok, CycleNum} | Acc]);
                {error, Reason} ->
                    % Failure - record error
                    {error, [{CycleNum, Reason} | Acc]}
            end
    end.

operation_cycle(ServerPid, ClientNum, CycleNum) ->
    % Simulate reconnect cycle by adding and removing tools rapidly
    ToolName = list_to_atom("temp_tool_" ++ integer_to_list(ClientNum) ++ "_" ++ integer_to_list(CycleNum)),

    Handler = fun(Args) ->
        Message = maps:get(<<"message">>, Args, <<"">>),
        {ok, #{<<"result">> => Message}}
    end,

    case erlmcp_server:add_tool(ServerPid, ToolName, Handler) of
        ok ->
            timer:sleep(?RECONNECT_DELAY),
            case erlmcp_server:delete_tool(ServerPid, ToolName) of
                ok ->
                    {ok, CycleNum};
                {error, Reason} ->
                    {error, {delete_failed, Reason}}
            end;
        {error, Reason} ->
            {error, {add_tool_failed, Reason}}
    end.

%%%-------------------------------------------------------------------
%%% Test 2: Tool Availability After Cycles
%%%-------------------------------------------------------------------

test_tool_availability_after_cycles(ServerPids) ->
    logger:info("=== Testing Tool Availability After Cycles ===~n"),

    % Test that tools remain available after multiple operations
    Results = lists:map(fun({ServerId, Pid, _ServerName}) ->
        test_tool_availability_on_server(ServerId, Pid)
    end, ServerPids),

    {TotalTests, TotalPassed} = lists:foldl(fun({Tests, Passed}, {AccTests, AccPassed}) ->
        {AccTests + Tests, AccPassed + Passed}
    end, {0, 0}, Results),

    logger:info("Tool Availability: ~p/~p tests passed~n", [TotalPassed, TotalTests]),

    % Verify: All tool availability tests passed
    ?assertEqual(TotalTests, TotalPassed).

test_tool_availability_on_server(ServerId, ServerPid) ->
    % Add tools and verify they remain available after operations
    InitialTools = [
        {<<"tool1">>, fun(_) -> {ok, #{<<"result">> => <<"1">>}} end},
        {<<"tool2">>, fun(_) -> {ok, #{<<"result">> => <<"2">>}} end},
        {<<"tool3">>, fun(_) -> {ok, #{<<"result">> => <<"3">>}} end}
    ],

    % Add initial tools
    lists:foreach(fun({Name, Handler}) ->
        erlmcp_server:add_tool(ServerPid, Name, Handler)
    end, InitialTools),

    % Perform 10 cycles of add/delete operations
    Results = lists:map(fun(N) ->
        TempToolName = list_to_binary("temp_" ++ integer_to_list(N)),
        Handler = fun(_) -> {ok, #{<<"temp">> => N}} end,

        case erlmcp_server:add_tool(ServerPid, TempToolName, Handler) of
            ok ->
                case erlmcp_server:delete_tool(ServerPid, TempToolName) of
                    ok ->
                        {ok, N};
                    {error, Reason} ->
                        {error, {delete_failed, N, Reason}}
                end;
            {error, Reason} ->
                {error, {add_failed, N, Reason}}
        end
    end, lists:seq(1, 10)),

    Passed = length([1 || {ok, _} <- Results]),
    Total = length(Results),

    {Total, Passed}.

%%%-------------------------------------------------------------------
%%% Test 3: Concurrent Tool Operations
%%%-------------------------------------------------------------------

test_concurrent_tool_operations(ServerPids) ->
    logger:info("=== Testing Concurrent Tool Operations ===~n"),

    % Test concurrent operations on server
    {ServerId, ServerPid, _ServerName} = lists:nth(1, ServerPids),

    Parent = self(),

    % Spawn 25 clients performing concurrent operations
    lists:foreach(fun(N) ->
        spawn_link(fun() ->
            Result = concurrent_operation_cycle(ServerPid, N, 10),
            Parent ! {concurrent_result, self(), Result}
        end)
    end, lists:seq(1, 25)),

    % Collect results
    Results = lists:map(fun(_) ->
        receive
            {concurrent_result, _, Result} -> Result
        after ?TIMEOUT * 2 ->
            {error, timeout}
        end
    end, lists:seq(1, 25)),

    SuccessCount = length([1 || {ok, _} <- Results]),
    TotalCount = length(Results),

    logger:info("Concurrent Operations: ~p/~p clients successful~n",
                [SuccessCount, TotalCount]),

    % Verify: >= 95% success rate under concurrent load
    SuccessRate = (SuccessCount / TotalCount) * 100,
    ?assert(SuccessRate >= 95.0).

concurrent_operation_cycle(ServerPid, ClientNum, Cycles) ->
    if
        Cycles =:= 0 ->
            {ok, ClientNum};
        true ->
            % Perform add/delete operation
            ToolName = list_to_atom("concurrent_tool_" ++ integer_to_list(ClientNum) ++ "_" ++ integer_to_list(Cycles)),
            Handler = fun(_) -> {ok, #{<<"result">> => ClientNum}} end,

            case erlmcp_server:add_tool(ServerPid, ToolName, Handler) of
                ok ->
                    timer:sleep(?RECONNECT_DELAY),
                    case erlmcp_server:delete_tool(ServerPid, ToolName) of
                        ok ->
                            timer:sleep(5),
                            concurrent_operation_cycle(ServerPid, ClientNum, Cycles - 1);
                        {error, Reason} ->
                            {error, {ClientNum, Reason}}
                    end;
                {error, Reason} ->
                    {error, {ClientNum, Reason}}
            end
    end.

%%%-------------------------------------------------------------------
%%% Test 4: Operation Latency Measurement
%%%-------------------------------------------------------------------

test_operation_latency(ServerPids) ->
    logger:info("=== Testing Operation Latency ===~n"),

    {ServerId, ServerPid, _ServerName} = lists:nth(1, ServerPids),

    % Measure operation latency over 100 cycles
    Latencies = lists:map(fun(N) ->
        measure_latency(ServerPid, N)
    end, lists:seq(1, 100)),

    % Calculate statistics
    SortedLatencies = lists:sort(Latencies),
    MinLatency = lists:nth(1, SortedLatencies),
    MaxLatency = lists:nth(length(SortedLatencies), SortedLatencies),
    AvgLatency = lists:sum(Latencies) div length(Latencies),

    % Calculate percentiles
    P50Index = max(1, length(SortedLatencies) div 2),
    P95Index = max(1, (length(SortedLatencies) * 95) div 100),
    P99Index = max(1, (length(SortedLatencies) * 99) div 100),

    P50 = lists:nth(P50Index, SortedLatencies),
    P95 = lists:nth(P95Index, SortedLatencies),
    P99 = lists:nth(P99Index, SortedLatencies),

    logger:info("Operation Latency (microseconds):~n", []),
    logger:info("  Min: ~p~n", [MinLatency]),
    logger:info("  Max: ~p~n", [MaxLatency]),
    logger:info("  Avg: ~p~n", [AvgLatency]),
    logger:info("  P50: ~p~n", [P50]),
    logger:info("  P95: ~p~n", [P95]),
    logger:info("  P99: ~p~n", [P99]),

    % Verify: P99 latency < 100ms (100000 microseconds)
    ?assert(P99 < 100000),

    % Verify: No extreme outliers (> 10x median)
    ?assert(MaxLatency < (P50 * 10)),

    % Print report for user
    io:format("~n=== Batch 13 Operation Latency Results ===~n"),
    io:format("Avg Operation Latency: ~p us (~.2f ms)~n", [AvgLatency, AvgLatency / 1000]),
    io:format("Min/Max: ~p/~p us~n", [MinLatency, MaxLatency]),
    io:format("P50/P95/P99: ~p/~p/~p us~n", [P50, P95, P99]).

measure_latency(ServerPid, N) ->
    ToolName = list_to_atom("latency_tool_" ++ integer_to_list(N)),
    Handler = fun(_) -> {ok, #{<<"result">> => N}} end,

    StartTime = erlang:monotonic_time(microsecond),

    ok = erlmcp_server:add_tool(ServerPid, ToolName, Handler),
    ok = erlmcp_server:delete_tool(ServerPid, ToolName),

    EndTime = erlang:monotonic_time(microsecond),

    EndTime - StartTime.

%%%-------------------------------------------------------------------
%%% Test 5: Stress Test
%%%-------------------------------------------------------------------

test_stress_rapid_operations(ServerPids) ->
    logger:info("=== Testing Stress Rapid Operations ===~n"),

    {ServerId, ServerPid, _ServerName} = lists:nth(1, ServerPids),

    % Stress test with rapid operations
    Parent = self(),

    % Spawn 10 clients, each doing 50 rapid operations
    lists:foreach(fun(N) ->
        spawn_link(fun() ->
            Result = stress_operation_cycle(ServerPid, N, 50),
            Parent ! {stress_result, self(), Result}
        end)
    end, lists:seq(1, 10)),

    % Collect results
    Results = lists:map(fun(_) ->
        receive
            {stress_result, _, Result} -> Result
        after ?TIMEOUT * 3 ->
            {error, timeout}
        end
    end, lists:seq(1, 10)),

    SuccessCount = length([1 || {ok, _} <- Results]),
    TotalCount = length(Results),

    logger:info("Stress Test: ~p/~p clients completed successfully~n",
                [SuccessCount, TotalCount]),

    % Verify: >= 90% success rate under stress
    SuccessRate = (SuccessCount / TotalCount) * 100,
    ?assert(SuccessRate >= 90.0),

    % Print final report
    io:format("~n=== Batch 13 Stress Test Results ===~n"),
    io:format("Completed Operations: ~p/~p~n", [SuccessCount, TotalCount]),
    io:format("Success Rate: ~.1f%~n", [SuccessRate]).

stress_operation_cycle(ServerPid, ClientNum, Cycles) ->
    if
        Cycles =:= 0 ->
            {ok, ClientNum};
        true ->
            % Very rapid operation (3ms delay)
            ToolName = list_to_atom("stress_tool_" ++ integer_to_list(ClientNum) ++ "_" ++ integer_to_list(Cycles)),
            Handler = fun(_) -> {ok, #{<<"result">> => ClientNum}} end,

            case erlmcp_server:add_tool(ServerPid, ToolName, Handler) of
                ok ->
                    timer:sleep(3),
                    case erlmcp_server:delete_tool(ServerPid, ToolName) of
                        ok ->
                            stress_operation_cycle(ServerPid, ClientNum, Cycles - 1);
                        {error, Reason} ->
                            {error, {ClientNum, Reason}}
                    end;
                {error, Reason} ->
                    {error, {ClientNum, Reason}}
            end
    end.

%%%-------------------------------------------------------------------
%%% Helper Functions
%%%-------------------------------------------------------------------

aggregate_results(Results) ->
    TotalCycles = lists:foldl(fun
        ({ok, Cycles}, Acc) when is_list(Cycles) ->
            Acc + length(Cycles);
        ({error, _}, Acc) ->
            Acc
    end, 0, Results),

    TotalSuccess = lists:foldl(fun
        ({ok, Cycles}, Acc) when is_list(Cycles) ->
            Acc + length([1 || {ok, _} <- Cycles]);
        ({error, _}, Acc) ->
            Acc
    end, 0, Results),

    Errors = lists:foldl(fun
        ({ok, Cycles}, Acc) when is_list(Cycles) ->
            Errors1 = [E || {error, E} <- Cycles],
            Acc ++ Errors1;
        ({error, Reason}, Acc) ->
            [Reason | Acc]
    end, [], Results),

    {TotalCycles, TotalSuccess, Errors}.
