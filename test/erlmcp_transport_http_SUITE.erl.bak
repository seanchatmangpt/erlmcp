%%%-------------------------------------------------------------------
%%% @doc
%%% Common Test suite for erlmcp_transport_http module
%%%
%%% This comprehensive test suite covers HTTP transport functionality
%%% including request/response handling, retry logic, SSL support,
%%% error handling, and performance characteristics.
%%%-------------------------------------------------------------------
-module(erlmcp_transport_http_SUITE).

-include_lib("common_test/include/ct.hrl").
-include_lib("eunit/include/eunit.hrl").
-include("erlmcp.hrl").

%% Suite callbacks
-export([all/0, groups/0, init_per_suite/1, end_per_suite/1,
         init_per_group/2, end_per_group/2,
         init_per_testcase/2, end_per_testcase/2]).

%% Test cases
-export([
    % Basic functionality
    basic_startup_test/1,
    basic_send_test/1,
    basic_close_test/1,
    get_state_test/1,
    
    % Transport behavior tests
    transport_behavior_init/1,
    transport_behavior_send/1,
    transport_behavior_close/1,
    
    % HTTP operations
    http_post_requests/1,
    http_headers_handling/1,
    http_response_processing/1,
    http_status_codes/1,
    
    % Registry integration
    registry_registration/1,
    registry_message_routing/1,
    registry_response_handling/1,
    registry_unregistration/1,
    
    % Configuration
    url_validation/1,
    headers_configuration/1,
    timeout_configuration/1,
    ssl_configuration/1,
    
    % Retry logic
    retry_on_failure/1,
    retry_backoff/1,
    max_retries_limit/1,
    retry_conditions/1,
    
    % Error handling
    network_errors/1,
    http_errors/1,
    timeout_handling/1,
    malformed_responses/1,
    
    % Performance
    throughput_test/1,
    latency_test/1,
    concurrent_requests/1,
    memory_usage_test/1,
    
    % SSL/TLS
    https_requests/1,
    ssl_certificate_validation/1,
    ssl_options_test/1,
    
    % Integration tests
    end_to_end_communication/1,
    load_testing/1,
    stress_testing/1
]).

%%====================================================================
%% Suite Configuration
%%====================================================================

all() ->
    [
        {group, basic_functionality},
        {group, transport_behavior},
        {group, http_operations},
        {group, registry_integration},
        {group, configuration},
        {group, retry_logic},
        {group, error_handling},
        {group, performance},
        {group, ssl_tls},
        {group, integration}
    ].

groups() ->
    [
        {basic_functionality, [parallel], [
            basic_startup_test,
            basic_send_test,
            basic_close_test,
            get_state_test
        ]},
        {transport_behavior, [parallel], [
            transport_behavior_init,
            transport_behavior_send,
            transport_behavior_close
        ]},
        {http_operations, [sequential], [
            http_post_requests,
            http_headers_handling,
            http_response_processing,
            http_status_codes
        ]},
        {registry_integration, [sequential], [
            registry_registration,
            registry_message_routing,
            registry_response_handling,
            registry_unregistration
        ]},
        {configuration, [parallel], [
            url_validation,
            headers_configuration,
            timeout_configuration,
            ssl_configuration
        ]},
        {retry_logic, [sequential], [
            retry_on_failure,
            retry_backoff,
            max_retries_limit,
            retry_conditions
        ]},
        {error_handling, [sequential], [
            network_errors,
            http_errors,
            timeout_handling,
            malformed_responses
        ]},
        {performance, [sequential], [
            throughput_test,
            latency_test,
            concurrent_requests,
            memory_usage_test
        ]},
        {ssl_tls, [sequential], [
            https_requests,
            ssl_certificate_validation,
            ssl_options_test
        ]},
        {integration, [sequential], [
            end_to_end_communication,
            load_testing,
            stress_testing
        ]}
    ].

%%====================================================================
%% Suite Setup/Teardown
%%====================================================================

init_per_suite(Config) ->
    ct:pal("Starting HTTP transport test suite"),
    
    % Start necessary applications
    ok = application:ensure_started(crypto),
    ok = application:ensure_started(ssl),
    ok = application:ensure_started(inets),
    ok = application:ensure_started(sasl),
    
    % Start registry
    case erlmcp_registry:start_link() of
        {ok, _} -> ok;
        {error, {already_started, _}} -> ok
    end,
    
    % Start mock HTTP server
    {ok, MockServer} = start_mock_http_server(),
    ServerPort = get_mock_server_port(MockServer),
    
    [{mock_server, MockServer}, {server_port, ServerPort} | Config].

end_per_suite(Config) ->
    MockServer = ?config(mock_server, Config),
    stop_mock_http_server(MockServer),
    ct:pal("Ending HTTP transport test suite"),
    ok.

init_per_group(GroupName, Config) ->
    ct:pal("Starting group: ~p", [GroupName]),
    Config.

end_per_group(GroupName, _Config) ->
    ct:pal("Ending group: ~p", [GroupName]),
    ok.

init_per_testcase(TestCase, Config) ->
    ct:pal("Starting test case: ~p", [TestCase]),
    Config.

end_per_testcase(TestCase, _Config) ->
    ct:pal("Ending test case: ~p", [TestCase]),
    cleanup_processes(),
    ok.

%%====================================================================
%% Test Cases - Basic Functionality
%%====================================================================

basic_startup_test(Config) ->
    ServerPort = ?config(server_port, Config),
    
    Opts = #{
        transport_id => test_http_basic,
        server_id => test_server_basic,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/mcp"
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    ?assert(is_pid(Pid)),
    ?assert(is_process_alive(Pid)),
    
    % Verify state
    {ok, State} = gen_server:call(Pid, get_state),
    ?assertEqual(test_http_basic, State#state.transport_id),
    ?assertEqual(test_server_basic, State#state.server_id),
    
    ok = gen_server:stop(Pid),
    ok.

basic_send_test(Config) ->
    ServerPort = ?config(server_port, Config),
    
    Opts = #{
        transport_id => test_http_send,
        server_id => test_server_send,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/mcp",
        timeout => 5000
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    {ok, State} = gen_server:call(Pid, get_state),
    
    % Test sending JSON data
    TestData = jsx:encode(#{method => <<"test">>, params => #{}}),
    ?assertEqual(ok, erlmcp_transport_http:send(State, TestData)),
    
    ok = gen_server:stop(Pid),
    ok.

basic_close_test(Config) ->
    ServerPort = ?config(server_port, Config),
    
    Opts = #{
        transport_id => test_http_close,
        server_id => test_server_close,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/mcp"
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    {ok, State} = gen_server:call(Pid, get_state),
    
    % HTTP is stateless, close should always succeed
    ?assertEqual(ok, erlmcp_transport_http:close(State)),
    
    ok = gen_server:stop(Pid),
    ok.

get_state_test(Config) ->
    ServerPort = ?config(server_port, Config),
    
    Opts = #{
        transport_id => test_http_state,
        server_id => test_server_state,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/mcp",
        timeout => 10000,
        max_retries => 5
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    {ok, State} = gen_server:call(Pid, get_state),
    
    ?assertEqual(test_http_state, State#state.transport_id),
    ?assertEqual(test_server_state, State#state.server_id),
    ?assertEqual(10000, State#state.timeout),
    ?assertEqual(5, State#state.max_retries),
    
    ok = gen_server:stop(Pid),
    ok.

%%====================================================================
%% Test Cases - Transport Behavior
%%====================================================================

transport_behavior_init(Config) ->
    Opts = #{
        transport_id => test_http_init,
        server_id => test_server_init,
        url => "http://example.com/mcp",
        headers => [{"X-Custom", "test"}],
        timeout => 15000
    },
    
    {ok, State} = erlmcp_transport_http:init_transport(Opts),
    ?assertEqual(test_http_init, State#state.transport_id),
    ?assertEqual(test_server_init, State#state.server_id),
    ?assertEqual("http://example.com/mcp", State#state.url),
    ?assertEqual(15000, State#state.timeout),
    ?assert(lists:member({"X-Custom", "test"}, State#state.headers)),
    ok.

transport_behavior_send(Config) ->
    ServerPort = ?config(server_port, Config),
    
    Opts = #{
        transport_id => test_http_behavior_send,
        server_id => test_server_behavior_send,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/mcp"
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    {ok, State} = gen_server:call(Pid, get_state),
    
    % Test different data types
    TestCases = [
        <<"binary data">>,
        "string data",
        jsx:encode(#{method => <<"test">>, params => #{}})
    ],
    
    lists:foreach(fun(Data) ->
        ?assertEqual(ok, erlmcp_transport_http:send(State, Data))
    end, TestCases),
    
    ok = gen_server:stop(Pid),
    ok.

transport_behavior_close(Config) ->
    Opts = #{
        transport_id => test_http_behavior_close,
        server_id => test_server_behavior_close,
        url => "http://example.com/mcp"
    },
    
    {ok, State} = erlmcp_transport_http:init_transport(Opts),
    % HTTP is stateless, close is always ok
    ?assertEqual(ok, erlmcp_transport_http:close(State)),
    ok.

%%====================================================================
%% Test Cases - HTTP Operations
%%====================================================================

http_post_requests(Config) ->
    ServerPort = ?config(server_port, Config),
    
    Opts = #{
        transport_id => test_http_post,
        server_id => test_server_post,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/mcp"
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    
    % Send POST request
    RequestData = jsx:encode(#{
        jsonrpc => <<"2.0">>,
        method => <<"initialize">>,
        params => #{},
        id => 1
    }),
    
    ?assertEqual(ok, gen_server:call(Pid, {send, RequestData})),
    
    ok = gen_server:stop(Pid),
    ok.

http_headers_handling(Config) ->
    ServerPort = ?config(server_port, Config),
    
    CustomHeaders = [
        {"Authorization", "Bearer token123"},
        {"X-Client-Version", "1.0.0"},
        {"Custom-Header", "custom-value"}
    ],
    
    Opts = #{
        transport_id => test_http_headers,
        server_id => test_server_headers,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/mcp",
        headers => CustomHeaders
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    {ok, State} = gen_server:call(Pid, get_state),
    
    % Verify custom headers are included
    Headers = State#state.headers,
    ?assert(lists:member({"Authorization", "Bearer token123"}, Headers)),
    ?assert(lists:member({"X-Client-Version", "1.0.0"}, Headers)),
    ?assert(lists:member({"Custom-Header", "custom-value"}, Headers)),
    
    % Should also have default headers
    ?assert(lists:member({"Content-Type", "application/json"}, Headers)),
    ?assert(lists:member({"Accept", "application/json"}, Headers)),
    
    ok = gen_server:stop(Pid),
    ok.

http_response_processing(Config) ->
    ServerPort = ?config(server_port, Config),
    
    Opts = #{
        transport_id => test_http_response,
        server_id => test_server_response,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/echo"
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    
    % Send request and verify response processing
    RequestData = jsx:encode(#{test => <<"data">>}),
    ?assertEqual(ok, gen_server:call(Pid, {send, RequestData})),
    
    ok = gen_server:stop(Pid),
    ok.

http_status_codes(Config) ->
    ServerPort = ?config(server_port, Config),
    
    % Test different HTTP status codes
    StatusCodes = [200, 201, 400, 404, 500, 502, 503],
    
    lists:foreach(fun(StatusCode) ->
        Opts = #{
            transport_id => list_to_atom("test_http_status_" ++ integer_to_list(StatusCode)),
            server_id => list_to_atom("test_server_status_" ++ integer_to_list(StatusCode)),
            url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/status/" ++ integer_to_list(StatusCode),
            max_retries => 0 % Don't retry for this test
        },
        
        {ok, Pid} = erlmcp_transport_http:start_link(Opts),
        
        RequestData = <<"test data">>,
        Result = gen_server:call(Pid, {send, RequestData}),
        
        case StatusCode of
            Code when Code >= 200, Code < 300 ->
                ?assertEqual(ok, Result);
            _ ->
                ?assertMatch({error, _}, Result)
        end,
        
        ok = gen_server:stop(Pid)
    end, StatusCodes),
    ok.

%%====================================================================
%% Test Cases - Registry Integration
%%====================================================================

registry_registration(Config) ->
    ServerPort = ?config(server_port, Config),
    
    TransportId = test_http_registry_reg,
    ServerId = test_server_registry_reg,
    
    Opts = #{
        transport_id => TransportId,
        server_id => ServerId,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/mcp"
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    timer:sleep(100),
    
    % Verify registration
    {ok, {RegPid, RegConfig}} = erlmcp_registry:find_transport(TransportId),
    ?assertEqual(Pid, RegPid),
    ?assertMatch(#{type := http}, RegConfig),
    
    ok = gen_server:stop(Pid),
    ok.

registry_message_routing(Config) ->
    ServerPort = ?config(server_port, Config),
    
    TransportId = test_http_registry_routing,
    ServerId = test_server_registry_routing,
    
    % Start mock server
    MockServer = spawn_mock_server(ServerId),
    
    Opts = #{
        transport_id => TransportId,
        server_id => ServerId,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/echo"
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    timer:sleep(100),
    
    % Send request - should route response to server
    RequestData = jsx:encode(#{method => <<"test">>, data => <<"routing test">>}),
    ?assertEqual(ok, gen_server:call(Pid, {send, RequestData})),
    
    % Verify server receives response
    receive
        {mock_server, ServerId, _Response} ->
            ok % Response received
    after 2000 ->
        ?assert(false, "Response not routed to server")
    end,
    
    cleanup_mock_server(MockServer),
    ok = gen_server:stop(Pid),
    ok.

registry_response_handling(Config) ->
    ServerPort = ?config(server_port, Config),
    
    TransportId = test_http_registry_response,
    ServerId = test_server_registry_response,
    
    Opts = #{
        transport_id => TransportId,
        server_id => ServerId,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/mcp"
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    timer:sleep(100),
    
    % Send response via registry mechanism  
    ResponseData = jsx:encode(#{result => <<"test response">>}),
    gen_server:cast(Pid, {mcp_response, ServerId, ResponseData}),
    timer:sleep(100),
    
    % Should handle gracefully
    ?assert(is_process_alive(Pid)),
    
    ok = gen_server:stop(Pid),
    ok.

registry_unregistration(Config) ->
    ServerPort = ?config(server_port, Config),
    
    TransportId = test_http_registry_unreg,
    ServerId = test_server_registry_unreg,
    
    Opts = #{
        transport_id => TransportId,
        server_id => ServerId,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/mcp"
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    timer:sleep(100),
    
    % Verify registered
    {ok, _} = erlmcp_registry:find_transport(TransportId),
    
    % Stop and verify unregistration
    ok = gen_server:stop(Pid),
    timer:sleep(100),
    
    ?assertEqual({error, not_found}, erlmcp_registry:find_transport(TransportId)),
    ok.

%%====================================================================
%% Test Cases - Configuration
%%====================================================================

url_validation(Config) ->
    ValidUrls = [
        "http://example.com/api",
        "https://api.example.com/v1/mcp",
        "http://localhost:8080/mcp",
        <<"https://secure.example.com/endpoint">>
    ],
    
    lists:foreach(fun(Url) ->
        Opts = #{
            transport_id => test_http_url_validation,
            server_id => test_server_url_validation,
            url => Url
        },
        {ok, _State} = erlmcp_transport_http:init_transport(Opts)
    end, ValidUrls),
    
    % Test invalid URLs (should still initialize but may fail on use)
    InvalidUrls = [
        "ftp://example.com",
        "not-a-url",
        ""
    ],
    
    lists:foreach(fun(Url) ->
        Opts = #{
            transport_id => test_http_invalid_url,
            server_id => test_server_invalid_url,
            url => Url
        },
        % May succeed in init but fail during actual use
        try
            {ok, _State} = erlmcp_transport_http:init_transport(Opts)
        catch
            _:_ -> ok % Expected for some invalid URLs
        end
    end, InvalidUrls),
    ok.

headers_configuration(Config) ->
    TestHeaders = [
        {"Authorization", "Bearer test-token"},
        {"X-API-Version", "v1"},
        {"User-Agent", "test-client/1.0"}
    ],
    
    Opts = #{
        transport_id => test_http_headers_config,
        server_id => test_server_headers_config,
        url => "http://example.com/api",
        headers => TestHeaders
    },
    
    {ok, State} = erlmcp_transport_http:init_transport(Opts),
    
    % Verify all custom headers are present
    Headers = State#state.headers,
    lists:foreach(fun(Header) ->
        ?assert(lists:member(Header, Headers))
    end, TestHeaders),
    
    % Verify default headers are still present
    ?assert(lists:member({"Content-Type", "application/json"}, Headers)),
    ok.

timeout_configuration(Config) ->
    TimeoutConfigs = [
        {1000, 500},   % 1s timeout, 0.5s connect timeout
        {5000, 2000},  % 5s timeout, 2s connect timeout
        {30000, 5000}  % 30s timeout, 5s connect timeout
    ],
    
    lists:foreach(fun({Timeout, ConnectTimeout}) ->
        Opts = #{
            transport_id => test_http_timeout_config,
            server_id => test_server_timeout_config,
            url => "http://example.com/api",
            timeout => Timeout,
            connect_timeout => ConnectTimeout
        },
        
        {ok, State} = erlmcp_transport_http:init_transport(Opts),
        ?assertEqual(Timeout, State#state.timeout),
        
        % Verify HTTP options contain timeouts
        HttpOptions = State#state.http_options,
        ?assert(lists:member({timeout, Timeout}, HttpOptions)),
        ?assert(lists:member({connect_timeout, ConnectTimeout}, HttpOptions))
    end, TimeoutConfigs),
    ok.

ssl_configuration(Config) ->
    Opts = #{
        transport_id => test_http_ssl_config,
        server_id => test_server_ssl_config,
        url => "https://secure.example.com/api",
        http_options => [
            {ssl, [
                {verify, verify_peer},
                {cacerts, public_key:cacerts_get()}
            ]}
        ]
    },
    
    {ok, State} = erlmcp_transport_http:init_transport(Opts),
    
    % Verify SSL options are configured
    HttpOptions = State#state.http_options,
    ?assert(lists:keymember(ssl, 1, HttpOptions)),
    ok.

%%====================================================================
%% Test Cases - Retry Logic
%%====================================================================

retry_on_failure(Config) ->
    % Use non-existent port to trigger retries
    Opts = #{
        transport_id => test_http_retry,
        server_id => test_server_retry,
        url => "http://localhost:99999/mcp", % Non-existent port
        max_retries => 3,
        retry_delay => 100
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    {ok, State} = gen_server:call(Pid, get_state),
    
    StartTime = erlang:monotonic_time(millisecond),
    
    % This should fail and retry
    {error, _} = erlmcp_transport_http:send(State, <<"test">>),
    
    EndTime = erlang:monotonic_time(millisecond),
    Duration = EndTime - StartTime,
    
    % Should take time for retries (at least 3 * retry_delay)
    ?assert(Duration > 250), % 3 retries * 100ms + some overhead
    
    ok = gen_server:stop(Pid),
    ok.

retry_backoff(Config) ->
    Opts = #{
        transport_id => test_http_backoff,
        server_id => test_server_backoff,
        url => "http://localhost:99998/mcp", % Non-existent port
        max_retries => 4,
        retry_delay => 50 % Small delay for testing
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    {ok, State} = gen_server:call(Pid, get_state),
    
    StartTime = erlang:monotonic_time(millisecond),
    
    % This should fail with exponential backoff
    {error, _} = erlmcp_transport_http:send(State, <<"test">>),
    
    EndTime = erlang:monotonic_time(millisecond),
    Duration = EndTime - StartTime,
    
    % With exponential backoff: 50ms + 100ms + 200ms + 400ms = 750ms minimum
    ?assert(Duration > 600), % Allow some variance
    
    ok = gen_server:stop(Pid),
    ok.

max_retries_limit(Config) ->
    Opts = #{
        transport_id => test_http_max_retries,
        server_id => test_server_max_retries,
        url => "http://localhost:99997/mcp", % Non-existent port
        max_retries => 2,
        retry_delay => 10
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    {ok, State} = gen_server:call(Pid, get_state),
    
    StartTime = erlang:monotonic_time(millisecond),
    
    % Should fail after exactly max_retries attempts
    {error, _} = erlmcp_transport_http:send(State, <<"test">>),
    
    EndTime = erlang:monotonic_time(millisecond),
    Duration = EndTime - StartTime,
    
    % Should not exceed timeout for max_retries
    ?assert(Duration < 1000), % Should complete relatively quickly
    
    ok = gen_server:stop(Pid),
    ok.

retry_conditions(Config) ->
    ServerPort = ?config(server_port, Config),
    
    % Test which conditions trigger retries
    RetryConditions = [
        {timeout, "http://localhost:99996/mcp"},
        {503, "http://localhost:" ++ integer_to_list(ServerPort) ++ "/status/503"},
        {502, "http://localhost:" ++ integer_to_list(ServerPort) ++ "/status/502"},
        {500, "http://localhost:" ++ integer_to_list(ServerPort) ++ "/status/500"}
    ],
    
    lists:foreach(fun({Condition, Url}) ->
        Opts = #{
            transport_id => list_to_atom("test_http_retry_" ++ atom_to_list(Condition)),
            server_id => list_to_atom("test_server_retry_" ++ atom_to_list(Condition)),
            url => Url,
            max_retries => 1,
            retry_delay => 10
        },
        
        {ok, Pid} = erlmcp_transport_http:start_link(Opts),
        {ok, State} = gen_server:call(Pid, get_state),
        
        % Should trigger retry logic
        {error, _} = erlmcp_transport_http:send(State, <<"test">>),
        
        ok = gen_server:stop(Pid)
    end, RetryConditions),
    ok.

%%====================================================================
%% Test Cases - Error Handling
%%====================================================================

network_errors(Config) ->
    NetworkErrorUrls = [
        "http://nonexistent.example.com/mcp",
        "http://192.0.2.1/mcp", % TEST-NET-1, should fail
        "http://localhost:99995/mcp" % Non-existent port
    ],
    
    lists:foreach(fun(Url) ->
        Opts = #{
            transport_id => test_http_network_error,
            server_id => test_server_network_error,
            url => Url,
            timeout => 1000,
            max_retries => 0 % No retries for this test
        },
        
        {ok, Pid} = erlmcp_transport_http:start_link(Opts),
        {ok, State} = gen_server:call(Pid, get_state),
        
        % Should fail with network error
        {error, _} = erlmcp_transport_http:send(State, <<"test">>),
        
        ok = gen_server:stop(Pid)
    end, NetworkErrorUrls),
    ok.

http_errors(Config) ->
    ServerPort = ?config(server_port, Config),
    
    HttpErrorCodes = [400, 401, 403, 404, 422, 500, 502, 503, 504],
    
    lists:foreach(fun(ErrorCode) ->
        Opts = #{
            transport_id => list_to_atom("test_http_error_" ++ integer_to_list(ErrorCode)),
            server_id => list_to_atom("test_server_error_" ++ integer_to_list(ErrorCode)),
            url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/status/" ++ integer_to_list(ErrorCode),
            max_retries => 0
        },
        
        {ok, Pid} = erlmcp_transport_http:start_link(Opts),
        {ok, State} = gen_server:call(Pid, get_state),
        
        % Should return error for non-2xx status codes
        {error, Reason} = erlmcp_transport_http:send(State, <<"test">>),
        ?assertMatch({http_failed, _}, Reason),
        
        ok = gen_server:stop(Pid)
    end, HttpErrorCodes),
    ok.

timeout_handling(Config) ->
    ServerPort = ?config(server_port, Config),
    
    Opts = #{
        transport_id => test_http_timeout,
        server_id => test_server_timeout,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/slow",
        timeout => 500, % Very short timeout
        max_retries => 0
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    {ok, State} = gen_server:call(Pid, get_state),
    
    StartTime = erlang:monotonic_time(millisecond),
    
    % Should timeout quickly
    {error, Reason} = erlmcp_transport_http:send(State, <<"test">>),
    
    EndTime = erlang:monotonic_time(millisecond),
    Duration = EndTime - StartTime,
    
    ?assertMatch({http_failed, timeout}, Reason),
    ?assert(Duration < 1000), % Should timeout within 1 second
    
    ok = gen_server:stop(Pid),
    ok.

malformed_responses(Config) ->
    ServerPort = ?config(server_port, Config),
    
    % Test handling of various malformed responses
    MalformedEndpoints = [
        "/malformed/invalid-json",
        "/malformed/empty",
        "/malformed/binary-data"
    ],
    
    lists:foreach(fun(Endpoint) ->
        Opts = #{
            transport_id => test_http_malformed,
            server_id => test_server_malformed,
            url => "http://localhost:" ++ integer_to_list(ServerPort) ++ Endpoint,
            max_retries => 0
        },
        
        {ok, Pid} = erlmcp_transport_http:start_link(Opts),
        
        % Should handle malformed responses gracefully
        Result = gen_server:call(Pid, {send, <<"test">>}),
        % May succeed (depending on how server responds) but shouldn't crash
        ?assert(is_process_alive(Pid)),
        
        ok = gen_server:stop(Pid)
    end, MalformedEndpoints),
    ok.

%%====================================================================
%% Test Cases - Performance
%%====================================================================

throughput_test(Config) ->
    ServerPort = ?config(server_port, Config),
    
    Opts = #{
        transport_id => test_http_throughput,
        server_id => test_server_throughput,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/echo",
        timeout => 10000
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    
    % Measure throughput
    RequestCount = 100,
    RequestData = jsx:encode(#{method => <<"test">>, data => binary:copy(<<"x">>, 1024)}),
    
    StartTime = erlang:monotonic_time(millisecond),
    
    lists:foreach(fun(_) ->
        ok = gen_server:call(Pid, {send, RequestData}, 10000)
    end, lists:seq(1, RequestCount)),
    
    EndTime = erlang:monotonic_time(millisecond),
    Duration = EndTime - StartTime,
    RequestsPerSec = (RequestCount * 1000) / Duration,
    
    ct:pal("HTTP throughput: ~.2f requests/sec (~p requests in ~p ms)", 
           [RequestsPerSec, RequestCount, Duration]),
    
    ok = gen_server:stop(Pid),
    ok.

latency_test(Config) ->
    ServerPort = ?config(server_port, Config),
    
    Opts = #{
        transport_id => test_http_latency,
        server_id => test_server_latency,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/echo",
        timeout => 5000
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    
    % Measure latency
    RequestData = jsx:encode(#{method => <<"ping">>}),
    RequestCount = 50,
    
    Latencies = lists:map(fun(_) ->
        StartTime = erlang:monotonic_time(microsecond),
        ok = gen_server:call(Pid, {send, RequestData}),
        EndTime = erlang:monotonic_time(microsecond),
        EndTime - StartTime
    end, lists:seq(1, RequestCount)),
    
    AvgLatency = lists:sum(Latencies) / length(Latencies),
    MaxLatency = lists:max(Latencies),
    MinLatency = lists:min(Latencies),
    
    ct:pal("HTTP latency - Avg: ~.2f ms, Min: ~.2f ms, Max: ~.2f ms", 
           [AvgLatency/1000, MinLatency/1000, MaxLatency/1000]),
    
    ok = gen_server:stop(Pid),
    ok.

concurrent_requests(Config) ->
    ServerPort = ?config(server_port, Config),
    
    % Start multiple HTTP transports
    TransportCount = 10,
    Transports = lists:map(fun(N) ->
        Opts = #{
            transport_id => list_to_atom("test_http_concurrent_" ++ integer_to_list(N)),
            server_id => list_to_atom("test_server_concurrent_" ++ integer_to_list(N)),
            url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/echo"
        },
        {ok, Pid} = erlmcp_transport_http:start_link(Opts),
        Pid
    end, lists:seq(1, TransportCount)),
    
    % Send concurrent requests
    Parent = self(),
    Workers = [spawn(fun() ->
        RequestData = jsx:encode(#{worker => N, data => <<"test">>}),
        ok = gen_server:call(Pid, {send, RequestData}),
        Parent ! {done, N}
    end) || {N, Pid} <- lists:zip(lists:seq(1, TransportCount), Transports)],
    
    StartTime = erlang:monotonic_time(millisecond),
    
    % Wait for all workers
    lists:foreach(fun(N) ->
        receive
            {done, N} -> ok
        after 5000 ->
            ?assert(false, "Concurrent request timed out")
        end
    end, lists:seq(1, TransportCount)),
    
    EndTime = erlang:monotonic_time(millisecond),
    Duration = EndTime - StartTime,
    
    ct:pal("Concurrent requests: ~p transports completed in ~p ms", [TransportCount, Duration]),
    
    % Cleanup
    lists:foreach(fun(Pid) ->
        gen_server:stop(Pid)
    end, Transports),
    
    ok.

memory_usage_test(Config) ->
    ServerPort = ?config(server_port, Config),
    
    Opts = #{
        transport_id => test_http_memory,
        server_id => test_server_memory,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/mcp"
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    timer:sleep(100),
    
    % Measure memory usage
    {memory, Memory} = erlang:process_info(Pid, memory),
    ct:pal("HTTP transport memory usage: ~p bytes", [Memory]),
    
    % Verify reasonable memory usage (< 5MB)
    ?assert(Memory < 5 * 1024 * 1024),
    
    ok = gen_server:stop(Pid),
    ok.

%%====================================================================
%% Test Cases - SSL/TLS
%%====================================================================

https_requests(Config) ->
    % Test basic HTTPS functionality
    Opts = #{
        transport_id => test_https_basic,
        server_id => test_server_https_basic,
        url => "https://httpbin.org/post", % Public HTTPS endpoint
        timeout => 10000,
        max_retries => 1
    },
    
    try
        {ok, Pid} = erlmcp_transport_http:start_link(Opts),
        
        RequestData = jsx:encode(#{test => <<"https_test">>}),
        
        % This may succeed or fail depending on network access
        Result = gen_server:call(Pid, {send, RequestData}, 15000),
        ct:pal("HTTPS request result: ~p", [Result]),
        
        ok = gen_server:stop(Pid)
    catch
        _:Error ->
            ct:pal("HTTPS test failed (expected in some environments): ~p", [Error])
    end,
    ok.

ssl_certificate_validation(Config) ->
    % Test SSL certificate validation options
    SslOptions = [
        [],  % Default SSL options
        [{verify, verify_none}], % No certificate verification
        [{verify, verify_peer}]  % Peer certificate verification
    ],
    
    lists:foreach(fun(SslOpts) ->
        Opts = #{
            transport_id => test_https_ssl_validation,
            server_id => test_server_https_ssl_validation,
            url => "https://httpbin.org/post",
            timeout => 5000,
            max_retries => 0,
            http_options => [{ssl, SslOpts}]
        },
        
        try
            {ok, Pid} = erlmcp_transport_http:start_link(Opts),
            {ok, State} = gen_server:call(Pid, get_state),
            
            % Verify SSL options are configured
            HttpOptions = State#state.http_options,
            ?assert(lists:keymember(ssl, 1, HttpOptions)),
            
            ok = gen_server:stop(Pid)
        catch
            _:Error ->
                ct:pal("SSL validation test failed: ~p", [Error])
        end
    end, SslOptions),
    ok.

ssl_options_test(Config) ->
    % Test various SSL options
    Opts = #{
        transport_id => test_https_ssl_options,
        server_id => test_server_https_ssl_options,
        url => "https://example.com/api",
        http_options => [
            {ssl, [
                {verify, verify_peer},
                {depth, 2},
                {versions, ['tlsv1.2', 'tlsv1.3']}
            ]}
        ]
    },
    
    {ok, State} = erlmcp_transport_http:init_transport(Opts),
    
    % Verify SSL options in HTTP configuration
    HttpOptions = State#state.http_options,
    {ssl, SslOptions} = lists:keyfind(ssl, 1, HttpOptions),
    
    ?assert(lists:member({verify, verify_peer}, SslOptions)),
    ?assert(lists:member({depth, 2}, SslOptions)),
    ?assert(lists:member({versions, ['tlsv1.2', 'tlsv1.3']}, SslOptions)),
    ok.

%%====================================================================
%% Test Cases - Integration
%%====================================================================

end_to_end_communication(Config) ->
    ServerPort = ?config(server_port, Config),
    
    TransportId = test_http_e2e,
    ServerId = test_server_e2e,
    
    % Start mock server
    MockServer = spawn_mock_server(ServerId),
    
    Opts = #{
        transport_id => TransportId,
        server_id => ServerId,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/echo"
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    timer:sleep(100),
    
    % Send complete MCP message
    MCPRequest = jsx:encode(#{
        jsonrpc => <<"2.0">>,
        method => <<"initialize">>,
        params => #{
            protocolVersion => <<"2024-11-05">>,
            capabilities => #{
                roots => #{
                    listChanged => true
                }
            },
            clientInfo => #{
                name => <<"test-client">>,
                version => <<"1.0.0">>
            }
        },
        id => 1
    }),
    
    ?assertEqual(ok, gen_server:call(Pid, {send, MCPRequest})),
    
    % Verify mock server receives processed response
    receive
        {mock_server, ServerId, Response} ->
            ct:pal("E2E response received: ~p", [Response])
    after 2000 ->
        ?assert(false, "E2E response not received")
    end,
    
    cleanup_mock_server(MockServer),
    ok = gen_server:stop(Pid),
    ok.

load_testing(Config) ->
    ServerPort = ?config(server_port, Config),
    
    % Create multiple transports and send many requests
    TransportCount = 5,
    RequestsPerTransport = 20,
    
    Parent = self(),
    Transports = [spawn(fun() ->
        Opts = #{
            transport_id => list_to_atom("test_http_load_" ++ integer_to_list(N)),
            server_id => list_to_atom("test_server_load_" ++ integer_to_list(N)),
            url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/echo"
        },
        
        {ok, Pid} = erlmcp_transport_http:start_link(Opts),
        
        % Send multiple requests
        lists:foreach(fun(M) ->
            RequestData = jsx:encode(#{transport => N, request => M}),
            ok = gen_server:call(Pid, {send, RequestData}, 10000)
        end, lists:seq(1, RequestsPerTransport)),
        
        ok = gen_server:stop(Pid),
        Parent ! {transport_done, N}
    end) || N <- lists:seq(1, TransportCount)],
    
    StartTime = erlang:monotonic_time(millisecond),
    
    % Wait for all transports to complete
    lists:foreach(fun(N) ->
        receive
            {transport_done, N} -> ok
        after 30000 ->
            ?assert(false, "Load test transport timed out")
        end
    end, lists:seq(1, TransportCount)),
    
    EndTime = erlang:monotonic_time(millisecond),
    Duration = EndTime - StartTime,
    TotalRequests = TransportCount * RequestsPerTransport,
    RequestRate = (TotalRequests * 1000) / Duration,
    
    ct:pal("Load test: ~p requests (~p transports x ~p requests) in ~p ms (~.2f req/sec)", 
           [TotalRequests, TransportCount, RequestsPerTransport, Duration, RequestRate]),
    
    ok.

stress_testing(Config) ->
    ServerPort = ?config(server_port, Config),
    
    Opts = #{
        transport_id => test_http_stress,
        server_id => test_server_stress,
        url => "http://localhost:" ++ integer_to_list(ServerPort) ++ "/echo",
        timeout => 5000
    },
    
    {ok, Pid} = erlmcp_transport_http:start_link(Opts),
    
    % Stress test with rapid concurrent requests
    WorkerCount = 10,
    RequestsPerWorker = 50,
    
    Parent = self(),
    Workers = [spawn(fun() ->
        lists:foreach(fun(M) ->
            RequestData = jsx:encode(#{worker => N, request => M, data => binary:copy(<<"x">>, 100)}),
            
            case gen_server:call(Pid, {send, RequestData}, 10000) of
                ok -> ok;
                {error, _} -> ok % Some failures are acceptable under stress
            end
        end, lists:seq(1, RequestsPerWorker)),
        Parent ! {worker_done, N}
    end) || N <- lists:seq(1, WorkerCount)],
    
    StartTime = erlang:monotonic_time(millisecond),
    
    % Wait for all workers
    lists:foreach(fun(N) ->
        receive
            {worker_done, N} -> ok
        after 30000 ->
            ?assert(false, "Stress test worker timed out")
        end
    end, lists:seq(1, WorkerCount)),
    
    EndTime = erlang:monotonic_time(millisecond),
    Duration = EndTime - StartTime,
    TotalRequests = WorkerCount * RequestsPerWorker,
    
    ct:pal("Stress test: ~p requests in ~p ms with ~p workers", 
           [TotalRequests, Duration, WorkerCount]),
    
    % Transport should survive stress test
    ?assert(is_process_alive(Pid)),
    
    ok = gen_server:stop(Pid),
    ok.

%%====================================================================
%% Helper Functions
%%====================================================================

cleanup_processes() ->
    % Cleanup any test processes
    TestProcesses = [test_server_e2e],
    lists:foreach(fun(Name) ->
        case whereis(Name) of
            undefined -> ok;
            Pid -> exit(Pid, kill)
        end
    end, TestProcesses).

%% Mock HTTP server for testing
start_mock_http_server() ->
    spawn(fun() ->
        {ok, _} = inets:start(httpd, [
            {port, 0},
            {server_name, "mock_http_server"},
            {server_root, "/tmp"},
            {document_root, "/tmp"},
            {modules, [mod_esi]},
            {erl_script_alias, {"/", [mock_http_server]}}
        ]),
        receive
            stop -> ok
        end
    end).

get_mock_server_port(ServerPid) ->
    % For testing purposes, use a fixed port
    % In real implementation, you'd get the actual port from the server
    8080.

stop_mock_http_server(ServerPid) ->
    ServerPid ! stop.

%% Mock server for registry testing
spawn_mock_server(ServerId) ->
    Parent = self(),
    Pid = spawn(fun() ->
        register(ServerId, self()),
        Config = #{capabilities => #{}, options => #{}},
        erlmcp_registry:register_server(ServerId, self(), Config),
        mock_server_loop(Parent, ServerId)
    end),
    Pid.

mock_server_loop(Parent, ServerId) ->
    receive
        {route_message, _TransportId, Message} ->
            Parent ! {mock_server, ServerId, Message},
            mock_server_loop(Parent, ServerId);
        stop ->
            erlmcp_registry:unregister_server(ServerId)
    end.

cleanup_mock_server(Pid) ->
    Pid ! stop,
    timer:sleep(50).