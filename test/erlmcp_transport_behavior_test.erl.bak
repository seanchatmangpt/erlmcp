%%%-------------------------------------------------------------------
%%% @doc
%%% Transport Behavior Compliance Tests
%%%
%%% This module provides standardized compliance tests for all transport
%%% implementations to ensure they properly implement the erlmcp_transport
%%% behavior interface. All transport modules must pass these tests.
%%%
%%% Test Categories:
%%% - Behavior callback compliance
%%% - Registry integration requirements
%%% - Message routing standards
%%% - Error handling contracts
%%% - Performance requirements
%%%-------------------------------------------------------------------
-module(erlmcp_transport_behavior_test).

-include_lib("eunit/include/eunit.hrl").
-include("../src/erlmcp.hrl").

%% Test configuration
-define(TEST_TIMEOUT, 5000).
-define(PERFORMANCE_MESSAGE_COUNT, 1000).
-define(MAX_LATENCY_MS, 100).
-define(MIN_THROUGHPUT_MSG_PER_SEC, 100).

%% =============================================================================
%% Test Suite Entry Point
%% =============================================================================

%% @doc Run all behavior compliance tests for a given transport module
%% @param Module Transport module to test
%% @param InitOpts Initialization options for the transport
-spec test_transport_behavior(module(), map()) -> ok | {error, term()}.
test_transport_behavior(Module, InitOpts) ->
    Tests = [
        fun() -> test_behavior_exports(Module) end,
        fun() -> test_init_callback(Module, InitOpts) end,
        fun() -> test_send_callback(Module, InitOpts) end,
        fun() -> test_close_callback(Module, InitOpts) end,
        fun() -> test_optional_callbacks(Module, InitOpts) end,
        fun() -> test_message_validation(Module, InitOpts) end,
        fun() -> test_error_handling(Module, InitOpts) end,
        fun() -> test_performance_requirements(Module, InitOpts) end,
        fun() -> test_concurrent_access(Module, InitOpts) end,
        fun() -> test_resource_cleanup(Module, InitOpts) end
    ],
    
    Results = [catch Test() || Test <- Tests],
    case [Error || Error <- Results, element(1, Error) =:= error] of
        [] -> ok;
        Errors -> {error, {compliance_failures, Errors}}
    end.

%% =============================================================================
%% Individual Test Functions
%% =============================================================================

%% @doc Test that module exports all required behavior callbacks
test_behavior_exports(Module) ->
    RequiredExports = [
        {init, 1},
        {send, 2}, 
        {close, 1}
    ],
    
    OptionalExports = [
        {get_info, 1},
        {handle_transport_call, 2}
    ],
    
    ModuleExports = Module:module_info(exports),
    
    %% Check required exports
    lists:foreach(fun(Export) ->
        ?assert(lists:member(Export, ModuleExports)),
        ?debugFmt("Required export ~p:~p/~p found", [Module, element(1, Export), element(2, Export)])
    end, RequiredExports),
    
    %% Check optional exports (just log if present)
    lists:foreach(fun(Export) ->
        case lists:member(Export, ModuleExports) of
            true -> ?debugFmt("Optional export ~p:~p/~p found", [Module, element(1, Export), element(2, Export)]);
            false -> ?debugFmt("Optional export ~p:~p/~p not implemented", [Module, element(1, Export), element(2, Export)])
        end
    end, OptionalExports),
    
    ok.

%% @doc Test init callback compliance
test_init_callback(Module, InitOpts) ->
    %% Test successful initialization
    case Module:init(InitOpts) of
        {ok, State} ->
            ?assert(State =/= undefined),
            ?debugFmt("~p:init/1 succeeded with state type: ~p", [Module, element(1, State)]);
        {error, Reason} ->
            ?debugFmt("~p:init/1 failed with reason: ~p", [Module, Reason]),
            throw({init_failed, Reason})
    end,
    
    %% Test with invalid options
    InvalidOpts = #{invalid_option => invalid_value},
    case Module:init(InvalidOpts) of
        {ok, _} ->
            ?debugFmt("Warning: ~p:init/1 accepts invalid options", [Module]);
        {error, _} ->
            ?debugFmt("~p:init/1 properly rejects invalid options", [Module])
    end,
    
    ok.

%% @doc Test send callback compliance  
test_send_callback(Module, InitOpts) ->
    {ok, State} = Module:init(InitOpts),
    
    %% Test different data types
    TestData = [
        <<"binary message">>,
        "string message",
        [<<"iodata">>, " ", <<"message">>],
        []  % empty iodata
    ],
    
    lists:foreach(fun(Data) ->
        case Module:send(State, Data) of
            ok ->
                ?debugFmt("~p:send/2 succeeded for data type: ~p", [Module, typeof(Data)]);
            {error, Reason} ->
                ?debugFmt("~p:send/2 failed for data type ~p: ~p", [Module, typeof(Data), Reason])
        end
    end, TestData),
    
    %% Test invalid data
    InvalidData = [undefined, atom, {tuple}, #{map => value}],
    lists:foreach(fun(Data) ->
        case Module:send(State, Data) of
            ok ->
                ?debugFmt("Warning: ~p:send/2 accepts invalid data: ~p", [Module, Data]);
            {error, _Reason} ->
                ?debugFmt("~p:send/2 properly rejects invalid data: ~p", [Module, Data])
        end
    end, InvalidData),
    
    ok.

%% @doc Test close callback compliance
test_close_callback(Module, InitOpts) ->
    {ok, State} = Module:init(InitOpts),
    
    %% Close should always succeed
    Result = Module:close(State),
    ?assertEqual(ok, Result),
    ?debugFmt("~p:close/1 succeeded", [Module]),
    
    %% Test multiple close calls (should be idempotent)
    Result2 = Module:close(State),
    ?assertEqual(ok, Result2),
    ?debugFmt("~p:close/1 is idempotent", [Module]),
    
    ok.

%% @doc Test optional callbacks if implemented
test_optional_callbacks(Module, InitOpts) ->
    {ok, State} = Module:init(InitOpts),
    
    %% Test get_info if implemented
    case erlang:function_exported(Module, get_info, 1) of
        true ->
            Info = Module:get_info(State),
            ?assert(is_map(Info)),
            ?assert(maps:is_key(type, Info)),
            ?debugFmt("~p:get_info/1 returned: ~p", [Module, maps:keys(Info)]);
        false ->
            ?debugFmt("~p:get_info/1 not implemented", [Module])
    end,
    
    %% Test handle_transport_call if implemented
    case erlang:function_exported(Module, handle_transport_call, 2) of
        true ->
            case Module:handle_transport_call(test_request, State) of
                {reply, Reply, NewState} ->
                    ?debugFmt("~p:handle_transport_call/2 replied: ~p", [Module, Reply]);
                {error, Reason} ->
                    ?debugFmt("~p:handle_transport_call/2 error: ~p", [Module, Reason])
            end;
        false ->
            ?debugFmt("~p:handle_transport_call/2 not implemented", [Module])
    end,
    
    ok.

%% @doc Test message validation using transport utilities
test_message_validation(Module, InitOpts) ->
    {ok, State} = Module:init(InitOpts),
    
    %% Valid JSON-RPC messages
    ValidMessages = [
        erlmcp_transport:create_message(<<"test.method">>, #{}, <<"test-id">>),
        erlmcp_transport:create_notification(<<"test.notification">>, []),
        erlmcp_transport:create_response(<<"test-id">>, #{result => success}),
        erlmcp_transport:create_error_response(<<"test-id">>, -32600, <<"Invalid Request">>, undefined)
    ],
    
    lists:foreach(fun(Message) ->
        ?assertEqual(ok, erlmcp_transport:validate_message(Message)),
        EncodedMessage = jsx:encode(Message),
        case Module:send(State, EncodedMessage) of
            ok -> 
                ?debugFmt("~p:send/2 accepted valid message", [Module]);
            {error, Reason} ->
                ?debugFmt("~p:send/2 rejected valid message: ~p", [Module, Reason])
        end
    end, ValidMessages),
    
    %% Invalid messages
    InvalidMessages = [
        #{},  % no jsonrpc field
        #{<<"jsonrpc">> => <<"1.0">>},  % wrong version
        #{<<"jsonrpc">> => <<"2.0">>},  % no method/result/error
        not_a_map
    ],
    
    lists:foreach(fun(Message) ->
        ?assertMatch({error, _}, erlmcp_transport:validate_message(Message))
    end, InvalidMessages),
    
    ok.

%% @doc Test error handling requirements
test_error_handling(Module, InitOpts) ->
    %% Test graceful handling of errors
    {ok, State} = Module:init(InitOpts),
    
    %% Send should handle errors gracefully
    case Module:send(State, undefined) of
        ok -> 
            ?debugFmt("Warning: ~p:send/2 accepts undefined data", [Module]);
        {error, Reason} ->
            ?assert(is_atom(Reason) orelse is_tuple(Reason)),
            ?debugFmt("~p:send/2 properly handles undefined data: ~p", [Module, Reason])
    end,
    
    %% Test with corrupted state (if possible to detect)
    CorruptedState = corrupted_state,
    case Module:send(CorruptedState, <<"test">>) of
        ok ->
            ?debugFmt("Warning: ~p:send/2 doesn't validate state", [Module]);
        {error, _Reason} ->
            ?debugFmt("~p:send/2 properly handles corrupted state", [Module])
    end,
    
    ok.

%% @doc Test performance requirements
test_performance_requirements(Module, InitOpts) ->
    {ok, State} = Module:init(InitOpts),
    
    %% Throughput test
    TestMessage = <<"performance test message">>,
    StartTime = erlang:monotonic_time(millisecond),
    
    lists:foreach(fun(_) ->
        Module:send(State, TestMessage)
    end, lists:seq(1, ?PERFORMANCE_MESSAGE_COUNT)),
    
    EndTime = erlang:monotonic_time(millisecond),
    Duration = EndTime - StartTime,
    Throughput = round(?PERFORMANCE_MESSAGE_COUNT * 1000 / Duration),
    
    ?debugFmt("~p throughput: ~p msgs/sec", [Module, Throughput]),
    ?assert(Throughput >= ?MIN_THROUGHPUT_MSG_PER_SEC),
    
    %% Latency test
    Latencies = lists:map(fun(_) ->
        Start = erlang:monotonic_time(microsecond),
        Module:send(State, TestMessage),
        End = erlang:monotonic_time(microsecond),
        (End - Start) / 1000  % Convert to milliseconds
    end, lists:seq(1, 100)),
    
    AvgLatency = lists:sum(Latencies) / length(Latencies),
    MaxLatency = lists:max(Latencies),
    
    ?debugFmt("~p latency - Avg: ~.2f ms, Max: ~.2f ms", [Module, AvgLatency, MaxLatency]),
    ?assert(AvgLatency =< ?MAX_LATENCY_MS),
    ?assert(MaxLatency =< ?MAX_LATENCY_MS * 2),  % Allow 2x max for outliers
    
    ok.

%% @doc Test concurrent access safety
test_concurrent_access(Module, InitOpts) ->
    {ok, State} = Module:init(InitOpts),
    
    NumProcesses = 10,
    OperationsPerProcess = 100,
    
    Parent = self(),
    Processes = [spawn(fun() ->
        lists:foreach(fun(N) ->
            Message = iolist_to_binary([<<"concurrent_test_">>, integer_to_list(N)]),
            Module:send(State, Message)
        end, lists:seq(1, OperationsPerProcess)),
        Parent ! {done, self()}
    end) || _ <- lists:seq(1, NumProcesses)],
    
    %% Wait for all processes to complete
    lists:foreach(fun(Pid) ->
        receive
            {done, Pid} -> ok
        after ?TEST_TIMEOUT ->
            throw({concurrent_test_timeout, Pid})
        end
    end, Processes),
    
    ?debugFmt("~p passed concurrent access test", [Module]),
    ok.

%% @doc Test proper resource cleanup
test_resource_cleanup(Module, InitOpts) ->
    InitialProcessCount = length(processes()),
    InitialPortCount = length(ports()),
    
    %% Create and destroy multiple transport instances
    States = [begin
        {ok, State} = Module:init(InitOpts),
        State
    end || _ <- lists:seq(1, 10)],
    
    %% Close all transports
    lists:foreach(fun(State) ->
        ok = Module:close(State)
    end, States),
    
    %% Allow some time for cleanup
    timer:sleep(100),
    
    FinalProcessCount = length(processes()),
    FinalPortCount = length(ports()),
    
    %% Check for resource leaks
    ProcessLeak = FinalProcessCount - InitialProcessCount,
    PortLeak = FinalPortCount - InitialPortCount,
    
    ?debugFmt("~p resource usage - Process delta: ~p, Port delta: ~p", 
              [Module, ProcessLeak, PortLeak]),
    
    %% Allow small variations but detect major leaks
    ?assert(abs(ProcessLeak) =< 2),
    ?assert(abs(PortLeak) =< 2),
    
    ok.

%% =============================================================================
%% Registry Integration Tests
%% =============================================================================

%% @doc Test registry integration requirements for transport modules
%% These tests verify that transports properly integrate with erlmcp_registry
test_registry_integration(Module, InitOpts, TransportId) ->
    %% Ensure registry is available
    case whereis(erlmcp_registry) of
        undefined ->
            {ok, _} = erlmcp_registry:start_link();
        _ ->
            ok
    end,
    
    %% Test registration
    {ok, State} = Module:init(InitOpts#{transport_id => TransportId}),
    timer:sleep(100),  % Allow registration to complete
    
    case erlmcp_registry:find_transport(TransportId) of
        {ok, {Pid, Config}} ->
            ?assert(is_pid(Pid)),
            ?assert(is_map(Config)),
            ?debugFmt("Transport ~p registered successfully", [TransportId]);
        {error, not_found} ->
            ?debugFmt("Warning: Transport ~p not registered with registry", [TransportId])
    end,
    
    %% Test message routing (if applicable)
    TestMessage = <<"registry integration test">>,
    case Module:send(State, TestMessage) of
        ok -> 
            ?debugFmt("Message sent successfully for registry test");
        {error, Reason} ->
            ?debugFmt("Message send failed: ~p", [Reason])
    end,
    
    %% Cleanup
    ok = Module:close(State),
    timer:sleep(100),
    
    %% Verify unregistration
    case erlmcp_registry:find_transport(TransportId) of
        {error, not_found} ->
            ?debugFmt("Transport ~p properly unregistered", [TransportId]);
        {ok, _} ->
            ?debugFmt("Warning: Transport ~p still registered after close", [TransportId])
    end,
    
    ok.

%% =============================================================================
%% Utility Functions
%% =============================================================================

%% @doc Get the type of a term for debugging
typeof(Term) when is_binary(Term) -> binary;
typeof(Term) when is_list(Term) -> list;
typeof(Term) when is_atom(Term) -> atom;
typeof(Term) when is_tuple(Term) -> tuple;
typeof(Term) when is_map(Term) -> map;
typeof(Term) when is_pid(Term) -> pid;
typeof(_) -> unknown.

%% =============================================================================
%% EUnit Test Wrappers
%% =============================================================================

%% EUnit test generator for stdio transport
stdio_behavior_test_() ->
    {setup,
     fun() ->
         InitOpts = #{test_mode => true},
         {erlmcp_transport_stdio_new, InitOpts}
     end,
     fun(_) -> ok end,
     fun({Module, InitOpts}) ->
         [?_assertEqual(ok, test_transport_behavior(Module, InitOpts))]
     end}.

%% EUnit test generator for TCP transport  
tcp_behavior_test_() ->
    {setup,
     fun() ->
         InitOpts = #{
             host => "127.0.0.1",
             port => 8080,
             owner => self(),
             test_mode => true
         },
         {erlmcp_transport_tcp, InitOpts}
     end,
     fun(_) -> ok end,
     fun({Module, InitOpts}) ->
         [?_assertEqual(ok, test_transport_behavior(Module, InitOpts))]
     end}.

%% EUnit test generator for HTTP transport
http_behavior_test_() ->
    {setup,
     fun() ->
         InitOpts = #{
             url => "http://localhost:8080/mcp",
             owner => self(),
             test_mode => true
         },
         {erlmcp_transport_http, InitOpts}
     end,
     fun(_) -> ok end,
     fun({Module, InitOpts}) ->
         [?_assertEqual(ok, test_transport_behavior(Module, InitOpts))]
     end}.