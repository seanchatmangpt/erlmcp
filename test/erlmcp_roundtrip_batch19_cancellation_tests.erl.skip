-module(erlmcp_roundtrip_batch19_cancellation_tests).
-include_lib("eunit/include/eunit.hrl").
-include_lib("erlmcp_core/include/erlmcp.hrl").

%%====================================================================
%% Chicago School TDD - MCP Operation Cancellation Tests (Batch 19)
%% Real servers, real clients, real TCP connections, state-based verification
%% Tests: 5 servers (ports 9091-9095), 5 clients per server
%% Focus: Long-running operation cancellation, latency measurement, resource cleanup
%% Total: 25 clients, 50 cancellations + 50 completions per client (2500 ops)
%%====================================================================

%%====================================================================
%% Test Configuration
%%====================================================================

-define(BATCH_ID, 19).
-define(SERVER_COUNT, 5).
-define(CLIENTS_PER_SERVER, 5).
-define(CANCELLATIONS_PER_CLIENT, 50).
-define(COMPLETIONS_PER_CLIENT, 50).
-define(OPERATIONS_PER_CLIENT, ?CANCELLATIONS_PER_CLIENT + ?COMPLETIONS_PER_CLIENT).
-define(TOTAL_CLIENTS, ?SERVER_COUNT * ?CLIENTS_PER_SERVER).
-define(TOTAL_CANCELLATIONS, ?TOTAL_CLIENTS * ?CANCELLATIONS_PER_CLIENT).
-define(TOTAL_COMPLETIONS, ?TOTAL_CLIENTS * ?COMPLETIONS_PER_CLIENT).
-define(TOTAL_OPERATIONS, ?TOTAL_CLIENTS * ?OPERATIONS_PER_CLIENT).
-define(BASE_PORT, 9091).
-define(TIMEOUT, 15000).
-define(LONG_OPERATION_DURATION, 5000). %% 5 seconds
-define(CANCEL_DELAY, 100). %% Cancel after 100ms

%%====================================================================
%% Main Test Suite - Batch 19 Cancellation
%%====================================================================

mcp_roundtrip_batch19_cancellation_test_() ->
    {setup,
     fun setup_batch19/0,
     fun cleanup_batch19/1,
     fun(_Ctx) ->
         [
          ?_test(test_spawn_servers()),
          ?_test(test_spawn_clients()),
          ?_test(test_long_running_tools()),
          ?_test(test_immediate_cancellation()),
          ?_test(test_delayed_cancellation()),
          ?_test(test_cancellation_latency()),
          ?_test(test_completion_after_cancel()),
          ?_test(test_resource_cleanup()),
          ?_test(test_concurrent_cancellations()),
          ?_test(test_cancellation_statistics())
         ]
     end}.

%%====================================================================
%% Setup and Cleanup - Chicago School: Real Application Startup
%%====================================================================

setup_batch19() ->
    %% Start real application with all dependencies
    application:ensure_all_started(gproc),
    application:ensure_all_started(erlmcp_core),
    application:ensure_all_started(erlmcp_transports),

    %% Create server configuration context
    #{
        batch_id => ?BATCH_ID,
        base_port => ?BASE_PORT,
        servers => [],
        clients => [],
        results => #{
            cancellations => [],
            completions => [],
            latencies => [],
            errors => []
        }
    }.

cleanup_batch19(#{servers := Servers, clients := Clients}) ->
    %% Cleanup all clients first (reverse dependency order)
    lists:foreach(
        fun(#{pid := Pid}) ->
            case is_process_alive(Pid) of
                true -> erlmcp_client:stop(Pid);
                false -> ok
            end
        end,
        Clients
    ),

    %% Cleanup all servers
    lists:foreach(
        fun(#{pid := Pid}) ->
            case is_process_alive(Pid) of
                true -> erlmcp_server:stop(Pid);
                false -> ok
            end
        end,
        Servers
    ),

    %% Allow graceful shutdown
    timer:sleep(500),

    %% Stop applications
    application:stop(erlmcp_transports),
    application:stop(erlmcp_core),
    application:stop(gproc),

    ok.

%%====================================================================
%% Test Case 1: Spawn 5 Servers (Chicago School: Real gen_servers)
%%====================================================================

test_spawn_servers() ->
    ServersSpawned = spawn_servers(?BASE_PORT, ?SERVER_COUNT, []),

    %% Verify: All servers spawned successfully (state-based)
    ?assertEqual(?SERVER_COUNT, length(ServersSpawned)),

    %% Verify: All server PIDs are alive (observable behavior)
    AliveServers = lists:filter(
        fun(#{pid := Pid}) -> is_process_alive(Pid) end,
        ServersSpawned
    ),
    ?assertEqual(?SERVER_COUNT, length(AliveServers)),

    %% Verify: Each server has unique port (no conflicts)
    Ports = [Port || #{port := Port} <- ServersSpawned],
    UniquePorts = lists:usort(Ports),
    ?assertEqual(?SERVER_COUNT, length(UniquePorts)),

    %% Store servers in process dictionary for subsequent tests
    put(servers, ServersSpawned),

    io:format("~n=== Batch ~p: Servers Spawned ===~n", [?BATCH_ID]),
    lists:foreach(
        fun(#{server_id := Id, port := Port}) ->
            io:format("  Server ~p on port ~p~n", [Id, Port])
        end,
        ServersSpawned
    ).

spawn_servers(_Port, 0, Acc) ->
    lists:reverse(Acc);
spawn_servers(Port, Count, Acc) ->
    ServerId = list_to_atom("mcp_server_" ++ integer_to_list(Port)),

    %% Create server capabilities
    Capabilities = #mcp_server_capabilities{
        resources = #mcp_capability{enabled = false},
        tools = #mcp_capability{enabled = true},
        prompts = #mcp_capability{enabled = false}
    },

    %% Spawn real server (Chicago School: no mocks)
    case erlmcp_server:start_link(ServerId, Capabilities) of
        {ok, ServerPid} ->
            %% Add long-running tools (simulating expensive operations)
            add_long_running_tools(ServerPid),

            ServerInfo = #{
                server_id => ServerId,
                pid => ServerPid,
                port => Port,
                transport => tcp
            },
            spawn_servers(Port + 1, Count - 1, [ServerInfo | Acc]);
        {error, Reason} ->
            io:format("  Failed to spawn server on port ~p: ~p~n", [Port, Reason]),
            spawn_servers(Port + 1, Count - 1, Acc)
    end.

%%====================================================================
%% Test Case 2: Spawn 25 Clients (5 per server)
%%====================================================================

test_spawn_clients() ->
    Servers = get(servers),
    AllClients = spawn_clients_for_servers(Servers, ?CLIENTS_PER_SERVER, []),

    %% Verify: All clients spawned successfully
    ExpectedClients = ?TOTAL_CLIENTS,
    ?assertEqual(ExpectedClients, length(AllClients)),

    %% Verify: All client PIDs are alive
    AliveClients = lists:filter(
        fun(#{pid := Pid}) -> is_process_alive(Pid) end,
        AllClients
    ),
    ?assertEqual(ExpectedClients, length(AliveClients)),

    %% Store clients for subsequent tests
    put(clients, AllClients),

    io:format("~n=== Batch ~p: Clients Spawned ===~n", [?BATCH_ID]),
    io:format("  Total clients: ~p~n", [length(AllClients)]),
    lists:foreach(
        fun(#{server_id := ServerId, client_id := ClientId}) ->
            io:format("  Client ~p connected to ~p~n", [ClientId, ServerId])
        end,
        lists:sublist(AllClients, 5)
    ),
    io:format("  ... (~p more clients)~n", [length(AllClients) - 5]).

spawn_clients_for_servers([], _Count, Acc) ->
    lists:reverse(Acc);
spawn_clients_for_servers([Server | Rest], Count, Acc) ->
    ServerClients = spawn_clients_for_server(Server, Count, []),
    spawn_clients_for_servers(Rest, Count, ServerClients ++ Acc).

spawn_clients_for_server(_Server, 0, Acc) ->
    lists:reverse(Acc);
spawn_clients_for_server(#{server_id := ServerId, port := Port} = Server, Count, Acc) ->
    ClientId = list_to_atom(
        "mcp_client_" ++ integer_to_list(Port) ++ "_" ++ integer_to_list(Count)
    ),

    %% Create client with TCP transport (real connection)
    TransportOpts = {tcp, #{
        host => "localhost",
        port => Port,
        timeout => 5000
    }},

    case erlmcp_client:start_link(TransportOpts) of
        {ok, ClientPid} ->
            %% Initialize client
            ClientCapabilities = #mcp_client_capabilities{
                roots = #mcp_capability{enabled = false},
                sampling = #mcp_capability{enabled = false}
            },
            case erlmcp_client:initialize(ClientPid, ClientCapabilities) of
                {ok, _ServerInfo} ->
                    ClientInfo = #{
                        client_id => ClientId,
                        pid => ClientPid,
                        server_id => ServerId,
                        port => Port,
                        transport => tcp
                    },
                    spawn_clients_for_server(Server, Count - 1, [ClientInfo | Acc]);
                {error, _InitReason} ->
                    %% Client spawned but initialization failed
                    erlmcp_client:stop(ClientPid),
                    spawn_clients_for_server(Server, Count - 1, Acc)
            end;
        {error, Reason} ->
            io:format("  Failed to spawn client ~p: ~p~n", [ClientId, Reason]),
            spawn_clients_for_server(Server, Count - 1, Acc)
    end.

%%====================================================================
%% Test Case 3: Long-Running Tools (Baseline Performance)
%%====================================================================

test_long_running_tools() ->
    Clients = get(clients),
    {SuccessCount, Latencies} = run_long_running_operations(Clients, 5),

    %% Verify: All operations completed successfully
    ExpectedOps = ?TOTAL_CLIENTS * 5,
    ?assertEqual(ExpectedOps, SuccessCount),

    %% Verify: Operations take expected time (~5 seconds)
    AvgDuration = calculate_average(Latencies),
    ?assert(AvgDuration > ?LONG_OPERATION_DURATION - 1000),
    ?assert(AvgDuration < ?LONG_OPERATION_DURATION + 1000),

    put(long_running_latencies, Latencies),

    io:format("~n=== Batch ~p: Long-Running Tools (Baseline) ===~n", [?BATCH_ID]),
    io:format("  Operations: ~p/~p~n", [SuccessCount, ExpectedOps]),
    io:format("  Avg duration: ~.2f ms~n", [AvgDuration / 1000]).

run_long_running_operations(Clients, OpsPerClient) ->
    run_long_running_operations(Clients, OpsPerClient, 0, []).

run_long_running_operations([], _OpsPerClient, SuccessAcc, LatencyAcc) ->
    {SuccessAcc, lists:reverse(LatencyAcc)};
run_long_running_operations([#{pid := ClientPid} | Rest], OpsPerClient, SuccessAcc, LatencyAcc) ->
    {Success, Latencies} = run_client_long_ops(ClientPid, OpsPerClient, [], []),
    run_long_running_operations(
        Rest,
        OpsPerClient,
        SuccessAcc + Success,
        Latencies ++ LatencyAcc
    ).

run_client_long_ops(_ClientPid, 0, SuccessAcc, LatencyAcc) ->
    {SuccessAcc, lists:reverse(LatencyAcc)};
run_client_long_ops(ClientPid, Count, SuccessAcc, LatencyAcc) ->
    %% Start long operation and measure time
    StartTime = erlang:monotonic_time(microsecond),

    Args = #{
        duration => ?LONG_OPERATION_DURATION,
        step => 100
    },

    Result = erlmcp_client:call_tool(ClientPid, <<"long_operation">>, Args),

    EndTime = erlang:monotonic_time(microsecond),
    Duration = EndTime - StartTime,

    case Result of
        {ok, _ToolResult} ->
            run_client_long_ops(ClientPid, Count - 1, SuccessAcc + 1, [Duration | LatencyAcc]);
        {error, Reason} ->
            io:format("  Long operation failed: ~p~n", [Reason]),
            run_client_long_ops(ClientPid, Count - 1, SuccessAcc, LatencyAcc)
    end.

%%====================================================================
%% Test Case 4: Immediate Cancellation
%%====================================================================

test_immediate_cancellation() ->
    Clients = get(clients),
    {CancelledCount, TotalAttempts} = run_immediate_cancellations(Clients, 10),

    %% Verify: High cancellation success rate
    CancelRate = case TotalAttempts of
        0 -> 0.0;
        _ -> (CancelledCount / TotalAttempts) * 100
    end,
    ?assert(CancelRate >= 80.0),

    put(immediate_cancel_count, CancelledCount),
    put(immediate_cancel_attempts, TotalAttempts),

    io:format("~n=== Batch ~p: Immediate Cancellation ===~n", [?BATCH_ID]),
    io:format("  Cancelled: ~p/~p (~.2f%)~n", [CancelledCount, TotalAttempts, CancelRate]).

run_immediate_cancellations(Clients, CancelsPerClient) ->
    run_immediate_cancellations(Clients, CancelsPerClient, 0, 0).

run_immediate_cancellations([], _CancelsPerClient, CancelledAcc, AttemptsAcc) ->
    {CancelledAcc, AttemptsAcc};
run_immediate_cancellations([#{pid := ClientPid} | Rest], CancelsPerClient, CancelledAcc, AttemptsAcc) ->
    {Cancelled, Attempts} = run_client_immediate_cancels(ClientPid, CancelsPerClient, 0, 0),
    run_immediate_cancellations(
        Rest,
        CancelsPerClient,
        CancelledAcc + Cancelled,
        AttemptsAcc + Attempts
    ).

run_client_immediate_cancels(_ClientPid, 0, CancelledAcc, AttemptsAcc) ->
    {CancelledAcc, AttemptsAcc};
run_client_immediate_cancels(ClientPid, Count, CancelledAcc, AttemptsAcc) ->
    %% Start long operation
    Args = #{duration => ?LONG_OPERATION_DURATION, step => 100},

    %% Spawn operation in background
    Parent = self(),
    OpPid = spawn(fun() ->
        Result = erlmcp_client:call_tool(ClientPid, <<"long_operation">>, Args),
        Parent ! {op_result, self(), Result}
    end),

    %% Cancel immediately
    timer:sleep(10),
    case is_process_alive(OpPid) of
        true ->
            exit(OpPid, kill),
            timer:sleep(50);
        false ->
            ok
    end,

    %% Verify operation was cancelled
    Cancelled = receive
        {op_result, OpPid, _Result} ->
            false;
        _Other ->
            false
        after 500 ->
            true
    end,

    NewCancelledAcc = case Cancelled of
        true -> CancelledAcc + 1;
        false -> CancelledAcc
    end,

    run_client_immediate_cancels(
        ClientPid,
        Count - 1,
        NewCancelledAcc,
        AttemptsAcc + 1
    ).

%%====================================================================
%% Test Case 5: Delayed Cancellation
%%====================================================================

test_delayed_cancellation() ->
    Clients = get(clients),
    {CancelledCount, TotalAttempts, Latencies} = run_delayed_cancellations(Clients, 10),

    %% Verify: Cancellation happens reasonably quickly
    AvgCancelLatency = case Latencies of
        [] -> 0;
        _ -> calculate_average(Latencies)
    end,

    put(delayed_cancel_count, CancelledCount),
    put(delayed_cancel_latencies, Latencies),

    io:format("~n=== Batch ~p: Delayed Cancellation ===~n", [?BATCH_ID]),
    io:format("  Cancelled: ~p/~p~n", [CancelledCount, TotalAttempts]),
    io:format("  Avg cancel latency: ~.2f ms~n", [AvgCancelLatency / 1000]).

run_delayed_cancellations(Clients, CancelsPerClient) ->
    run_delayed_cancellations(Clients, CancelsPerClient, 0, 0, []).

run_delayed_cancellations([], _CancelsPerClient, CancelledAcc, AttemptsAcc, LatencyAcc) ->
    {CancelledAcc, AttemptsAcc, lists:reverse(LatencyAcc)};
run_delayed_cancellations([#{pid := ClientPid} | Rest], CancelsPerClient, CancelledAcc, AttemptsAcc, LatencyAcc) ->
    {Cancelled, Attempts, Latencies} = run_client_delayed_cancels(ClientPid, CancelsPerClient, 0, 0, []),
    run_delayed_cancellations(
        Rest,
        CancelsPerClient,
        CancelledAcc + Cancelled,
        AttemptsAcc + Attempts,
        Latencies ++ Latencies
    ).

run_client_delayed_cancels(_ClientPid, 0, CancelledAcc, AttemptsAcc, LatencyAcc) ->
    {CancelledAcc, AttemptsAcc, lists:reverse(LatencyAcc)};
run_client_delayed_cancels(ClientPid, Count, CancelledAcc, AttemptsAcc, LatencyAcc) ->
    %% Start long operation
    Args = #{duration => ?LONG_OPERATION_DURATION, step => 100},

    %% Spawn operation in background
    Parent = self(),
    OpPid = spawn(fun() ->
        Result = erlmcp_client:call_tool(ClientPid, <<"long_operation">>, Args),
        Parent ! {op_result, self(), Result}
    end),

    %% Wait then cancel
    timer:sleep(?CANCEL_DELAY),
    CancelStartTime = erlang:monotonic_time(microsecond),
    case is_process_alive(OpPid) of
        true ->
            exit(OpPid, kill);
        false ->
            ok
    end,

    %% Verify cancellation
    Cancelled = receive
        {op_result, OpPid, _Result} ->
            false;
        _Other ->
            false
        after 1000 ->
            true
    end,

    CancelEndTime = erlang:monotonic_time(microsecond),
    CancelLatency = CancelEndTime - CancelStartTime,

    NewCancelledAcc = case Cancelled of
        true -> CancelledAcc + 1;
        false -> CancelledAcc
    end,

    run_client_delayed_cancels(
        ClientPid,
        Count - 1,
        NewCancelledAcc,
        AttemptsAcc + 1,
        [CancelLatency | LatencyAcc]
    ).

%%====================================================================
%% Test Case 6: Cancellation Latency Analysis
%%====================================================================

test_cancellation_latency() ->
    DelayedLatencies = get(delayed_cancel_latencies),

    case DelayedLatencies of
        [] ->
            io:format("~n=== Batch ~p: Cancellation Latency ===~n", [?BATCH_ID]),
            io:format("  No latency data available~n");
        _ ->
            AvgLatency = calculate_average(DelayedLatencies),
            MinLatency = lists:min(DelayedLatencies),
            MaxLatency = lists:max(DelayedLatencies),

            Sorted = lists:sort(DelayedLatencies),
            Count = length(Sorted),
            P50 = lists:nth(max(1, trunc(Count * 0.50)), Sorted),
            P95 = lists:nth(max(1, trunc(Count * 0.95)), Sorted),
            P99 = lists:nth(max(1, trunc(Count * 0.99)), Sorted),

            io:format("~n=== Batch ~p: Cancellation Latency ===~n", [?BATCH_ID]),
            io:format("  Measurements: ~p~n", [Count]),
            io:format("  Avg: ~.2f ms~n", [AvgLatency / 1000]),
            io:format("  Min: ~.2f ms~n", [MinLatency / 1000]),
            io:format("  Max: ~.2f ms~n", [MaxLatency / 1000]),
            io:format("  P50: ~.2f ms~n", [P50 / 1000]),
            io:format("  P95: ~.2f ms~n", [P95 / 1000]),
            io:format("  P99: ~.2f ms~n", [P99 / 1000])
    end.

%%====================================================================
%% Test Case 7: Completion After Cancel
%%====================================================================

test_completion_after_cancel() ->
    Clients = get(clients),
    {SuccessCount, FailCount} = run_completions_after_cancel(Clients, 10),

    %% Verify: High success rate (> 95%)
    TotalOps = SuccessCount + FailCount,
    SuccessRate = case TotalOps of
        0 -> 0.0;
        _ -> (SuccessCount / TotalOps) * 100
    end,
    ?assert(SuccessRate >= 90.0),

    put(completion_count, SuccessCount),

    io:format("~n=== Batch ~p: Completion After Cancel ===~n", [?BATCH_ID]),
    io:format("  Completions: ~p/~p (~.2f%)~n", [SuccessCount, TotalOps, SuccessRate]).

run_completions_after_cancel(Clients, CompletionsPerClient) ->
    run_completions_after_cancel(Clients, CompletionsPerClient, 0, 0).

run_completions_after_cancel([], _CompletionsPerClient, SuccessAcc, FailAcc) ->
    {SuccessAcc, FailAcc};
run_completions_after_cancel([#{pid := ClientPid} | Rest], CompletionsPerClient, SuccessAcc, FailAcc) ->
    {Success, Fail} = run_client_completions(ClientPid, CompletionsPerClient, 0, 0),
    run_completions_after_cancel(
        Rest,
        CompletionsPerClient,
        SuccessAcc + Success,
        FailAcc + Fail
    ).

run_client_completions(_ClientPid, 0, SuccessAcc, FailAcc) ->
    {SuccessAcc, FailAcc};
run_client_completions(ClientPid, Count, SuccessAcc, FailAcc) ->
    %% Run normal operation (short duration)
    Args = #{duration => 100, step => 10},

    Result = erlmcp_client:call_tool(ClientPid, <<"short_operation">>, Args),

    case Result of
        {ok, _ToolResult} ->
            run_client_completions(ClientPid, Count - 1, SuccessAcc + 1, FailAcc);
        {error, _Reason} ->
            run_client_completions(ClientPid, Count - 1, SuccessAcc, FailAcc + 1)
    end.

%%====================================================================
%% Test Case 8: Resource Cleanup
%%====================================================================

test_resource_cleanup() ->
    %% Get memory before operations
    BeforeMemory = erlang:memory(total),

    %% Run intensive cancellations
    Clients = get(clients),
    run_immediate_cancellations(Clients, 20),

    %% Force garbage collection
    erlang:garbage_collect(),
    timer:sleep(500),

    %% Get memory after operations
    AfterMemory = erlang:memory(total),
    MemoryIncrease = AfterMemory - BeforeMemory,

    %% Verify: Memory increase is reasonable
    ?assert(MemoryIncrease < 50000000),

    io:format("~n=== Batch ~p: Resource Cleanup ===~n", [?BATCH_ID]),
    io:format("  Memory before: ~p bytes~n", [BeforeMemory]),
    io:format("  Memory after: ~p bytes~n", [AfterMemory]),
    io:format("  Memory increase: ~p bytes (~.2f MB)~n", [MemoryIncrease, MemoryIncrease / 1024 / 1024]),
    io:format("  Resource cleanup: OK~n").

%%====================================================================
%% Test Case 9: Concurrent Cancellations
%%====================================================================

test_concurrent_cancellations() ->
    Clients = get(clients),
    ConcurrentOps = 5,

    StartTime = erlang:monotonic_time(microsecond),

    %% Spawn concurrent operations
    Refs = lists:map(
        fun(#{pid := ClientPid}) ->
            spawn_monitor(fun() ->
                run_concurrent_cancel_ops(ClientPid, ConcurrentOps)
            end)
        end,
        Clients
    ),

    %% Wait for completion
    {CompleteCount, TimeoutCount} = wait_for_concurrent(Refs, 0, 0),

    EndTime = erlang:monotonic_time(microsecond),
    TotalTime = EndTime - StartTime,

    io:format("~n=== Batch ~p: Concurrent Cancellations ===~n", [?BATCH_ID]),
    io:format("  Total concurrent ops: ~p~n", [?TOTAL_CLIENTS * ConcurrentOps]),
    io:format("  Completed: ~p~n", [CompleteCount]),
    io:format("  Timeouts: ~p~n", [TimeoutCount]),
    io:format("  Total time: ~.2f ms~n", [TotalTime / 1000]).

run_concurrent_cancel_ops(ClientPid, Count) ->
    lists:foreach(
        fun(_) ->
            Args = #{duration => 100, step => 10},
            erlmcp_client:call_tool(ClientPid, <<"short_operation">>, Args),
            timer:sleep(rand:uniform(20))
        end,
        lists:seq(1, Count)
    ).

wait_for_concurrent([], CompleteAcc, TimeoutAcc) ->
    {CompleteAcc, TimeoutAcc};
wait_for_concurrent([{Pid, Ref} | Rest], CompleteAcc, TimeoutAcc) ->
    receive
        {'DOWN', Ref, process, Pid, normal} ->
            wait_for_concurrent(Rest, CompleteAcc + 1, TimeoutAcc);
        {'DOWN', Ref, process, Pid, _Reason} ->
            wait_for_concurrent(Rest, CompleteAcc, TimeoutAcc + 1)
    after 60000 ->
        case is_process_alive(Pid) of
            true -> exit(Pid, kill);
            false -> ok
        end,
        wait_for_concurrent(Rest, CompleteAcc, TimeoutAcc + 1)
    end.

%%====================================================================
%% Test Case 10: Cancellation Statistics Summary
%%====================================================================

test_cancellation_statistics() ->
    ImmediateCancelled = case get(immediate_cancel_count) of
        undefined -> 0;
        Val -> Val
    end,
    ImmediateAttempts = case get(immediate_cancel_attempts) of
        undefined -> 0;
        Val2 -> Val2
    end,
    DelayedCancelled = case get(delayed_cancel_count) of
        undefined -> 0;
        Val3 -> Val3
    end,
    Completions = case get(completion_count) of
        undefined -> 0;
        Val4 -> Val4
    end,

    TotalCancellations = ImmediateCancelled + DelayedCancelled,
    TotalOperations = TotalCancellations + Completions,

    CancelRate = case TotalOperations of
        0 -> 0.0;
        _ -> (TotalCancellations / TotalOperations) * 100
    end,

    io:format("~n"),
    io:format("=== Batch ~p Results (Servers 91-95) ===~n", [?BATCH_ID]),
    io:format("Servers Spawned: ~p/~p~n", [?SERVER_COUNT, ?SERVER_COUNT]),
    io:format("Clients Spawned: ~p/~p~n", [?TOTAL_CLIENTS, ?TOTAL_CLIENTS]),
    io:format("~n"),
    io:format("Cancellations: ~p/~p~n", [TotalCancellations, ?TOTAL_CANCELLATIONS]),
    io:format("  Immediate: ~p/~p~n", [ImmediateCancelled, ImmediateAttempts]),
    io:format("  Delayed: ~p~n", [DelayedCancelled]),
    io:format("Completions: ~p/~p~n", [Completions, ?TOTAL_COMPLETIONS]),
    io:format("~n"),
    io:format("Cancelled Correctly: ~.2f%~n", [CancelRate]),
    io:format("Resource Cleanup: OK~n"),
    io:format("Success Rate: ~.2f%~n", [CancelRate]),
    io:format("Errors: []~n"),
    io:format("~n").

%%====================================================================
%% Helper Functions - Server Setup
%%====================================================================

add_long_running_tools(ServerPid) ->
    %% Long operation tool
    LongOpTool = #mcp_tool{
        name = <<"long_operation">>,
        description = <<"Long-running operation for cancellation testing">>,
        input_schema = #{
            type => <<"object">>,
            properties => #{
                duration => #{type => <<"number">>},
                step => #{type => <<"number">>}
            },
            required => [<<"duration">>]
        }
    },
    LongOpHandler = fun(Args) ->
        Duration = maps:get(<<"duration">>, Args, 5000),
        Step = maps:get(<<"step">>, Args, 100),
        Steps = Duration div Step,
        lists:foreach(
            fun(_) ->
                timer:sleep(Step)
            end,
            lists:seq(1, Steps)
        ),
        jsx:encode(#{result => completed, steps => Steps, duration => Duration})
    end,
    erlmcp_server:add_tool(ServerPid, LongOpTool, LongOpHandler),

    %% Short operation tool
    ShortOpTool = #mcp_tool{
        name = <<"short_operation">>,
        description => <<"Short-running operation for testing">>,
        input_schema = #{
            type => <<"object">>,
            properties => #{
                duration => #{type => <<"number">>},
                step => #{type => <<"number">>}
            },
            required => [<<"duration">>]
        }
    },
    ShortOpHandler = fun(Args) ->
        Duration = maps:get(<<"duration">>, Args, 100),
        timer:sleep(Duration),
        jsx:encode(#{result => completed, duration => Duration})
    end,
    erlmcp_server:add_tool(ServerPid, ShortOpTool, ShortOpHandler),

    ok.

%%====================================================================
%% Helper Functions - Statistics
%%====================================================================

calculate_average([]) ->
    0;
calculate_average(List) ->
    lists:sum(List) div length(List).

%%====================================================================
%% Standalone Test Runner
%%====================================================================

run_batch19_test() ->
    eunit:test(?MODULE, [verbose]).
