-module(erlmcp_transport_tracing_test).

-include_lib("eunit/include/eunit.hrl").
-include_lib("opentelemetry/include/otel_tracer.hrl").

%%====================================================================
%% Test Suite for Transport Tracing Integration
%%====================================================================

transport_tracing_test_() ->
    {setup,
     fun setup/0,
     fun cleanup/1,
     [
        {"STDIO Transport Tracing", fun test_stdio_transport_tracing/0},
        {"TCP Transport Tracing", fun test_tcp_transport_tracing/0},
        {"HTTP Transport Tracing", fun test_http_transport_tracing/0},
        {"Registry Tracing", fun test_registry_tracing/0},
        {"Server Request Tracing", fun test_server_request_tracing/0},
        {"End-to-End Tracing", fun test_end_to_end_tracing/0}
     ]}.

%%====================================================================
%% Setup and Cleanup
%%====================================================================

setup() ->
    % Start necessary applications
    application:ensure_all_started(logger),
    
    % Mock OpenTelemetry
    meck:new(otel_tracer, [unstick, passthrough]),
    meck:new(otel_span, [unstick, passthrough]),
    
    % Mock tracer functions with detailed tracking
    meck:expect(otel_tracer, get_tracer, fun(_) -> test_tracer end),
    meck:expect(otel_tracer, start_span, fun(_, Name, _) -> 
        {span, Name, erlang:timestamp(), self()}
    end),
    meck:expect(otel_span, end_span, fun({span, _, _, _}) -> ok end),
    meck:expect(otel_span, set_attributes, fun({span, _, _, _}, Attrs) -> 
        put(span_attributes, Attrs),
        ok
    end),
    meck:expect(otel_span, set_status, fun({span, _, _, _}, Status) -> 
        put(span_status, Status),
        ok
    end),
    meck:expect(otel_span, record_exception, fun({span, _, _, _}, Class, Reason, Stack) -> 
        put(span_exception, {Class, Reason, Stack}),
        ok
    end),
    meck:expect(otel_span, add_event, fun({span, _, _, _}, Name, Attrs) -> 
        Events = get(span_events, []),
        put(span_events, [{Name, Attrs} | Events]),
        ok
    end),
    
    ok.

cleanup(_) ->
    % Clean up process dictionary
    erase(),
    
    % Unload mocks
    meck:unload([otel_tracer, otel_span]).

%%====================================================================
%% STDIO Transport Tracing Tests
%%====================================================================

test_stdio_transport_tracing() ->
    TransportId = stdio_test_transport,
    
    % Test send operation tracing
    SpanCtx = erlmcp_tracing:start_transport_span(<<"transport.send">>, TransportId, stdio),
    
    % Simulate send operation
    Data = <<"test message">>,
    DataSize = byte_size(Data),
    
    erlmcp_tracing:set_attributes(SpanCtx, #{
        <<"test_mode">> => true,
        <<"data.size">> => DataSize
    }),
    
    erlmcp_tracing:set_status(SpanCtx, ok),
    erlmcp_tracing:end_span(SpanCtx),
    
    % Verify span was created
    ?assertMatch({span, <<"transport.send">>, _, _}, SpanCtx),
    
    % Verify attributes were set
    Attributes = get(span_attributes),
    ?assert(is_map(Attributes)),
    ?assertEqual(true, maps:get(<<"test_mode">>, Attributes)),
    ?assertEqual(DataSize, maps:get(<<"data.size">>, Attributes)),
    
    % Verify status was set
    ?assertEqual(ok, get(span_status)).

%%====================================================================
%% TCP Transport Tracing Tests  
%%====================================================================

test_tcp_transport_tracing() ->
    TransportId = tcp_test_transport,
    
    % Test connection attempt tracing
    SpanCtx = erlmcp_tracing:start_transport_span(<<"transport.attempt_connection">>, TransportId, tcp),
    
    % Simulate connection attributes
    Host = "localhost",
    Port = 8080,
    ConnectTimeout = 5000,
    
    erlmcp_tracing:set_attributes(SpanCtx, #{
        <<"host">> => list_to_binary(Host),
        <<"port">> => Port,
        <<"connect_timeout">> => ConnectTimeout,
        <<"attempt_number">> => 1
    }),
    
    % Simulate performance metrics
    erlmcp_tracing:record_performance_metrics(SpanCtx, #{
        connection_count => 1,
        retry_count => 0,
        latency => 150
    }),
    
    erlmcp_tracing:set_status(SpanCtx, ok),
    erlmcp_tracing:end_span(SpanCtx),
    
    % Verify span creation
    ?assertMatch({span, <<"transport.attempt_connection">>, _, _}, SpanCtx),
    
    % Verify attributes include connection details
    Attributes = get(span_attributes),
    ?assertEqual(list_to_binary(Host), maps:get(<<"host">>, Attributes)),
    ?assertEqual(Port, maps:get(<<"port">>, Attributes)),
    ?assertEqual(1, maps:get(<<"connection.count">>, Attributes)).

%%====================================================================
%% HTTP Transport Tracing Tests
%%====================================================================

test_http_transport_tracing() ->
    TransportId = http_test_transport,
    
    % Test HTTP request tracing
    SpanCtx = erlmcp_tracing:start_transport_span(<<"http.perform_request">>, TransportId, http),
    
    Url = "https://api.example.com/mcp",
    BodySize = 256,
    
    erlmcp_tracing:set_attributes(SpanCtx, #{
        <<"url">> => list_to_binary(Url),
        <<"body.size">> => BodySize,
        <<"attempts">> => 1,
        <<"headers_count">> => 3
    }),
    
    % Test retry scenario
    RetrySpanCtx = erlmcp_tracing:start_transport_span(<<"http.maybe_retry">>, TransportId, http),
    
    erlmcp_tracing:set_attributes(RetrySpanCtx, #{
        <<"attempts">> => 1,
        <<"max_retries">> => 3,
        <<"should_retry">> => true,
        <<"reason">> => timeout
    }),
    
    erlmcp_tracing:record_performance_metrics(RetrySpanCtx, #{
        retry_count => 2,
        latency => 1000
    }),
    
    erlmcp_tracing:end_span(RetrySpanCtx),
    erlmcp_tracing:set_status(SpanCtx, ok),
    erlmcp_tracing:end_span(SpanCtx),
    
    % Verify HTTP-specific attributes
    Attributes = get(span_attributes),
    ?assertEqual(list_to_binary(Url), maps:get(<<"url">>, Attributes)),
    ?assertEqual(BodySize, maps:get(<<"body.size">>, Attributes)).

%%====================================================================
%% Registry Tracing Tests
%%====================================================================

test_registry_tracing() ->
    % Test server registration tracing
    ServerId = test_server,
    ServerPid = self(),
    
    SpanCtx = erlmcp_tracing:start_registry_span(<<"registry.register_server">>),
    
    erlmcp_tracing:set_attributes(SpanCtx, #{
        <<"server_id">> => ServerId,
        <<"server_pid">> => ServerPid
    }),
    
    % Test message routing tracing
    TransportId = test_transport,
    Message = <<"test message">>,
    MessageSize = byte_size(Message),
    
    RouteSpanCtx = erlmcp_tracing:start_registry_span(<<"registry.route_to_server">>),
    
    erlmcp_tracing:set_attributes(RouteSpanCtx, #{
        <<"server_id">> => ServerId,
        <<"transport_id">> => TransportId,
        <<"message.size">> => MessageSize
    }),
    
    erlmcp_tracing:set_status(RouteSpanCtx, ok),
    erlmcp_tracing:end_span(RouteSpanCtx),
    
    erlmcp_tracing:set_status(SpanCtx, ok),
    erlmcp_tracing:end_span(SpanCtx),
    
    % Verify registry operations were traced
    ?assertMatch({span, <<"registry.register_server">>, _, _}, SpanCtx),
    ?assertMatch({span, <<"registry.route_to_server">>, _, _}, RouteSpanCtx).

%%====================================================================
%% Server Request Tracing Tests
%%====================================================================

test_server_request_tracing() ->
    ServerId = test_mcp_server,
    TransportId = test_transport,
    RequestId = 1,
    
    % Test initialize request tracing
    InitSpanCtx = erlmcp_tracing:start_server_span(<<"server.handle_initialize">>, ServerId),
    
    erlmcp_tracing:set_attributes(InitSpanCtx, #{
        <<"request_id">> => RequestId,
        <<"transport_id">> => TransportId,
        <<"method">> => <<"initialize">>
    }),
    
    erlmcp_tracing:set_status(InitSpanCtx, ok),
    erlmcp_tracing:end_span(InitSpanCtx),
    
    % Test resource read tracing
    ResourceUri = <<"file:///test.txt">>,
    ReadSpanCtx = erlmcp_tracing:start_server_span(<<"server.read_resource">>, ServerId),
    
    erlmcp_tracing:set_attributes(ReadSpanCtx, #{
        <<"request_id">> => RequestId + 1,
        <<"resource.uri">> => ResourceUri,
        <<"transport_id">> => TransportId
    }),
    
    % Simulate resource handler execution
    HandlerSpanCtx = erlmcp_tracing:start_span(<<"resource.handler">>),
    erlmcp_tracing:set_attributes(HandlerSpanCtx, #{<<"content.size">> => 1024}),
    erlmcp_tracing:set_status(HandlerSpanCtx, ok),
    erlmcp_tracing:end_span(HandlerSpanCtx),
    
    erlmcp_tracing:set_status(ReadSpanCtx, ok),
    erlmcp_tracing:end_span(ReadSpanCtx),
    
    % Test tool call tracing
    ToolName = <<"test_tool">>,
    ToolSpanCtx = erlmcp_tracing:start_server_span(<<"server.call_tool">>, ServerId),
    
    erlmcp_tracing:set_attributes(ToolSpanCtx, #{
        <<"request_id">> => RequestId + 2,
        <<"tool.name">> => ToolName,
        <<"transport_id">> => TransportId,
        <<"arguments_count">> => 2
    }),
    
    erlmcp_tracing:set_status(ToolSpanCtx, ok),
    erlmcp_tracing:end_span(ToolSpanCtx),
    
    % Verify server request spans
    Attributes = get(span_attributes),
    ?assertEqual(ToolName, maps:get(<<"tool.name">>, Attributes)).

%%====================================================================
%% End-to-End Tracing Tests
%%====================================================================

test_end_to_end_tracing() ->
    % Simulate a complete MCP request flow with tracing
    ServerId = e2e_server,
    TransportId = e2e_transport,
    RequestId = 42,
    
    % 1. Message arrives at transport
    TransportSpanCtx = erlmcp_tracing:start_transport_span(
        <<"transport.handle_tcp_data">>, TransportId, tcp),
    
    erlmcp_tracing:set_attributes(TransportSpanCtx, #{
        <<"data.size">> => 256,
        <<"buffer.size_before">> => 0,
        <<"buffer.size_after">> => 0,
        <<"messages.count">> => 1
    }),
    
    % 2. Message routed via registry  
    RouteSpanCtx = erlmcp_tracing:start_registry_span(<<"registry.route_to_server">>),
    
    erlmcp_tracing:set_attributes(RouteSpanCtx, #{
        <<"server_id">> => ServerId,
        <<"transport_id">> => TransportId,
        <<"message.size">> => 256
    }),
    
    erlmcp_tracing:set_status(RouteSpanCtx, ok),
    erlmcp_tracing:end_span(RouteSpanCtx),
    
    % 3. Server processes request
    ServerSpanCtx = erlmcp_tracing:start_server_span(<<"server.handle_mcp_message">>, ServerId),
    
    erlmcp_tracing:set_attributes(ServerSpanCtx, #{
        <<"transport_id">> => TransportId,
        <<"data.size">> => 256
    }),
    
    % JSON-RPC decode
    DecodeSpanCtx = erlmcp_tracing:start_span(<<"json_rpc.decode">>),
    erlmcp_tracing:record_message_metrics(ServerSpanCtx, <<"tools/call">>, 256),
    erlmcp_tracing:set_status(DecodeSpanCtx, ok),
    erlmcp_tracing:end_span(DecodeSpanCtx),
    
    % Request handling
    RequestSpanCtx = erlmcp_tracing:start_server_span(<<"server.call_tool">>, ServerId),
    
    erlmcp_tracing:set_attributes(RequestSpanCtx, #{
        <<"request_id">> => RequestId,
        <<"tool.name">> => <<"test_tool">>,
        <<"transport_id">> => TransportId,
        <<"arguments_count">> => 1
    }),
    
    erlmcp_tracing:set_status(RequestSpanCtx, ok),
    erlmcp_tracing:end_span(RequestSpanCtx),
    
    erlmcp_tracing:set_status(ServerSpanCtx, ok),
    erlmcp_tracing:end_span(ServerSpanCtx),
    
    % 4. Response sent back
    ResponseSpanCtx = erlmcp_tracing:start_transport_span(
        <<"transport.handle_mcp_response">>, TransportId, tcp),
    
    erlmcp_tracing:set_attributes(ResponseSpanCtx, #{
        <<"server_id">> => ServerId,
        <<"message.size">> => 128
    }),
    
    erlmcp_tracing:record_performance_metrics(TransportSpanCtx, #{
        throughput => 1,
        buffer_size => 0
    }),
    
    erlmcp_tracing:set_status(ResponseSpanCtx, ok),
    erlmcp_tracing:end_span(ResponseSpanCtx),
    
    erlmcp_tracing:set_status(TransportSpanCtx, ok),
    erlmcp_tracing:end_span(TransportSpanCtx),
    
    % Verify complete trace
    ?assert(meck:validate([otel_tracer, otel_span])),
    
    % Check that multiple spans were created
    History = meck:history(otel_tracer, start_span),
    ?assert(length(History) >= 6), % At least 6 spans created
    
    % Verify the span names include our expected operations
    SpanNames = [Name || {_, {otel_tracer, start_span, [_, Name, _]}, _} <- History],
    ?assert(lists:member(<<"transport.handle_tcp_data">>, SpanNames)),
    ?assert(lists:member(<<"registry.route_to_server">>, SpanNames)),
    ?assert(lists:member(<<"server.handle_mcp_message">>, SpanNames)).

%%====================================================================
%% Performance Impact Tests
%%====================================================================

performance_impact_test_() ->
    {timeout, 30, fun test_tracing_performance_impact/0}.

test_tracing_performance_impact() ->
    % Test that tracing doesn't significantly impact performance
    NumOperations = 1000,
    
    % Measure time without tracing
    {TimeWithoutTracing, _} = timer:tc(fun() ->
        lists:foreach(fun(I) ->
            % Simulate some work
            _ = binary:copy(<<I>>, 100)
        end, lists:seq(1, NumOperations))
    end),
    
    % Measure time with tracing
    {TimeWithTracing, _} = timer:tc(fun() ->
        lists:foreach(fun(I) ->
            SpanCtx = erlmcp_tracing:start_span(<<"perf.test">>),
            try
                erlmcp_tracing:set_attributes(SpanCtx, #{<<"iteration">> => I}),
                % Simulate some work
                _ = binary:copy(<<I>>, 100),
                erlmcp_tracing:set_status(SpanCtx, ok)
            after
                erlmcp_tracing:end_span(SpanCtx)
            end
        end, lists:seq(1, NumOperations))
    end),
    
    % Tracing overhead should be reasonable (less than 3x slower)
    OverheadRatio = TimeWithTracing / TimeWithoutTracing,
    ?assert(OverheadRatio < 3.0),
    
    io:format("Performance impact: ~.2fx slower with tracing~n", [OverheadRatio]).