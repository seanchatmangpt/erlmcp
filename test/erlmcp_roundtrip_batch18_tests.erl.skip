-module(erlmcp_roundtrip_batch18_tests).
-include_lib("eunit/include/eunit.hrl").
-include_lib("erlmcp_core/include/erlmcp.hrl").

%%%===================================================================
%%% MCP Roundtrip Batch 18: Rate Limiting Tests (Servers 86-90)
%%%===================================================================
%%% Tests MCP server/client rate limiting enforcement for:
%%% - Per-client rate limiting (10 req/s per client)
%%% - Rate limit enforcement under burst load
%%% - Retry-after header verification
%%% - Multiple concurrent clients with rate limits
%%% - Rate limit accuracy and consistency
%%%
%%% 5 servers (ports 9086-9090) × 5 clients each = 25 clients
%%% 100 requests per client × 25 = 2500 total requests
%%% Expected: ~1000 success (within limit), ~1500 rate limited
%%%
%%% Chicago School TDD: Real servers, real clients, real rate limiting
%%% State-based verification: Observable success/failure counts and timing
%%%===================================================================

-define(SERVER_IDS, lists:seq(86, 90)).
-define(PORTS, lists:seq(9086, 9090)).
-define(CLIENTS_PER_SERVER, 5).
-define(REQUESTS_PER_CLIENT, 100).
-define(TIMEOUT, 60000).
-define(RATE_LIMIT_PER_SEC, 10).  % 10 req/s rate limit
-define(BURST_SIZE, 100).  % Send all 100 requests as fast as possible

%%%-------------------------------------------------------------------
%%% Test Fixture: Setup/Teardown
%%%-------------------------------------------------------------------

batch18_test_() ->
    {setup,
     fun setup_batch18/0,
     fun teardown_batch18/1,
     fun run_batch18_tests/1}.

setup_batch18() ->
    logger:set_application_level(erlmcp, all),

    % Configure rate limiting for testing
    application:set_env(erlmcp, rate_limiting, #{
        max_messages_per_sec => ?RATE_LIMIT_PER_SEC,
        max_connections_per_sec => 10,
        global_max_messages_per_sec => 10000,
        max_tool_calls_per_sec => ?RATE_LIMIT_PER_SEC,
        max_subscriptions_per_sec => 20,
        bucket_refill_interval_ms => 100,
        ddos_violation_threshold => 100,
        ddos_block_duration_ms => 300000,
        enabled => true
    }),

    {ok, _Pid} = erlmcp_rate_limiter:start_link(),

    {ok, Pids} = start_servers(?SERVER_IDS, ?PORTS, []),
    timer:sleep(500), % Let servers fully initialize
    Pids.

teardown_batch18(ServerPids) ->
    stop_servers(ServerPids),
    erlmcp_rate_limiter:stop(),
    timer:sleep(200).

run_batch18_tests(ServerPids) ->
    [
     ?_test(test_rate_limit_enforcement_under_burst(ServerPids)),
     ?_test(test_retry_after_headers(ServerPids)),
     ?_test(test_concurrent_clients_with_rate_limits(ServerPids)),
     ?_test(test_rate_limit_accuracy(ServerPids)),
     ?_test(test_rate_limit_recovery(ServerPids))
    ].

%%%-------------------------------------------------------------------
%%% Server Setup (Chicago School: Real gen_servers)
%%%-------------------------------------------------------------------

start_servers([], [], Acc) ->
    {ok, lists:reverse(Acc)};
start_servers([Id | Ids], [Port | Ports], Acc) ->
    ServerId = list_to_atom("mcp_server_" ++ integer_to_list(Port)),

    % Configure server capabilities with tools enabled
    Capabilities = #mcp_server_capabilities{
        resources = #mcp_capability{enabled = false},
        tools = #mcp_capability{enabled = true},
        prompts = #mcp_capability{enabled = false}
    },

    case erlmcp_server:start_link(ServerId, Capabilities) of
        {ok, Pid} ->
            % Add echo tool with rate limiting
            add_rate_limited_tools(Pid, Port),
            start_servers(Ids, Ports, [{Id, Pid, Port, ServerId} | Acc]);
        {error, Reason} ->
            logger:error("Failed to start server ~p on port ~p: ~p", [Id, Port, Reason]),
            start_servers(Ids, Ports, Acc)
    end.

add_rate_limited_tools(ServerPid, Port) ->
    % Add echo tool (simple echo for rate limit testing)
    HandlerEcho = fun(Args) ->
        Message = maps:get(<<"message">>, Args, <<"">>),
        #{<<"echo">> => Message, <<"timestamp">> => erlang:system_time(millisecond)}
    end,

    EchoTool = #mcp_tool{
        name = <<"echo">>,
        description = <<"Echo tool for rate limit testing">>,
        input_schema => #{
            type => <<"object">>,
            properties => #{
                <<"message">> => #{
                    type => <<"string">>,
                    description => <<"Message to echo">>
                }
            },
            required => [<<"message">>]
        }
    },
    erlmcp_server:add_tool(ServerPid, EchoTool, HandlerEcho),

    % Add fast tool (minimal processing time)
    HandlerFast = fun(Args) ->
        Value = maps:get(<<"value">>, Args, 0),
        #{<<"result">> => Value * 2, <<"processed">> => true}
    end,

    FastTool = #mcp_tool{
        name = <<"fast">>,
        description = <<"Fast tool for rate limit testing">>,
        input_schema => #{
            type => <<"object">>,
            properties => #{
                <<"value">> => #{type => <<"number">>}
            },
            required => [<<"value">>]
        }
    },
    erlmcp_server:add_tool(ServerPid, FastTool, HandlerFast).

stop_servers(ServerPids) ->
    lists:foreach(fun({_Id, Pid, _Port, _ServerId}) ->
        case erlmcp_server:stop(Pid) of
            ok -> ok;
            {error, Reason} ->
                logger:error("Failed to stop server: ~p", [Reason])
        end
    end, ServerPids).

%%%-------------------------------------------------------------------
%%% Test 1: Rate Limit Enforcement Under Burst
%%%-------------------------------------------------------------------

test_rate_limit_enforcement_under_burst(ServerPids) ->
    logger:info("=== Testing Rate Limit Enforcement Under Burst ===~n"),

    Results = lists:map(fun({_ServerId, _Pid, Port, _ServerName}) ->
        test_burst_on_server(Port)
    end, ServerPids),

    {TotalServers, TotalClients, TotalRequests, TotalSuccess, TotalRateLimited, Errors} =
        aggregate_burst_results(Results),

    logger:info("Burst Test: ~p/~p servers, ~p/~p clients, ~p/~p requests~n",
                [TotalServers, length(?SERVER_IDS),
                 TotalClients, ?CLIENTS_PER_SERVER * length(?SERVER_IDS),
                 TotalSuccess, TotalRequests]),
    logger:info("Success: ~p, Rate Limited: ~p, Errors: ~p~n",
                [TotalSuccess, TotalRateLimited, length(Errors)]),

    % With 10 req/s limit and 100 burst requests, expect ~10 success, ~90 rate limited per client
    ExpectedSuccessPerClient = ?RATE_LIMIT_PER_SEC,
    ExpectedTotalSuccess = ExpectedSuccessPerClient * TotalClients,
    ExpectedTotalRateLimited = TotalRequests - ExpectedTotalSuccess,

    % Allow 20% tolerance for timing variations
    SuccessTolerance = ExpectedTotalSuccess * 0.20,
    ?assert(TotalSuccess >= (ExpectedTotalSuccess - SuccessTolerance)),
    ?assert(TotalSuccess =< (ExpectedTotalSuccess + SuccessTolerance)),
    ?assert(TotalRateLimited >= (ExpectedTotalRateLimited - SuccessTolerance)),
    ?assertEqual([], Errors),

    io:format("~n=== Batch 18 Burst Test Results ===~n"),
    io:format("Servers: ~p~n", [TotalServers]),
    io:format("Clients: ~p~n", [TotalClients]),
    io:format("Requests: ~p~n", [TotalRequests]),
    io:format("Successful: ~p (expected ~p)~n", [TotalSuccess, ExpectedTotalSuccess]),
    io:format("Rate Limited: ~p (expected ~p)~n", [TotalRateLimited, ExpectedTotalRateLimited]),
    io:format("Success Rate: ~.2f%~n", [(TotalSuccess / TotalRequests) * 100]).

test_burst_on_server(Port) ->
    % Spawn multiple clients for burst testing
    Parent = self(),
    ClientPids = lists:map(fun(N) ->
        spawn_link(fun() ->
            Result = run_burst_client(Port, N, ?REQUESTS_PER_CLIENT),
            Parent ! {burst_result, self(), Result}
        end)
    end, lists:seq(1, ?CLIENTS_PER_SERVER)),

    % Collect results from all clients
    Results = lists:map(fun(Pid) ->
        receive
            {burst_result, Pid, Result} -> Result
        after ?TIMEOUT ->
            {error, timeout}
        end
    end, ClientPids),

    {Port, Results}.

run_burst_client(Port, ClientNum, RequestCount) ->
    {ok, ClientPid} = erlmcp_client:start_link(#{transport => {erlmcp_transport_tcp, [{port, Port}]}}),
    {ok, _} = erlmcp_client:initialize(ClientPid, #mcp_client_capabilities{}),

    ClientId = list_to_binary("client_" ++ integer_to_list(Port) ++ "_" ++ integer_to_list(ClientNum)),

    % Send all requests as fast as possible (burst)
    StartTime = erlang:monotonic_time(microsecond),

    Results = lists:map(fun(N) ->
        Args = #{<<"message">> => list_to_binary("burst_msg_" ++ integer_to_list(N))},

        TimeNowMs = erlang:system_time(millisecond),

        % Check rate limit before request
        case erlmcp_rate_limiter:check_message_rate(ClientId, TimeNowMs) of
            {ok, _TokensRemaining} ->
                % Within rate limit, send request
                Result = erlmcp_client:call_tool(ClientPid, <<"echo">>, Args),
                case Result of
                    {ok, _Response} ->
                        {success, N};
                    {error, Reason} ->
                        {error, {N, Reason}}
                end;
            {error, rate_limited, RetryAfterMs} ->
                % Rate limited
                {rate_limited, N, RetryAfterMs}
        end
    end, lists:seq(1, RequestCount)),

    EndTime = erlang:monotonic_time(microsecond),
    TotalDuration = (EndTime - StartTime) div 1000, % Convert to ms

    ok = erlmcp_client:stop(ClientPid),

    % Aggregate results
    SuccessCount = length([R || {success, _} <- Results]),
    RateLimitedCount = length([R || {rate_limited, _, _} <- Results]),
    ErrorCount = length([R || {error, _} <- Results]),
    Errors = [E || {error, E} <- Results],

    % Calculate actual throughput
    ActualRate = if
        TotalDuration > 0 -> (SuccessCount * 1000) div TotalDuration;
        true -> 0
    end,

    {SuccessCount, RateLimitedCount, ErrorCount, ActualRate, TotalDuration, Errors}.

%%%-------------------------------------------------------------------
%%% Test 2: Retry-After Headers
%%%-------------------------------------------------------------------

test_retry_after_headers(ServerPids) ->
    logger:info("=== Testing Retry-After Headers ===~n"),

    {_ServerId, _Pid, Port, _ServerName} = lists:nth(1, ServerPids),

    {ok, ClientPid} = erlmcp_client:start_link(#{transport => {erlmcp_transport_tcp, [{port, Port}]}}),
    {ok, _} = erlmcp_client:initialize(ClientPid, #mcp_client_capabilities{}),

    ClientId = <<"retry_test_client">>,

    % Exhaust rate limit
    lists:foreach(fun(N) ->
        Args = #{<<"message">> => list_to_binary("test_" ++ integer_to_list(N))},
        erlmcp_client:call_tool(ClientPid, <<"echo">>, Args)
    end, lists:seq(1, 20)),

    % Now check rate limit responses
    TimeNowMs = erlang:system_time(millisecond),
    case erlmcp_rate_limiter:check_message_rate(ClientId, TimeNowMs) of
        {error, rate_limited, RetryAfterMs} ->
            logger:info("Rate limited with retry-after: ~p ms~n", [RetryAfterMs]),

            % Verify retry-after is reasonable (should be ~100ms based on refill interval)
            ?assert(RetryAfterMs > 0),
            ?assert(RetryAfterMs =< 1000),  % Should be <= 1 second

            io:format("~n=== Batch 18 Retry-After Test ===~n"),
            io:format("Retry-After: ~p ms~n", [RetryAfterMs]),
            io:format("Retry-After reasonable: yes~n");
        {ok, _} ->
            ?assert(false, "Expected rate limit to be exceeded")
    end,

    ok = erlmcp_client:stop(ClientPid).

%%%-------------------------------------------------------------------
%%% Test 3: Concurrent Clients with Rate Limits
%%%-------------------------------------------------------------------

test_concurrent_clients_with_rate_limits(ServerPids) ->
    logger:info("=== Testing Concurrent Clients with Rate Limits ===~n"),

    {_ServerId, _Pid, Port, _ServerName} = lists:nth(1, ServerPids),

    % Spawn multiple concurrent clients
    Parent = self(),
    ClientPids = lists:map(fun(N) ->
        spawn_link(fun() ->
            Result = run_concurrent_rate_limit_client(Port, N),
            Parent ! {concurrent_rate_result, self(), Result}
        end)
    end, lists:seq(1, 10)),

    % Collect results
    Results = lists:map(fun(Pid) ->
        receive
            {concurrent_rate_result, Pid, Result} -> Result
        after ?TIMEOUT ->
            {error, timeout}
        end
    end, ClientPids),

    % Aggregate statistics
    TotalRequests = lists:sum([R || {R, _S, _RL} <- Results]),
    TotalSuccess = lists:sum([S || {_R, S, _RL} <- Results]),
    TotalRateLimited = lists:sum([RL || {_R, _S, RL} <- Results]),

    logger:info("Concurrent Clients: ~p requests, ~p success, ~p rate limited~n",
                [TotalRequests, TotalSuccess, TotalRateLimited]),

    % Each client should get ~10 success (rate limit) with 50 requests
    ExpectedSuccessPerClient = ?RATE_LIMIT_PER_SEC,
    ExpectedTotalSuccess = ExpectedSuccessPerClient * length(Results),

    % Allow 30% tolerance due to concurrent timing
    SuccessTolerance = ExpectedTotalSuccess * 0.30,
    ?assert(TotalSuccess >= (ExpectedTotalSuccess - SuccessTolerance)),
    ?assert(TotalSuccess =< (ExpectedTotalSuccess + SuccessTolerance)),

    io:format("~n=== Batch 18 Concurrent Clients Results ===~n"),
    io:format("Clients: ~p~n", [length(Results)]),
    io:format("Total Requests: ~p~n", [TotalRequests]),
    io:format("Successful: ~p (expected ~p)~n", [TotalSuccess, ExpectedTotalSuccess]),
    io:format("Rate Limited: ~p~n", [TotalRateLimited]),
    io:format("Avg Success per Client: ~.2f~n", [TotalSuccess / length(Results)]).

run_concurrent_rate_limit_client(Port, ClientNum) ->
    {ok, ClientPid} = erlmcp_client:start_link(#{transport => {erlmcp_transport_tcp, [{port, Port}]}}),
    {ok, _} = erlmcp_client:initialize(ClientPid, #mcp_client_capabilities{}),

    ClientId = list_to_binary("concurrent_client_" ++ integer_to_list(ClientNum)),

    % Send 50 requests as fast as possible
    Results = lists:map(fun(N) ->
        Args = #{<<"message">> => list_to_binary("msg_" ++ integer_to_list(N))},

        TimeNowMs = erlang:system_time(millisecond),

        case erlmcp_rate_limiter:check_message_rate(ClientId, TimeNowMs) of
            {ok, _} ->
                Result = erlmcp_client:call_tool(ClientPid, <<"echo">>, Args),
                case Result of
                    {ok, _} -> 1;  % Success
                    {error, _} -> 0  % Failed but not rate limited
                end;
            {error, rate_limited, _RetryAfter} ->
                0  % Rate limited
        end
    end, lists:seq(1, 50)),

    ok = erlmcp_client:stop(ClientPid),

    TotalRequests = 50,
    SuccessCount = lists:sum(Results),
    RateLimitedCount = TotalRequests - SuccessCount,

    {TotalRequests, SuccessCount, RateLimitedCount}.

%%%-------------------------------------------------------------------
%%% Test 4: Rate Limit Accuracy
%%%-------------------------------------------------------------------

test_rate_limit_accuracy(ServerPids) ->
    logger:info("=== Testing Rate Limit Accuracy ===~n"),

    {_ServerId, _Pid, Port, _ServerName} = lists:nth(1, ServerPids),

    {ok, ClientPid} = erlmcp_client:start_link(#{transport => {erlmcp_transport_tcp, [{port, Port}]}}),
    {ok, _} = erlmcp_client:initialize(ClientPid, #mcp_client_capabilities{}),

    ClientId = <<"accuracy_test_client">>,

    % Test rate limit accuracy over 3 seconds
    TestDurationSec = 3,
    StartTime = erlang:system_time(millisecond),

    Results = lists:map(fun(N) ->
        Args = #{<<"message">> => list_to_binary("accuracy_" ++ integer_to_list(N))},

        TimeNowMs = erlang:system_time(millisecond),
        ElapsedSec = (TimeNowMs - StartTime) div 1000,

        if
            ElapsedSec >= TestDurationSec ->
                done;
            true ->
                case erlmcp_rate_limiter:check_message_rate(ClientId, TimeNowMs) of
                    {ok, _} ->
                        Result = erlmcp_client:call_tool(ClientPid, <<"echo">>, Args),
                        case Result of
                            {ok, _} -> {success, ElapsedSec};
                            {error, _} -> {error, ElapsedSec}
                        end;
                    {error, rate_limited, _} ->
                        {rate_limited, ElapsedSec}
                end
        end
    end, lists:seq(1, 1000)),

    ok = erlmcp_client:stop(ClientPid),

    % Count successes per second
    SuccessCounts = lists:foldl(fun
        (done, Acc) -> Acc;
        ({success, Sec}, Acc) ->
            maps:update_with(Sec, fun(Count) -> Count + 1 end, 1, Acc);
        (_, Acc) -> Acc
    end, #{}, Results),

    logger:info("Rate limit accuracy by second: ~p~n", [maps:to_list(SuccessCounts)]),

    % Verify each second is close to rate limit (10 req/s)
    AccuracyErrors = lists:filter(fun({Sec, Count}) ->
        AbsDiff = abs(Count - ?RATE_LIMIT_PER_SEC),
        AbsDiff > 3  % Allow 30% variance
    end, maps:to_list(SuccessCounts)),

    ?assertEqual([], AccuracyErrors),

    io:format("~n=== Batch 18 Rate Limit Accuracy Results ===~n"),
    io:format("Test Duration: ~p seconds~n", [TestDurationSec]),
    io:format("Rate Limit: ~p req/s~n", [?RATE_LIMIT_PER_SEC]),
    io:format("Per-Second Counts: ~p~n", [maps:to_list(SuccessCounts)]),
    io:format("Accuracy: Within tolerance~n").

%%%-------------------------------------------------------------------
%%% Test 5: Rate Limit Recovery
%%%-------------------------------------------------------------------

test_rate_limit_recovery(ServerPids) ->
    logger:info("=== Testing Rate Limit Recovery ===~n"),

    {_ServerId, _Pid, Port, _ServerName} = lists:nth(1, ServerPids),

    {ok, ClientPid} = erlmcp_client:start_link(#{transport => {erlmcp_transport_tcp, [{port, Port}]}}),
    {ok, _} = erlmcp_client:initialize(ClientPid, #mcp_client_capabilities{}),

    ClientId = <<"recovery_test_client">>,

    % Phase 1: Exhaust rate limit (send 20 requests)
    Phase1Results = lists:map(fun(N) ->
        Args = #{<<"message">> => list_to_binary("phase1_" ++ integer_to_list(N))},
        TimeNowMs = erlang:system_time(millisecond),

        case erlmcp_rate_limiter:check_message_rate(ClientId, TimeNowMs) of
            {ok, _} ->
                Result = erlmcp_client:call_tool(ClientPid, <<"echo">>, Args),
                case Result of
                    {ok, _} -> success;
                    {error, _} -> error
                end;
            {error, rate_limited, _} ->
                rate_limited
        end
    end, lists:seq(1, 20)),

    Phase1Success = length([R || R <- Phase1Results, R =:= success]),
    Phase1RateLimited = length([R || R <- Phase1Results, R =:= rate_limited]),

    logger:info("Phase 1: ~p success, ~p rate limited~n", [Phase1Success, Phase1RateLimited]),

    % Wait for bucket to refill (200ms should be enough for partial refill)
    timer:sleep(200),

    % Phase 2: Try again after waiting
    Phase2Results = lists:map(fun(N) ->
        Args = #{<<"message">> => list_to_binary("phase2_" ++ integer_to_list(N))},
        TimeNowMs = erlang:system_time(millisecond),

        case erlmcp_rate_limiter:check_message_rate(ClientId, TimeNowMs) of
            {ok, _} ->
                Result = erlmcp_client:call_tool(ClientPid, <<"echo">>, Args),
                case Result of
                    {ok, _} -> success;
                    {error, _} -> error
                end;
            {error, rate_limited, _} ->
                rate_limited
        end
    end, lists:seq(1, 10)),

    Phase2Success = length([R || R <- Phase2Results, R =:= success]),
    Phase2RateLimited = length([R || R <- Phase2Results, R =:= rate_limited]),

    logger:info("Phase 2: ~p success, ~p rate limited~n", [Phase2Success, Phase2RateLimited]),

    % Verify recovery: Phase 2 should have more success than Phase 1
    ?assert(Phase2Success >= Phase1Success),

    io:format("~n=== Batch 18 Rate Limit Recovery Results ===~n"),
    io:format("Phase 1 (exhaust): ~p success, ~p rate limited~n", [Phase1Success, Phase1RateLimited]),
    io:format("Phase 2 (after 200ms): ~p success, ~p rate limited~n", [Phase2Success, Phase2RateLimited]),
    io:format("Recovery: yes (~p more success in phase 2)~n", [Phase2Success - Phase1Success]),

    ok = erlmcp_client:stop(ClientPid).

%%%-------------------------------------------------------------------
%%% Helper Functions
%%%-------------------------------------------------------------------

aggregate_burst_results(Results) ->
    lists:foldl(fun({_Port, ClientResults}, {AccSrv, AccClient, AccReq, AccSucc, AccRL, AccErr}) ->
        {Servers, Clients, Requests, Success, RateLimited, Errors} =
            lists:foldl(fun({SuccessCount, RateLimitedCount, ErrorCount, _Rate, _Duration, ClientErrors},
                            {AS, AC, AR, ASuc, ARL, AE}) ->
                {AS + 1, AC + 1, AR + SuccessCount + RateLimitedCount + ErrorCount,
                 ASuc + SuccessCount, ARL + RateLimitedCount, AE ++ ClientErrors}
            end, {0, 0, 0, 0, 0, []}, ClientResults),

        {AccSrv + Servers, AccClient + Clients, AccReq + Requests,
         AccSucc + Success, AccRL + RateLimited, AccErr ++ Errors}
    end, {0, 0, 0, 0, 0, []}, Results).

%%%-------------------------------------------------------------------
%%% Final Report Generator
%%%-------------------------------------------------------------------

generate_batch18_report() ->
    io:format("~n"),
    io:format("=== Batch 18 Results (Servers 86-90) ===~n"),
    io:format("Servers: 5 (ports 9086-9090)~n"),
    io:format("Clients: 25 (5 per server)~n"),
    io:format("Requests: 2500 (100 per client)~n"),
    io:format("Rate Limit: ~p req/s per client~n", [?RATE_LIMIT_PER_SEC]),
    io:format("Expected Success: ~1000 (~40%)~n"),
    io:format("Expected Rate Limited: ~1500 (~60%)~n"),
    io:format("Test Coverage:~n"),
    io:format("  - Rate limit enforcement under burst load~n"),
    io:format("  - Retry-after header verification~n"),
    io:format("  - Multiple concurrent clients with rate limits~n"),
    io:format("  - Rate limit accuracy per second~n"),
    io:format("  - Rate limit recovery after waiting~n"),
    io:format("~n").

%%%-------------------------------------------------------------------
%%% Standalone Test Runner
%%%-------------------------------------------------------------------

run_batch18_test() ->
    eunit:test(?MODULE, [verbose]).
