%%%-------------------------------------------------------------------
%%% @doc
%%% MCP Roundtrip Test - Batch 8 (Servers 36-40, Ports 9036-9040)
%%%
%%% WebSocket-based MCP server/client roundtrip testing.
%%% Tests echo tools, broadcast tools, and message latency.
%%%
%%% Configuration:
%%%   - 5 MCP servers on ports 9036-9040
%%%   - 5 clients per server (25 total clients)
%%%   - 100 messages per client (2500 total messages)
%%%
%%% Metrics:
%%%   - Average latency
%%%   - Min/Max latency
%%%   - Message rate (msg/s)
%%%   - Broadcast count
%%%   - Success rate
%%%
%%% @end
%%%-------------------------------------------------------------------
-module(erlmcp_roundtrip_batch_8_SUITE).

-include_lib("common_test/include/ct.hrl").
-include_lib("eunit/include/eunit.hrl").
-include("erlmcp.hrl").

%% Suite callbacks
-export([
    all/0,
    init_per_suite/1,
    end_per_suite/1,
    init_per_testcase/2,
    end_per_testcase/2
]).

%% Test cases
-export([
    test_batch_8_websocket_roundtrip/1
]).

%% Test constants
-define(BATCH_ID, 8).
-define(SERVER_START, 36).
-define(SERVER_END, 40).
-define(PORT_START, 9036).
-define(PORT_END, 9040).
-define(CLIENTS_PER_SERVER, 5).
-define(MESSAGES_PER_CLIENT, 100).
-define(TOTAL_SERVERS, 5).
-define(TOTAL_CLIENTS, 25).
-define(TOTAL_MESSAGES, 2500).
-define(WAIT_TIMEOUT, 60000). %% 60 seconds
-define(MSG_TIMEOUT, 5000). %% 5 seconds per message

%% Test state record
-record(test_state, {
    servers = [] :: list({integer(), pid(), integer()}), %% ServerId, ServerPid, Port
    clients = [] :: list({integer(), pid()}), %% ServerId, ClientPid
    results = [] :: list({integer(), list({atom(), number() | atom()})}),
    broadcast_count = 0 :: non_neg_integer(),
    start_time :: integer()
}).

%%====================================================================
%% Suite Configuration
%%====================================================================

all() ->
    [
        test_batch_8_websocket_roundtrip
    ].

init_per_suite(Config) ->
    ct:pal("Starting Batch ~p Roundtrip Test (Servers ~p-~p, Ports ~p-~p)", [
        ?BATCH_ID, ?SERVER_START, ?SERVER_END, ?PORT_START, ?PORT_END
    ]),
    %% Ensure application is started
    {ok, _} = application:ensure_all_started(erlmcp),
    %% Ensure cowboy is available for WebSocket
    {ok, _} = application:ensure_all_started(cowboy),
    %% Ensure gun is available for WebSocket client
    {ok, _} = application:ensure_all_started(gun),
    Config.

end_per_suite(Config) ->
    ct:pal("Batch ~p Roundtrip Test completed", [?BATCH_ID]),
    Config.

init_per_testcase(_TestCase, _Config) ->
    #test_state{
        servers = [],
        clients = [],
        results = [],
        broadcast_count = 0,
        start_time = 0
    }.

end_per_testcase(_TestCase, _Config) ->
    ok.

%%====================================================================
%% Test Cases
%%====================================================================

test_batch_8_websocket_roundtrip(_Config) ->
    ct:pal("=== Batch ~p: WebSocket Roundtrip Test ===", [?BATCH_ID]),
    ct:pal("Servers: ~p-~p", [?SERVER_START, ?SERVER_END]),
    ct:pal("Ports: ~p-~p", [?PORT_START, ?PORT_END]),
    ct:pal("Clients per server: ~p", [?CLIENTS_PER_SERVER]),
    ct:pal("Messages per client: ~p", [?MESSAGES_PER_CLIENT]),
    ct:pal("Total messages: ~p", [?TOTAL_MESSAGES]),

    State0 = #test_state{start_time = erlang:monotonic_time(millisecond)},

    %% Step 1: Spawn MCP servers with WebSocket transport
    ct:pal("~nStep 1: Spawning ~p MCP servers with WebSocket transport", [?TOTAL_SERVERS]),
    {ok, State1} = spawn_batch_servers(State0),
    ct:pal("Servers spawned: ~p/~p", [length(State1#test_state.servers), ?TOTAL_SERVERS]),

    %% Step 2: Spawn clients (5 per server)
    ct:pal("~nStep 2: Spawning ~p WebSocket clients", [?TOTAL_CLIENTS]),
    {ok, State2} = spawn_batch_clients(State1),
    ct:pal("Clients spawned: ~p/~p", [length(State2#test_state.clients), ?TOTAL_CLIENTS]),

    %% Step 3: Send echo messages from all clients
    ct:pal("~nStep 3: Sending ~p echo messages", [?TOTAL_MESSAGES]),
    {ok, State3} = send_echo_messages(State2),
    ct:pal("Messages sent: ~p", [?TOTAL_MESSAGES]),

    %% Step 4: Wait for responses and collect metrics
    ct:pal("~nStep 4: Waiting for responses and collecting metrics"),
    {ok, State4} = collect_metrics(State3),

    %% Step 5: Broadcast messages
    ct:pal("~nStep 5: Broadcasting messages from all servers"),
    {ok, State5} = broadcast_messages(State4),
    ct:pal("Broadcasts sent: ~p", [State5#test_state.broadcast_count]),

    %% Step 6: Calculate and report results
    ct:pal("~nStep 6: Calculating results"),
    report_results(State5),

    %% Verify all tests passed
    verify_results(State5),

    ok.

%%====================================================================
%% Server Spawning
%%====================================================================

spawn_batch_servers(State) ->
    PortList = lists:seq(?PORT_START, ?PORT_END),

    Result = lists:mapfoldl(
        fun(Port, {ServerId, Acc}) ->
            ServerName = list_to_atom(lists:flatten(io_lib:format("batch_~p_server_~p", [?BATCH_ID, ServerId]))),
            TransportId = list_to_atom(lists:flatten(io_lib:format("ws_transport_~p", [ServerId]))),

            %% Start WebSocket transport on port
            WsConfig = #{
                port => Port,
                path => "/mcp/ws",
                max_message_size => 16777216,
                strict_delimiter_check => true,
                validate_utf8 => true
            },

            case erlmcp_transport_ws:init(TransportId, WsConfig) of
                {ok, _WsPid} ->
                    %% Start MCP server
                    ServerCaps = #mcp_server_capabilities{
                        tools = #mcp_capability{enabled = true},
                        resources = #mcp_capability{enabled = true},
                        prompts = #mcp_capability{enabled = true}
                    },

                    case erlmcp_server:start_link(ServerName, ServerCaps) of
                        {ok, ServerPid} ->
                            %% Add echo tool
                            EchoHandler = fun(Args) ->
                                Text = maps:get(<<"text">>, Args, <<"hello">>),
                                <<"Echo: ", Text/binary>>
                            end,
                            ok = erlmcp_server:add_tool(ServerPid, <<"echo">>, EchoHandler),

                            %% Add broadcast tool
                            BroadcastHandler = fun(Args) ->
                                Message = maps:get(<<"message">>, Args, <<"broadcast">>),
                                {ok, ServerPid} ! {broadcast, Message},
                                #{<<"result">> => <<"Broadcast sent">>}
                            end,
                            ok = erlmcp_server:add_tool(ServerPid, <<"broadcast">>, BroadcastHandler),

                            ct:pal("  Server ~p started on port ~p (pid: ~p)", [ServerId, Port, ServerPid]),
                            {{ServerId + 1, Acc ++ [{ServerId, ServerPid, Port}]}, ok};
                        {error, Reason} ->
                            ct:pal("  ERROR: Failed to start server ~p: ~p", [ServerId, Reason]),
                            {{ServerId + 1, Acc}, {error, Reason}}
                    end;
                {error, Reason} ->
                    ct:pal("  ERROR: Failed to start WebSocket transport on port ~p: ~p", [Port, Reason]),
                    {{ServerId + 1, Acc}, {error, Reason}}
            end
        end,
        {?SERVER_START, []},
        PortList
    ),

    case Result of
        {_, Servers} when length(Servers) =:= ?TOTAL_SERVERS ->
            {ok, State#test_state{servers = Servers}};
        {_, Servers} ->
            ct:pal("WARNING: Only ~p/~p servers started", [length(Servers), ?TOTAL_SERVERS]),
            {ok, State#test_state{servers = Servers}}
    end.

%%====================================================================
%% Client Spawning
%%====================================================================

spawn_batch_clients(State) ->
    Servers = State#test_state.servers,

    AllClients = lists:flatmap(
        fun({ServerId, _ServerPid, Port}) ->
            lists:map(
                fun(ClientNum) ->
                    %% Start WebSocket client using gun
                    case gun:open("localhost", Port, #{protocols => [http], transport => tcp}) of
                        {ok, GunPid} ->
                            {gun_up, GunPid, http} = receive
                                {gun_up, GunPid, http} -> ok
                            after 5000 ->
                                timeout
                            end,

                            %% Upgrade to WebSocket
                            StreamRef = gun:ws_upgrade(GunPid, "/mcp/ws", []),

                            receive
                                {gun_upgrade, GunPid, StreamRef, _, _} ->
                                    ok;
                                {gun_response, GunPid, StreamRef, _, Status, _Headers} ->
                                    ct:pal("  ERROR: WebSocket upgrade failed for client ~p_~p: ~p", [ServerId, ClientNum, Status]),
                                    gun:close(GunPid),
                                    []
                            after 5000 ->
                                ct:pal("  ERROR: WebSocket upgrade timeout for client ~p_~p", [ServerId, ClientNum]),
                                gun:close(GunPid),
                                []
                            end,

                            %% Initialize MCP connection
                            InitMsg = jsx:encode(#{
                                <<"jsonrpc">> => <<"2.0">>,
                                <<"id">> => 1,
                                <<"method">> => <<"initialize">>,
                                <<"params">> => #{
                                    <<"protocolVersion">> => <<"2025-11-25">>,
                                    <<"capabilities">> => #{},
                                    <<"clientInfo">> => #{
                                        <<"name">> => <<"erlmcp_test_client">>,
                                        <<"version">> => <<"1.0.0">>
                                    }
                                }
                            }),

                            gun:ws_send(GunPid, {text, InitMsg}),

                            receive
                                {gun_ws, GunPid, {text, InitResponse}} ->
                                    Response = jsx:decode(InitResponse, [return_maps]),
                                    case maps:get(<<"result">>, Response, undefined) of
                                        undefined ->
                                            ct:pal("  ERROR: Initialize failed for client ~p_~p", [ServerId, ClientNum]),
                                            gun:close(GunPid),
                                            [];
                                        _ ->
                                            ct:pal("  Client ~p_~p connected (pid: ~p)", [ServerId, ClientNum, GunPid]),
                                            [{ServerId, GunPid}]
                                    end
                            after 5000 ->
                                ct:pal("  ERROR: Initialize timeout for client ~p_~p", [ServerId, ClientNum]),
                                gun:close(GunPid),
                                []
                            end;
                        {error, Reason} ->
                            ct:pal("  ERROR: Failed to open gun connection for client ~p_~p: ~p", [ServerId, ClientNum, Reason]),
                            []
                    end
                end,
                lists:seq(1, ?CLIENTS_PER_SERVER)
            )
        end,
        Servers
    ),

    %% Filter out failed clients
    ValidClients = lists:filter(
        fun
            ({_ServerId, _GunPid}) -> true;
            (_) -> false
        end,
        AllClients
    ),

    ct:pal("Valid clients: ~p/~p", [length(ValidClients), ?TOTAL_CLIENTS]),
    {ok, State#test_state{clients = ValidClients}}.

%%====================================================================
%% Message Sending
%%====================================================================

send_echo_messages(State) ->
    Clients = State#test_state.clients,

    RequestId = 2,

    Results = lists:map(
        fun({ServerId, GunPid}) ->
            lists:map(
                fun(MsgNum) ->
                    Message = jsx:encode(#{
                        <<"jsonrpc">> => <<"2.0">>,
                        <<"id">> => RequestId + MsgNum,
                        <<"method">> => <<"tools/call">>,
                        <<"params">> => #{
                            <<"name">> => <<"echo">>,
                            <<"arguments">> => #{
                                <<"text">> => list_to_binary(io_lib:format("Message ~p from client ~p", [MsgNum, ServerId]))
                            }
                        }
                    }),

                    StartTime = erlang:monotonic_time(millisecond),

                    gun:ws_send(GunPid, {text, Message}),

                    receive
                        {gun_ws, GunPid, {text, Response}} ->
                            EndTime = erlang:monotonic_time(millisecond),
                            Latency = EndTime - StartTime,

                            ResponseObj = jsx:decode(Response, [return_maps]),
                            case maps:get(<<"result">>, ResponseObj, undefined) of
                                undefined ->
                                    Error = maps:get(<<"error">>, ResponseObj, undefined),
                                    ct:pal("  ERROR: Echo message ~p failed for server ~p: ~p", [MsgNum, ServerId, Error]),
                                    {MsgNum, [{latency, Latency}, {status, error}]};
                                _ ->
                                    {MsgNum, [{latency, Latency}, {status, ok}]}
                            end
                    after ?MSG_TIMEOUT ->
                        ct:pal("  ERROR: Echo message ~p timeout for server ~p", [MsgNum, ServerId]),
                        {MsgNum, [{latency, ?MSG_TIMEOUT}, {status, timeout}]}
                    end
                end,
                lists:seq(1, ?MESSAGES_PER_CLIENT)
            )
        end,
        Clients
    ),

    {ok, State#test_state{results = Results}}.

%%====================================================================
%% Metrics Collection
%%====================================================================

collect_metrics(State) ->
    Results = State#test_state.results,

    %% Flatten results
    AllResults = lists:flatten(Results),

    %% Calculate statistics
    Latencies = [Latency || {_, [{latency, Latency}, {status, ok}]} <- AllResults],
    SuccessCount = length([1 || {_, [{_, _}, {status, ok}]} <- AllResults]),
    ErrorCount = length([1 || {_, [{_, _}, {status, error}]} <- AllResults]),
    TimeoutCount = length([1 || {_, [{_, _}, {status, timeout}]} <- AllResults]),

    AvgLatency = case length(Latencies) of
        0 -> 0;
        N -> lists:sum(Latencies) / N
    end,

    MinLatency = case Latencies of
        [] -> 0;
        _ -> lists:min(Latencies)
    end,

    MaxLatency = case Latencies of
        [] -> 0;
        _ -> lists:max(Latencies)
    end,

    %% Calculate message rate (messages per second)
    TotalTime = (erlang:monotonic_time(millisecond) - State#test_state.start_time) / 1000,
    MessageRate = case TotalTime > 0 of
        true -> length(AllResults) / TotalTime;
        false -> 0
    end,

    ct:pal("~nMetrics:"),
    ct:pal("  Total messages: ~p", [length(AllResults)]),
    ct:pal("  Successful: ~p", [SuccessCount]),
    ct:pal("  Errors: ~p", [ErrorCount]),
    ct:pal("  Timeouts: ~p", [TimeoutCount]),
    ct:pal("  Avg latency: ~.2f ms", [AvgLatency]),
    ct:pal("  Min latency: ~p ms", [MinLatency]),
    ct:pal("  Max latency: ~p ms", [MaxLatency]),
    ct:pal("  Message rate: ~.2f msg/s", [MessageRate]),
    ct:pal("  Total time: ~.2f s", [TotalTime]),

    {ok, State}.

%%====================================================================
%% Broadcasting
%%====================================================================

broadcast_messages(State) ->
    Servers = State#test_state.servers,
    Clients = State#test_state.clients,

    %% Send broadcast from each server
    BroadcastCount = lists:foldl(
        fun({ServerId, ServerPid, _Port}, Acc) ->
            %% Send broadcast message
            ServerPid ! {broadcast, <<"Test broadcast from server ", (integer_to_binary(ServerId))/binary>>},

            %% Count how many clients receive it
            ReceivedCount = lists:foldl(
                fun({ClientServerId, GunPid}, InnerAcc) ->
                    if
                        ClientServerId =:= ServerId ->
                            receive
                                {gun_ws, GunPid, {text, BroadcastMsg}} ->
                                    case jsx:decode(BroadcastMsg, [return_maps]) of
                                        #{<<"method">> := <<"notifications/message">>, <<"params">> := Params} ->
                                            ct:pal("  Client ~p received broadcast: ~p", [ClientServerId, Params]),
                                            InnerAcc + 1;
                                        _ ->
                                            InnerAcc
                                    end
                            after 1000 ->
                                InnerAcc
                            end;
                        true ->
                            InnerAcc
                    end
                end,
                0,
                Clients
            ),

            ct:pal("  Broadcast from server ~p received by ~p clients", [ServerId, ReceivedCount]),
            Acc + ReceivedCount
        end,
        0,
        Servers
    ),

    {ok, State#test_state{broadcast_count = BroadcastCount}}.

%%====================================================================
%% Results Reporting
%%====================================================================

report_results(State) ->
    Results = State#test_state.results,
    AllResults = lists:flatten(Results),

    %% Count successes and failures
    SuccessCount = length([1 || {_, [{_, _}, {status, ok}]} <- AllResults]),
    ErrorCount = length([1 || {_, [{_, _}, {status, error}]} <- AllResults]),
    TimeoutCount = length([1 || {_, [{_, _}, {status, timeout}]} <- AllResults]),

    %% Calculate latencies
    Latencies = [Latency || {_, [{latency, Latency}, {status, ok}]} <- AllResults],

    AvgLatency = case length(Latencies) of
        0 -> 0;
        N -> lists:sum(Latencies) / N
    end,

    MinLatency = case Latencies of
        [] -> 0;
        _ -> lists:min(Latencies)
    end,

    MaxLatency = case Latencies of
        [] -> 0;
        _ -> lists:max(Latencies)
    end,

    %% Calculate message rate
    TotalTime = (erlang:monotonic_time(millisecond) - State#test_state.start_time) / 1000,
    MessageRate = case TotalTime > 0 of
        true -> length(AllResults) / TotalTime;
        false -> 0
    end,

    SuccessRate = case length(AllResults) of
        0 -> 0.0;
        TotalMsgs -> (SuccessCount / TotalMsgs) * 100
    end,

    %% Print results
    ct:pal("~n=== Batch ~p Results (Servers ~p-~p) ===", [
        ?BATCH_ID, ?SERVER_START, ?SERVER_END
    ]),
    ct:pal("Servers Spawned: ~p/~p", [length(State#test_state.servers), ?TOTAL_SERVERS]),
    ct:pal("Clients Spawned: ~p/~p", [length(State#test_state.clients), ?TOTAL_CLIENTS]),
    ct:pal("Messages: ~p/~p", [length(AllResults), ?TOTAL_MESSAGES]),
    ct:pal("Avg Latency: ~.2f ms", [AvgLatency]),
    ct:pal("Min/Max: ~p/~p ms", [MinLatency, MaxLatency]),
    ct:pal("Message Rate: ~.2f msg/s", [MessageRate]),
    ct:pal("Broadcasts: ~p", [State#test_state.broadcast_count]),
    ct:pal("Success Rate: ~.2f%", [SuccessRate]),
    ct:pal("Errors: [success=~p, error=~p, timeout=~p]", [SuccessCount, ErrorCount, TimeoutCount]),

    ok.

%%====================================================================
%% Verification
%%====================================================================

verify_results(State) ->
    Results = State#test_state.results,
    AllResults = lists:flatten(Results),

    %% Verify we have results
    ?assert(length(AllResults) > 0),

    %% Verify success rate is at least 95%
    SuccessCount = length([1 || {_, [{_, _}, {status, ok}]} <- AllResults]),
    SuccessRate = (SuccessCount / length(AllResults)) * 100,
    ?assert(SuccessRate >= 95.0),

    %% Verify all servers spawned
    ?assertEqual(?TOTAL_SERVERS, length(State#test_state.servers)),

    %% Verify all clients spawned (allow some failures)
    ?assert(length(State#test_state.clients) >= (?TOTAL_CLIENTS * 0.8)),

    ok.
