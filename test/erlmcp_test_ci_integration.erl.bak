-module(erlmcp_test_ci_integration).

%% API exports
-export([
    start/0,
    stop/0,
    setup_github_integration/1,
    setup_jenkins_integration/1,
    setup_gitlab_integration/1,
    trigger_on_commit/2,
    report_status_check/3,
    send_notifications/2,
    export_for_ci/2
]).

%% Webhook handlers
-export([
    handle_github_webhook/2,
    handle_jenkins_webhook/2,
    handle_gitlab_webhook/2
]).

-include_lib("kernel/include/logger.hrl").

-record(ci_config, {
    platform,          % github | jenkins | gitlab | azure | circleci
    webhook_secret,
    api_token,
    repository,
    notifications = [],
    status_checks = true,
    auto_bisect = false
}).

-record(test_trigger, {
    event_type,         % push | pull_request | schedule
    branch_patterns = ["main", "master", "develop"],
    test_suites = [],
    conditions = #{}
}).

-record(notification_config, {
    type,              % slack | email | teams | discord
    endpoint,
    channels = [],
    conditions = []    % when to notify
}).

%%% ============================================================================
%%% API Functions
%%% ============================================================================

start() ->
    application:ensure_all_started(cowboy),
    application:ensure_all_started(gun),
    
    % Start webhook server
    start_webhook_server(),
    
    ?LOG_INFO("CI Integration service started"),
    ok.

stop() ->
    cowboy:stop_listener(ci_webhook_listener),
    ?LOG_INFO("CI Integration service stopped"),
    ok.

setup_github_integration(Config) ->
    CIConfig = #ci_config{
        platform = github,
        webhook_secret = maps:get(webhook_secret, Config),
        api_token = maps:get(api_token, Config),
        repository = maps:get(repository, Config),
        notifications = maps:get(notifications, Config, []),
        status_checks = maps:get(status_checks, Config, true),
        auto_bisect = maps:get(auto_bisect, Config, false)
    },
    
    % Register webhook endpoint
    register_github_webhook(CIConfig),
    
    % Store configuration
    ets:insert(ci_configs, {github, CIConfig}),
    
    ?LOG_INFO("GitHub integration configured for ~s", [maps:get(repository, Config)]),
    {ok, CIConfig}.

setup_jenkins_integration(Config) ->
    CIConfig = #ci_config{
        platform = jenkins,
        api_token = maps:get(api_token, Config),
        notifications = maps:get(notifications, Config, [])
    },
    
    ets:insert(ci_configs, {jenkins, CIConfig}),
    
    ?LOG_INFO("Jenkins integration configured"),
    {ok, CIConfig}.

setup_gitlab_integration(Config) ->
    CIConfig = #ci_config{
        platform = gitlab,
        webhook_secret = maps:get(webhook_secret, Config),
        api_token = maps:get(api_token, Config),
        repository = maps:get(repository, Config),
        notifications = maps:get(notifications, Config, [])
    },
    
    register_gitlab_webhook(CIConfig),
    ets:insert(ci_configs, {gitlab, CIConfig}),
    
    ?LOG_INFO("GitLab integration configured"),
    {ok, CIConfig}.

trigger_on_commit(Repository, CommitData) ->
    ?LOG_INFO("Triggering tests for commit ~s in ~s", 
              [maps:get(sha, CommitData, "unknown"), Repository]),
    
    % Create test trigger
    Trigger = #test_trigger{
        event_type = push,
        test_suites = [benchmark_suite, stress_suite, unit_suite],
        conditions = #{
            commit_sha => maps:get(sha, CommitData),
            branch => maps:get(branch, CommitData, "main"),
            repository => Repository
        }
    },
    
    % Start test execution
    spawn(fun() -> execute_triggered_tests(Trigger) end),
    
    {ok, triggered}.

report_status_check(Repository, CommitSha, Status) ->
    case ets:lookup(ci_configs, github) of
        [{github, Config}] ->
            send_github_status_check(Repository, CommitSha, Status, Config);
        [] ->
            ?LOG_WARNING("No GitHub configuration found for status check"),
            {error, no_config}
    end.

send_notifications(TestResults, NotificationType) ->
    Configs = get_all_notification_configs(),
    
    lists:foreach(fun(Config) ->
        case should_notify(TestResults, Config) of
            true ->
                send_notification(TestResults, Config);
            false ->
                ok
        end
    end, Configs),
    
    ok.

export_for_ci(TestResults, Format) ->
    case Format of
        junit ->
            export_junit_xml(TestResults);
        github_actions ->
            export_github_actions_format(TestResults);
        jenkins ->
            export_jenkins_format(TestResults);
        gitlab ->
            export_gitlab_format(TestResults);
        azure ->
            export_azure_format(TestResults);
        _ ->
            {error, unsupported_format}
    end.

%%% ============================================================================
%%% Webhook Server
%%% ============================================================================

start_webhook_server() ->
    % Create ETS table for configurations
    ets:new(ci_configs, [named_table, public, set]),
    
    Port = application:get_env(erlmcp, ci_webhook_port, 8090),
    
    Dispatch = cowboy_router:compile([
        {'_', [
            {"/webhook/github", github_webhook_handler, []},
            {"/webhook/jenkins", jenkins_webhook_handler, []},
            {"/webhook/gitlab", gitlab_webhook_handler, []},
            {"/health", health_check_handler, []}
        ]}
    ]),
    
    {ok, _} = cowboy:start_clear(ci_webhook_listener,
        [{port, Port}],
        #{env => #{dispatch => Dispatch}}
    ),
    
    ?LOG_INFO("CI webhook server started on port ~p", [Port]),
    ok.

handle_github_webhook(Event, Payload) ->
    ?LOG_INFO("Received GitHub webhook: ~s", [Event]),
    
    case Event of
        <<"push">> ->
            handle_push_event(Payload);
        <<"pull_request">> ->
            handle_pull_request_event(Payload);
        <<"workflow_run">> ->
            handle_workflow_run_event(Payload);
        _ ->
            ?LOG_INFO("Unhandled GitHub event: ~s", [Event]),
            {ok, ignored}
    end.

handle_jenkins_webhook(Event, Payload) ->
    ?LOG_INFO("Received Jenkins webhook: ~s", [Event]),
    
    case Event of
        <<"build_started">> ->
            handle_jenkins_build_started(Payload);
        <<"build_completed">> ->
            handle_jenkins_build_completed(Payload);
        _ ->
            {ok, ignored}
    end.

handle_gitlab_webhook(Event, Payload) ->
    ?LOG_INFO("Received GitLab webhook: ~s", [Event]),
    
    case Event of
        <<"push">> ->
            handle_gitlab_push_event(Payload);
        <<"merge_request">> ->
            handle_gitlab_merge_request_event(Payload);
        _ ->
            {ok, ignored}
    end.

%%% ============================================================================
%%% Event Handlers
%%% ============================================================================

handle_push_event(Payload) ->
    Repository = maps:get(<<"repository">>, Payload, #{}),
    RepoName = maps:get(<<"full_name">>, Repository, <<"unknown">>),
    
    Commits = maps:get(<<"commits">>, Payload, []),
    
    lists:foreach(fun(Commit) ->
        CommitSha = maps:get(<<"id">>, Commit),
        Branch = extract_branch_from_ref(maps:get(<<"ref">>, Payload, <<"refs/heads/main">>)),
        
        CommitData = #{
            sha => CommitSha,
            branch => Branch,
            message => maps:get(<<"message">>, Commit, <<>>),
            author => maps:get(<<"author">>, Commit, #{})
        },
        
        trigger_on_commit(binary_to_list(RepoName), CommitData)
    end, Commits),
    
    {ok, processed}.

handle_pull_request_event(Payload) ->
    Action = maps:get(<<"action">>, Payload),
    
    case Action of
        <<"opened">> ->
            trigger_pr_tests(Payload);
        <<"synchronize">> ->
            trigger_pr_tests(Payload);
        <<"reopened">> ->
            trigger_pr_tests(Payload);
        _ ->
            {ok, ignored}
    end.

handle_workflow_run_event(Payload) ->
    WorkflowRun = maps:get(<<"workflow_run">>, Payload, #{}),
    Status = maps:get(<<"status">>, WorkflowRun),
    Conclusion = maps:get(<<"conclusion">>, WorkflowRun),
    
    case {Status, Conclusion} of
        {<<"completed">>, <<"failure">>} ->
            trigger_failure_analysis(WorkflowRun);
        {<<"completed">>, <<"success">>} ->
            update_success_metrics(WorkflowRun);
        _ ->
            {ok, ignored}
    end.

trigger_pr_tests(Payload) ->
    PullRequest = maps:get(<<"pull_request">>, Payload, #{}),
    Head = maps:get(<<"head">>, PullRequest, #{}),
    CommitSha = maps:get(<<"sha">>, Head),
    
    Repository = maps:get(<<"repository">>, Payload, #{}),
    RepoName = maps:get(<<"full_name">>, Repository),
    
    % Trigger comprehensive test suite for PR
    Trigger = #test_trigger{
        event_type = pull_request,
        test_suites = [unit_suite, integration_suite, benchmark_suite],
        conditions = #{
            commit_sha => CommitSha,
            pr_number => maps:get(<<"number">>, PullRequest),
            repository => binary_to_list(RepoName)
        }
    },
    
    spawn(fun() -> execute_triggered_tests(Trigger) end),
    {ok, triggered}.

%%% ============================================================================
%%% Test Execution
%%% ============================================================================

execute_triggered_tests(Trigger) ->
    StartTime = erlang:timestamp(),
    Repository = maps:get(repository, Trigger#test_trigger.conditions),
    CommitSha = maps:get(commit_sha, Trigger#test_trigger.conditions),
    
    ?LOG_INFO("Executing triggered tests for ~s@~s", [Repository, CommitSha]),
    
    % Report pending status
    report_status_check(Repository, CommitSha, #{
        state => pending,
        description => <<"Running ErlMCP test suite">>,
        context => <<"erlmcp/tests">>
    }),
    
    try
        % Execute test suites
        Results = execute_test_suites(Trigger#test_trigger.test_suites),
        
        % Calculate overall status
        OverallStatus = calculate_overall_status(Results),
        Duration = timer:now_diff(erlang:timestamp(), StartTime) / 1000000,
        
        % Report final status
        StatusReport = #{
            state => case OverallStatus of
                success -> success;
                _ -> failure
            end,
            description => format_status_description(Results, Duration),
            context => <<"erlmcp/tests">>,
            target_url => generate_results_url(Results)
        },
        
        report_status_check(Repository, CommitSha, StatusReport),
        
        % Send notifications if needed
        send_notifications(Results, Trigger#test_trigger.event_type),
        
        % Export results in CI formats
        export_ci_results(Results, Trigger),
        
        ?LOG_INFO("Test execution completed with status: ~p", [OverallStatus]),
        {ok, OverallStatus, Results}
        
    catch
        Class:Error:Stacktrace ->
            % Report error status
            report_status_check(Repository, CommitSha, #{
                state => error,
                description => <<"Test execution failed">>,
                context => <<"erlmcp/tests">>
            }),
            
            ?LOG_ERROR("Test execution failed: ~p:~p~n~p", 
                      [Class, Error, Stacktrace]),
            {error, {Class, Error, Stacktrace}}
    end.

execute_test_suites(Suites) ->
    Results = lists:map(fun(Suite) ->
        case erlmcp_test_orchestrator:run_test_suite(Suite) of
            {ok, Result} -> Result;
            {error, Reason} -> 
                #{
                    suite => Suite,
                    status => error,
                    error => Reason,
                    timestamp => calendar:universal_time()
                }
        end
    end, Suites),
    
    Results.

calculate_overall_status(Results) ->
    HasErrors = lists:any(fun(Result) ->
        maps:get(status, Result, success) =:= error orelse
        maps:get(failed_tests, Result, 0) > 0
    end, Results),
    
    case HasErrors of
        true -> failure;
        false -> success
    end.

format_status_description(Results, Duration) ->
    TotalTests = lists:sum([maps:get(total_tests, R, 0) || R <- Results]),
    PassedTests = lists:sum([maps:get(passed_tests, R, 0) || R <- Results]),
    FailedTests = TotalTests - PassedTests,
    
    case FailedTests of
        0 ->
            io_lib:format("All ~p tests passed in ~.1fs", [TotalTests, Duration]);
        _ ->
            io_lib:format("~p/~p tests failed in ~.1fs", [FailedTests, TotalTests, Duration])
    end.

generate_results_url(_Results) ->
    % Would generate URL to detailed test results
    <<"https://ci.example.com/erlmcp/test-results">>.

%%% ============================================================================
%%% Status Check Integration
%%% ============================================================================

send_github_status_check(Repository, CommitSha, Status, Config) ->
    Url = io_lib:format("https://api.github.com/repos/~s/statuses/~s", 
                       [Repository, CommitSha]),
    
    Headers = [
        {<<"Authorization">>, iolist_to_binary(["token ", Config#ci_config.api_token])},
        {<<"Content-Type">>, <<"application/json">>},
        {<<"User-Agent">>, <<"ErlMCP-CI/1.0">>}
    ],
    
    Body = jsx:encode(Status),
    
    case gun_request(post, Url, Headers, Body) of
        {ok, 201, _RespHeaders, _RespBody} ->
            ?LOG_INFO("GitHub status check sent successfully"),
            ok;
        {ok, StatusCode, _RespHeaders, RespBody} ->
            ?LOG_ERROR("GitHub status check failed: ~p - ~s", [StatusCode, RespBody]),
            {error, {http_error, StatusCode, RespBody}};
        {error, Reason} ->
            ?LOG_ERROR("Failed to send GitHub status check: ~p", [Reason]),
            {error, Reason}
    end.

%%% ============================================================================
%%% Notification System
%%% ============================================================================

get_all_notification_configs() ->
    AllConfigs = ets:tab2list(ci_configs),
    
    lists:flatmap(fun({_Platform, Config}) ->
        Config#ci_config.notifications
    end, AllConfigs).

should_notify(TestResults, NotificationConfig) ->
    Conditions = NotificationConfig#notification_config.conditions,
    
    % Check if any condition matches
    lists:any(fun(Condition) ->
        check_notification_condition(TestResults, Condition)
    end, Conditions).

check_notification_condition(TestResults, Condition) ->
    case Condition of
        on_failure ->
            lists:any(fun(Result) ->
                maps:get(failed_tests, Result, 0) > 0
            end, TestResults);
        on_success ->
            lists:all(fun(Result) ->
                maps:get(failed_tests, Result, 0) =:= 0
            end, TestResults);
        always ->
            true;
        {failure_threshold, Threshold} ->
            TotalFailed = lists:sum([maps:get(failed_tests, R, 0) || R <- TestResults]),
            TotalFailed >= Threshold;
        _ ->
            false
    end.

send_notification(TestResults, NotificationConfig) ->
    case NotificationConfig#notification_config.type of
        slack ->
            send_slack_notification(TestResults, NotificationConfig);
        email ->
            send_email_notification(TestResults, NotificationConfig);
        teams ->
            send_teams_notification(TestResults, NotificationConfig);
        discord ->
            send_discord_notification(TestResults, NotificationConfig);
        _ ->
            ?LOG_WARNING("Unsupported notification type: ~p", 
                        [NotificationConfig#notification_config.type])
    end.

send_slack_notification(TestResults, Config) ->
    Webhook = Config#notification_config.endpoint,
    
    Summary = calculate_test_summary(TestResults),
    Color = case maps:get(failed_tests, Summary, 0) of
        0 -> <<"good">>;
        _ -> <<"danger">>
    end,
    
    Message = #{
        text => <<"ErlMCP Test Results">>,
        attachments => [#{
            color => Color,
            title => <<"Test Summary">>,
            fields => [
                #{
                    title => <<"Total Tests">>,
                    value => maps:get(total_tests, Summary, 0),
                    short => true
                },
                #{
                    title => <<"Passed">>,
                    value => maps:get(passed_tests, Summary, 0),
                    short => true
                },
                #{
                    title => <<"Failed">>,
                    value => maps:get(failed_tests, Summary, 0),
                    short => true
                },
                #{
                    title => <<"Success Rate">>,
                    value => io_lib:format("~.1f%", [maps:get(success_rate, Summary, 0) * 100]),
                    short => true
                }
            ]
        }]
    },
    
    send_webhook_notification(Webhook, jsx:encode(Message)).

send_email_notification(TestResults, Config) ->
    % Placeholder for email notification
    ?LOG_INFO("Email notification would be sent here"),
    ok.

send_teams_notification(TestResults, Config) ->
    % Placeholder for Microsoft Teams notification
    ?LOG_INFO("Teams notification would be sent here"),
    ok.

send_discord_notification(TestResults, Config) ->
    % Placeholder for Discord notification
    ?LOG_INFO("Discord notification would be sent here"),
    ok.

send_webhook_notification(Webhook, Payload) ->
    case gun_request(post, Webhook, [], Payload) of
        {ok, 200, _Headers, _Body} ->
            ?LOG_INFO("Webhook notification sent successfully"),
            ok;
        {ok, StatusCode, _Headers, Body} ->
            ?LOG_ERROR("Webhook notification failed: ~p - ~s", [StatusCode, Body]),
            {error, {http_error, StatusCode, Body}};
        {error, Reason} ->
            ?LOG_ERROR("Failed to send webhook notification: ~p", [Reason]),
            {error, Reason}
    end.

%%% ============================================================================
%%% CI Format Exports
%%% ============================================================================

export_junit_xml(TestResults) ->
    TestSuites = group_results_by_suite(TestResults),
    
    XmlDoc = [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n",
        "<testsuites>\n",
        lists:map(fun({Suite, Results}) ->
            export_junit_testsuite(Suite, Results)
        end, maps:to_list(TestSuites)),
        "</testsuites>\n"
    ],
    
    OutputFile = "test_results.xml",
    case file:write_file(OutputFile, XmlDoc) of
        ok -> 
            ?LOG_INFO("JUnit XML report exported to ~s", [OutputFile]),
            {ok, OutputFile};
        {error, Reason} ->
            ?LOG_ERROR("Failed to export JUnit XML: ~p", [Reason]),
            {error, Reason}
    end.

export_junit_testsuite(Suite, Results) ->
    TotalTests = length(Results),
    Failures = length([R || R <- Results, maps:get(status, R) =:= failed]),
    Errors = length([R || R <- Results, maps:get(status, R) =:= error]),
    TotalTime = lists:sum([maps:get(duration, R, 0) || R <- Results]),
    
    [
        io_lib:format("  <testsuite name=\"~s\" tests=\"~p\" failures=\"~p\" errors=\"~p\" time=\"~.3f\">\n",
                     [Suite, TotalTests, Failures, Errors, TotalTime / 1000]),
        lists:map(fun(Result) ->
            export_junit_testcase(Result)
        end, Results),
        "  </testsuite>\n"
    ].

export_junit_testcase(Result) ->
    Name = maps:get(test_name, Result, unknown),
    Duration = maps:get(duration, Result, 0) / 1000,
    Status = maps:get(status, Result, unknown),
    
    BaseTestCase = io_lib:format("    <testcase name=\"~s\" time=\"~.3f\"", [Name, Duration]),
    
    case Status of
        passed ->
            [BaseTestCase, "/>\n"];
        failed ->
            Details = maps:get(details, Result, "Test failed"),
            [BaseTestCase, ">\n",
             "      <failure message=\"Test failed\">", format_xml_cdata(Details), "</failure>\n",
             "    </testcase>\n"];
        error ->
            Details = maps:get(details, Result, "Test error"),
            [BaseTestCase, ">\n",
             "      <error message=\"Test error\">", format_xml_cdata(Details), "</error>\n",
             "    </testcase>\n"]
    end.

export_github_actions_format(TestResults) ->
    Summary = calculate_test_summary(TestResults),
    
    % Generate GitHub Actions summary format
    Summary = [
        "## Test Results\n\n",
        io_lib:format("- **Total Tests:** ~p\n", [maps:get(total_tests, Summary, 0)]),
        io_lib:format("- **Passed:** ~p\n", [maps:get(passed_tests, Summary, 0)]),
        io_lib:format("- **Failed:** ~p\n", [maps:get(failed_tests, Summary, 0)]),
        io_lib:format("- **Success Rate:** ~.1f%\n\n", [maps:get(success_rate, Summary, 0) * 100]),
        
        "### Failed Tests\n\n",
        lists:map(fun(Result) ->
            case maps:get(status, Result) of
                failed ->
                    io_lib:format("- `~s`: ~s\n", [
                        maps:get(test_name, Result),
                        maps:get(details, Result, "Failed")
                    ]);
                _ -> ""
            end
        end, TestResults)
    ],
    
    OutputFile = "github_summary.md",
    case file:write_file(OutputFile, Summary) of
        ok -> {ok, OutputFile};
        {error, Reason} -> {error, Reason}
    end.

export_jenkins_format(TestResults) ->
    % Jenkins format (similar to JUnit but with additional metadata)
    export_junit_xml(TestResults).

export_gitlab_format(TestResults) ->
    % GitLab format
    Summary = calculate_test_summary(TestResults),
    
    GitLabReport = jsx:encode(#{
        total_tests => maps:get(total_tests, Summary, 0),
        passed_tests => maps:get(passed_tests, Summary, 0),
        failed_tests => maps:get(failed_tests, Summary, 0),
        success_rate => maps:get(success_rate, Summary, 0),
        test_results => [format_result_for_gitlab(R) || R <- TestResults]
    }),
    
    OutputFile = "gitlab_report.json",
    case file:write_file(OutputFile, GitLabReport) of
        ok -> {ok, OutputFile};
        {error, Reason} -> {error, Reason}
    end.

export_azure_format(TestResults) ->
    % Azure DevOps format
    AzureReport = jsx:encode(#{
        results => [format_result_for_azure(R) || R <- TestResults],
        summary => calculate_test_summary(TestResults)
    }),
    
    OutputFile = "azure_report.json",
    case file:write_file(OutputFile, AzureReport) of
        ok -> {ok, OutputFile};
        {error, Reason} -> {error, Reason}
    end.

%%% ============================================================================
%%% Utility Functions
%%% ============================================================================

register_github_webhook(Config) ->
    % Would register webhook with GitHub API
    ?LOG_INFO("GitHub webhook registration would happen here"),
    ok.

register_gitlab_webhook(Config) ->
    % Would register webhook with GitLab API
    ?LOG_INFO("GitLab webhook registration would happen here"),
    ok.

extract_branch_from_ref(Ref) ->
    case binary:split(Ref, <<"/">>, [global]) of
        [<<"refs">>, <<"heads">> | BranchParts] ->
            binary:list_to_bin(binary:split(binary:list_to_bin(BranchParts), <<"/">>, [global]));
        _ ->
            <<"main">>
    end.

trigger_failure_analysis(WorkflowRun) ->
    ?LOG_INFO("Triggering failure analysis for workflow run"),
    % Would trigger automated failure analysis
    ok.

update_success_metrics(WorkflowRun) ->
    ?LOG_INFO("Updating success metrics"),
    % Would update success metrics
    ok.

export_ci_results(Results, Trigger) ->
    % Export in multiple formats for different CI systems
    spawn(fun() -> export_junit_xml(Results) end),
    spawn(fun() -> export_github_actions_format(Results) end),
    spawn(fun() -> export_gitlab_format(Results) end),
    ok.

gun_request(Method, Url, Headers, Body) ->
    % Simplified HTTP client implementation
    ?LOG_INFO("HTTP ~p request to ~s", [Method, Url]),
    
    % This would use gun or httpc for actual HTTP requests
    {ok, 200, [], <<"{\"message\":\"success\"}">>}.

calculate_test_summary(TestResults) ->
    TotalTests = length(TestResults),
    PassedTests = length([R || R <- TestResults, maps:get(status, R) =:= passed]),
    FailedTests = TotalTests - PassedTests,
    SuccessRate = case TotalTests of
        0 -> 0;
        _ -> PassedTests / TotalTests
    end,
    
    #{
        total_tests => TotalTests,
        passed_tests => PassedTests,
        failed_tests => FailedTests,
        success_rate => SuccessRate
    }.

group_results_by_suite(TestResults) ->
    lists:foldl(fun(Result, Acc) ->
        Suite = maps:get(suite, Result, unknown),
        SuiteResults = maps:get(Suite, Acc, []),
        maps:put(Suite, [Result | SuiteResults], Acc)
    end, #{}, TestResults).

format_xml_cdata(Data) ->
    % Simple CDATA formatting
    io_lib:format("<![CDATA[~p]]>", [Data]).

format_result_for_gitlab(Result) ->
    #{
        name => maps:get(test_name, Result),
        status => maps:get(status, Result),
        duration => maps:get(duration, Result, 0)
    }.

format_result_for_azure(Result) ->
    #{
        testName => maps:get(test_name, Result),
        outcome => maps:get(status, Result),
        durationInMs => maps:get(duration, Result, 0)
    }.

handle_jenkins_build_started(Payload) ->
    ?LOG_INFO("Jenkins build started"),
    ok.

handle_jenkins_build_completed(Payload) ->
    ?LOG_INFO("Jenkins build completed"),
    ok.

handle_gitlab_push_event(Payload) ->
    ?LOG_INFO("GitLab push event"),
    ok.

handle_gitlab_merge_request_event(Payload) ->
    ?LOG_INFO("GitLab merge request event"),
    ok.