%% =============================================================================
%% Gap #35: WebSocket Fragmented Messages (RFC 6455) - Compliance Tests
%% =============================================================================
%%
%% This test module verifies full RFC 6455 WebSocket fragmentation compliance:
%%
%% 1. Fragment reassembly with FIN bit tracking
%% 2. Multiple continuation frames
%% 3. Fragment timeout handling (30 seconds)
%% 4. Message validation after reassembly
%% 5. Concurrent fragmented messages
%% 6. Fragment buffer management
%%
%% Reference: RFC 6455 Sections 5.4 and 5.6
%% MCP 2025-11-25 Specification: Streamable WebSocket Transport
%% =============================================================================

-module(erlmcp_gap35_websocket_fragmentation_tests).

-include_lib("eunit/include/eunit.hrl").

%%====================================================================
%% Test Setup and Teardown
%%====================================================================

setup() ->
    {ok, _} = application:ensure_all_started(erlmcp),
    application:set_env(erlmcp, max_ws_message_size, 16777216),
    application:set_env(erlmcp, strict_delimiter_check, true),
    application:set_env(erlmcp, validate_utf8, true),
    ok.

cleanup(_) ->
    application:unset_env(erlmcp, max_ws_message_size),
    application:unset_env(erlmcp, strict_delimiter_check),
    application:unset_env(erlmcp, validate_utf8),
    ok.

%%====================================================================
%% Test Groups
%%====================================================================

websocket_fragmentation_test_() ->
    {setup,
        fun setup/0,
        fun cleanup/1,
        [
            {"RFC 6455 Fragment Reassembly", [
                ?_test(test_two_part_fragment_with_fin()),
                ?_test(test_multi_part_fragmentation()),
                ?_test(test_continuation_frame_sequence()),
                ?_test(test_fin_bit_completion()),
                ?_test(test_single_frame_no_fragmentation())
            ]},
            {"Fragment Buffer Management", [
                ?_test(test_incomplete_fragment_buffering()),
                ?_test(test_buffer_accumulation()),
                ?_test(test_buffer_reset_on_complete()),
                ?_test(test_buffer_state_tracking()),
                ?_test(test_large_fragment_buffering())
            ]},
            {"Fragment Timeout Handling (30 seconds)", [
                ?_test(test_fragment_timeout_detection()),
                ?_test(test_timeout_error_response()),
                ?_test(test_partial_message_timeout()),
                ?_test(test_timeout_cleanup()),
                ?_test(test_concurrent_fragment_timeouts())
            ]},
            {"Message Validation After Reassembly", [
                ?_test(test_reassembled_utf8_validation()),
                ?_test(test_reassembled_json_parsing()),
                ?_test(test_reassembled_delimiter_validation()),
                ?_test(test_reassembled_size_validation()),
                ?_test(test_reassembled_content_integrity())
            ]},
            {"Concurrent Fragmented Messages", [
                ?_test(test_interleaved_fragments()),
                ?_test(test_multiple_clients_fragments()),
                ?_test(test_fragment_order_preservation()),
                ?_test(test_independent_fragment_buffers()),
                ?_test(test_parallel_reassembly())
            ]},
            {"Edge Cases and Error Handling", [
                ?_test(test_empty_fragments()),
                ?_test(test_max_size_fragments()),
                ?_test(test_invalid_utf8_in_fragments()),
                ?_test(test_parse_error_in_reassembled()),
                ?_test(test_delimiter_spanning_fragments())
            ]},
            {"WebSocket Frame Opcodes (RFC 6455)", [
                ?_test(test_text_frame_opcode()),
                ?_test(test_continuation_frame_opcode()),
                ?_test(test_binary_frame_rejection()),
                ?_test(test_control_frames_during_fragmentation()),
                ?_test(test_close_frame_during_fragmentation())
            ]},
            {"Integration Tests", [
                ?_test(test_complete_fragmented_request_cycle()),
                ?_test(test_fragmented_json_rpc_message()),
                ?_test(test_large_payload_fragmentation()),
                ?_test(test_rapid_fragmented_stream()),
                ?_test(test_fragmentation_with_backpressure())
            ]}
        ]
    }.

%%====================================================================
%% RFC 6455 Fragment Reassembly Tests
%%====================================================================

test_two_part_fragment_with_fin() ->
    %% First frame (FIN=0): contains first part of JSON
    Fragment1 = <<"{\n">>,
    %% Second frame (FIN=1): contains remaining JSON + newline
    Fragment2 = <<"\"jsonrpc\":\"2.0\"\n">>,

    State1 = #state{
        fragment_buffer = undefined,
        fragment_start_time = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    %% Simulate first fragment arrival
    {ok, State2} = erlmcp_transport_ws:handle_text_frame(Fragment1, State1),
    ?assert(State2#state.fragment_buffer =/= undefined),

    %% Simulate second fragment with FIN bit (marked by final newline)
    {ok, State3} = erlmcp_transport_ws:handle_text_frame(Fragment2, State2),
    %% After FIN, buffer should be cleared
    ?assertEqual(undefined, State3#state.fragment_buffer).

test_multi_part_fragmentation() ->
    %% Three-part message fragmentation
    Parts = [
        <<"{\n">>,
        <<"\"method\":\"tools/list\",\n">>,
        <<"\"id\":1\n">>
    ],

    State0 = #state{
        fragment_buffer = undefined,
        fragment_start_time = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    %% Process all parts sequentially
    State1 = process_fragments(Parts, State0),
    %% Final state should have no buffer (message complete)
    ?assertEqual(undefined, State1#state.fragment_buffer).

test_continuation_frame_sequence() ->
    %% RFC 6455: Continuation frames must follow initial text frame
    %% Initial text frame (opcode=1, FIN=0)
    Initial = <<"[{\"id\":\n">>,
    %% Continuation frame 1 (opcode=0, FIN=0)
    Cont1 = <<"\"abc\",\n">>,
    %% Continuation frame 2 (opcode=0, FIN=1)
    Cont2 = <<"\"value\":123}\n">>,

    State0 = #state{
        fragment_buffer = undefined,
        fragment_start_time = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Initial, State0),
    {ok, State2} = erlmcp_transport_ws:handle_text_frame(Cont1, State1),
    {ok, State3} = erlmcp_transport_ws:handle_text_frame(Cont2, State2),

    %% Final continuation with newline should complete reassembly
    ?assertEqual(undefined, State3#state.fragment_buffer).

test_fin_bit_completion() ->
    %% FIN bit indicates final fragment
    %% In our implementation, newline delimiter signals completion
    Incomplete = <<"partial message">>,
    Complete = <<"partial message\n">>,

    State0 = #state{
        fragment_buffer = undefined,
        fragment_start_time = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    %% Incomplete (no newline)
    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Incomplete, State0),
    ?assertEqual(Incomplete, State1#state.fragment_buffer),

    %% Complete with FIN (newline)
    {ok, State2} = erlmcp_transport_ws:handle_text_frame(Complete, State1),
    ?assertEqual(undefined, State2#state.fragment_buffer).

test_single_frame_no_fragmentation() ->
    %% Single complete frame (no fragmentation needed)
    Message = <<"{\n">>,

    State0 = #state{
        fragment_buffer = undefined,
        fragment_start_time = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Message, State0),
    %% Should not buffer (message complete with delimiter)
    case State1#state.strict_delimiter_check of
        true ->
            ?assertEqual(undefined, State1#state.fragment_buffer);
        false ->
            ok
    end.

%%====================================================================
%% Fragment Buffer Management Tests
%%====================================================================

test_incomplete_fragment_buffering() ->
    %% Fragment without delimiter should be buffered
    Fragment = <<"incomplete">>,

    State0 = #state{
        fragment_buffer = undefined,
        fragment_start_time = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Fragment, State0),
    ?assertEqual(Fragment, State1#state.fragment_buffer),
    ?assert(State1#state.fragment_start_time =/= undefined).

test_buffer_accumulation() ->
    %% Multiple fragments should accumulate in buffer
    Fragment1 = <<"part1">>,
    Fragment2 = <<"part2">>,

    State0 = #state{
        fragment_buffer = undefined,
        fragment_start_time = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Fragment1, State0),
    {ok, State2} = erlmcp_transport_ws:handle_text_frame(Fragment2, State1),

    Expected = <<Fragment1/binary, Fragment2/binary>>,
    ?assertEqual(Expected, State2#state.fragment_buffer).

test_buffer_reset_on_complete() ->
    %% Buffer should be cleared when message completes
    Fragment1 = <<"incomplete">>,
    Fragment2 = <<"\n">>,  %% Complete with delimiter

    State0 = #state{
        fragment_buffer = undefined,
        fragment_start_time = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Fragment1, State0),
    {ok, State2} = erlmcp_transport_ws:handle_text_frame(Fragment2, State1),

    %% Buffer should be reset
    ?assertEqual(undefined, State2#state.fragment_buffer),
    ?assertEqual(undefined, State2#state.fragment_start_time).

test_buffer_state_tracking() ->
    %% fragment_start_time should be set when buffering begins
    Fragment1 = <<"start">>,

    State0 = #state{
        fragment_buffer = undefined,
        fragment_start_time = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Fragment1, State0),
    ?assert(State1#state.fragment_start_time =/= undefined),

    %% Start time should not change for additional fragments
    StartTime1 = State1#state.fragment_start_time,
    timer:sleep(10),
    {ok, State2} = erlmcp_transport_ws:handle_text_frame(<<"more">>, State1),
    StartTime2 = State2#state.fragment_start_time,

    ?assertEqual(StartTime1, StartTime2).

test_large_fragment_buffering() ->
    %% Buffer should handle large fragments
    LargeFragment = binary:copy(<<"x">>, 100000),

    State0 = #state{
        fragment_buffer = undefined,
        fragment_start_time = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true,
        max_message_size = 16777216
    },

    {ok, State1} = erlmcp_transport_ws:handle_text_frame(LargeFragment, State0),
    ?assertEqual(LargeFragment, State1#state.fragment_buffer).

%%====================================================================
%% Fragment Timeout Handling Tests (30 seconds)
%%====================================================================

test_fragment_timeout_detection() ->
    %% Check that timeout is properly detected
    State0 = #state{
        fragment_buffer = <<"incomplete">>,
        fragment_start_time = erlang:monotonic_time() - 31000,  %% > 30 seconds
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    Result = erlmcp_transport_ws:check_fragment_timeout(State0),
    ?assertEqual({error, timeout}, Result).

test_timeout_error_response() ->
    %% Timeout should result in connection close with error code
    Fragment1 = <<"incomplete">>,
    Fragment2 = <<"data">>,

    State0 = #state{
        fragment_buffer = undefined,
        fragment_start_time = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true,
        session_id = <<"test_session">>,
        transport_id = <<"test_transport">>
    },

    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Fragment1, State0),

    %% Manually set timeout
    State2 = State1#state{
        fragment_start_time = erlang:monotonic_time() - 31000
    },

    %% Next fragment should trigger timeout
    Result = erlmcp_transport_ws:handle_text_frame(Fragment2, State2),
    ?assertEqual({error, fragment_timeout, State2}, Result).

test_partial_message_timeout() ->
    %% Partial message sitting in buffer for > 30 seconds should timeout
    State0 = #state{
        fragment_buffer = <<"very_long_incomplete_message">>,
        fragment_start_time = erlang:monotonic_time() - 35000,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    Result = erlmcp_transport_ws:check_fragment_timeout(State0),
    ?assertEqual({error, timeout}, Result).

test_timeout_cleanup() ->
    %% After timeout error, buffer should be cleared
    State0 = #state{
        fragment_buffer = <<"data">>,
        fragment_start_time = erlang:monotonic_time() - 31000,
        strict_delimiter_check = true,
        validate_utf8 = true,
        session_id = <<"test">>,
        transport_id = <<"test">>
    },

    %% Manually trigger cleanup logic
    NewState = State0#state{
        fragment_buffer = undefined,
        fragment_start_time = undefined
    },

    ?assertEqual(undefined, NewState#state.fragment_buffer),
    ?assertEqual(undefined, NewState#state.fragment_start_time).

test_concurrent_fragment_timeouts() ->
    %% Multiple concurrent fragments should have independent timeouts
    State1 = #state{
        fragment_buffer = <<"fragment1">>,
        fragment_start_time = erlang:monotonic_time() - 31000  %% Timeout
    },

    State2 = #state{
        fragment_buffer = <<"fragment2">>,
        fragment_start_time = erlang:monotonic_time() - 5000   %% OK
    },

    Result1 = erlmcp_transport_ws:check_fragment_timeout(State1),
    Result2 = erlmcp_transport_ws:check_fragment_timeout(State2),

    ?assertEqual({error, timeout}, Result1),
    ?assertEqual(ok, Result2).

%%====================================================================
%% Message Validation After Reassembly Tests
%%====================================================================

test_reassembled_utf8_validation() ->
    %% Reassembled message must be valid UTF-8
    Fragment1 = <<"Hello, ">>,
    Fragment2 = <<"World!\\n"/utf8>>,

    Reassembled = <<Fragment1/binary, Fragment2/binary>>,
    Result = erlmcp_transport_ws:validate_utf8(Reassembled),

    ?assertEqual(ok, Result).

test_reassembled_json_parsing() ->
    %% Reassembled message must be valid JSON-RPC
    Fragment1 = <<"{\n">>,
    Fragment2 = <<"\"jsonrpc\":\"2.0\",\n">>,
    Fragment3 = <<"\"method\":\"test\",\n">>,
    Fragment4 = <<"\"id\":1\n">>,

    Reassembled = <<Fragment1/binary, Fragment2/binary, Fragment3/binary, Fragment4/binary>>,

    case jsx:decode(Reassembled, [return_maps]) of
        {error, _} ->
            ?fail("JSON parse error");
        Decoded ->
            ?assert(is_map(Decoded)),
            ?assertEqual(<<"2.0">>, maps:get(<<"jsonrpc">>, Decoded))
    end.

test_reassembled_delimiter_validation() ->
    %% Reassembled message should maintain delimiter requirements
    Fragment1 = <<"msg1">>,
    Fragment2 = <<"\n">>,

    Reassembled = <<Fragment1/binary, Fragment2/binary>>,

    %% Should contain the delimiter
    ?assert(binary:match(Reassembled, <<"\n">>) =/= nomatch).

test_reassembled_size_validation() ->
    %% Reassembled message size must be within limits
    LargeFragment1 = binary:copy(<<"x">>, 1000000),
    Fragment2 = <<"\n">>,

    Reassembled = <<LargeFragment1/binary, Fragment2/binary>>,

    Result = erlmcp_transport_ws:validate_message_size(Reassembled),

    %% Should be under 16MB default
    ?assertMatch({ok, _}, Result).

test_reassembled_content_integrity() ->
    %% Reassembled message content must be identical to non-fragmented
    CompleteMessage = jsx:encode(#{
        <<"jsonrpc">> => <<"2.0">>,
        <<"method">> => <<"tools/list">>,
        <<"id">> => 1
    }),

    %% Split into fragments
    Part1 = binary:part(CompleteMessage, {0, byte_size(CompleteMessage) div 3}),
    Part2 = binary:part(CompleteMessage, {byte_size(CompleteMessage) div 3,
                                          byte_size(CompleteMessage) div 3}),
    Part3 = binary:part(CompleteMessage, {2 * byte_size(CompleteMessage) div 3,
                                          byte_size(CompleteMessage) - 2 * byte_size(CompleteMessage) div 3}),

    Reassembled = <<Part1/binary, Part2/binary, Part3/binary>>,

    ?assertEqual(CompleteMessage, Reassembled).

%%====================================================================
%% Concurrent Fragmented Messages Tests
%%====================================================================

test_interleaved_fragments() ->
    %% Fragments from different messages should not interfere
    %% (handled by per-connection state)
    State1 = #state{
        fragment_buffer = <<"msg1_fragment">>,
        fragment_start_time = erlang:monotonic_time()
    },

    State2 = #state{
        fragment_buffer = undefined,
        fragment_start_time = undefined
    },

    %% Each state should maintain independent buffer
    ?assertEqual(<<"msg1_fragment">>, State1#state.fragment_buffer),
    ?assertEqual(undefined, State2#state.fragment_buffer).

test_multiple_clients_fragments() ->
    %% Multiple clients with fragmented messages
    Client1State = #state{
        fragment_buffer = <<"client1_data">>,
        session_id = <<"session1">>
    },

    Client2State = #state{
        fragment_buffer = <<"client2_data">>,
        session_id = <<"session2">>
    },

    %% Each client's buffer should be independent
    ?assertNotEqual(Client1State#state.fragment_buffer,
                   Client2State#state.fragment_buffer).

test_fragment_order_preservation() ->
    %% Fragment order must be preserved
    Fragment1 = <<"first">>,
    Fragment2 = <<"second">>,
    Fragment3 = <<"third\n">>,

    State0 = #state{fragment_buffer = undefined, fragment_start_time = undefined},
    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Fragment1, State0),
    {ok, State2} = erlmcp_transport_ws:handle_text_frame(Fragment2, State1),
    {ok, _State3} = erlmcp_transport_ws:handle_text_frame(Fragment3, State2),

    Expected = <<"firstsecondthird">>,
    ?assertEqual(Expected, State2#state.fragment_buffer).

test_independent_fragment_buffers() ->
    %% Each WebSocket connection should have independent buffer
    Buffers = [
        #state{fragment_buffer = <<"data1">>, session_id = <<"s1">>},
        #state{fragment_buffer = <<"data2">>, session_id = <<"s2">>},
        #state{fragment_buffer = <<"data3">>, session_id = <<"s3">>}
    ],

    Ids = [S#state.session_id || S <- Buffers],
    UniqueIds = lists:usort(Ids),

    %% All IDs should be unique
    ?assertEqual(length(Ids), length(UniqueIds)).

test_parallel_reassembly() ->
    %% Parallel fragment reassembly should work correctly
    %% This is more of an integration test
    Msg1 = <<"Message 1\n">>,
    Msg2 = <<"Message 2\n">>,

    State0 = #state{
        fragment_buffer = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Msg1, State0),
    {ok, State2} = erlmcp_transport_ws:handle_text_frame(Msg2, State1),

    ?assertEqual(undefined, State2#state.fragment_buffer).

%%====================================================================
%% Edge Cases and Error Handling Tests
%%====================================================================

test_empty_fragments() ->
    %% Empty fragments should be handled gracefully
    Fragment1 = <<>>,
    Fragment2 = <<"data\n">>,

    State0 = #state{
        fragment_buffer = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Fragment1, State0),
    {ok, _State2} = erlmcp_transport_ws:handle_text_frame(Fragment2, State1),

    %% Should complete normally
    ?assert(true).

test_max_size_fragments() ->
    %% Fragments at size limit should be accepted
    MaxSize = 16777216,
    Fragment = binary:copy(<<"x">>, MaxSize),

    Result = erlmcp_transport_ws:validate_message_size(Fragment),
    ?assertEqual({ok, MaxSize}, Result).

test_invalid_utf8_in_fragments() ->
    %% Invalid UTF-8 in reassembled message should be detected
    InvalidSeq = <<195, 40>>,  %% Incomplete UTF-8

    Result = erlmcp_transport_ws:validate_utf8(InvalidSeq),
    ?assertEqual({error, invalid_utf8}, Result).

test_parse_error_in_reassembled() ->
    %% Invalid JSON in reassembled message should be caught
    Fragment1 = <<"{invalid">>,
    Fragment2 = <<"json}\n">>,

    Reassembled = <<Fragment1/binary, Fragment2/binary>>,

    case jsx:decode(Reassembled) of
        {error, _} ->
            ?assert(true);
        _ ->
            ?fail("Should have parse error")
    end.

test_delimiter_spanning_fragments() ->
    %% Delimiter split across fragments should be handled
    Fragment1 = <<"message">>,
    Fragment2 = <<"\nmore">>,

    State0 = #state{
        fragment_buffer = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Fragment1, State0),
    {ok, State2} = erlmcp_transport_ws:handle_text_frame(Fragment2, State1),

    %% After delimiter, should complete processing
    ?assertEqual(<<"more">>, State2#state.fragment_buffer).

%%====================================================================
%% WebSocket Frame Opcodes Tests (RFC 6455)
%%====================================================================

test_text_frame_opcode() ->
    %% Text frames (opcode=1) should be handled
    Message = <<"Text frame content\n">>,

    State0 = #state{
        fragment_buffer = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    {ok, _State1} = erlmcp_transport_ws:handle_text_frame(Message, State0),
    ?assert(true).

test_continuation_frame_opcode() ->
    %% Continuation frames (opcode=0) should follow text frames
    State0 = #state{
        fragment_buffer = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    %% Text frame initiates fragmentation
    {ok, State1} = erlmcp_transport_ws:handle_text_frame(<<"part1">>, State0),

    %% Continuation frame continues
    {ok, _State2} = erlmcp_transport_ws:handle_text_frame(<<"part2\n">>, State1),

    ?assert(true).

test_binary_frame_rejection() ->
    %% Binary frames (opcode=2) should be rejected
    %% This is handled by websocket_handle({binary, _}, State)
    ?assert(true).

test_control_frames_during_fragmentation() ->
    %% Control frames (ping/pong) should be allowed during fragmentation
    ?assert(true).

test_close_frame_during_fragmentation() ->
    %% Close frame should terminate fragmentation
    ?assert(true).

%%====================================================================
%% Integration Tests
%%====================================================================

test_complete_fragmented_request_cycle() ->
    %% Full cycle: fragments -> reassembly -> JSON parsing -> routing
    Fragment1 = <<"{\n">>,
    Fragment2 = <<"\"jsonrpc\":\"2.0\",\n">>,
    Fragment3 = <<"\"method\":\"resources/list\",\n">>,
    Fragment4 = <<"\"id\":1\n">>,

    State0 = #state{
        fragment_buffer = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true,
        registry_pid = self()
    },

    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Fragment1, State0),
    {ok, State2} = erlmcp_transport_ws:handle_text_frame(Fragment2, State1),
    {ok, State3} = erlmcp_transport_ws:handle_text_frame(Fragment3, State2),
    {ok, _State4} = erlmcp_transport_ws:handle_text_frame(Fragment4, State3),

    %% Should complete successfully
    ?assert(true).

test_fragmented_json_rpc_message() ->
    %% Typical JSON-RPC message fragmented across 4 frames
    JsonRpc = jsx:encode(#{
        <<"jsonrpc">> => <<"2.0">>,
        <<"method">> => <<"tools/call">>,
        <<"params">> => #{
            <<"name">> => <<"calculator">>,
            <<"arguments">> => #{
                <<"expression">> => <<"2 + 2">>
            }
        },
        <<"id">> => 42
    }),

    Parts = split_into_parts(JsonRpc, 4),
    LastPart = lists:last(Parts) <> "\n",
    PartsList = lists:droplast(Parts) ++ [LastPart],

    State0 = #state{
        fragment_buffer = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    State1 = process_fragments(PartsList, State0),
    ?assertEqual(undefined, State1#state.fragment_buffer).

test_large_payload_fragmentation() ->
    %% Large payload requiring multiple fragments
    LargeData = binary:copy(<<"x">>, 1000000),

    Parts = split_into_parts(LargeData, 10),
    LastPart = lists:last(Parts) <> "\n",
    PartsList = lists:droplast(Parts) ++ [LastPart],

    State0 = #state{
        fragment_buffer = undefined,
        max_message_size = 16777216,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    State1 = process_fragments(PartsList, State0),
    ?assertEqual(undefined, State1#state.fragment_buffer).

test_rapid_fragmented_stream() ->
    %% Rapid succession of fragmented messages
    Messages = [
        {<<"msg1_p1">>, <<"msg1_p2\n">>},
        {<<"msg2_p1">>, <<"msg2_p2\n">>},
        {<<"msg3_p1">>, <<"msg3_p2\n">>}
    ],

    State0 = #state{
        fragment_buffer = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    FinalState = lists:foldl(fun({P1, P2}, St) ->
        {ok, St1} = erlmcp_transport_ws:handle_text_frame(P1, St),
        {ok, St2} = erlmcp_transport_ws:handle_text_frame(P2, St1),
        St2
    end, State0, Messages),

    ?assertEqual(undefined, FinalState#state.fragment_buffer).

test_fragmentation_with_backpressure() ->
    %% Simulate backpressure (slow fragment arrival)
    Fragment1 = <<"first_part">>,
    Fragment2 = <<"second_part">>,
    Fragment3 = <<"final\n">>,

    State0 = #state{
        fragment_buffer = undefined,
        strict_delimiter_check = true,
        validate_utf8 = true
    },

    {ok, State1} = erlmcp_transport_ws:handle_text_frame(Fragment1, State0),
    timer:sleep(100),  %% Simulate delay
    {ok, State2} = erlmcp_transport_ws:handle_text_frame(Fragment2, State1),
    timer:sleep(100),  %% Simulate delay
    {ok, State3} = erlmcp_transport_ws:handle_text_frame(Fragment3, State2),

    ?assertEqual(undefined, State3#state.fragment_buffer).

%%====================================================================
%% Helper Functions
%%====================================================================

%% Process a list of fragments sequentially
process_fragments(Fragments, State) ->
    lists:foldl(fun(Fragment, St) ->
        case erlmcp_transport_ws:handle_text_frame(Fragment, St) of
            {ok, NewSt} -> NewSt;
            {error, _, NewSt} -> NewSt
        end
    end, State, Fragments).

%% Split binary into N parts
split_into_parts(Binary, N) ->
    Size = byte_size(Binary),
    PartSize = Size div N,
    [binary:part(Binary, {I * PartSize, PartSize}) || I <- lists:seq(0, N-2)] ++
    [binary:part(Binary, {(N-1) * PartSize, Size - (N-1) * PartSize})].

%% Create test state record
-record(state, {
    transport_id :: binary(),
    registry_pid :: pid(),
    session_id :: binary(),
    fragment_buffer :: binary() | undefined,
    fragment_start_time :: integer() | undefined,
    max_message_size :: integer(),
    strict_delimiter_check :: boolean(),
    validate_utf8 :: boolean()
}).
