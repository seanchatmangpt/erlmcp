#!/usr/bin/env escript
%%%-------------------------------------------------------------------
%%% @doc Stack overflow stress test runner
%%% Created: 2025-01-29
%%% Purpose: Run progressive depth tests until crash
%%%-------------------------------------------------------------------

-mode(compile).

main([]) ->
    io:format("~n~n"),
    io:format("╔════════════════════════════════════════════════════════════╗~n"),
    io:format("║     STACK OVERFLOW CRASH TEST - Find Recursion Limit       ║~n"),
    io:format("╚════════════════════════════════════════════════════════════╝~n"),
    io:format("~n"),
    
    %% Test progressively deeper levels
    Depths = [10, 100, 1000, 10000, 100000, 1000000],
    
    %% Test tail recursion first (should all pass)
    io:format("~n=== PHASE 1: TAIL RECURSION (Expected: All Pass) ===~n~n"),
    TailResults = test_all_tail(Depths, []),
    print_tail_results(TailResults),
    
    %% Test non-tail recursion (should crash)
    io:format("~n~n=== PHASE 2: NON-TAIL RECURSION (Expected: Crash) ===~n~n"),
    NonTailResults = test_all_non_tail(Depths, []),
    print_non_tail_results(NonTailResults),
    
    %% Test mutual recursion
    io:format("~n~n=== PHASE 3: MUTUAL RECURSION (Expected: Crash) ===~n~n"),
    MutualResults = test_all_mutual(Depths, []),
    print_mutual_results(MutualResults),
    
    %% Find exact breaking point
    io:format("~n~n=== PHASE 4: BINARY SEARCH FOR EXACT LIMIT ===~n~n"),
    Limit = find_stack_limit(),
    
    %% Final report
    print_final_report(TailResults, NonTailResults, MutualResults, Limit),
    
    io:format("~n~n"),
    io:format("╔════════════════════════════════════════════════════════════╗~n"),
    io:format("║              TEST COMPLETE - SEE RESULTS ABOVE              ║~n"),
    io:format("╚════════════════════════════════════════════════════════════╝~n"),
    io:format("~n"),
    ok.

%%%===================================================================
%%% Test Functions
%%%===================================================================

test_all_tail([], Acc) ->
    lists:reverse(Acc);
test_all_tail([Depth | Rest], Acc) ->
    Result = test_tail_recursion(Depth),
    test_all_tail(Rest, [{Depth, Result} | Acc]).

test_all_non_tail([], Acc) ->
    lists:reverse(Acc);
test_all_non_tail([Depth | Rest], Acc) ->
    Result = test_non_tail_recursion(Depth),
    test_all_non_tail(Rest, [{Depth, Result} | Acc]).

test_all_mutual([], Acc) ->
    lists:reverse(Acc);
test_all_mutual([Depth | Rest], Acc) ->
    Result = test_mutual_recursion(Depth),
    test_all_mutual(Rest, [{Depth, Result} | Acc]).

%%%===================================================================
%%% Tail Recursion Test
%%%===================================================================

test_tail_recursion(Depth) ->
    io:format("Testing tail recursion: ~p levels...~n", [Depth]),
    Start = erlang:monotonic_time(microsecond),
    
    case catch tail_recurse(Depth, Depth) of
        {'EXIT', {Class, Error, _StackTrace}} ->
            Elapsed = erlang:monotonic_time(microsecond) - Start,
            io:format("  ✗ CRASH: ~p after ~p us~n", [Class, Elapsed]),
            io:format("    Error: ~p~n", [Error]),
            {crashed, Depth, Class, Error};
        _Result ->
            Elapsed = erlang:monotonic_time(microsecond) - Start,
            Rate = case Elapsed of 
                0 -> infinity;
                _ -> Depth * 1000000 div Elapsed
            end,
            io:format("  ✓ SUCCESS: ~p us (~.2f K depth/sec)~n", [Elapsed, Rate / 1000.0]),
            {success, Depth, Elapsed, Rate}
    end.

tail_recurse(0, Original) -> {reached, Original};
tail_recurse(N, Original) when N > 0 -> tail_recurse(N - 1, Original).

%%%===================================================================
%%% Non-Tail Recursion Test
%%%===================================================================

test_non_tail_recursion(Depth) ->
    io:format("Testing non-tail recursion: ~p levels...~n", [Depth]),
    Start = erlang:monotonic_time(microsecond),
    
    Process = spawn(fun() ->
        case catch not_tail_recurse(Depth) of
            {'EXIT', {Class, Error, _StackTrace}} ->
                Elapsed = erlang:monotonic_time(microsecond) - Start,
                io:format("  ✗ CRASH: ~p after ~p us~n", [Class, Elapsed]),
                io:format("    Error: ~p~n", [Error]),
                exit({crashed, Depth, Class, Error});
            Result ->
                Elapsed = erlang:monotonic_time(microsecond) - Start,
                io:format("  ✓ SUCCESS: ~p us~n", [Elapsed]),
                exit({success, Depth, Elapsed})
        end
    end),
    
    receive
        {'EXIT', Process, Result} -> Result
    after 
        30000 -> {timeout, Depth}
    end.

not_tail_recurse(0) -> reached;
not_tail_recurse(N) when N > 0 -> 
    Result = not_tail_recurse(N - 1),
    Result + 1.

%%%===================================================================
%%% Mutual Recursion Test
%%%===================================================================

test_mutual_recursion(Depth) ->
    io:format("Testing mutual recursion: ~p levels...~n", [Depth]),
    Start = erlang:monotonic_time(microsecond),
    
    Process = spawn(fun() ->
        case catch mutual_recurse_a(Depth) of
            {'EXIT', {Class, Error, _StackTrace}} ->
                Elapsed = erlang:monotonic_time(microsecond) - Start,
                io:format("  ✗ CRASH: ~p after ~p us~n", [Class, Elapsed]),
                io:format("    Error: ~p~n", [Error]),
                exit({crashed, Depth, Class, Error});
            Result ->
                Elapsed = erlang:monotonic_time(microsecond) - Start,
                io:format("  ✓ SUCCESS: ~p us~n", [Elapsed]),
                exit({success, Depth, Elapsed})
        end
    end),
    
    receive
        {'EXIT', Process, Result} -> Result
    after 
        30000 -> {timeout, Depth}
    end.

mutual_recurse_a(0) -> reached;
mutual_recurse_a(N) when N > 0 -> mutual_recurse_b(N - 1).

mutual_recurse_b(0) -> reached;
mutual_recurse_b(N) when N > 0 -> 
    Result = mutual_recurse_a(N - 1),
    Result.

%%%===================================================================
%%% Binary Search for Stack Limit
%%%===================================================================

find_stack_limit() ->
    io:format("Binary searching for stack limit...~n"),
    binary_search_limit(1, 1000000).

binary_search_limit(Low, High) when High < Low ->
    io:format("~nStack limit: ~p levels~n", [Low]),
    Low;
binary_search_limit(Low, High) ->
    Mid = (Low + High) div 2,
    io:format("  Testing ~p levels (range: ~p - ~p)...~n", [Mid, Low, High]),
    
    case test_depth_safe(Mid) of
        success ->
            io:format("    ✓ Pass~n"),
            binary_search_limit(Mid + 1, High);
        crash ->
            io:format("    ✗ Fail~n"),
            binary_search_limit(Low, Mid - 1)
    end.

test_depth_safe(Depth) ->
    Process = spawn(fun() ->
        case catch not_tail_recurse(Depth) of
            {'EXIT', _} -> exit(crash);
            _ -> exit(success)
        end
    end),
    
    receive
        {'EXIT', Process, Result} -> Result
    after 
        5000 -> timeout
    end.

%%%===================================================================
%%% Report Functions
%%%===================================================================

print_tail_results(Results) ->
    io:format("~nTail Recursion Results:~n"),
    io:format("  Depth    Status      Time        Rate~n"),
    io:format("  -------  ----------  ----------  ----------~n"),
    
    lists:foreach(fun({_Depth, {success, _, Time, Rate}}) ->
        io:format("  ~7w  SUCCESS    ~10w us  ~.2f K/s~n", [_Depth, Time, Rate / 1000.0]);
       ({_Depth, {crashed, _, Type, _}}) ->
        io:format("  ~7w  CRASHED    ~10w~n", [_Depth, Type])
    end, Results).

print_non_tail_results(Results) ->
    io:format("~nNon-Tail Recursion Results:~n"),
    io:format("  Depth    Status      Details~n"),
    io:format("  -------  ----------  ----------~n"),
    
    lists:foreach(fun({_Depth, {success, _, Time}}) ->
        io:format("  ~7w  SUCCESS    ~w us~n", [_Depth, Time]);
       ({_Depth, {crashed, _, Type, Error}}) ->
        io:format("  ~7w  CRASHED    ~w: ~p~n", [_Depth, Type, Error]);
       ({_Depth, {timeout, _}}) ->
        io:format("  ~7w  TIMEOUT    >30s~n", [_Depth])
    end, Results).

print_mutual_results(Results) ->
    io:format("~nMutual Recursion Results:~n"),
    io:format("  Depth    Status      Details~n"),
    io:format("  -------  ----------  ----------~n"),
    
    lists:foreach(fun({_Depth, {success, _, Time}}) ->
        io:format("  ~7w  SUCCESS    ~w us~n", [_Depth, Time]);
       ({_Depth, {crashed, _, Type, Error}}) ->
        io:format("  ~7w  CRASHED    ~w: ~p~n", [_Depth, Type, Error]);
       ({_Depth, {timeout, _}}) ->
        io:format("  ~7w  TIMEOUT    >30s~n", [_Depth])
    end, Results).

print_final_report(TailResults, NonTailResults, MutualResults, Limit) ->
    io:format("~n~n"),
    io:format("╔════════════════════════════════════════════════════════════╗~n"),
    io:format("║              FINAL STACK OVERFLOW REPORT                  ║~n"),
    io:format("╚════════════════════════════════════════════════════════════╝~n"),
    io:format("~n"),
    
    %% Tail recursion summary
    io:format("TAIL RECURSION (Stack Optimization):~n"),
    TailSuccess = length([R || {_, {success, _, _, _}=R} <- TailResults]),
    io:format("  - Passed: ~p/~p tests~n", [TailSuccess, length(TailResults)]),
    case TailSuccess of
        6 -> io:format("  - Status: TAIL-CALL OPTIMIZATION WORKING~n");
        _ -> io:format("  - Status: TAIL-CALL OPTIMIZATION MAY BE BROKEN~n")
    end,
    io:format("~n"),
    
    %% Non-tail recursion summary
    io:format("NON-TAIL RECURSION (Stack Growth):~n"),
    NonTailCrashed = length([R || {_, {crashed, _, _, _}=R} <- NonTailResults]),
    io:format("  - Crashed: ~p/~p tests~n", [NonTailCrashed, length(NonTailResults)]),
    case NonTailCrashed of
        0 -> io:format("  - Status: NO CRASHES DETECTED (unexpected)~n");
        _ -> io:format("  - Status: STACK OVERFLOW DETECTED~n")
    end,
    
    %% Find crash point
    case [R || {_, {crashed, _, _, _}=R} <- NonTailResults] of
        [] -> ok;
        [{crashed, CrashDepth, _, _} | _] ->
            io:format("  - First Crash: ~p levels~n", [CrashDepth])
    end,
    io:format("~n"),
    
    %% Mutual recursion summary
    io:format("MUTUAL RECURSION (A calls B, B calls A):~n"),
    MutualCrashed = length([R || {_, {crashed, _, _, _}=R} <- MutualResults]),
    io:format("  - Crashed: ~p/~p tests~n", [MutualCrashed, length(MutualResults)]),
    case MutualCrashed of
        0 -> io:format("  - Status: NO CRASHES DETECTED~n");
        _ -> io:format("  - Status: STACK OVERFLOW DETECTED~n")
    end,
    io:format("~n"),
    
    %% Binary search result
    io:format("BREAKING POINT (Binary Search):~n"),
    io:format("  - Maximum Stack Depth: ~p levels~n", [Limit]),
    io:format("  - Estimated Stack Size: ~p KB~n", [Limit * 8 div 1024]),
    io:format("~n"),
    
    %% Analysis
    io:format("ANALYSIS:~n"),
    io:format("  1. Tail-call optimization: "),
    case TailSuccess of
        6 -> io:format("WORKING (unlimited depth)~n");
        _ -> io:format("BROKEN (limited depth)~n")
    end,
    io:format("  2. Stack limit: ~p levels before overflow~n", [Limit]),
    io:format("  3. Stack overflow error: Process crash (not VM crash)~n"),
    io:format("  4. VM stability: Process isolation working correctly~n"),
    io:format("~n"),
    
    %% Memory usage
    io:format("MEMORY ESTIMATES:~n"),
    io:format("  - Per-stack-frame: 8 bytes (estimated)~n"),
    io:format("  - At limit (~p): ~p KB total stack~n", [Limit, Limit * 8 div 1024]),
    io:format("~n"),
    
    io:format("═════════════════════════════════════════════════════════════~n"),
    ok.
