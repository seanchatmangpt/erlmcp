#!/usr/bin/env escript

-mode(compile).

main(_) ->
    io:format("~n=== TRANSPORT LAYER ABUSE CRASH TEST ===~n~n"),
    
    %% Simple test - just try to abuse the port directly
    %% We'll test if we can crash TCP handlers
    
    io:format("Testing TCP connection abuse on port 10019...~n"),
    
    %% Test 1: Incomplete handshakes
    io:format("~n1. Incomplete Handshake Test (100 attempts)...~n"),
    Results1 = test_incomplete_handshakes(10019, 100),
    io:format("  Result: ~p succeeded, ~p failed, ~p crashes~n", 
              [maps:get(succeeded, Results1, 0),
               maps:get(failed, Results1, 0),
               maps:get(crashes, Results1, 0)]),
    
    %% Test 2: Half-close
    io:format("~n2. Half-Close Test (100 attempts)...~n"),
    Results2 = test_half_close(10019, 100),
    io:format("  Result: ~p succeeded, ~p failed, ~p crashes~n",
              [maps:get(succeeded, Results2, 0),
               maps:get(failed, Results2, 0),
               maps:get(crashes, Results2, 0)]),
    
    %% Test 3: SYN flood simulation
    io:format("~n3. SYN Flood Simulation (500 attempts)...~n"),
    {StartTime, Results3} = timer:tc(fun() -> test_syn_flood(10019, 500) end),
    DurationMS = StartTime div 1000,
    io:format("  Result: ~p accepted, ~p rejected in ~p ms (~p conns/sec)~n",
              [maps:get(accepted, Results3, 0),
               maps:get(rejected, Results3, 0),
               DurationMS,
               (500 * 1000) div (DurationMS + 1)]),
    
    %% Test 4: Fragmentation
    io:format("~n4. Fragmentation Test (100 attempts)...~n"),
    Results4 = test_fragmentation(10019, 100),
    io:format("  Result: ~p succeeded, ~p failed, ~p total fragments~n",
              [maps:get(succeeded, Results4, 0),
               maps:get(failed, Results4, 0),
               maps:get(fragments, Results4, 0)]),
    
    %% Test 5: Slowloris
    io:format("~n5. Slowloris Test (50 attempts)...~n"),
    Results5 = test_slowloris(10019, 50),
    io:format("  Result: ~p succeeded, ~p failed~n",
              [maps:get(succeeded, Results5, 0),
               maps:get(failed, Results5, 0)]),
    
    %% Final report
    TotalCrashes = maps:get(crashes, Results1, 0) +
                   maps:get(crashes, Results2, 0) +
                   maps:get(crashes, Results3, 0) +
                   maps:get(crashes, Results4, 0) +
                   maps:get(crashes, Results5, 0),
    
    io:format("~n=== FINAL REPORT ===~n"),
    io:format("Total Crashes: ~p~n", [TotalCrashes]),
    
    case TotalCrashes of
        0 ->
            io:format("STATUS: ROBUST - No crashes detected~n"),
            io:format("TCP transport handled all abuse patterns~n");
        _ ->
            io:format("STATUS: VULNERABLE - Crashes detected!~n")
    end,
    
    ok.

test_incomplete_handshakes(Port, Count) ->
    Parent = self(),
    Pids = [spawn(fun() ->
        Result = case gen_tcp:connect("localhost", Port, [binary, {active, false}], 2000) of
            {ok, Socket} ->
                %% Connect but hang
                timer:sleep(5000),
                catch gen_tcp:close(Socket),
                #{result => succeeded};
            {error, _} ->
                #{result => failed}
        end,
        Parent ! {result, self(), Result}
    end) || _ <- lists:seq(1, Count)],
    
    collect_results(Pids, #{succeeded => 0, failed => 0, crashes => 0}).

test_half_close(Port, Count) ->
    Parent = self(),
    Pids = [spawn(fun() ->
        Result = case gen_tcp:connect("localhost", Port, [binary, {active, false}]) of
            {ok, Socket} ->
                gen_tcp:send(Socket, <<"TEST_DATA">>),
                gen_tcp:shutdown(Socket, write),
                timer:sleep(100),
                catch gen_tcp:close(Socket),
                #{result => succeeded};
            {error, _} ->
                #{result => failed}
        end,
        Parent ! {result, self(), Result}
    end) || _ <- lists:seq(1, Count)],
    
    collect_results(Pids, #{succeeded => 0, failed => 0, crashes => 0}).

test_syn_flood(Port, Count) ->
    Results = [begin
        case gen_tcp:connect("localhost", Port, [binary, {active, false}], 100) of
            {ok, Socket} ->
                gen_tcp:close(Socket),
                accepted;
            {error, _} ->
                rejected
        end
    end || _ <- lists:seq(1, Count)],
    
    Accepted = length([R || R <- Results, R =:= accepted]),
    Rejected = length([R || R <- Results, R =:= rejected]),
    
    #{accepted => Accepted, rejected => Rejected, crashes => 0}.

test_fragmentation(Port, Count) ->
    Parent = self(),
    Pids = [spawn(fun() ->
        Result = case gen_tcp:connect("localhost", Port, [binary, {active, false}]) of
            {ok, Socket} ->
                Data = <<"FRAGMENTED_MESSAGE">>,
                Fragments = [<<C>> || <<C>> <= Data],
                lists:foreach(fun(F) ->
                    gen_tcp:send(Socket, F),
                    timer:sleep(10)
                end, Fragments),
                gen_tcp:close(Socket),
                #{result => succeeded, fragments => length(Fragments)};
            {error, _} ->
                #{result => failed, fragments => 0}
        end,
        Parent ! {result, self(), Result}
    end) || _ <- lists:seq(1, Count)],
    
    collect_results_with_fragments(Pids, #{succeeded => 0, failed => 0, crashes => 0, fragments => 0}).

test_slowloris(Port, Count) ->
    Parent = self(),
    Pids = [spawn(fun() ->
        Result = case gen_tcp:connect("localhost", Port, [binary, {active, false}], 2000) of
            {ok, Socket} ->
                %% Send very slowly
                Data = <<"SLOW_TEST">>,
                send_slow_bytes(Socket, Data, 500),
                gen_tcp:close(Socket),
                #{result => succeeded};
            {error, _} ->
                #{result => failed}
        end,
        Parent ! {result, self(), Result}
    end) || _ <- lists:seq(1, min(Count, 20))],  % Limit to 20 for time
    
    collect_results(Pids, #{succeeded => 0, failed => 0, crashes => 0}).

send_slow_bytes(_Socket, <<>>, _Interval) ->
    ok;
send_slow_bytes(Socket, <<Byte, Rest/binary>>, Interval) ->
    gen_tcp:send(Socket, <<Byte>>),
    timer:sleep(Interval),
    send_slow_bytes(Socket, Rest, Interval).

collect_results([], Acc) ->
    Acc;
collect_results([Pid | Rest], Acc) ->
    receive
        {result, Pid, #{result := Result} = Map} ->
            NewAcc = maps:update_with(Result, fun(V) -> V + 1 end, 1, Acc),
            case maps:get(fragments, Map, 0) of
                0 -> collect_results(Rest, NewAcc);
                N -> collect_results(Rest, NewAcc#{fragments => maps:get(fragments, NewAcc, 0) + N})
            end;
        {'EXIT', Pid, _Reason} ->
            collect_results(Rest, maps:update_with(crashes, fun(V) -> V + 1 end, 1, Acc))
    after 10000 ->
        collect_results(Rest, Acc)
    end.

collect_results_with_fragments([], Acc) ->
    Acc;
collect_results_with_fragments([Pid | Rest], Acc) ->
    receive
        {result, Pid, #{result := Result} = Map} ->
            NewAcc = maps:update_with(Result, fun(V) -> V + 1 end, 1, Acc),
            case maps:get(fragments, Map, 0) of
                0 -> collect_results_with_fragments(Rest, NewAcc);
                N -> collect_results_with_fragments(Rest, NewAcc#{fragments => maps:get(fragments, NewAcc, 0) + N})
            end;
        {'EXIT', Pid, _Reason} ->
            collect_results_with_fragments(Rest, maps:update_with(crashes, fun(V) -> V + 1 end, 1, Acc))
    after 10000 ->
        collect_results_with_fragments(Rest, Acc)
    end.
