#!/usr/bin/env escript
%%! +P 1048576 +Q 65536

%% Incremental timeout storm test - find exact breaking point

main([CountStr]) ->
    TimeoutCount = list_to_integer(CountStr),
    run_test(TimeoutCount);
main(_) ->
    io:format("Usage: timeout_incremental.erl <count>~n"),
    halt(1).

run_test(TimeoutCount) ->
    Port = 10010,
    TimeoutMs = 1,
    ClientCount = min(100, TimeoutCount),
    RequestsPerClient = max(1, TimeoutCount div ClientCount),
    
    io:format("~n=== Testing ~p concurrent timeouts ===~n", [TimeoutCount]),
    
    %% Start server
    {ok, ListenSocket} = gen_tcp:listen(Port, [binary, {packet, 0}, {active, false}, {reuseaddr, true}]),
    spawn(fun() -> accept_loop(ListenSocket) end),
    timer:sleep(100),
    
    MemoryBefore = erlang:memory(total) / (1024 * 1024),
    StartTimestamp = erlang:monotonic_time(millisecond),
    
    %% Spawn clients
    Parent = self(),
    Clients = lists:map(fun(ClientIndex) ->
        spawn_link(fun() ->
            timeout_client(Port, RequestsPerClient, TimeoutMs, Parent, ClientIndex)
        end)
    end, lists:seq(1, ClientCount)),
    
    %% Collect results (30s max)
    Results = collect_results(Clients, TimeoutCount, 30000),
    
    EndTimestamp = erlang:monotonic_time(millisecond),
    DurationMs = (EndTimestamp - StartTimestamp) / 1000.0,
    MemoryAfter = erlang:memory(total) / (1024 * 1024),
    
    %% Analyze
    TimeoutsFired = length(lists:filter(fun(R) -> element(1, R) =:= timeout end, Results)),
    Errors = length(lists:filter(fun(R) ->
        case element(1, R) of
            error -> true;
            connect_error -> true;
            send_error -> true;
            _ -> false
        end
    end, Results)),
    
    CleanupSuccessPercent = case TimeoutsFired + Errors of
        0 -> 100.0;
        Total -> (TimeoutsFired / Total) * 100.0
    end,
    
    %% Check server
    ServerResponsive = case gen_tcp:connect({127,0,0,1}, Port, [binary, {packet, 0}], 1000) of
        {ok, Socket} -> gen_tcp:close(Socket), true;
        _ -> false
    end,
    
    %% Print results
    io:format("  Timeouts Fired: ~p/~p (~.2f%)~n", [TimeoutsFired, TimeoutCount, CleanupSuccessPercent]),
    io:format("  Duration: ~.2f seconds~n", [DurationMs]),
    io:format("  Memory: ~.2f -> ~.2f MB (~.2f%)~n", 
              [MemoryBefore, MemoryAfter, ((MemoryAfter - MemoryBefore) / max(1, MemoryBefore)) * 100]),
    io:format("  Server Responsive: ~p~n", [ServerResponsive]),
    
    %% Cleanup
    gen_tcp:close(ListenSocket),
    lists:foreach(fun(Pid) -> catch exit(Pid, kill) end, Clients),
    
    %% Determine result
    case CleanupSuccessPercent >= 99.0 of
        true ->
            io:format("  Result: ✅ PASSED~n"),
            halt(0);
        false ->
            io:format("  Result: ❌ FAILED (breaking point: ~p)~n", [TimeoutsFired]),
            halt(1)
    end.

accept_loop(ListenSocket) ->
    case gen_tcp:accept(ListenSocket, 1000) of
        {ok, Socket} ->
            spawn(fun() -> slow_handler(Socket) end),
            accept_loop(ListenSocket);
        {error, timeout} ->
            accept_loop(ListenSocket)
    end.

slow_handler(Socket) ->
    case gen_tcp:recv(Socket, 0, 5000) of
        {ok, _Data} ->
            timer:sleep(10000),
            Response = <<"{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":{\"status\":\"done\"}}">>,
            catch gen_tcp:send(Socket, Response);
        {error, _Reason} ->
            ok
    end,
    catch gen_tcp:close(Socket).

timeout_client(Port, RequestCount, TimeoutMs, Parent, ClientIndex) ->
    Results = lists:map(fun(RequestIndex) ->
        RequestStart = erlang:monotonic_time(millisecond),
        
        case gen_tcp:connect({127,0,0,1}, Port, [binary, {packet, 0}, {active, false}], 5000) of
            {ok, Socket} ->
                Request = <<"{\"jsonrpc\":\"2.0\",\"id\":",
                           (integer_to_binary(RequestIndex))/binary,
                           ",\"method\":\"tools/call\",\"params\":{\"name\":\"very_slow_operation\"}}">>,
                
                case gen_tcp:send(Socket, Request) of
                    ok ->
                        ResponseResult = gen_tcp:recv(Socket, 0, TimeoutMs),
                        RequestEnd = erlang:monotonic_time(millisecond),
                        catch gen_tcp:close(Socket),
                        
                        case ResponseResult of
                            {error, timeout} -> {timeout, RequestEnd - RequestStart};
                            {ok, _Data} -> {success, RequestEnd - RequestStart};
                            {error, Reason} -> {error, Reason, RequestEnd - RequestStart}
                        end;
                    {error, Reason} ->
                        {send_error, Reason}
                end;
            {error, Reason} ->
                {connect_error, Reason}
        end
    end, lists:seq(1, RequestCount)),
    
    Parent ! {client_result, ClientIndex, Results},
    ok.

collect_results(Clients, ExpectedCount, Timeout) ->
    collect_results(Clients, ExpectedCount, Timeout, []).

collect_results(_Clients, ExpectedCount, Timeout, Acc) when length(Acc) >= ExpectedCount; Timeout =< 0 ->
    lists:flatten(Acc);
collect_results(Clients, ExpectedCount, Timeout, Acc) ->
    Start = erlang:monotonic_time(millisecond),
    receive
        {client_result, _ClientIndex, Results} ->
            End = erlang:monotonic_time(millisecond),
            NewTimeout = Timeout - (End - Start),
            collect_results(Clients, ExpectedCount, NewTimeout, [Results | Acc])
    after 1000 ->
        End = erlang:monotonic_time(millisecond),
        NewTimeout = Timeout - (End - Start),
        collect_results(Clients, ExpectedCount, NewTimeout, Acc)
    end.
