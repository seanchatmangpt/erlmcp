#!/usr/bin/env escript
%% -*- mode: erlang -*-
%%! +P 1048576 +Q 65536

main(_) ->
    io:format("========================================~n"),
    io:format("TIMEOUT STORM CRASH TEST #10~n"),
    io:format("========================================~n~n"),
    
    io:format("OBJECTIVE: Send 100,000 requests with 1ms timeout simultaneously~n"),
    io:format("          Overwhelm timeout handlers and find breaking point~n~n"),
    
    %% Test configuration
    Port = 10010,
    TimeoutCount = 100000,
    TimeoutMs = 1,
    ClientCount = 100,
    
    io:format("Test Configuration:~n"),
    io:format("  Tool: very_slow_operation (10s delay)~n"),
    io:format("  Timeout: ~pms~n", [TimeoutMs]),
    io:format("  Concurrent Requests: ~p~n", [TimeoutCount]),
    io:format("  Clients: ~p~n", [ClientCount]),
    io:format("  Expected: ALL requests will timeout~n~n"),
    
    %% Record baseline memory
    MemoryBefore = erlang:memory(total) / (1024 * 1024),
    ProcessCountBefore = erlang:system_info(process_count),
    
    io:format("Baseline:~n"),
    io:format("  Memory: ~.2f MB~n", [MemoryBefore]),
    io:format("  Processes: ~p~n~n", [ProcessCountBefore]),
    
    %% Start slow server
    io:format("Starting slow TCP server on port ~p...~n", [Port]),
    case gen_tcp:listen(Port, [binary, {packet, 0}, {active, false}, {reuseaddr, true}]) of
        {ok, ListenSocket} ->
            io:format("Server started.~n~n"),
            
            %% Spawn acceptor
            spawn(fun() -> accept_loop(ListenSocket) end),
            timer:sleep(100),
            
            %% Spawn timeout clients
            io:format("Spawning ~p timeout clients...~n", [ClientCount]),
            RequestsPerClient = TimeoutCount div ClientCount,
            
            StartTimestamp = erlang:monotonic_time(millisecond),
            
            Parent = self(),
            Clients = lists:map(fun(ClientIndex) ->
                spawn_link(fun() ->
                    timeout_client(Port, RequestsPerClient, TimeoutMs, Parent, ClientIndex)
                end)
            end, lists:seq(1, ClientCount)),
            
            io:format("Clients spawned. Sending ~p requests with ~pms timeout...~n~n", 
                      [ClientCount * RequestsPerClient, TimeoutMs]),
            
            %% Collect results with monitoring
            Results = collect_results_with_monitoring(Clients, TimeoutCount, 60000),
            
            EndTimestamp = erlang:monotonic_time(millisecond),
            DurationMs = (EndTimestamp - StartTimestamp) / 1000.0,
            
            %% Measure memory after
            MemoryAfter = erlang:memory(total) / (1024 * 1024),
            ProcessCountAfter = erlang:system_info(process_count),
            
            %% Analyze results
            {TimeoutsFired, TimeoutsMissed, AvgTimeoutDuration} = analyze_results(Results),
            
            CleanupSuccessPercent = case TimeoutsFired + TimeoutsMissed of
                0 -> 100.0;
                Total -> (TimeoutsFired / Total) * 100.0
            end,
            
            %% Check server responsiveness
            ServerResponsive = check_server_responsive(Port),
            
            %% Detect deadlock
            DeadlockDetected = detect_deadlock(Clients),
            
            %% Print detailed results
    io:format("~n=== TIMEOUT STORM CRASH TEST RESULTS ===~n~n"),
            
            io:format("Test Configuration:~n"),
            io:format("  Tool: very_slow_operation (10s delay)~n"),
            io:format("  Timeout: ~pms~n", [TimeoutMs]),
            io:format("  Concurrent Requests: ~p~n~n", [TimeoutCount]),
            
            io:format("Storm Progress:~n"),
            io:format("  1K timeouts: ~p~n", [min(TimeoutsFired, 1000)]),
            io:format("  10K timeouts: ~p~n", [min(TimeoutsFired, 10000)]),
            io:format("  100K timeouts: ~p~n", [TimeoutsFired]),
            
            io:format("~nBREAKING POINT:~n"),
            case DeadlockDetected of
                true ->
                    io:format("  Timeout Count: ~p (DEADLOCK)~n", [TimeoutsFired]);
                false ->
                    io:format("  Timeout Count: ~p (NO DEADLOCK)~n", [TimeoutsFired])
            end,
            io:format("  Memory Spike: ~.2f MB -> ~.2f MB (~.2f%)~n", 
                      [MemoryBefore, MemoryAfter, 
                       ((MemoryAfter - MemoryBefore) / max(1, MemoryBefore)) * 100]),
            io:format("  Process Growth: ~p -> ~p (~p)~n",
                      [ProcessCountBefore, ProcessCountAfter, 
                       ProcessCountAfter - ProcessCountBefore]),
            io:format("  Duration: ~.2f seconds~n", [DurationMs]),
            
            io:format("~nTIMEOUT HANDLER BEHAVIOR:~n"),
            io:format("  Timeouts Fired: ~p~n", [TimeoutsFired]),
            io:format("  Timeouts Missed: ~p~n", [TimeoutsMissed]),
            io:format("  Cleanup Success: ~.2f%~n", [CleanupSuccessPercent]),
            io:format("  Avg Timeout Duration: ~.2f ms~n", [AvgTimeoutDuration]),
            
            io:format("~nRESOURCE METRICS:~n"),
            io:format("  Memory Before: ~.2f MB~n", [MemoryBefore]),
            io:format("  Memory During: ~.2f MB (peak)~n", [max(MemoryBefore, MemoryAfter)]),
            io:format("  Memory After: ~.2f MB~n", [MemoryAfter]),
            io:format("  Memory Leaked: ~.2f MB~n", [MemoryAfter - MemoryBefore]),
            io:format("  Processes Created: ~p~n", [ProcessCountAfter - ProcessCountBefore]),
            
            io:format("~nDEADLOCK DETECTION:~n"),
            io:format("  Server Responding: ~p~n", [ServerResponsive]),
            io:format("  Clients Alive: ~p/~p~n", 
                      [length([P || P <- Clients, erlang:is_process_alive(P)]), 
                       length(Clients)]),
            io:format("  Deadlock Detected: ~p~n", [DeadlockDetected]),
            
            io:format("~nANALYSIS:~n"),
            case ServerResponsive andalso CleanupSuccessPercent >= 99.0 of
                true ->
                    io:format("  Result: PASSED - System handled ~p concurrent timeouts~n", 
                              [TimeoutsFired]),
                    io:format("  Timeout mechanism scales correctly~n"),
                    io:format("  No deadlocks or resource leaks detected~n");
                false ->
                    io:format("  Result: WARNING - System strained at ~p concurrent timeouts~n", 
                              [TimeoutsFired]),
                    case DeadlockDetected of
                        true -> io:format("  DEADLOCK DETECTED - Breaking point found~n");
                        false -> ok
                    end,
                    case CleanupSuccessPercent < 99.0 of
                        true -> io:format("  Cleanup rate degraded to ~.2f%~n", 
                                          [CleanupSuccessPercent]);
                        false -> ok
                    end
            end,
            
            %% Cleanup
            gen_tcp:close(ListenSocket),
            lists:foreach(fun(Pid) -> catch exit(Pid, kill) end, Clients),
            
            io:format("~n=== TEST COMPLETE ===~n"),
            
            %% Exit with appropriate code
            case DeadlockDetected of
                true ->
                    halt(1);  % Deadlock detected
                false when CleanupSuccessPercent < 90.0 ->
                    halt(2);  % Cleanup failed
                false ->
                    halt(0)   % Success
            end;
        
        {error, Reason} ->
            io:format("Failed to start server: ~p~n", [Reason]),
            halt(3)
    end.

%% Accept connections
accept_loop(ListenSocket) ->
    case gen_tcp:accept(ListenSocket, 1000) of
        {ok, Socket} ->
            spawn(fun() -> slow_handler(Socket) end),
            accept_loop(ListenSocket);
        {error, timeout} ->
            accept_loop(ListenSocket)
    end.

%% Slow handler - sleeps 10 seconds
slow_handler(Socket) ->
    case gen_tcp:recv(Socket, 0, 5000) of
        {ok, _Data} ->
            timer:sleep(10000),  %% 10 second delay
            Response = <<"{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":{\"status\":\"done\"}}">>,
            catch gen_tcp:send(Socket, Response);
        {error, _Reason} ->
            ok
    end,
    catch gen_tcp:close(Socket).

%% Timeout client
timeout_client(Port, RequestCount, TimeoutMs, Parent, ClientIndex) ->
    Results = lists:map(fun(RequestIndex) ->
        RequestStart = erlang:monotonic_time(millisecond),
        
        case gen_tcp:connect({127,0,0,1}, Port, [binary, {packet, 0}, {active, false}], 5000) of
            {ok, Socket} ->
                Request = <<"{\"jsonrpc\":\"2.0\",\"id\":",
                           (integer_to_binary(RequestIndex))/binary,
                           ",\"method\":\"tools/call\",\"params\":{\"name\":\"very_slow_operation\"}}">>,
                
                case gen_tcp:send(Socket, Request) of
                    ok ->
                        ResponseResult = gen_tcp:recv(Socket, 0, TimeoutMs),
                        RequestEnd = erlang:monotonic_time(millisecond),
                        catch gen_tcp:close(Socket),
                        
                        case ResponseResult of
                            {error, timeout} -> 
                                {timeout, RequestEnd - RequestStart};
                            {ok, _Data} -> 
                                {success, RequestEnd - RequestStart};
                            {error, Reason} -> 
                                {error, Reason, RequestEnd - RequestStart}
                        end;
                    {error, Reason} ->
                        {send_error, Reason}
                end;
            {error, Reason} ->
                {connect_error, Reason}
        end
    end, lists:seq(1, RequestCount)),
    
    Parent ! {client_result, ClientIndex, Results},
    ok.

%% Collect results with monitoring
collect_results_with_monitoring(Clients, ExpectedCount, Timeout) ->
    collect_results_with_monitoring(Clients, ExpectedCount, Timeout, [], 0).

collect_results_with_monitoring(_Clients, ExpectedCount, Timeout, Acc, _MonitorCount) 
    when length(Acc) >= ExpectedCount; Timeout =< 0 ->
    lists:flatten(Acc);
collect_results_with_monitoring(Clients, ExpectedCount, Timeout, Acc, MonitorCount) ->
    Start = erlang:monotonic_time(millisecond),
    
    %% Print progress every 10K results
    NewMonitorCount = case length(Acc) div 10000 of
        N when N > MonitorCount ->
            io:format("  Progress: ~p/~p timeouts completed...~n", [length(Acc), ExpectedCount]),
            N;
        _ ->
            MonitorCount
    end,
    
    receive
        {client_result, _ClientIndex, Results} ->
            End = erlang:monotonic_time(millisecond),
            NewTimeout = Timeout - (End - Start),
            collect_results_with_monitoring(Clients, ExpectedCount, NewTimeout, [Results | Acc], NewMonitorCount)
    after 1000 ->
        End = erlang:monotonic_time(millisecond),
        NewTimeout = Timeout - (End - Start),
        collect_results_with_monitoring(Clients, ExpectedCount, NewTimeout, Acc, NewMonitorCount)
    end.

%% Analyze results
analyze_results(Results) ->
    Timeouts = lists:filter(fun(R) -> element(1, R) =:= timeout end, Results),
    Errors = lists:filter(fun(R) ->
        case element(1, R) of
            error -> true;
            connect_error -> true;
            send_error -> true;
            _ -> false
        end
    end, Results),
    
    TimeoutsFired = length(Timeouts),
    TimeoutsMissed = length(Errors),
    
    %% Calculate average timeout duration
    AvgTimeoutDuration = case Timeouts of
        [] -> 0.0;
        _ ->
            TotalDuration = lists:sum([element(2, R) || R <- Timeouts]),
            TotalDuration / length(Timeouts)
    end,
    
    {TimeoutsFired, TimeoutsMissed, AvgTimeoutDuration}.

%% Check server responsiveness
check_server_responsive(Port) ->
    case gen_tcp:connect({127,0,0,1}, Port, [binary, {packet, 0}], 1000) of
        {ok, Socket} ->
            gen_tcp:close(Socket),
            true;
        {error, _Reason} ->
            false
    end.

%% Detect deadlock
detect_deadlock(Clients) ->
    %% Check if clients are still alive after expected completion
    timer:sleep(2000),  %% Wait for stragglers
    LiveClients = lists:filter(fun(Pid) ->
        erlang:is_process_alive(Pid)
    end, Clients),
    
    %% Deadlock if many clients still alive after timeout
    length(LiveClients) > (length(Clients) div 10).
