{#
  Comprehensive MCP Test Suite Template - Generated from SPARQL/Ontology

  Generates comprehensive test suites for MCP protocol compliance testing.
  Follows Chicago School TDD: Real processes, state-based verification, no mocks.

  Context Variables from SPARQL:
    - module_name: string - Name of module being tested (e.g., "erlmcp_client")
    - methods: array - List of MCP methods with schemas and validation rules
      [{
        name: "initialize",
        method_constant: "MCP_METHOD_INITIALIZE",
        required_params: ["protocolVersion", "capabilities"],
        optional_params: ["clientInfo"],
        schema: {...},
        error_codes: [-32005, -32061],
        phase_required: "disconnected",
        capability_required: null,
        description: "Initialize MCP session"
      }]
    - capabilities: array - List of capabilities
    - error_codes: map - Error code definitions
    - integration_flows: array - Integration test scenarios
    - edge_cases: array - Edge case scenarios from evaluation

  Generator: ggen v{{ generator_version | default(value="1.0.0") }}
#}
%%% -*- mode: erlang; erlang-indent-level: 4; indent-tabs-mode: nil -*-
%%%-------------------------------------------------------------------
%%% @doc
%%% Comprehensive test suite for {{ module_name }}.
%%%
%%% Generated from MCP protocol specification and ontology.
%%% Tests MCP 2025-11-25 compliance with Chicago School TDD patterns.
%%%
%%% WARNING: This file is auto-generated by ggen.
%%% DO NOT EDIT MANUALLY - Changes will be overwritten.
%%% Edit the ontology source and regenerate.
%%%
%%% Generated: {{ timestamp }}
%%% Source: MCP Protocol Specification 2025-11-25
%%% Generator: ggen v{{ generator_version | default(value="1.0.0") }}
%%%
%%% Test Philosophy: Chicago School TDD
%%% - Real processes (no mocks)
%%% - State-based verification
%%% - Real message passing
%%% - Integration over isolation
%%%
%%% Coverage Target: 80%+ (85%+ for core modules)
%%%
%%% @end
%%%-------------------------------------------------------------------
-module({{ module_name }}_tests).

-include_lib("eunit/include/eunit.hrl").
-include("erlmcp.hrl").
{% if proper_tests | default(value=true) -%}
-ifdef(PROPER).
-include_lib("proper/include/proper.hrl").
-endif.
{% endif %}

%%%===================================================================
%%% Test Module Exports
%%%===================================================================

-export([
    %% Test setup/teardown
    setup/0,
    cleanup/1,

    %% Test helpers
    start_{{ module_name | lower }}/0,
    stop_{{ module_name | lower }}/1,
    create_valid_request/2,
    expect_error/2
]).

%%%===================================================================
%%% EUnit Test Groups
%%%===================================================================

%% Main test group with setup/teardown
{{ module_name | lower }}_test_() ->
    {setup,
     fun setup/0,
     fun cleanup/1,
     fun(Context) ->
         [
          %% Basic functionality tests
          {inorder, basic_functionality_tests(Context)},

          %% MCP method compliance tests
          {inorder, mcp_method_tests(Context)},

          %% Validation tests
          {inorder, validation_tests(Context)},

          %% Error handling tests
          {inorder, error_handling_tests(Context)},

          %% Edge case tests
          {inorder, edge_case_tests(Context)},

          %% Integration tests
          {inorder, integration_tests(Context)}
{% if proper_tests | default(value=true) -%}
          ,
          %% Property-based tests
          {inorder, property_tests(Context)}
{% endif %}
         ]
     end}.

%%%===================================================================
%%% Setup and Teardown (Chicago School: Real System)
%%%===================================================================

%% @doc Setup test environment
%% Starts real applications and processes (Chicago School TDD)
-spec setup() -> term().
setup() ->
    %% Start dependencies
    application:ensure_all_started(jsx),
    application:ensure_all_started(gproc),

    %% Start erlmcp application with real supervision tree
    {ok, _Apps} = application:ensure_all_started(erlmcp),

    %% Start test-specific {{ module_name | lower }}
    {ok, Pid} = start_{{ module_name | lower }}(),

    %% Return context
    #{
        pid => Pid,
        started_at => erlang:system_time(millisecond),
        test_id => make_ref()
    }.

%% @doc Cleanup test environment
-spec cleanup(term()) -> ok.
cleanup(#{pid := Pid} = _Context) ->
    %% Stop {{ module_name | lower }} (real process cleanup)
    stop_{{ module_name | lower }}(Pid),

    %% Stop application
    application:stop(erlmcp),

    ok.

%%%===================================================================
%%% Basic Functionality Tests
%%%===================================================================

basic_functionality_tests(Context) ->
    [
     ?_test(test_module_starts(Context)),
     ?_test(test_module_responds_to_ping(Context)),
     ?_test(test_module_handles_state(Context))
    ].

test_module_starts(#{pid := Pid}) ->
    %% Verify: Process alive (state verification, Chicago School)
    ?assert(is_process_alive(Pid)),
    ?assert(is_pid(Pid)).

test_module_responds_to_ping(#{pid := Pid}) ->
    %% Exercise: Send ping (real message passing)
    Pid ! {ping, self()},

    %% Verify: Receive pong (observable behavior)
    receive
        {pong, Pid} -> ok
    after 1000 ->
        ?assert(false) % Timeout
    end.

test_module_handles_state(#{pid := Pid}) ->
    %% Exercise: Query state via API
    {ok, State} = {{ module_name }}:get_state(Pid),

    %% Verify: State has expected structure (state-based verification)
    ?assertMatch(#{initialized := false}, State).

%%%===================================================================
%%% MCP Method Tests (Generated from Specification)
%%%===================================================================

mcp_method_tests(Context) ->
    [
{% for method in methods -%}
     %% {{ method.name }} method tests
     {inorder, [
      ?_test(test_{{ method.name | lower | replace(from="/", to="_") }}_valid_request(Context)),
      ?_test(test_{{ method.name | lower | replace(from="/", to="_") }}_invalid_params(Context)),
{% if method.phase_required -%}
      ?_test(test_{{ method.name | lower | replace(from="/", to="_") }}_phase_violation(Context)),
{% endif -%}
{% if method.capability_required -%}
      ?_test(test_{{ method.name | lower | replace(from="/", to="_") }}_capability_violation(Context)),
{% endif -%}
      ?_test(test_{{ method.name | lower | replace(from="/", to="_") }}_schema_validation(Context)),
      ?_test(test_{{ method.name | lower | replace(from="/", to="_") }}_error_codes(Context))
     ]}{% if not loop.last %},{% endif %}

{% endfor -%}
    ].

{% for method in methods %}
%% -------------------------------------------------------------------
%% {{ method.name }} Method Tests
%% -------------------------------------------------------------------

%% @doc Test {{ method.name }} with valid request
test_{{ method.name | lower | replace(from="/", to="_") }}_valid_request(#{pid := Pid}) ->
    %% Setup: Create valid request
    Request = create_valid_request({{ method.method_constant }}, #{
{% for param in method.required_params -%}
        {{ param }} => {{ method.sample_values[param] | default(value='<<"test_value">>') }}{% if not loop.last %},{% endif %}

{% endfor -%}
    }),

    %% Exercise: Send request (real message passing, Chicago School)
    {ok, Response} = {{ module_name }}:handle_request(Pid, Request),

    %% Verify: Response has expected structure (state-based verification)
    ?assertMatch(#{
        <<"jsonrpc">> := <<"2.0">>,
        <<"id">> := _,
        <<"result">> := _
    }, Response),

    %% Verify: No error in response
    ?assertEqual(false, maps:is_key(<<"error">>, Response)).

%% @doc Test {{ method.name }} with invalid parameters
test_{{ method.name | lower | replace(from="/", to="_") }}_invalid_params(#{pid := Pid}) ->
    %% Setup: Create request with invalid params
    Request = create_valid_request({{ method.method_constant }}, #{
        <<"invalid_param">> => <<"should_fail">>
    }),

    %% Exercise: Send request
    {error, Response} = {{ module_name }}:handle_request(Pid, Request),

    %% Verify: Error code is INVALID_PARAMS (MCP compliance)
    ?assertMatch(#{
        <<"error">> := #{
            <<"code">> := ?JSONRPC_INVALID_PARAMS
        }
    }, Response).

{% if method.phase_required -%}
%% @doc Test {{ method.name }} phase violation
test_{{ method.name | lower | replace(from="/", to="_") }}_phase_violation(#{pid := Pid}) ->
    %% Setup: Ensure wrong phase
    %% (This test assumes phase != {{ method.phase_required }})
    Request = create_valid_request({{ method.method_constant }}, #{}),

    %% Exercise: Send request in wrong phase
    {error, Response} = {{ module_name }}:handle_request(Pid, Request),

    %% Verify: Error code indicates phase violation
    ?assertMatch(#{
        <<"error">> := #{
            <<"code">> := ?MCP_ERROR_NOT_INITIALIZED
        }
    }, Response).
{% endif -%}

{% if method.capability_required -%}
%% @doc Test {{ method.name }} capability violation
test_{{ method.name | lower | replace(from="/", to="_") }}_capability_violation(#{pid := Pid}) ->
    %% Setup: Disable required capability
    ok = {{ module_name }}:set_capabilities(Pid, #{}),

    Request = create_valid_request({{ method.method_constant }}, #{}),

    %% Exercise: Send request without capability
    {error, Response} = {{ module_name }}:handle_request(Pid, Request),

    %% Verify: Error code indicates capability not supported
    ?assertMatch(#{
        <<"error">> := #{
            <<"code">> := ?MCP_ERROR_CAPABILITY_NOT_SUPPORTED
        }
    }, Response).
{% endif -%}

%% @doc Test {{ method.name }} schema validation
test_{{ method.name | lower | replace(from="/", to="_") }}_schema_validation(#{pid := Pid}) ->
    %% Setup: Create request with schema violations
    InvalidRequests = [
{% for violation in method.schema_violations | default(value=[]) -%}
        #{{{ violation.field }} => {{ violation.invalid_value }}}{% if not loop.last %},{% endif %}

{% endfor -%}
    ],

    %% Exercise & Verify: Each violation should return validation error
    lists:foreach(fun(Params) ->
        Request = create_valid_request({{ method.method_constant }}, Params),
        {error, Response} = {{ module_name }}:handle_request(Pid, Request),
        ?assertMatch(#{
            <<"error">> := #{
                <<"code">> := ?MCP_ERROR_VALIDATION_FAILED
            }
        }, Response)
    end, InvalidRequests).

%% @doc Test {{ method.name }} error codes
test_{{ method.name | lower | replace(from="/", to="_") }}_error_codes(#{pid := Pid}) ->
    %% Verify: All expected error codes are defined
    ExpectedErrors = [{{ method.error_codes | join(", ") }}],
    lists:foreach(fun(ErrorCode) ->
        ?assert(lists:member(ErrorCode, ?VALID_ERROR_CODES))
    end, ExpectedErrors).

{% endfor %}
%%%===================================================================
%%% Validation Tests
%%%===================================================================

validation_tests(Context) ->
    [
     ?_test(test_json_rpc_version_validation(Context)),
     ?_test(test_request_id_validation(Context)),
     ?_test(test_method_name_validation(Context)),
     ?_test(test_params_type_validation(Context))
    ].

test_json_rpc_version_validation(#{pid := Pid}) ->
    %% Setup: Request with wrong JSON-RPC version
    Request = #{
        <<"jsonrpc">> => <<"1.0">>,  %% Wrong version
        <<"id">> => 1,
        <<"method">> => ?MCP_METHOD_PING,
        <<"params">> => #{}
    },

    %% Exercise: Send request
    {error, Response} = {{ module_name }}:handle_request(Pid, Request),

    %% Verify: Invalid request error
    ?assertMatch(#{
        <<"error">> := #{
            <<"code">> := ?JSONRPC_INVALID_REQUEST
        }
    }, Response).

test_request_id_validation(#{pid := Pid}) ->
    %% Setup: Request with invalid ID types
    InvalidIds = [null, [], #{}, <<"string_with_spaces">>],

    %% Exercise & Verify: Each should be accepted or rejected per JSON-RPC 2.0
    lists:foreach(fun(Id) ->
        Request = create_valid_request(?MCP_METHOD_PING, #{}),
        RequestWithId = Request#{<<"id">> => Id},

        %% JSON-RPC 2.0: id can be string, number, or null
        %% Arrays and objects are invalid
        case Id of
            [] ->
                {error, _} = {{ module_name }}:handle_request(Pid, RequestWithId);
            #{} ->
                {error, _} = {{ module_name }}:handle_request(Pid, RequestWithId);
            _ ->
                {ok, _} = {{ module_name }}:handle_request(Pid, RequestWithId)
        end
    end, InvalidIds).

test_method_name_validation(#{pid := Pid}) ->
    %% Setup: Request with unknown method
    Request = create_valid_request(<<"unknown/method">>, #{}),

    %% Exercise: Send request
    {error, Response} = {{ module_name }}:handle_request(Pid, Request),

    %% Verify: Method not found error
    ?assertMatch(#{
        <<"error">> := #{
            <<"code">> := ?JSONRPC_METHOD_NOT_FOUND
        }
    }, Response).

test_params_type_validation(#{pid := Pid}) ->
    %% Setup: Request with params as array (should be object)
    Request = #{
        <<"jsonrpc">> => <<"2.0">>,
        <<"id">> => 1,
        <<"method">> => ?MCP_METHOD_INITIALIZE,
        <<"params">> => [<<"array_not_object">>]  %% Invalid type
    },

    %% Exercise: Send request
    {error, Response} = {{ module_name }}:handle_request(Pid, Request),

    %% Verify: Invalid params error
    ?assertMatch(#{
        <<"error">> := #{
            <<"code">> := ?JSONRPC_INVALID_PARAMS
        }
    }, Response).

%%%===================================================================
%%% Error Handling Tests
%%%===================================================================

error_handling_tests(Context) ->
    [
     ?_test(test_malformed_json(Context)),
     ?_test(test_missing_required_fields(Context)),
     ?_test(test_timeout_handling(Context)),
     ?_test(test_error_response_structure(Context))
    ].

test_malformed_json(#{pid := Pid}) ->
    %% Setup: Malformed JSON string
    MalformedJson = <<"{invalid json}">>,

    %% Exercise: Send malformed data
    {error, Response} = {{ module_name }}:handle_raw_data(Pid, MalformedJson),

    %% Verify: Parse error
    ?assertMatch(#{
        <<"error">> := #{
            <<"code">> := ?JSONRPC_PARSE_ERROR
        }
    }, Response).

test_missing_required_fields(#{pid := Pid}) ->
    %% Setup: Requests missing required fields
    InvalidRequests = [
        #{<<"id">> => 1},  %% Missing method
        #{<<"method">> => ?MCP_METHOD_PING},  %% Missing jsonrpc
        #{<<"jsonrpc">> => <<"2.0">>}  %% Missing both method and id
    ],

    %% Exercise & Verify: Each should return invalid request
    lists:foreach(fun(Request) ->
        {error, Response} = {{ module_name }}:handle_request(Pid, Request),
        ?assertMatch(#{
            <<"error">> := #{
                <<"code">> := ?JSONRPC_INVALID_REQUEST
            }
        }, Response)
    end, InvalidRequests).

test_timeout_handling(#{pid := Pid}) ->
    %% Setup: Request that will timeout
    Request = create_valid_request(<<"slow/operation">>, #{
        <<"timeout">> => 100  %% 100ms timeout
    }),

    %% Exercise: Send request with timeout
    {error, Response} = {{ module_name }}:handle_request(Pid, Request, 100),

    %% Verify: Timeout error
    ?assertMatch(#{
        <<"error">> := #{
            <<"code">> := ?MCP_ERROR_TIMEOUT
        }
    }, Response).

test_error_response_structure(#{pid := Pid}) ->
    %% Setup: Request that triggers error
    Request = create_valid_request(<<"unknown/method">>, #{}),

    %% Exercise: Send request
    {error, Response} = {{ module_name }}:handle_request(Pid, Request),

    %% Verify: Error response has required structure per JSON-RPC 2.0
    ?assertMatch(#{
        <<"jsonrpc">> := <<"2.0">>,
        <<"id">> := _,
        <<"error">> := #{
            <<"code">> := _,
            <<"message">> := _
        }
    }, Response),

    %% Verify: No result field in error response
    ?assertEqual(false, maps:is_key(<<"result">>, Response)).

%%%===================================================================
%%% Edge Case Tests (From Evaluation Findings)
%%%===================================================================

edge_case_tests(Context) ->
    [
{% for edge_case in edge_cases | default(value=[]) -%}
     ?_test(test_{{ edge_case.name | lower | replace(from=" ", to="_") }}(Context)){% if not loop.last %},{% endif %}

{% endfor -%}
{% if not edge_cases -%}
     ?_test(test_concurrent_requests(Context)),
     ?_test(test_request_cancellation(Context)),
     ?_test(test_large_payload(Context)),
     ?_test(test_rapid_reconnection(Context))
{% endif -%}
    ].

{% for edge_case in edge_cases | default(value=[]) %}
%% @doc Test edge case: {{ edge_case.description }}
test_{{ edge_case.name | lower | replace(from=" ", to="_") }}(#{pid := Pid}) ->
    %% Setup: {{ edge_case.setup }}
    {{ edge_case.setup_code | default(value="ok") }},

    %% Exercise: {{ edge_case.action }}
    {{ edge_case.exercise_code }},

    %% Verify: {{ edge_case.expected }}
    {{ edge_case.verify_code }}.

{% endfor %}
{% if not edge_cases %}
test_concurrent_requests(#{pid := Pid}) ->
    %% Setup: Spawn 100 processes sending concurrent requests
    Parent = self(),
    Pids = [spawn(fun() ->
        Request = create_valid_request(?MCP_METHOD_PING, #{}),
        {ok, Response} = {{ module_name }}:handle_request(Pid, Request),
        Parent ! {done, self(), Response}
    end) || _ <- lists:seq(1, 100)],

    %% Verify: All requests complete successfully
    Responses = [receive {done, P, R} -> R after 5000 -> timeout end || P <- Pids],
    ?assertEqual(100, length(Responses)),
    ?assert(lists:all(fun(R) -> maps:is_key(<<"result">>, R) end, Responses)).

test_request_cancellation(#{pid := Pid}) ->
    %% Setup: Start long-running request
    Request = create_valid_request(<<"long/operation">>, #{}),
    Ref = make_ref(),
    spawn(fun() ->
        {{ module_name }}:handle_request(Pid, Request)
    end),

    %% Exercise: Cancel request
    timer:sleep(50),  %% Let request start
    ok = {{ module_name }}:cancel_request(Pid, maps:get(<<"id">>, Request)),

    %% Verify: Request cancelled
    {ok, State} = {{ module_name }}:get_state(Pid),
    PendingRequests = maps:get(pending_requests, State, #{}),
    ?assertEqual(0, maps:size(PendingRequests)).

test_large_payload(#{pid := Pid}) ->
    %% Setup: Create request with large payload (but within limits)
    LargeData = binary:copy(<<"x">>, 1024 * 1024),  %% 1 MB
    Request = create_valid_request(?MCP_METHOD_PING, #{
        <<"data">> => LargeData
    }),

    %% Exercise: Send large request
    Result = {{ module_name }}:handle_request(Pid, Request),

    %% Verify: Request handled successfully
    ?assertMatch({ok, _}, Result).

test_rapid_reconnection(#{pid := Pid}) ->
    %% Setup: Disconnect and reconnect rapidly
    ok = {{ module_name }}:disconnect(Pid),
    timer:sleep(10),

    %% Exercise: Reconnect immediately
    {ok, _} = {{ module_name }}:connect(Pid),

    %% Verify: Connection restored
    {ok, State} = {{ module_name }}:get_state(Pid),
    ?assertMatch(#{connected := true}, State).
{% endif %}

%%%===================================================================
%%% Integration Tests
%%%===================================================================

integration_tests(Context) ->
    [
{% for flow in integration_flows | default(value=[]) -%}
     ?_test(test_{{ flow.name | lower | replace(from=" ", to="_") }}_flow(Context)){% if not loop.last %},{% endif %}

{% endfor -%}
{% if not integration_flows -%}
     ?_test(test_initialize_flow(Context)),
     ?_test(test_tool_call_flow(Context)),
     ?_test(test_resource_read_flow(Context)),
     ?_test(test_subscription_flow(Context))
{% endif -%}
    ].

{% for flow in integration_flows | default(value=[]) %}
%% @doc Integration test: {{ flow.description }}
test_{{ flow.name | lower | replace(from=" ", to="_") }}_flow(#{pid := Pid}) ->
    %% {{ flow.description }}
    {{ flow.test_code }}.

{% endfor %}
{% if not integration_flows %}
test_initialize_flow(#{pid := Pid}) ->
    %% Step 1: Send initialize request
    InitRequest = create_valid_request(?MCP_METHOD_INITIALIZE, #{
        <<"protocolVersion">> => ?MCP_VERSION,
        <<"capabilities">> => #{},
        <<"clientInfo">> => #{
            <<"name">> => <<"test_client">>,
            <<"version">> => <<"1.0.0">>
        }
    }),

    {ok, InitResponse} = {{ module_name }}:handle_request(Pid, InitRequest),

    %% Verify: Initialize response
    ?assertMatch(#{
        <<"result">> := #{
            <<"protocolVersion">> := ?MCP_VERSION,
            <<"capabilities">> := _,
            <<"serverInfo">> := _
        }
    }, InitResponse),

    %% Step 2: Send initialized notification
    InitializedNotif = #{
        <<"jsonrpc">> => <<"2.0">>,
        <<"method">> => ?MCP_METHOD_INITIALIZED,
        <<"params">> => #{}
    },

    ok = {{ module_name }}:handle_notification(Pid, InitializedNotif),

    %% Verify: State is now initialized
    {ok, State} = {{ module_name }}:get_state(Pid),
    ?assertMatch(#{initialized := true}, State).

test_tool_call_flow(#{pid := Pid}) ->
    %% Setup: Initialize first
    test_initialize_flow(#{pid => Pid}),

    %% Step 1: List available tools
    ListRequest = create_valid_request(?MCP_METHOD_TOOLS_LIST, #{}),
    {ok, ListResponse} = {{ module_name }}:handle_request(Pid, ListRequest),

    ?assertMatch(#{
        <<"result">> := #{
            <<"tools">> := _
        }
    }, ListResponse),

    %% Step 2: Call a tool
    CallRequest = create_valid_request(?MCP_METHOD_TOOLS_CALL, #{
        <<"name">> => <<"test_tool">>,
        <<"arguments">> => #{}
    }),

    {ok, CallResponse} = {{ module_name }}:handle_request(Pid, CallRequest),

    %% Verify: Tool call result
    ?assertMatch(#{
        <<"result">> := #{
            <<"content">> := _
        }
    }, CallResponse).

test_resource_read_flow(#{pid := Pid}) ->
    %% Setup: Initialize first
    test_initialize_flow(#{pid => Pid}),

    %% Step 1: List resources
    ListRequest = create_valid_request(?MCP_METHOD_RESOURCES_LIST, #{}),
    {ok, ListResponse} = {{ module_name }}:handle_request(Pid, ListRequest),

    ?assertMatch(#{
        <<"result">> := #{
            <<"resources">> := _
        }
    }, ListResponse),

    %% Step 2: Read a resource
    ReadRequest = create_valid_request(?MCP_METHOD_RESOURCES_READ, #{
        <<"uri">> => <<"test://resource/1">>
    }),

    {ok, ReadResponse} = {{ module_name }}:handle_request(Pid, ReadRequest),

    %% Verify: Resource content
    ?assertMatch(#{
        <<"result">> := #{
            <<"contents">> := _
        }
    }, ReadResponse).

test_subscription_flow(#{pid := Pid}) ->
    %% Setup: Initialize first
    test_initialize_flow(#{pid => Pid}),

    %% Step 1: Subscribe to resource updates
    SubRequest = create_valid_request(?MCP_METHOD_RESOURCES_SUBSCRIBE, #{
        <<"uri">> => <<"test://resource/1">>
    }),

    {ok, _SubResponse} = {{ module_name }}:handle_request(Pid, SubRequest),

    %% Step 2: Trigger resource update (simulate)
    ok = {{ module_name }}:update_resource(Pid, <<"test://resource/1">>, #{data => <<"new">>}),

    %% Verify: Notification received
    receive
        {notification, #{
            <<"method">> := ?MCP_METHOD_NOTIFICATIONS_RESOURCES_UPDATED
        }} -> ok
    after 1000 ->
        ?assert(false)  %% Timeout
    end,

    %% Step 3: Unsubscribe
    UnsubRequest = create_valid_request(?MCP_METHOD_RESOURCES_UNSUBSCRIBE, #{
        <<"uri">> => <<"test://resource/1">>
    }),

    {ok, _UnsubResponse} = {{ module_name }}:handle_request(Pid, UnsubRequest).
{% endif %}

{% if proper_tests | default(value=true) -%}
%%%===================================================================
%%% Property-Based Tests (PropEr)
%%%===================================================================

-ifdef(PROPER).

property_tests(_Context) ->
    [
     ?_test(prop_json_rpc_roundtrip()),
     ?_test(prop_request_id_correlation()),
     ?_test(prop_error_code_validity()),
     ?_test(prop_message_encoding_roundtrip())
    ].

%% @doc Property: JSON-RPC encoding/decoding roundtrip
prop_json_rpc_roundtrip() ->
    ?FORALL(Request, json_rpc_request_gen(),
        begin
            Encoded = jsx:encode(Request),
            Decoded = jsx:decode(Encoded, [return_maps]),
            Decoded =:= Request
        end
    ).

%% @doc Property: Request ID correlation maintained
prop_request_id_correlation() ->
    ?FORALL({RequestId, Method, Params}, {request_id_gen(), method_gen(), params_gen()},
        begin
            Request = #{
                <<"jsonrpc">> => <<"2.0">>,
                <<"id">> => RequestId,
                <<"method">> => Method,
                <<"params">> => Params
            },

            %% Response should have same ID
            {ok, Pid} = start_{{ module_name | lower }}(),
            {ok, Response} = {{ module_name }}:handle_request(Pid, Request),
            stop_{{ module_name | lower }}(Pid),

            maps:get(<<"id">>, Response) =:= RequestId
        end
    ).

%% @doc Property: All error codes are valid per specification
prop_error_code_validity() ->
    ?FORALL(ErrorCode, error_code_gen(),
        lists:member(ErrorCode, ?VALID_ERROR_CODES)
    ).

%% @doc Property: MCP message encoding roundtrip
prop_message_encoding_roundtrip() ->
    ?FORALL(Message, mcp_message_gen(),
        begin
            Encoded = erlmcp_json_rpc:encode(Message),
            {ok, Decoded} = erlmcp_json_rpc:decode(Encoded),
            normalize_message(Decoded) =:= normalize_message(Message)
        end
    ).

%%%===================================================================
%%% PropEr Generators
%%%===================================================================

%% @doc Generate valid JSON-RPC request
json_rpc_request_gen() ->
    ?LET({Id, Method, Params},
         {request_id_gen(), method_gen(), params_gen()},
         #{
             <<"jsonrpc">> => <<"2.0">>,
             <<"id">> => Id,
             <<"method">> => Method,
             <<"params">> => Params
         }).

%% @doc Generate valid request ID (string, number, or null)
request_id_gen() ->
    proper_types:oneof([
        proper_types:integer(),
        proper_types:binary(),
        null
    ]).

%% @doc Generate valid MCP method name
method_gen() ->
    proper_types:oneof([
{% for method in methods -%}
        {{ method.method_constant }}{% if not loop.last %},{% endif %}

{% endfor -%}
    ]).

%% @doc Generate valid params object
params_gen() ->
    ?LET(KeyVals, proper_types:list({proper_types:binary(), proper_types:any()}),
         maps:from_list(KeyVals)).

%% @doc Generate valid error code
error_code_gen() ->
    proper_types:oneof(?VALID_ERROR_CODES).

%% @doc Generate valid MCP message
mcp_message_gen() ->
    proper_types:oneof([
        json_rpc_request_gen(),
        json_rpc_response_gen(),
        json_rpc_notification_gen()
    ]).

json_rpc_response_gen() ->
    ?LET({Id, Result},
         {request_id_gen(), proper_types:any()},
         #{
             <<"jsonrpc">> => <<"2.0">>,
             <<"id">> => Id,
             <<"result">> => Result
         }).

json_rpc_notification_gen() ->
    ?LET({Method, Params},
         {method_gen(), params_gen()},
         #{
             <<"jsonrpc">> => <<"2.0">>,
             <<"method">> => Method,
             <<"params">> => Params
         }).

%% @doc Normalize message for comparison (handle JSON encoding differences)
normalize_message(Msg) when is_map(Msg) ->
    maps:map(fun(_K, V) -> normalize_value(V) end, Msg);
normalize_message(Other) ->
    Other.

normalize_value(V) when is_map(V) -> normalize_message(V);
normalize_value(V) when is_list(V) -> lists:map(fun normalize_value/1, V);
normalize_value(V) -> V.

-endif. % PROPER
{% endif %}

%%%===================================================================
%%% Test Helpers
%%%===================================================================

%% @doc Start {{ module_name | lower }} for testing (Chicago School: real process)
-spec start_{{ module_name | lower }}() -> {ok, pid()}.
start_{{ module_name | lower }}() ->
    %% Start real {{ module_name }} gen_server
    {{ module_name }}:start_link(#{
        transport => test,
        capabilities => #{}
    }).

%% @doc Stop {{ module_name | lower }}
-spec stop_{{ module_name | lower }}(pid()) -> ok.
stop_{{ module_name | lower }}(Pid) ->
    {{ module_name }}:stop(Pid).

%% @doc Create valid JSON-RPC request
-spec create_valid_request(binary(), map()) -> map().
create_valid_request(Method, Params) ->
    #{
        <<"jsonrpc">> => <<"2.0">>,
        <<"id">> => erlang:unique_integer([positive]),
        <<"method">> => Method,
        <<"params">> => Params
    }.

%% @doc Expect specific error code in response
-spec expect_error(map(), integer()) -> boolean().
expect_error(Response, ExpectedCode) ->
    case Response of
        #{<<"error">> := #{<<"code">> := Code}} ->
            Code =:= ExpectedCode;
        _ ->
            false
    end.

%%%===================================================================
%%% Generated Test Summary
%%%===================================================================

%% Test Coverage:
%% - Basic functionality: {{ methods | length }} methods
%% - MCP method tests: {{ methods | length * 6 }} tests (6 per method)
%% - Validation tests: 4 tests
%% - Error handling: 4 tests
%% - Edge cases: {{ edge_cases | default(value=[]) | length | default(value=4) }} tests
%% - Integration flows: {{ integration_flows | default(value=[]) | length | default(value=4) }} tests
{% if proper_tests | default(value=true) -%}
%% - Property tests: 4 properties
{% endif -%}
%%
%% Total: {{ (methods | length * 6) + 4 + 4 + (edge_cases | default(value=[]) | length | default(value=4)) + (integration_flows | default(value=[]) | length | default(value=4)) + (proper_tests | default(value=true) | ternary(4, 0)) }} tests
%%
%% Target Coverage: 80%+ (85%+ for core modules)
%% Quality Gates: 0 errors, 100% pass rate, Chicago School TDD compliance
