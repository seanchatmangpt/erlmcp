{#
  Erlang Task Manager Gen_Server Template

  Generates a production-ready OTP task management system implementing
  the MCP 2025-11-25 specification task lifecycle state machine.

  Context Variables:
    - module_name: string - Module name (default: erlmcp_task_manager)
    - lifecycle: object - Task lifecycle state machine definition
      - states: array - List of state names
      - transitions: array - Valid state transitions {from, to, event}
      - initial_state: string - Initial state name
      - terminal_states: array - Terminal states (no transitions out)
    - api_functions: array - API functions to generate
    - max_retries: integer - Max ID generation retries (default: 3)
    - pagination_limit: integer - Default page size (default: 50)
    - worker_limit: integer - Max concurrent workers (default: 100)
    - timeout_ms: integer - Task execution timeout (default: 300000)
    - enable_progress: boolean - Enable progress notifications (default: true)
    - enable_cancellation: boolean - Enable cancellation support (default: true)
    - enable_pagination: boolean - Enable cursor pagination (default: true)
    - ets_options: array - ETS table options
    - timestamp: string - Generation timestamp
    - generator_version: string - Template version
#}
%%% -*- mode: erlang; erlang-indent-level: 4; indent-tabs-mode: nil -*-
%%%-------------------------------------------------------------------
%%% @doc
%%% Task Management System for MCP 2025-11-25 Specification
%%%
%%% Implements a production-ready task lifecycle manager with state machine,
%%% pagination, progress tracking, and cancellation support.
%%%
%%% ## Features
%%%
%%% - Task lifecycle: {{ lifecycle.states | join(sep=" → ") }}
%%% - Cursor-based pagination
%%% - Progress notifications
%%% - Cancellation token support
%%% - Worker process supervision
%%% - Concurrent task limiting
%%% - Timeout handling
%%% - ETS-backed storage
%%%
%%% ## State Machine
%%%
%%% {% for transition in lifecycle.transitions %}
%%% - {{ transition.from }} → {{ transition.to }} (on {{ transition.event }})
%%% {% endfor %}
%%%
%%% ## Performance Characteristics
%%%
%%% - Task creation: <10ms (p99)
%%% - Task retrieval: <50ms (p99)
%%% - Task listing: <100ms for 1000 tasks (p99)
%%%
%%% WARNING: This file is auto-generated by ggen.
%%% DO NOT EDIT MANUALLY - Changes will be overwritten.
%%%
%%% Generated: {{ timestamp }}
%%% Generator: ggen v{{ generator_version }}
%%% @end
%%%-------------------------------------------------------------------
-module({{ module_name | default(value="erlmcp_task_manager") }}).
-behaviour(gen_server).

%% API exports
-export([
    start_link/0,
    start_link/1,
    create_task/2,
    create_task/3,
    list_tasks/0,
    list_tasks/1,
    list_tasks/2,
    get_task/1,
    get_task_result/1,
    cancel_task/1,
    cancel_task/2,
    update_progress/2,
    transition_task/3,
    cleanup_completed_tasks/1
]).

%% gen_server callbacks
-export([
    init/1,
    handle_call/3,
    handle_cast/2,
    handle_info/2,
    terminate/2,
    code_change/3
]).

%% Test exports
-ifdef(TEST).
-export([
    get_state/0,
    reset/0,
    set_worker_limit/1
]).
-endif.

%%%===================================================================
%%% Type Definitions
%%%===================================================================

-type task_id() :: binary().
-type task_status() :: {% for state in lifecycle.states %}{{ state }}{% if not loop.last %} | {% endif %}{% endfor %}.
-type progress() :: float(). % 0.0 to 1.0
-type cursor() :: binary() | undefined.
-type task_handler() :: fun(() -> {ok, term()} | {error, term()}).
-type cancellation_token() :: reference().

-record(task, {
    task_id :: task_id(),
    status :: task_status(),
    handler :: task_handler() | undefined,
    result :: term() | undefined,
    error :: term() | undefined,
    progress = 0.0 :: progress(),
    created_at :: erlang:timestamp(),
    updated_at :: erlang:timestamp(),
    metadata = #{} :: map(),
    worker_pid :: pid() | undefined,
    worker_monitor :: reference() | undefined,
    cancellation_token :: cancellation_token() | undefined
}).

-record(state, {
    tasks_table :: ets:tid(),
    worker_count = 0 :: non_neg_integer(),
    worker_limit = {{ worker_limit | default(value=100) }} :: non_neg_integer(),
    max_retries = {{ max_retries | default(value=3) }} :: non_neg_integer(),
    pagination_limit = {{ pagination_limit | default(value=50) }} :: non_neg_integer(),
    timeout_ms = {{ timeout_ms | default(value=300000) }} :: non_neg_integer(),
    enable_progress = {{ enable_progress | default(value="true") }} :: boolean(),
    enable_cancellation = {{ enable_cancellation | default(value="true") }} :: boolean(),
    enable_pagination = {{ enable_pagination | default(value="true") }} :: boolean()
}).

-type state() :: #state{}.

%%%===================================================================
%%% API Functions
%%%===================================================================

%% @doc Starts the task manager with default configuration.
-spec start_link() -> {ok, pid()} | {error, term()}.
start_link() ->
    start_link(#{}).

%% @doc Starts the task manager with custom configuration.
-spec start_link(map()) -> {ok, pid()} | {error, term()}.
start_link(Config) ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, Config, []).

%% @doc Creates a new task with auto-generated ID.
-spec create_task(task_handler(), map()) -> {ok, task_id()} | {error, term()}.
create_task(Handler, Metadata) when is_function(Handler, 0), is_map(Metadata) ->
    gen_server:call(?MODULE, {create_task, Handler, Metadata}, infinity).

%% @doc Creates a new task with specific ID (for testing).
-spec create_task(task_id(), task_handler(), map()) -> {ok, task_id()} | {error, term()}.
create_task(TaskId, Handler, Metadata) when is_binary(TaskId), is_function(Handler, 0), is_map(Metadata) ->
    gen_server:call(?MODULE, {create_task, TaskId, Handler, Metadata}, infinity).

%% @doc Lists all tasks with default pagination.
-spec list_tasks() -> {ok, [#task{}], cursor()} | {error, term()}.
list_tasks() ->
    list_tasks(undefined, {{ pagination_limit | default(value=50) }}).

%% @doc Lists tasks with cursor-based pagination.
-spec list_tasks(cursor()) -> {ok, [#task{}], cursor()} | {error, term()}.
list_tasks(Cursor) ->
    list_tasks(Cursor, {{ pagination_limit | default(value=50) }}).

%% @doc Lists tasks with cursor and custom limit.
-spec list_tasks(cursor(), pos_integer()) -> {ok, [#task{}], cursor()} | {error, term()}.
list_tasks(Cursor, Limit) ->
    gen_server:call(?MODULE, {list_tasks, Cursor, Limit}, infinity).

%% @doc Gets a specific task by ID.
-spec get_task(task_id()) -> {ok, #task{}} | {error, not_found}.
get_task(TaskId) when is_binary(TaskId) ->
    gen_server:call(?MODULE, {get_task, TaskId}, infinity).

%% @doc Gets the result of a completed task.
-spec get_task_result(task_id()) -> {ok, term()} | {error, term()}.
get_task_result(TaskId) when is_binary(TaskId) ->
    gen_server:call(?MODULE, {get_task_result, TaskId}, infinity).

%% @doc Cancels a running task.
-spec cancel_task(task_id()) -> ok | {error, term()}.
cancel_task(TaskId) ->
    cancel_task(TaskId, <<"User cancelled">>).

%% @doc Cancels a running task with reason.
-spec cancel_task(task_id(), binary()) -> ok | {error, term()}.
cancel_task(TaskId, Reason) when is_binary(TaskId), is_binary(Reason) ->
    gen_server:call(?MODULE, {cancel_task, TaskId, Reason}, infinity).

%% @doc Updates task progress (called by worker).
-spec update_progress(task_id(), progress()) -> ok | {error, term()}.
update_progress(TaskId, Progress) when is_binary(TaskId), is_float(Progress) ->
    gen_server:cast(?MODULE, {update_progress, TaskId, Progress}).

%% @doc Manually transitions task state (for testing).
-spec transition_task(task_id(), task_status(), task_status()) -> ok | {error, term()}.
transition_task(TaskId, FromStatus, ToStatus) ->
    gen_server:call(?MODULE, {transition_task, TaskId, FromStatus, ToStatus}, infinity).

%% @doc Cleans up completed tasks older than specified age.
-spec cleanup_completed_tasks(non_neg_integer()) -> {ok, non_neg_integer()}.
cleanup_completed_tasks(MaxAgeMs) ->
    gen_server:call(?MODULE, {cleanup_completed_tasks, MaxAgeMs}, infinity).

%%%===================================================================
%%% gen_server Callbacks
%%%===================================================================

%% @private
init(Config) ->
    process_flag(trap_exit, true),

    TableOpts = [
        set,
        public,
        named_table,
        {keypos, #task.task_id},
        {read_concurrency, true},
        {write_concurrency, true}
        {% if ets_options %}{% for opt in ets_options %},
        {{ opt }}{% endfor %}{% endif %}
    ],

    TasksTable = ets:new({{ module_name | default(value="erlmcp_task_manager") }}_tasks, TableOpts),

    State = #state{
        tasks_table = TasksTable,
        worker_limit = maps:get(worker_limit, Config, {{ worker_limit | default(value=100) }}),
        max_retries = maps:get(max_retries, Config, {{ max_retries | default(value=3) }}),
        pagination_limit = maps:get(pagination_limit, Config, {{ pagination_limit | default(value=50) }}),
        timeout_ms = maps:get(timeout_ms, Config, {{ timeout_ms | default(value=300000) }}),
        enable_progress = maps:get(enable_progress, Config, {{ enable_progress | default(value="true") }}),
        enable_cancellation = maps:get(enable_cancellation, Config, {{ enable_cancellation | default(value="true") }}),
        enable_pagination = maps:get(enable_pagination, Config, {{ enable_pagination | default(value="true") }})
    },

    {ok, State}.

%% @private
handle_call({create_task, Handler, Metadata}, _From, State) ->
    case create_task_internal(undefined, Handler, Metadata, State) of
        {ok, TaskId, NewState} ->
            {reply, {ok, TaskId}, NewState};
        {error, Reason} ->
            {reply, {error, Reason}, State}
    end;

handle_call({create_task, TaskId, Handler, Metadata}, _From, State) ->
    case create_task_internal(TaskId, Handler, Metadata, State) of
        {ok, TaskId, NewState} ->
            {reply, {ok, TaskId}, NewState};
        {error, Reason} ->
            {reply, {error, Reason}, State}
    end;

handle_call({list_tasks, Cursor, Limit}, _From, State) ->
    case list_tasks_internal(Cursor, Limit, State) of
        {ok, Tasks, NextCursor} ->
            {reply, {ok, Tasks, NextCursor}, State};
        {error, Reason} ->
            {reply, {error, Reason}, State}
    end;

handle_call({get_task, TaskId}, _From, State) ->
    case ets:lookup(State#state.tasks_table, TaskId) of
        [Task] ->
            {reply, {ok, Task}, State};
        [] ->
            {reply, {error, not_found}, State}
    end;

handle_call({get_task_result, TaskId}, _From, State) ->
    case ets:lookup(State#state.tasks_table, TaskId) of
        [#task{status = completed, result = Result}] ->
            {reply, {ok, Result}, State};
        [#task{status = failed, error = Error}] ->
            {reply, {error, Error}, State};
        [#task{status = cancelled}] ->
            {reply, {error, cancelled}, State};
        [#task{status = Status}] ->
            {reply, {error, {not_completed, Status}}, State};
        [] ->
            {reply, {error, not_found}, State}
    end;

handle_call({cancel_task, TaskId, Reason}, _From, State) ->
    case cancel_task_internal(TaskId, Reason, State) of
        {ok, NewState} ->
            {reply, ok, NewState};
        {error, Reason} ->
            {reply, {error, Reason}, State}
    end;

handle_call({transition_task, TaskId, FromStatus, ToStatus}, _From, State) ->
    case transition_task_internal(TaskId, FromStatus, ToStatus, State) of
        ok ->
            {reply, ok, State};
        {error, Reason} ->
            {reply, {error, Reason}, State}
    end;

handle_call({cleanup_completed_tasks, MaxAgeMs}, _From, State) ->
    Count = cleanup_completed_tasks_internal(MaxAgeMs, State),
    {reply, {ok, Count}, State};

%% Test helpers
-ifdef(TEST).
handle_call(get_state, _From, State) ->
    {reply, State, State};

handle_call(reset, _From, State) ->
    ets:delete_all_objects(State#state.tasks_table),
    {reply, ok, State#state{worker_count = 0}};

handle_call({set_worker_limit, Limit}, _From, State) ->
    {reply, ok, State#state{worker_limit = Limit}};
-endif.

handle_call(_Request, _From, State) ->
    {reply, {error, unknown_request}, State}.

%% @private
handle_cast({update_progress, TaskId, Progress}, State) ->
    case ets:lookup(State#state.tasks_table, TaskId) of
        [Task] when Task#task.status =:= {{ lifecycle.states[1] | default(value="working") }} ->
            UpdatedTask = Task#task{
                progress = Progress,
                updated_at = erlang:timestamp()
            },
            ets:insert(State#state.tasks_table, UpdatedTask),

            %% Notify progress subscribers if enabled
            {% if enable_progress | default(value="true") %}
            case State#state.enable_progress of
                true ->
                    notify_progress(TaskId, Progress);
                false ->
                    ok
            end,
            {% endif %}

            {noreply, State};
        _ ->
            {noreply, State}
    end;

handle_cast(_Msg, State) ->
    {noreply, State}.

%% @private
handle_info({task_completed, TaskId, Result}, State) ->
    case ets:lookup(State#state.tasks_table, TaskId) of
        [Task] ->
            UpdatedTask = Task#task{
                status = {{ lifecycle.terminal_states[0] | default(value="completed") }},
                result = Result,
                progress = 1.0,
                updated_at = erlang:timestamp(),
                worker_pid = undefined,
                worker_monitor = undefined
            },
            ets:insert(State#state.tasks_table, UpdatedTask),
            NewState = State#state{worker_count = State#state.worker_count - 1},
            {noreply, NewState};
        [] ->
            {noreply, State}
    end;

handle_info({task_failed, TaskId, Error}, State) ->
    case ets:lookup(State#state.tasks_table, TaskId) of
        [Task] ->
            UpdatedTask = Task#task{
                status = {{ lifecycle.terminal_states[1] | default(value="failed") }},
                error = Error,
                updated_at = erlang:timestamp(),
                worker_pid = undefined,
                worker_monitor = undefined
            },
            ets:insert(State#state.tasks_table, UpdatedTask),
            NewState = State#state{worker_count = State#state.worker_count - 1},
            {noreply, NewState};
        [] ->
            {noreply, State}
    end;

handle_info({'DOWN', MonitorRef, process, _Pid, Reason}, State) ->
    %% Worker crashed - find task and mark as failed
    case find_task_by_monitor(MonitorRef, State) of
        {ok, TaskId} ->
            case ets:lookup(State#state.tasks_table, TaskId) of
                [Task] ->
                    UpdatedTask = Task#task{
                        status = {{ lifecycle.terminal_states[1] | default(value="failed") }},
                        error = {worker_crashed, Reason},
                        updated_at = erlang:timestamp(),
                        worker_pid = undefined,
                        worker_monitor = undefined
                    },
                    ets:insert(State#state.tasks_table, UpdatedTask),
                    NewState = State#state{worker_count = State#state.worker_count - 1},
                    {noreply, NewState};
                [] ->
                    {noreply, State}
            end;
        not_found ->
            {noreply, State}
    end;

handle_info({'EXIT', _Pid, _Reason}, State) ->
    {noreply, State};

handle_info(_Info, State) ->
    {noreply, State}.

%% @private
terminate(_Reason, State) ->
    %% Clean up ETS table
    catch ets:delete(State#state.tasks_table),

    %% Cancel all running tasks
    Tasks = ets:tab2list(State#state.tasks_table),
    lists:foreach(fun(Task) ->
        case Task#task.status of
            {{ lifecycle.states[1] | default(value="working") }} ->
                cancel_task_internal(Task#task.task_id, <<"Server shutting down">>, State);
            _ ->
                ok
        end
    end, Tasks),

    ok.

%% @private
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%===================================================================
%%% Internal Functions
%%%===================================================================

%% @doc Creates a task and spawns worker process
-spec create_task_internal(task_id() | undefined, task_handler(), map(), state()) ->
    {ok, task_id(), state()} | {error, term()}.
create_task_internal(MaybeTaskId, Handler, Metadata, State) ->
    case State#state.worker_count >= State#state.worker_limit of
        true ->
            {error, worker_limit_reached};
        false ->
            TaskId = case MaybeTaskId of
                undefined -> generate_task_id(State);
                Id -> Id
            end,

            case ets:member(State#state.tasks_table, TaskId) of
                true ->
                    {error, task_id_exists};
                false ->
                    {% if enable_cancellation | default(value="true") %}
                    CancellationToken = case State#state.enable_cancellation of
                        true -> make_ref();
                        false -> undefined
                    end,
                    {% else %}
                    CancellationToken = undefined,
                    {% endif %}

                    Task = #task{
                        task_id = TaskId,
                        status = {{ lifecycle.initial_state | default(value="pending") }},
                        handler = Handler,
                        created_at = erlang:timestamp(),
                        updated_at = erlang:timestamp(),
                        metadata = Metadata,
                        cancellation_token = CancellationToken
                    },

                    ets:insert(State#state.tasks_table, Task),

                    %% Spawn worker process
                    {WorkerPid, MonitorRef} = spawn_worker(TaskId, Handler, State),

                    UpdatedTask = Task#task{
                        worker_pid = WorkerPid,
                        worker_monitor = MonitorRef
                    },
                    ets:insert(State#state.tasks_table, UpdatedTask),

                    NewState = State#state{worker_count = State#state.worker_count + 1},
                    {ok, TaskId, NewState}
            end
    end.

%% @doc Generates a unique task ID with retry logic
-spec generate_task_id(state()) -> task_id().
generate_task_id(State) ->
    generate_task_id(State, 0).

-spec generate_task_id(state(), non_neg_integer()) -> task_id().
generate_task_id(State, Attempts) when Attempts < State#state.max_retries ->
    TaskId = list_to_binary(io_lib:format("task_~s", [generate_uuid()])),
    case ets:member(State#state.tasks_table, TaskId) of
        true ->
            generate_task_id(State, Attempts + 1);
        false ->
            TaskId
    end;
generate_task_id(_State, _Attempts) ->
    error(task_id_generation_failed).

%% @doc Generates a UUID for task IDs
-spec generate_uuid() -> string().
generate_uuid() ->
    <<A:32, B:16, C:16, D:16, E:48>> = crypto:strong_rand_bytes(16),
    io_lib:format("~8.16.0b-~4.16.0b-~4.16.0b-~4.16.0b-~12.16.0b",
                  [A, B, C band 16#0fff bor 16#4000, D band 16#3fff bor 16#8000, E]).

%% @doc Lists tasks with pagination
-spec list_tasks_internal(cursor(), pos_integer(), state()) ->
    {ok, [#task{}], cursor()} | {error, term()}.
list_tasks_internal(Cursor, Limit, State) ->
    {% if enable_pagination | default(value="true") %}
    case State#state.enable_pagination of
        true ->
            case Cursor of
                undefined ->
                    %% First page
                    AllTasks = ets:tab2list(State#state.tasks_table),
                    SortedTasks = lists:sort(
                        fun(A, B) -> A#task.created_at >= B#task.created_at end,
                        AllTasks
                    ),
                    {PageTasks, NextCursor} = paginate_tasks(SortedTasks, Limit),
                    {ok, PageTasks, NextCursor};
                _ ->
                    %% Subsequent page - decode cursor
                    case decode_cursor(Cursor) of
                        {ok, LastTaskId} ->
                            AllTasks = ets:tab2list(State#state.tasks_table),
                            SortedTasks = lists:sort(
                                fun(A, B) -> A#task.created_at >= B#task.created_at end,
                                AllTasks
                            ),
                            TasksAfterCursor = lists:dropwhile(
                                fun(T) -> T#task.task_id =/= LastTaskId end,
                                SortedTasks
                            ),
                            %% Drop the cursor task itself
                            RemainingTasks = case TasksAfterCursor of
                                [_|Rest] -> Rest;
                                [] -> []
                            end,
                            {PageTasks, NextCursor} = paginate_tasks(RemainingTasks, Limit),
                            {ok, PageTasks, NextCursor};
                        {error, Reason} ->
                            {error, Reason}
                    end
            end;
        false ->
            %% Pagination disabled - return all tasks
            AllTasks = ets:tab2list(State#state.tasks_table),
            {ok, AllTasks, undefined}
    end;
    {% else %}
    %% Pagination disabled in template
    AllTasks = ets:tab2list(State#state.tasks_table),
    {ok, AllTasks, undefined};
    {% endif %}

%% @doc Paginates task list and generates next cursor
-spec paginate_tasks([#task{}], pos_integer()) -> {[#task{}], cursor()}.
paginate_tasks(Tasks, Limit) ->
    case length(Tasks) > Limit of
        true ->
            PageTasks = lists:sublist(Tasks, Limit),
            LastTask = lists:last(PageTasks),
            NextCursor = encode_cursor(LastTask#task.task_id),
            {PageTasks, NextCursor};
        false ->
            {Tasks, undefined}
    end.

%% @doc Encodes task ID as pagination cursor
-spec encode_cursor(task_id()) -> cursor().
encode_cursor(TaskId) ->
    base64:encode(TaskId).

%% @doc Decodes pagination cursor to task ID
-spec decode_cursor(cursor()) -> {ok, task_id()} | {error, term()}.
decode_cursor(Cursor) ->
    try
        TaskId = base64:decode(Cursor),
        {ok, TaskId}
    catch
        _:_ ->
            {error, invalid_cursor}
    end.

%% @doc Cancels a task
-spec cancel_task_internal(task_id(), binary(), state()) -> {ok, state()} | {error, term()}.
cancel_task_internal(TaskId, Reason, State) ->
    case ets:lookup(State#state.tasks_table, TaskId) of
        [Task] ->
            %% Check if task can be cancelled
            case is_cancellable(Task#task.status) of
                true ->
                    %% Kill worker if running
                    case Task#task.worker_pid of
                        undefined ->
                            ok;
                        Pid when is_pid(Pid) ->
                            catch exit(Pid, kill),
                            case Task#task.worker_monitor of
                                undefined -> ok;
                                Ref -> demonitor(Ref, [flush])
                            end
                    end,

                    UpdatedTask = Task#task{
                        status = {{ lifecycle.terminal_states[2] | default(value="cancelled") }},
                        error = {cancelled, Reason},
                        updated_at = erlang:timestamp(),
                        worker_pid = undefined,
                        worker_monitor = undefined
                    },
                    ets:insert(State#state.tasks_table, UpdatedTask),

                    {% if enable_cancellation | default(value="true") %}
                    %% Notify cancellation subscribers
                    case State#state.enable_cancellation of
                        true ->
                            notify_cancellation(TaskId, Reason);
                        false ->
                            ok
                    end,
                    {% endif %}

                    NewState = case Task#task.status of
                        {{ lifecycle.states[1] | default(value="working") }} ->
                            State#state{worker_count = State#state.worker_count - 1};
                        _ ->
                            State
                    end,

                    {ok, NewState};
                false ->
                    {error, {cannot_cancel, Task#task.status}}
            end;
        [] ->
            {error, not_found}
    end.

%% @doc Checks if task status allows cancellation
-spec is_cancellable(task_status()) -> boolean().
is_cancellable(Status) ->
    not lists:member(Status, [{{ lifecycle.terminal_states | map(attribute="") | join(sep=", ") }}]).

%% @doc Transitions task state with validation
-spec transition_task_internal(task_id(), task_status(), task_status(), state()) ->
    ok | {error, term()}.
transition_task_internal(TaskId, FromStatus, ToStatus, State) ->
    case ets:lookup(State#state.tasks_table, TaskId) of
        [Task] ->
            case Task#task.status of
                FromStatus ->
                    case is_valid_transition(FromStatus, ToStatus) of
                        true ->
                            UpdatedTask = Task#task{
                                status = ToStatus,
                                updated_at = erlang:timestamp()
                            },
                            ets:insert(State#state.tasks_table, UpdatedTask),
                            ok;
                        false ->
                            {error, {invalid_transition, FromStatus, ToStatus}}
                    end;
                ActualStatus ->
                    {error, {wrong_status, ActualStatus, FromStatus}}
            end;
        [] ->
            {error, not_found}
    end.

%% @doc Validates state machine transitions
-spec is_valid_transition(task_status(), task_status()) -> boolean().
is_valid_transition(FromStatus, ToStatus) ->
    ValidTransitions = [
        {% for transition in lifecycle.transitions %}
        {{{ transition.from }}, {{ transition.to }}}{% if not loop.last %},{% endif %}
        {% endfor %}
    ],
    lists:member({FromStatus, ToStatus}, ValidTransitions).

%% @doc Spawns worker process for task execution
-spec spawn_worker(task_id(), task_handler(), state()) -> {pid(), reference()}.
spawn_worker(TaskId, Handler, State) ->
    ManagerPid = self(),
    Timeout = State#state.timeout_ms,

    WorkerPid = spawn_link(fun() ->
        %% Update status to working
        case ets:lookup(State#state.tasks_table, TaskId) of
            [Task] ->
                WorkingTask = Task#task{
                    status = {{ lifecycle.states[1] | default(value="working") }},
                    updated_at = erlang:timestamp()
                },
                ets:insert(State#state.tasks_table, WorkingTask);
            [] ->
                ok
        end,

        %% Execute handler with timeout
        try
            Result = case Timeout of
                infinity ->
                    Handler();
                _ ->
                    execute_with_timeout(Handler, Timeout)
            end,

            case Result of
                {ok, Data} ->
                    ManagerPid ! {task_completed, TaskId, Data};
                {error, Error} ->
                    ManagerPid ! {task_failed, TaskId, Error};
                Other ->
                    ManagerPid ! {task_completed, TaskId, Other}
            end
        catch
            Class:Reason:Stacktrace ->
                Error = #{
                    class => Class,
                    reason => Reason,
                    stacktrace => Stacktrace
                },
                ManagerPid ! {task_failed, TaskId, Error}
        end
    end),

    MonitorRef = monitor(process, WorkerPid),
    {WorkerPid, MonitorRef}.

%% @doc Executes handler with timeout
-spec execute_with_timeout(fun(), non_neg_integer()) -> term().
execute_with_timeout(Handler, Timeout) ->
    Parent = self(),
    Ref = make_ref(),

    Pid = spawn(fun() ->
        Result = Handler(),
        Parent ! {Ref, Result}
    end),

    receive
        {Ref, Result} ->
            Result
    after Timeout ->
        exit(Pid, kill),
        {error, timeout}
    end.

%% @doc Finds task by worker monitor reference
-spec find_task_by_monitor(reference(), state()) -> {ok, task_id()} | not_found.
find_task_by_monitor(MonitorRef, State) ->
    MatchSpec = [
        {#task{worker_monitor = MonitorRef, task_id = '$1', _ = '_'}, [], ['$1']}
    ],
    case ets:select(State#state.tasks_table, MatchSpec) of
        [TaskId] ->
            {ok, TaskId};
        [] ->
            not_found
    end.

%% @doc Cleans up old completed tasks
-spec cleanup_completed_tasks_internal(non_neg_integer(), state()) -> non_neg_integer().
cleanup_completed_tasks_internal(MaxAgeMs, State) ->
    Now = erlang:timestamp(),
    TerminalStates = [{{ lifecycle.terminal_states | join(sep=", ") }}],

    AllTasks = ets:tab2list(State#state.tasks_table),
    TasksToDelete = lists:filter(fun(Task) ->
        IsTerminal = lists:member(Task#task.status, TerminalStates),
        AgeMs = timer:now_diff(Now, Task#task.updated_at) div 1000,
        IsTerminal andalso (AgeMs > MaxAgeMs)
    end, AllTasks),

    lists:foreach(fun(Task) ->
        ets:delete(State#state.tasks_table, Task#task.task_id)
    end, TasksToDelete),

    length(TasksToDelete).

{% if enable_progress | default(value="true") %}
%% @doc Notifies progress subscribers (integration point)
-spec notify_progress(task_id(), progress()) -> ok.
notify_progress(TaskId, Progress) ->
    %% TODO: Integrate with erlmcp_progress module
    %% erlmcp_progress:notify(TaskId, Progress)
    logger:debug("Task ~s progress: ~p", [TaskId, Progress]),
    ok.
{% endif %}

{% if enable_cancellation | default(value="true") %}
%% @doc Notifies cancellation subscribers (integration point)
-spec notify_cancellation(task_id(), binary()) -> ok.
notify_cancellation(TaskId, Reason) ->
    %% TODO: Integrate with erlmcp_cancellation module
    %% erlmcp_cancellation:notify(TaskId, Reason)
    logger:debug("Task ~s cancelled: ~s", [TaskId, Reason]),
    ok.
{% endif %}

%%%===================================================================
%%% Test Helpers
%%%===================================================================

-ifdef(TEST).

get_state() ->
    gen_server:call(?MODULE, get_state, infinity).

reset() ->
    gen_server:call(?MODULE, reset, infinity).

set_worker_limit(Limit) ->
    gen_server:call(?MODULE, {set_worker_limit, Limit}, infinity).

-endif.
