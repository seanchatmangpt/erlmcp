{#
  Erlang Task Manager Tests Template

  Generates comprehensive EUnit tests for the task management system.
  Follows Chicago School TDD (no mocks, real processes).

  Context Variables:
    - module_name: string - Module name (default: erlmcp_task_manager_tests)
    - worker_module: string - Worker module to test (default: erlmcp_task_manager)
    - lifecycle: object - Task lifecycle for state machine tests
    - timestamp: string - Generation timestamp
    - generator_version: string - Template version
#}
%%% -*- mode: erlang; erlang-indent-level: 4; indent-tabs-mode: nil -*-
%%%-------------------------------------------------------------------
%%% @doc
%%% Task Manager EUnit Tests (Chicago School TDD)
%%%
%%% Tests the task management system using real processes and state.
%%% No mocks - validates actual behavior.
%%%
%%% WARNING: This file is auto-generated by ggen.
%%% DO NOT EDIT MANUALLY - Changes will be overwritten.
%%%
%%% Generated: {{ timestamp }}
%%% Generator: ggen v{{ generator_version }}
%%% @end
%%%-------------------------------------------------------------------
-module({{ module_name | default(value="erlmcp_task_manager_tests") }}).

-include_lib("eunit/include/eunit.hrl").

-define(WORKER, {{ worker_module | default(value="erlmcp_task_manager") }}).
-define(TIMEOUT, 5000).

%%%===================================================================
%%% Test Fixtures
%%%===================================================================

task_manager_test_() ->
    {foreach,
     fun setup/0,
     fun cleanup/1,
     [
         {"Process startup", fun test_start_link/0},
         {"Task creation", fun test_create_task/0},
         {"Task creation with ID", fun test_create_task_with_id/0},
         {"Task ID collision retry", fun test_task_id_collision/0},
         {"Get task", fun test_get_task/0},
         {"Get task not found", fun test_get_task_not_found/0},
         {"List tasks empty", fun test_list_tasks_empty/0},
         {"List tasks with data", fun test_list_tasks_with_data/0},
         {"List tasks pagination", fun test_list_tasks_pagination/0},
         {"Task lifecycle - success", fun test_task_lifecycle_success/0},
         {"Task lifecycle - failure", fun test_task_lifecycle_failure/0},
         {"Task cancellation - pending", fun test_cancel_task_pending/0},
         {"Task cancellation - working", fun test_cancel_task_working/0},
         {"Task cancellation - terminal state", fun test_cancel_terminal_state/0},
         {"Get task result - completed", fun test_get_task_result_completed/0},
         {"Get task result - failed", fun test_get_task_result_failed/0},
         {"Get task result - cancelled", fun test_get_task_result_cancelled/0},
         {"Get task result - not completed", fun test_get_task_result_not_completed/0},
         {"Progress updates", fun test_progress_updates/0},
         {"Worker crash handling", fun test_worker_crash/0},
         {"Worker limit enforcement", fun test_worker_limit/0},
         {"Task timeout", fun test_task_timeout/0},
         {"Cleanup completed tasks", fun test_cleanup_completed_tasks/0},
         {"State machine transitions", fun test_state_machine_transitions/0},
         {"Concurrent task creation", fun test_concurrent_task_creation/0}
     ]}.

%%%===================================================================
%%% Setup and Cleanup
%%%===================================================================

setup() ->
    %% Start task manager
    {ok, Pid} = ?WORKER:start_link(#{
        worker_limit => 10,
        timeout_ms => 5000
    }),
    Pid.

cleanup(Pid) ->
    %% Stop task manager
    catch exit(Pid, kill),
    timer:sleep(100),
    ok.

%%%===================================================================
%%% Test Cases
%%%===================================================================

test_start_link() ->
    State = ?WORKER:get_state(),
    ?assertMatch(#state{}, State),
    ?assert(is_process_alive(whereis(?WORKER))).

test_create_task() ->
    Handler = fun() -> {ok, #{result => success}} end,
    {ok, TaskId} = ?WORKER:create_task(Handler, #{metadata => <<"test">>}),
    ?assert(is_binary(TaskId)),
    {ok, Task} = ?WORKER:get_task(TaskId),
    ?assertEqual(TaskId, Task#task.task_id),
    ?assertMatch(#{metadata := <<"test">>}, Task#task.metadata).

test_create_task_with_id() ->
    TaskId = <<"custom_task_id">>,
    Handler = fun() -> {ok, #{result => success}} end,
    {ok, TaskId} = ?WORKER:create_task(TaskId, Handler, #{}),
    {ok, Task} = ?WORKER:get_task(TaskId),
    ?assertEqual(TaskId, Task#task.task_id).

test_task_id_collision() ->
    %% Create task with specific ID
    TaskId = <<"collision_test">>,
    Handler = fun() -> timer:sleep(100), {ok, done} end,
    {ok, TaskId} = ?WORKER:create_task(TaskId, Handler, #{}),

    %% Try to create another task with same ID - should fail
    ?assertMatch({error, task_id_exists},
                 ?WORKER:create_task(TaskId, Handler, #{})).

test_get_task() ->
    Handler = fun() -> {ok, #{}} end,
    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),
    {ok, Task} = ?WORKER:get_task(TaskId),
    ?assertEqual(TaskId, Task#task.task_id).

test_get_task_not_found() ->
    ?assertMatch({error, not_found}, ?WORKER:get_task(<<"nonexistent">>)).

test_list_tasks_empty() ->
    ?WORKER:reset(),
    {ok, Tasks, Cursor} = ?WORKER:list_tasks(),
    ?assertEqual([], Tasks),
    ?assertEqual(undefined, Cursor).

test_list_tasks_with_data() ->
    ?WORKER:reset(),
    Handler = fun() -> timer:sleep(100), {ok, done} end,

    %% Create 3 tasks
    {ok, _} = ?WORKER:create_task(Handler, #{num => 1}),
    {ok, _} = ?WORKER:create_task(Handler, #{num => 2}),
    {ok, _} = ?WORKER:create_task(Handler, #{num => 3}),

    {ok, Tasks, _Cursor} = ?WORKER:list_tasks(),
    ?assertEqual(3, length(Tasks)).

test_list_tasks_pagination() ->
    ?WORKER:reset(),
    Handler = fun() -> timer:sleep(100), {ok, done} end,

    %% Create 25 tasks
    lists:foreach(fun(N) ->
        ?WORKER:create_task(Handler, #{num => N})
    end, lists:seq(1, 25)),

    %% Get first page (limit 10)
    {ok, Page1, Cursor1} = ?WORKER:list_tasks(undefined, 10),
    ?assertEqual(10, length(Page1)),
    ?assertNotEqual(undefined, Cursor1),

    %% Get second page
    {ok, Page2, Cursor2} = ?WORKER:list_tasks(Cursor1, 10),
    ?assertEqual(10, length(Page2)),
    ?assertNotEqual(undefined, Cursor2),

    %% Get third page (remaining 5)
    {ok, Page3, Cursor3} = ?WORKER:list_tasks(Cursor2, 10),
    ?assertEqual(5, length(Page3)),
    ?assertEqual(undefined, Cursor3).

test_task_lifecycle_success() ->
    Handler = fun() ->
        timer:sleep(50),
        {ok, #{result => success}}
    end,

    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),

    %% Task should start in pending state, then move to working
    timer:sleep(10),
    {ok, Task1} = ?WORKER:get_task(TaskId),
    ?assert(Task1#task.status =:= {{ lifecycle.states[0] | default(value="pending") }} orelse
            Task1#task.status =:= {{ lifecycle.states[1] | default(value="working") }}),

    %% Wait for completion
    timer:sleep(100),
    {ok, Task2} = ?WORKER:get_task(TaskId),
    ?assertEqual({{ lifecycle.terminal_states[0] | default(value="completed") }}, Task2#task.status),
    ?assertMatch(#{result := success}, Task2#task.result).

test_task_lifecycle_failure() ->
    Handler = fun() ->
        timer:sleep(50),
        {error, something_went_wrong}
    end,

    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),

    %% Wait for failure
    timer:sleep(100),
    {ok, Task} = ?WORKER:get_task(TaskId),
    ?assertEqual({{ lifecycle.terminal_states[1] | default(value="failed") }}, Task#task.status),
    ?assertEqual(something_went_wrong, Task#task.error).

test_cancel_task_pending() ->
    Handler = fun() -> timer:sleep(5000), {ok, done} end,
    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),

    %% Cancel immediately
    ok = ?WORKER:cancel_task(TaskId, <<"test cancellation">>),

    {ok, Task} = ?WORKER:get_task(TaskId),
    ?assertEqual({{ lifecycle.terminal_states[2] | default(value="cancelled") }}, Task#task.status).

test_cancel_task_working() ->
    Handler = fun() ->
        timer:sleep(500),
        {ok, done}
    end,

    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),

    %% Wait for task to start working
    timer:sleep(50),

    %% Cancel while working
    ok = ?WORKER:cancel_task(TaskId, <<"test cancellation">>),

    {ok, Task} = ?WORKER:get_task(TaskId),
    ?assertEqual({{ lifecycle.terminal_states[2] | default(value="cancelled") }}, Task#task.status).

test_cancel_terminal_state() ->
    Handler = fun() -> {ok, done} end,
    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),

    %% Wait for completion
    timer:sleep(100),

    %% Try to cancel completed task - should fail
    ?assertMatch({error, {cannot_cancel, _}},
                 ?WORKER:cancel_task(TaskId, <<"too late">>)).

test_get_task_result_completed() ->
    Handler = fun() -> {ok, #{data => success_data}} end,
    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),

    %% Wait for completion
    timer:sleep(100),

    ?assertMatch({ok, #{data := success_data}}, ?WORKER:get_task_result(TaskId)).

test_get_task_result_failed() ->
    Handler = fun() -> {error, failure_reason} end,
    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),

    %% Wait for failure
    timer:sleep(100),

    ?assertMatch({error, failure_reason}, ?WORKER:get_task_result(TaskId)).

test_get_task_result_cancelled() ->
    Handler = fun() -> timer:sleep(5000), {ok, done} end,
    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),

    ok = ?WORKER:cancel_task(TaskId),

    ?assertMatch({error, cancelled}, ?WORKER:get_task_result(TaskId)).

test_get_task_result_not_completed() ->
    Handler = fun() -> timer:sleep(5000), {ok, done} end,
    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),

    %% Task is still running
    timer:sleep(50),

    ?assertMatch({error, {not_completed, _}}, ?WORKER:get_task_result(TaskId)),

    %% Cleanup
    ?WORKER:cancel_task(TaskId).

test_progress_updates() ->
    Handler = fun() ->
        Parent = self(),
        TaskId = receive {task_id, Id} -> Id after 1000 -> error(timeout) end,

        %% Report progress
        ?WORKER:update_progress(TaskId, 0.25),
        timer:sleep(20),
        ?WORKER:update_progress(TaskId, 0.50),
        timer:sleep(20),
        ?WORKER:update_progress(TaskId, 0.75),
        timer:sleep(20),

        {ok, done}
    end,

    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),

    %% Send task ID to handler
    %% (Note: This is a simplified test - real implementation would use better coordination)
    timer:sleep(100),

    {ok, Task} = ?WORKER:get_task(TaskId),
    %% Progress should be updated (exact value depends on timing)
    ?assert(Task#task.progress >= 0.0),

    %% Wait for completion
    timer:sleep(200),

    {ok, CompletedTask} = ?WORKER:get_task(TaskId),
    ?assertEqual(1.0, CompletedTask#task.progress).

test_worker_crash() ->
    Handler = fun() ->
        timer:sleep(50),
        error(intentional_crash)
    end,

    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),

    %% Wait for crash and failure detection
    timer:sleep(200),

    {ok, Task} = ?WORKER:get_task(TaskId),
    ?assertEqual({{ lifecycle.terminal_states[1] | default(value="failed") }}, Task#task.status),
    ?assertMatch(#{class := error, reason := intentional_crash}, Task#task.error).

test_worker_limit() ->
    ?WORKER:reset(),
    ?WORKER:set_worker_limit(3),

    Handler = fun() -> timer:sleep(1000), {ok, done} end,

    %% Create 3 tasks (should succeed)
    {ok, _} = ?WORKER:create_task(Handler, #{}),
    {ok, _} = ?WORKER:create_task(Handler, #{}),
    {ok, _} = ?WORKER:create_task(Handler, #{}),

    %% 4th task should fail (limit reached)
    ?assertMatch({error, worker_limit_reached},
                 ?WORKER:create_task(Handler, #{})),

    %% Reset limit for other tests
    ?WORKER:set_worker_limit(10).

test_task_timeout() ->
    Handler = fun() ->
        %% Sleep longer than timeout
        timer:sleep(10000),
        {ok, should_not_reach}
    end,

    %% Start with short timeout
    ?WORKER:reset(),
    {ok, Pid} = ?WORKER:start_link(#{timeout_ms => 100}),

    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),

    %% Wait for timeout
    timer:sleep(300),

    {ok, Task} = ?WORKER:get_task(TaskId),
    ?assertEqual({{ lifecycle.terminal_states[1] | default(value="failed") }}, Task#task.status),
    ?assertEqual(timeout, Task#task.error),

    %% Cleanup
    exit(Pid, kill).

test_cleanup_completed_tasks() ->
    ?WORKER:reset(),

    %% Create and complete some tasks
    Handler = fun() -> {ok, done} end,
    {ok, TaskId1} = ?WORKER:create_task(Handler, #{}),
    {ok, TaskId2} = ?WORKER:create_task(Handler, #{}),
    {ok, TaskId3} = fun() -> timer:sleep(1000), {ok, done} end,

    %% Wait for first two to complete
    timer:sleep(100),

    %% Cleanup tasks older than 50ms
    timer:sleep(100),
    {ok, Count} = ?WORKER:cleanup_completed_tasks(50),
    ?assert(Count >= 2),

    %% Verify tasks are deleted
    ?assertMatch({error, not_found}, ?WORKER:get_task(TaskId1)),
    ?assertMatch({error, not_found}, ?WORKER:get_task(TaskId2)).

test_state_machine_transitions() ->
    Handler = fun() -> timer:sleep(5000), {ok, done} end,
    {ok, TaskId} = ?WORKER:create_task(Handler, #{}),

    %% Valid transition: pending → working
    timer:sleep(10),
    ok = ?WORKER:transition_task(TaskId, {{ lifecycle.states[0] | default(value="pending") }}, {{ lifecycle.states[1] | default(value="working") }}),

    %% Invalid transition: working → pending (not in state machine)
    ?assertMatch({error, {invalid_transition, _, _}},
                 ?WORKER:transition_task(TaskId, {{ lifecycle.states[1] | default(value="working") }}, {{ lifecycle.states[0] | default(value="pending") }})),

    %% Valid transition: working → completed
    ok = ?WORKER:transition_task(TaskId, {{ lifecycle.states[1] | default(value="working") }}, {{ lifecycle.terminal_states[0] | default(value="completed") }}),

    %% Invalid transition from terminal state
    ?assertMatch({error, {invalid_transition, _, _}},
                 ?WORKER:transition_task(TaskId, {{ lifecycle.terminal_states[0] | default(value="completed") }}, {{ lifecycle.states[1] | default(value="working") }})).

test_concurrent_task_creation() ->
    ?WORKER:reset(),

    Handler = fun() -> timer:sleep(100), {ok, done} end,

    %% Create tasks concurrently from multiple processes
    Parent = self(),
    lists:foreach(fun(N) ->
        spawn(fun() ->
            {ok, TaskId} = ?WORKER:create_task(Handler, #{num => N}),
            Parent ! {task_created, TaskId}
        end)
    end, lists:seq(1, 10)),

    %% Wait for all tasks to be created
    TaskIds = receive_all_task_ids(10, []),
    ?assertEqual(10, length(TaskIds)),

    %% Verify all tasks exist
    lists:foreach(fun(TaskId) ->
        ?assertMatch({ok, _}, ?WORKER:get_task(TaskId))
    end, TaskIds).

%%%===================================================================
%%% Helper Functions
%%%===================================================================

receive_all_task_ids(0, Acc) ->
    Acc;
receive_all_task_ids(N, Acc) ->
    receive
        {task_created, TaskId} ->
            receive_all_task_ids(N - 1, [TaskId | Acc])
    after ?TIMEOUT ->
        Acc
    end.
