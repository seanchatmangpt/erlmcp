{#
  Erlang Validation Module Generator

  Generates validation modules for MCP components (tool, resource, prompt, task).
  This template creates gen_server-based validators with JSON Schema validation
  and semantic rules from the ontology.

  Context Variables:
    - component: string - Component type (tool, resource, prompt, task)
    - module_name: string - Generated module name (e.g., "erlmcp_tool_validator")
    - validation_type: string - Type of validation (argument, structure, semantic)
    - validation_rules: array - List of semantic validation rules to apply
    - schema: map - JSON Schema definition for the component
    - description_max_length: integer - Maximum description length (default: 10000)
    - uri_validation_enabled: boolean - Enable URI validation
    - path_traversal_check: boolean - Enable path traversal prevention
    - error_code_prefix: string - Error code prefix (e.g., "MCP_ERROR_TOOL_")
    - includes_schema_validator: boolean - Include erlmcp_schema_validator integration
    - timestamp: string - Generation timestamp
    - generator_version: string - Generator version
#}
%%% -*- mode: erlang; erlang-indent-level: 4; indent-tabs-mode: nil -*-
%%%-------------------------------------------------------------------
%%% @doc
%%% Generated {{ component | capitalize }} Validator Module
%%%
%%% Provides comprehensive validation for {{ component }} components including:
%%% - JSON Schema validation (via erlmcp_schema_validator)
%%% - Semantic validation rules from ontology
%%% - Field-level error messages
%%% - Integration with existing validators
%%%
%%% WARNING: This file is auto-generated by ggen.
%%% DO NOT EDIT MANUALLY - Changes will be overwritten.
%%% Edit the ontology source files instead and regenerate.
%%%
%%% Generated: {{ timestamp }}
%%% Component: {{ component }}
%%% Validation Type: {{ validation_type }}
%%% Generator: ggen v{{ generator_version }}
%%% @end
%%%-------------------------------------------------------------------

-module({{ module_name }}).
-behaviour(gen_server).

%% API exports
-export([
    start_link/0,
    validate_{{ component }}/1,
    validate_{{ component }}_arguments/2,
    {% if uri_validation_enabled -%}
    validate_uri/1,
    canonicalize_uri/1,
    {% endif -%}
    {% if path_traversal_check -%}
    check_path_traversal/1,
    {% endif -%}
    format_validation_error/1,
    format_validation_errors/1
]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).

-include("erlmcp.hrl").

%% Types
-type validation_result() :: ok | {error, {integer(), binary(), map()}}.
-type validation_error() :: #{
    code := integer(),
    message := binary(),
    data := map()
}.

-export_type([validation_result/0, validation_error/0]).

%% State record
-record(state, {
    worker_id :: integer(),
    {% if includes_schema_validator -%}
    schema_validator_pid :: pid() | undefined,
    {% endif -%}
    validation_stats = #{} :: map()
}).

-type state() :: #state{}.

%%====================================================================
%% Configuration Constants
%%====================================================================

{% if description_max_length -%}
-define(MAX_DESCRIPTION_LENGTH, {{ description_max_length }}).
{% else -%}
-define(MAX_DESCRIPTION_LENGTH, ?MCP_TOOL_DESCRIPTION_MAX_LENGTH_DEFAULT).
{% endif -%}

{% if uri_validation_enabled -%}
-define(MAX_URI_LENGTH, 2048).
-define(URI_REGEX, <<"^[a-zA-Z][a-zA-Z0-9+.-]*:">>). % URI scheme pattern
{% endif -%}

{% if path_traversal_check -%}
-define(PATH_TRAVERSAL_PATTERNS, [
    <<"../">>,
    <<"..\\\">>,
    <<"%2e%2e/">>,
    <<"%2e%2e\\">>,
    <<"..%2f">>,
    <<"..%5c">>
]).
{% endif -%}

%%====================================================================
%% API Functions
%%====================================================================

-spec start_link() -> {ok, pid()} | {error, term()}.
start_link() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).

%% @doc Validate {{ component }} structure and semantics.
%% This is the main entry point for {{ component }} validation.
%%
%% Performs comprehensive validation including:
%% 1. Required field validation
%% 2. Type checking
%% 3. JSON Schema validation (if schema provided)
%% 4. Semantic validation rules
%%
%% @param {{ component | capitalize }} The {{ component }} to validate
%% @return ok | {error, {Code, Message, Data}}
-spec validate_{{ component }}(map() | #mcp_{{ component }}{}) -> validation_result().
validate_{{ component }}({{ component | capitalize }}) ->
    gen_server:call(?MODULE, {validate_{{ component }}, {{ component | capitalize }}}, 5000).

%% @doc Validate {{ component }} arguments against declared schema.
%% Critical Gap Fix: Validates arguments BEFORE handler invocation.
%%
%% Validates:
%% 1. JSON Schema (if input_schema is defined)
%% 2. Required vs optional arguments
%% 3. Type checking for each argument
%% 4. Semantic constraints
%%
%% @param ProvidedArgs Arguments provided by caller
%% @param {{ component | capitalize }}Def {{ component | capitalize }} definition with schema
%% @return ok | {error, {Code, Message, Data}}
-spec validate_{{ component }}_arguments(map(), map() | #mcp_{{ component }}{}) -> validation_result().
validate_{{ component }}_arguments(ProvidedArgs, {{ component | capitalize }}Def) ->
    gen_server:call(?MODULE, {validate_{{ component }}_arguments, ProvidedArgs, {{ component | capitalize }}Def}, 5000).

{% if uri_validation_enabled -%}
%% @doc Validate and canonicalize URI.
%% Prevents injection attacks and ensures URI compliance.
%%
%% Checks:
%% - Valid URI syntax (RFC 3986)
%% - Length limits
%% - Scheme validation
%% - Path traversal prevention
%%
%% @param Uri URI to validate
%% @return ok | {error, term()}
-spec validate_uri(binary()) -> validation_result().
validate_uri(Uri) ->
    gen_server:call(?MODULE, {validate_uri, Uri}, 5000).

%% @doc Canonicalize URI to prevent injection attacks.
%% Normalizes URI format and removes dangerous patterns.
%%
%% @param Uri URI to canonicalize
%% @return {ok, CanonicalUri} | {error, term()}
-spec canonicalize_uri(binary()) -> {ok, binary()} | {error, term()}.
canonicalize_uri(Uri) ->
    gen_server:call(?MODULE, {canonicalize_uri, Uri}, 5000).
{% endif -%}

{% if path_traversal_check -%}
%% @doc Check for path traversal attacks in URI or path.
%% Detects patterns like ../, %2e%2e/, etc.
%%
%% @param Path Path or URI to check
%% @return ok | {error, term()}
-spec check_path_traversal(binary()) -> validation_result().
check_path_traversal(Path) ->
    gen_server:call(?MODULE, {check_path_traversal, Path}, 5000).
{% endif -%}

%%====================================================================
%% gen_server callbacks
%%====================================================================

-spec init([]) -> {ok, state()}.
init([]) ->
    WorkerId = erlang:unique_integer([positive]),
    {% if includes_schema_validator -%}
    %% Start schema validator worker
    SchemaValidatorPid = case whereis(erlmcp_schema_validator_pool) of
        undefined -> undefined;
        Pid -> Pid
    end,
    {ok, #state{
        worker_id = WorkerId,
        schema_validator_pid = SchemaValidatorPid,
        validation_stats = #{}
    }}.
    {% else -%}
    {ok, #state{worker_id = WorkerId, validation_stats = #{}}}.
    {% endif -%}

-spec handle_call(term(), {pid(), term()}, state()) -> {reply, term(), state()}.

handle_call({validate_{{ component }}, {{ component | capitalize }}}, _From, State) ->
    Result = do_validate_{{ component }}({{ component | capitalize }}),
    {reply, Result, State};

handle_call({validate_{{ component }}_arguments, ProvidedArgs, {{ component | capitalize }}Def}, _From, State) ->
    Result = do_validate_{{ component }}_arguments(ProvidedArgs, {{ component | capitalize }}Def{% if includes_schema_validator %}, State#state.schema_validator_pid{% endif %}),
    {reply, Result, State};

{% if uri_validation_enabled -%}
handle_call({validate_uri, Uri}, _From, State) ->
    Result = do_validate_uri(Uri),
    {reply, Result, State};

handle_call({canonicalize_uri, Uri}, _From, State) ->
    Result = do_canonicalize_uri(Uri),
    {reply, Result, State};
{% endif -%}

{% if path_traversal_check -%}
handle_call({check_path_traversal, Path}, _From, State) ->
    Result = do_check_path_traversal(Path),
    {reply, Result, State};
{% endif -%}

handle_call(_Request, _From, State) ->
    {reply, {error, unknown_request}, State}.

-spec handle_cast(term(), state()) -> {noreply, state()}.
handle_cast(_Msg, State) ->
    {noreply, State}.

-spec handle_info(term(), state()) -> {noreply, state()}.
handle_info(_Info, State) ->
    {noreply, State}.

-spec terminate(term(), state()) -> ok.
terminate(_Reason, _State) ->
    ok.

-spec code_change(term(), state(), term()) -> {ok, state()}.
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%====================================================================
%% Internal functions - Main Validation Orchestration
%%====================================================================

%% @doc Main {{ component }} validation orchestrator
-spec do_validate_{{ component }}(map() | #mcp_{{ component }}{}) -> validation_result().
do_validate_{{ component }}({{ component | capitalize }}) ->
    %% Extract fields from record or map
    Fields = extract_{{ component }}_fields({{ component | capitalize }}),

    %% Step 1: Required field validation
    case validate_required_{{ component }}_fields(Fields) of
        ok ->
            %% Step 2: Field-specific validation
            case validate_{{ component }}_field_constraints(Fields) of
                ok ->
                    %% Step 3: Semantic validation rules
                    validate_{{ component }}_semantics(Fields);
                {error, _} = Error ->
                    Error
            end;
        {error, _} = Error ->
            Error
    end.

%% @doc Validate {{ component }} arguments against schema
-spec do_validate_{{ component }}_arguments(
    map(),
    map() | #mcp_{{ component }}{}{% if includes_schema_validator %},
    pid() | undefined{% endif %}
) -> validation_result().
do_validate_{{ component }}_arguments(ProvidedArgs, {{ component | capitalize }}Def{% if includes_schema_validator %}, SchemaValidatorPid{% endif %}) ->
    %% Extract input schema from {{ component }} definition
    InputSchema = extract_input_schema({{ component | capitalize }}Def),

    {% if includes_schema_validator -%}
    %% Step 1: Validate JSON Schema if present (Critical Gap Fix)
    case validate_json_schema(ProvidedArgs, InputSchema, SchemaValidatorPid) of
        ok ->
            %% Step 2: Validate required arguments
            RequiredArgs = extract_required_arguments({{ component | capitalize }}Def),
            validate_required_arguments(ProvidedArgs, RequiredArgs);
        {error, _} = Error ->
            Error
    end.
    {% else -%}
    %% Step 1: Validate required arguments
    RequiredArgs = extract_required_arguments({{ component | capitalize }}Def),
    validate_required_arguments(ProvidedArgs, RequiredArgs).
    {% endif -%}

%%====================================================================
%% Internal functions - Field Extraction
%%====================================================================

%% @doc Extract fields from {{ component }} record or map
-spec extract_{{ component }}_fields(map() | #mcp_{{ component }}{}) -> map().
extract_{{ component }}_fields(#mcp_{{ component }}{} = Rec) ->
    #{
        name => Rec#mcp_{{ component }}.name,
        description => Rec#mcp_{{ component }}.description
        {% if component == "tool" -%}
        ,
        input_schema => Rec#mcp_{{ component }}.input_schema,
        metadata => Rec#mcp_{{ component }}.metadata,
        version => Rec#mcp_{{ component }}.version
        {% endif -%}
        {% if component == "resource" -%}
        ,
        uri => Rec#mcp_{{ component }}.uri,
        mime_type => Rec#mcp_{{ component }}.mime_type,
        metadata => Rec#mcp_{{ component }}.metadata
        {% endif -%}
        {% if component == "prompt" -%}
        ,
        arguments => Rec#mcp_{{ component }}.arguments,
        input_schema => Rec#mcp_{{ component }}.input_schema
        {% endif -%}
    };
extract_{{ component }}_fields(Map) when is_map(Map) ->
    Map.

%% @doc Extract input schema from {{ component }} definition
-spec extract_input_schema(map() | #mcp_{{ component }}{}) -> map() | undefined.
extract_input_schema(#mcp_{{ component }}{input_schema = Schema}) ->
    Schema;
extract_input_schema(#{<<"inputSchema">> := Schema}) ->
    Schema;
extract_input_schema(_) ->
    undefined.

%% @doc Extract required arguments from {{ component }} definition
-spec extract_required_arguments(map() | #mcp_{{ component }}{}) -> [binary()].
{% if component == "prompt" -%}
extract_required_arguments(#mcp_{{ component }}{arguments = Args}) when is_list(Args) ->
    [Arg#mcp_prompt_argument.name || Arg <- Args, Arg#mcp_prompt_argument.required =:= true];
{% else -%}
extract_required_arguments(#mcp_{{ component }}{input_schema = Schema}) when is_map(Schema) ->
    maps:get(<<"required">>, Schema, []);
{% endif -%}
extract_required_arguments(#{<<"inputSchema">> := Schema}) when is_map(Schema) ->
    maps:get(<<"required">>, Schema, []);
extract_required_arguments(_) ->
    [].

%%====================================================================
%% Internal functions - Required Field Validation
%%====================================================================

%% @doc Validate required {{ component }} fields are present
-spec validate_required_{{ component }}_fields(map()) -> validation_result().
validate_required_{{ component }}_fields(Fields) ->
    RequiredFields = [name{% if component == "resource" %}, uri{% endif %}],
    MissingFields = [F || F <- RequiredFields, not maps:is_key(F, Fields) orelse maps:get(F, Fields) =:= undefined],

    case MissingFields of
        [] ->
            ok;
        _ ->
            {error, {?JSONRPC_INVALID_PARAMS,
                <<"Missing required {{ component }} fields">>, #{
                    <<"missing_fields">> => MissingFields,
                    <<"provided_fields">> => maps:keys(Fields)
                }}}
    end.

%% @doc Validate required arguments are present
-spec validate_required_arguments(map(), [binary()]) -> validation_result().
validate_required_arguments(_ProvidedArgs, []) ->
    ok;
validate_required_arguments(ProvidedArgs, RequiredArgs) when is_list(RequiredArgs) ->
    MissingRequired = [Arg || Arg <- RequiredArgs, not maps:is_key(Arg, ProvidedArgs)],

    case MissingRequired of
        [] ->
            ok;
        _ ->
            {error, {?JSONRPC_INVALID_PARAMS,
                <<"Missing required {{ component }} arguments">>, #{
                    <<"missing_arguments">> => MissingRequired,
                    <<"provided_arguments">> => maps:keys(ProvidedArgs)
                }}}
    end.

%%====================================================================
%% Internal functions - Field Constraint Validation
%%====================================================================

%% @doc Validate {{ component }} field constraints
-spec validate_{{ component }}_field_constraints(map()) -> validation_result().
validate_{{ component }}_field_constraints(Fields) ->
    ValidationSteps = [
        fun() -> validate_name_field(maps:get(name, Fields, undefined)) end
        {% if component != "resource" -%}
        , fun() -> validate_description_field(maps:get(description, Fields, undefined)) end
        {% endif -%}
        {% if component == "resource" and uri_validation_enabled -%}
        , fun() -> validate_uri_field(maps:get(uri, Fields, undefined)) end
        {% endif -%}
        {% if component == "tool" -%}
        , fun() -> validate_version_field(maps:get(version, Fields, undefined)) end
        {% endif -%}
    ],

    execute_validation_steps(ValidationSteps).

%% @doc Execute validation steps in sequence
-spec execute_validation_steps([fun(() -> validation_result())]) -> validation_result().
execute_validation_steps([]) ->
    ok;
execute_validation_steps([Step | Rest]) ->
    case Step() of
        ok -> execute_validation_steps(Rest);
        {error, _} = Error -> Error
    end.

%% @doc Validate name field
-spec validate_name_field(binary() | undefined) -> validation_result().
validate_name_field(undefined) ->
    {error, {?JSONRPC_INVALID_PARAMS, <<"{{ component | capitalize }} name is required">>, #{}}};
validate_name_field(Name) when is_binary(Name), byte_size(Name) > 0 ->
    ok;
validate_name_field(_) ->
    {error, {?JSONRPC_INVALID_PARAMS, <<"{{ component | capitalize }} name must be a non-empty binary">>, #{}}}.

{% if component != "resource" -%}
%% @doc Validate description field
-spec validate_description_field(binary() | undefined) -> validation_result().
validate_description_field(undefined) ->
    ok; % Description is optional
validate_description_field(Desc) when is_binary(Desc) ->
    case byte_size(Desc) =< ?MAX_DESCRIPTION_LENGTH of
        true -> ok;
        false ->
            {error, {?{{ error_code_prefix }}DESCRIPTION_TOO_LONG,
                <<"{{ component | capitalize }} description exceeds maximum length">>, #{
                    <<"max_length">> => ?MAX_DESCRIPTION_LENGTH,
                    <<"actual_length">> => byte_size(Desc)
                }}}
    end;
validate_description_field(_) ->
    {error, {?JSONRPC_INVALID_PARAMS, <<"{{ component | capitalize }} description must be a binary">>, #{}}}.
{% endif -%}

{% if component == "resource" and uri_validation_enabled -%}
%% @doc Validate URI field
-spec validate_uri_field(binary() | undefined) -> validation_result().
validate_uri_field(undefined) ->
    {error, {?JSONRPC_INVALID_PARAMS, <<"Resource URI is required">>, #{}}};
validate_uri_field(Uri) when is_binary(Uri) ->
    do_validate_uri(Uri);
validate_uri_field(_) ->
    {error, {?JSONRPC_INVALID_PARAMS, <<"Resource URI must be a binary">>, #{}}}.
{% endif -%}

{% if component == "tool" -%}
%% @doc Validate version field (semantic versioning)
-spec validate_version_field(binary() | undefined) -> validation_result().
validate_version_field(undefined) ->
    ok; % Version is optional
validate_version_field(Version) when is_binary(Version) ->
    %% Semantic version pattern: major.minor.patch(-prerelease)(+build)
    case re:run(Version, <<"^\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z.-]+)?(\\+[0-9A-Za-z.-]+)?$">>) of
        {match, _} -> ok;
        _ ->
            {error, {?JSONRPC_INVALID_PARAMS,
                <<"Invalid tool version format (expected semver: X.Y.Z)">>, #{
                    <<"version">> => Version
                }}}
    end;
validate_version_field(_) ->
    {error, {?JSONRPC_INVALID_PARAMS, <<"Tool version must be a binary">>, #{}}}.
{% endif -%}

%%====================================================================
%% Internal functions - Semantic Validation
%%====================================================================

%% @doc Validate {{ component }} semantic constraints
-spec validate_{{ component }}_semantics(map()) -> validation_result().
validate_{{ component }}_semantics(_Fields) ->
    %% Semantic validation rules from ontology
    {% for rule in validation_rules -%}
    %% Rule: {{ rule.description }}
    %% TODO: Implement {{ rule.name }} validation
    {% endfor -%}
    ok.

{% if includes_schema_validator -%}
%%====================================================================
%% Internal functions - JSON Schema Validation
%%====================================================================

%% @doc Validate arguments against JSON Schema using jesse
-spec validate_json_schema(map(), map() | undefined, pid() | undefined) -> validation_result().
validate_json_schema(_ProvidedArgs, undefined, _SchemaValidatorPid) ->
    ok;
validate_json_schema(_ProvidedArgs, _InputSchema, undefined) ->
    %% Schema validator not available, skip JSON Schema validation
    ok;
validate_json_schema(ProvidedArgs, InputSchema, SchemaValidatorPid) when is_map(InputSchema) ->
    try
        case erlmcp_schema_validator:validate(SchemaValidatorPid, InputSchema, ProvidedArgs) of
            ok ->
                ok;
            {error, JesseErrors} ->
                FormattedErrors = format_jesse_errors(JesseErrors),
                {error, {?JSONRPC_INVALID_PARAMS, <<"Argument validation failed">>, #{
                    <<"validation_errors">> => FormattedErrors
                }}}
        end
    catch
        _:JessError ->
            logger:error("JSON Schema validation error in {{ module_name }}: ~p", [JessError]),
            {error, {?JSONRPC_INVALID_PARAMS, <<"Schema validation failed">>, #{
                <<"schema_error">> => iolist_to_binary(io_lib:format("~p", [JessError]))
            }}}
    end.

%% @doc Format jesse validation errors
-spec format_jesse_errors([map()]) -> [map()].
format_jesse_errors(Errors) when is_list(Errors) ->
    [format_jesse_error(E) || E <- Errors];
format_jesse_errors(Error) ->
    [format_jesse_error(Error)].

%% @doc Format a single jesse error
-spec format_jesse_error(map()) -> map().
format_jesse_error(#{path := Path, message := Message}) ->
    #{
        <<"path">> => format_path(Path),
        <<"error">> => Message
    };
format_jesse_error(Error) ->
    #{
        <<"path">> => <<>>,
        <<"error">> => iolist_to_binary(io_lib:format("~p", [Error]))
    }.

%% @doc Format JSON path for error messages
-spec format_path([binary()]) -> binary().
format_path([]) ->
    <<>>;
format_path(Path) ->
    PathParts = [iolist_to_binary(io_lib:format("~s", [P])) || P <- Path],
    iolist_to_binary(["$." | lists:join(<<".">>, PathParts)]).
{% endif -%}

{% if uri_validation_enabled -%}
%%====================================================================
%% Internal functions - URI Validation
%%====================================================================

%% @doc Validate URI (RFC 3986 compliance)
-spec do_validate_uri(binary()) -> validation_result().
do_validate_uri(Uri) when is_binary(Uri) ->
    %% Check 1: Length limit
    case byte_size(Uri) =< ?MAX_URI_LENGTH of
        false ->
            {error, {?MCP_ERROR_URI_TOO_LONG,
                <<"URI exceeds maximum length">>, #{
                    <<"max_length">> => ?MAX_URI_LENGTH,
                    <<"actual_length">> => byte_size(Uri)
                }}};
        true ->
            %% Check 2: URI scheme validation
            case re:run(Uri, ?URI_REGEX) of
                {match, _} ->
                    {% if path_traversal_check -%}
                    %% Check 3: Path traversal prevention
                    do_check_path_traversal(Uri);
                    {% else -%}
                    ok;
                    {% endif -%}
                nomatch ->
                    {error, {?MCP_ERROR_URI_SYNTAX_ERROR,
                        <<"Invalid URI scheme">>, #{
                            <<"uri">> => Uri
                        }}}
            end
    end;
do_validate_uri(_) ->
    {error, {?JSONRPC_INVALID_PARAMS, <<"URI must be a binary">>, #{}}}.

%% @doc Canonicalize URI to prevent injection attacks
-spec do_canonicalize_uri(binary()) -> {ok, binary()} | {error, term()}.
do_canonicalize_uri(Uri) when is_binary(Uri) ->
    %% Step 1: Normalize percent-encoding
    Normalized = normalize_percent_encoding(Uri),

    %% Step 2: Remove dot segments (. and ..)
    Cleaned = remove_dot_segments(Normalized),

    %% Step 3: Validate result
    case do_validate_uri(Cleaned) of
        ok -> {ok, Cleaned};
        {error, Reason} -> {error, Reason}
    end.

%% @doc Normalize percent-encoding in URI
-spec normalize_percent_encoding(binary()) -> binary().
normalize_percent_encoding(Uri) ->
    %% Convert percent-encoded characters to uppercase
    %% This is a simplified implementation
    Uri.

%% @doc Remove dot segments from URI path
-spec remove_dot_segments(binary()) -> binary().
remove_dot_segments(Uri) ->
    %% Remove . and .. segments from path
    %% This is a simplified implementation
    Uri.
{% endif -%}

{% if path_traversal_check -%}
%%====================================================================
%% Internal functions - Path Traversal Prevention
%%====================================================================

%% @doc Check for path traversal attack patterns
-spec do_check_path_traversal(binary()) -> validation_result().
do_check_path_traversal(Path) when is_binary(Path) ->
    %% Convert to lowercase for case-insensitive check
    LowerPath = string:lowercase(Path),

    %% Check for dangerous patterns
    HasTraversal = lists:any(
        fun(Pattern) ->
            case binary:match(LowerPath, Pattern) of
                {_Pos, _Len} -> true;
                nomatch -> false
            end
        end,
        ?PATH_TRAVERSAL_PATTERNS
    ),

    case HasTraversal of
        true ->
            {error, {?MCP_ERROR_INVALID_URI,
                <<"Path traversal attempt detected">>, #{
                    <<"path">> => Path
                }}};
        false ->
            ok
    end;
do_check_path_traversal(_) ->
    {error, {?JSONRPC_INVALID_PARAMS, <<"Path must be a binary">>, #{}}}.
{% endif -%}

%%====================================================================
%% Public API - Error Formatting
%%====================================================================

%% @doc Format validation error for JSON-RPC response
-spec format_validation_error(validation_error()) -> validation_error().
format_validation_error(Error) ->
    Error.

%% @doc Format multiple validation errors for JSON-RPC response
-spec format_validation_errors([validation_error()]) -> [validation_error()].
format_validation_errors(Errors) ->
    Errors.
