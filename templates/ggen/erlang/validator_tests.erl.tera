{#
  Erlang Validation Module Test Generator

  Generates EUnit tests for validation modules created by validator.erl.tera.
  Follows Chicago School TDD pattern (no mocks, real processes).

  Context Variables:
    - Same as validator.erl.tera
    - test_cases: array - List of test cases to generate
#}
%%% -*- mode: erlang; erlang-indent-level: 4; indent-tabs-mode: nil -*-
%%%-------------------------------------------------------------------
%%% @doc
%%% Generated {{ component | capitalize }} Validator Tests
%%%
%%% EUnit tests for {{ module_name }}.
%%% Follows Chicago School TDD (no mocks, real processes).
%%%
%%% WARNING: This file is auto-generated by ggen.
%%% DO NOT EDIT MANUALLY - Changes will be overwritten.
%%% Edit the test specification instead and regenerate.
%%%
%%% Generated: {{ timestamp }}
%%% Component: {{ component }}
%%% Generator: ggen v{{ generator_version }}
%%% @end
%%%-------------------------------------------------------------------

-module({{ module_name }}_tests).

-include_lib("eunit/include/eunit.hrl").
-include("erlmcp.hrl").

%%====================================================================
%% Test Fixtures
%%====================================================================

%% Setup function - called before each test
setup() ->
    %% Start validator gen_server
    {ok, Pid} = {{ module_name }}:start_link(),
    Pid.

%% Cleanup function - called after each test
cleanup(Pid) ->
    gen_server:stop(Pid).

%%====================================================================
%% Test Descriptions
%%====================================================================

{{ module_name }}_test_() ->
    {foreach,
     fun setup/0,
     fun cleanup/1,
     [
      fun test_validate_{{ component }}_valid/1,
      fun test_validate_{{ component }}_missing_name/1,
      {% if component != "resource" -%}
      fun test_validate_{{ component }}_description_too_long/1,
      {% endif -%}
      fun test_validate_{{ component }}_arguments_valid/1,
      fun test_validate_{{ component }}_arguments_missing_required/1
      {% if uri_validation_enabled -%}
      , fun test_validate_uri_valid/1,
      fun test_validate_uri_invalid_scheme/1,
      fun test_validate_uri_too_long/1
      {% endif -%}
      {% if path_traversal_check -%}
      , fun test_check_path_traversal_safe/1,
      fun test_check_path_traversal_attack/1
      {% endif -%}
     ]}.

%%====================================================================
%% Test Cases - Valid {{ component | capitalize }}
%%====================================================================

test_validate_{{ component }}_valid(_Pid) ->
    %% Test: Validate a well-formed {{ component }}
    {{ component | capitalize }} = create_valid_{{ component }}(),
    Result = {{ module_name }}:validate_{{ component }}({{ component | capitalize }}),
    ?_assertEqual(ok, Result).

%%====================================================================
%% Test Cases - Missing Required Fields
%%====================================================================

test_validate_{{ component }}_missing_name(_Pid) ->
    %% Test: Validate {{ component }} with missing name field
    {{ component | capitalize }} = (create_valid_{{ component }}())#mcp_{{ component }}{name = undefined},
    Result = {{ module_name }}:validate_{{ component }}({{ component | capitalize }}),
    ?_assertMatch({error, {?JSONRPC_INVALID_PARAMS, _, _}}, Result).

{% if component != "resource" -%}
%%====================================================================
%% Test Cases - Description Length Validation
%%====================================================================

test_validate_{{ component }}_description_too_long(_Pid) ->
    %% Test: Validate {{ component }} with description exceeding max length
    LongDesc = binary:copy(<<"a">>, {{ description_max_length }} + 1),
    {{ component | capitalize }} = (create_valid_{{ component }}())#mcp_{{ component }}{description = LongDesc},
    Result = {{ module_name }}:validate_{{ component }}({{ component | capitalize }}),
    ?_assertMatch({error, {?{{ error_code_prefix }}DESCRIPTION_TOO_LONG, _, _}}, Result).
{% endif -%}

%%====================================================================
%% Test Cases - Argument Validation
%%====================================================================

test_validate_{{ component }}_arguments_valid(_Pid) ->
    %% Test: Validate valid {{ component }} arguments
    ProvidedArgs = create_valid_arguments(),
    {{ component | capitalize }}Def = create_valid_{{ component }}_def(),
    Result = {{ module_name }}:validate_{{ component }}_arguments(ProvidedArgs, {{ component | capitalize }}Def),
    ?_assertEqual(ok, Result).

test_validate_{{ component }}_arguments_missing_required(_Pid) ->
    %% Test: Validate {{ component }} arguments missing required field
    ProvidedArgs = #{}, % Empty arguments
    {{ component | capitalize }}Def = create_valid_{{ component }}_def(),
    Result = {{ module_name }}:validate_{{ component }}_arguments(ProvidedArgs, {{ component | capitalize }}Def),
    ?_assertMatch({error, {?JSONRPC_INVALID_PARAMS, _, _}}, Result).

{% if uri_validation_enabled -%}
%%====================================================================
%% Test Cases - URI Validation
%%====================================================================

test_validate_uri_valid(_Pid) ->
    %% Test: Validate a well-formed URI
    Uri = <<"https://example.com/resource">>,
    Result = {{ module_name }}:validate_uri(Uri),
    ?_assertEqual(ok, Result).

test_validate_uri_invalid_scheme(_Pid) ->
    %% Test: Validate URI with invalid scheme
    Uri = <<"invalid-scheme-resource">>,
    Result = {{ module_name }}:validate_uri(Uri),
    ?_assertMatch({error, {?MCP_ERROR_URI_SYNTAX_ERROR, _, _}}, Result).

test_validate_uri_too_long(_Pid) ->
    %% Test: Validate URI exceeding maximum length
    Uri = binary:copy(<<"a">>, 3000),
    Result = {{ module_name }}:validate_uri(Uri),
    ?_assertMatch({error, {?MCP_ERROR_URI_TOO_LONG, _, _}}, Result).
{% endif -%}

{% if path_traversal_check -%}
%%====================================================================
%% Test Cases - Path Traversal Prevention
%%====================================================================

test_check_path_traversal_safe(_Pid) ->
    %% Test: Check safe path without traversal
    Path = <<"https://example.com/safe/path/resource">>,
    Result = {{ module_name }}:check_path_traversal(Path),
    ?_assertEqual(ok, Result).

test_check_path_traversal_attack(_Pid) ->
    %% Test: Detect path traversal attack
    AttackPaths = [
        <<"https://example.com/../etc/passwd">>,
        <<"https://example.com/%2e%2e/etc/passwd">>,
        <<"file:///../../../etc/passwd">>
    ],
    Results = [{{ module_name }}:check_path_traversal(P) || P <- AttackPaths],
    Expected = [{error, {?MCP_ERROR_INVALID_URI, _, _}} || _ <- AttackPaths],
    ?_assertEqual(length(Expected), length([R || R <- Results, element(1, R) =:= error])).
{% endif -%}

%%====================================================================
%% Test Helpers
%%====================================================================

%% @doc Create a valid {{ component }} for testing
-spec create_valid_{{ component }}() -> #mcp_{{ component }}{}.
create_valid_{{ component }}() ->
    #mcp_{{ component }}{
        name = <<"test_{{ component }}">>,
        description = <<"Test {{ component }} description">>
        {% if component == "tool" -%}
        ,
        input_schema = #{
            <<"type">> => <<"object">>,
            <<"properties">> => #{
                <<"arg1">> => #{<<"type">> => <<"string">>}
            },
            <<"required">> => [<<"arg1">>]
        },
        metadata = #{},
        version = <<"1.0.0">>
        {% endif -%}
        {% if component == "resource" -%}
        ,
        uri = <<"https://example.com/resource/test">>,
        mime_type = <<"text/plain">>,
        metadata = #{}
        {% endif -%}
        {% if component == "prompt" -%}
        ,
        arguments = [
            #mcp_prompt_argument{
                name = <<"arg1">>,
                description = <<"Test argument">>,
                required = true
            }
        ],
        input_schema = #{
            <<"type">> => <<"object">>,
            <<"properties">> => #{
                <<"arg1">> => #{<<"type">> => <<"string">>}
            },
            <<"required">> => [<<"arg1">>]
        }
        {% endif -%}
    }.

%% @doc Create valid {{ component }} definition for argument testing
-spec create_valid_{{ component }}_def() -> #mcp_{{ component }}{}.
create_valid_{{ component }}_def() ->
    create_valid_{{ component }}().

%% @doc Create valid arguments for testing
-spec create_valid_arguments() -> map().
create_valid_arguments() ->
    #{
        {% if component == "tool" or component == "prompt" -%}
        <<"arg1">> => <<"test_value">>
        {% else -%}
        <<"test_key">> => <<"test_value">>
        {% endif -%}
    }.

%%====================================================================
%% Property-Based Tests (Optional - requires PropEr)
%%====================================================================

%% Uncomment if PropEr is available

%% -ifdef(PROPER).
%% -include_lib("proper/include/proper.hrl").
%%
%% prop_validate_{{ component }}_always_returns_result() ->
%%     ?FORALL({{ component | capitalize }}, generate_{{ component }}(),
%%         begin
%%             Result = {{ module_name }}:validate_{{ component }}({{ component | capitalize }}),
%%             is_valid_result(Result)
%%         end).
%%
%% generate_{{ component }}() ->
%%     %% Generate arbitrary {{ component }} for property testing
%%     ?LET({Name, Desc},
%%          {binary(), binary()},
%%          #mcp_{{ component }}{name = Name, description = Desc}).
%%
%% is_valid_result(ok) -> true;
%% is_valid_result({error, _}) -> true;
%% is_valid_result(_) -> false.
%% -endif.
