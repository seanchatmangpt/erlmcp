transport_state_type(Config) ->
    % Test that transport state is properly typed
    % NOTE: Direct state inspection requires record definitions
    % For now, verify that transports start and return state
    % Actual field validation is done in transport-specific test suites

    % Test stdio transport
    StdioOpts = #{test_mode => true},
    {ok, StdioPid} = erlmcp_transport_stdio:start_link(self(), StdioOpts),
    {ok, StdioState} = gen_server:call(StdioPid, get_state),
    ?assert(is_tuple(StdioState)),
    ?assert(element(1, StdioState) =:= state),
    ok = gen_server:stop(StdioPid),

    % Test TCP transport
    TcpOpts = #{
        mode => client,
        host => "localhost",
        port => 9999,
        test_mode => true
    },
    {ok, TcpPid} = erlmcp_transport_tcp:start_link(test_tcp_state_type, TcpOpts),
    {ok, TcpState} = gen_server:call(TcpPid, get_state),
    ?assert(is_tuple(TcpState)),
    ?assert(element(1, TcpState) =:= state),
    ok = gen_server:stop(TcpPid),

    % Test HTTP transport
    HttpOpts = #{
        url => "http://example.com/api",
        test_mode => true
    },
    {ok, HttpPid} = erlmcp_transport_http:start_link(HttpOpts),
    {ok, HttpState} = gen_server:call(HttpPid, get_state),
    ?assert(is_tuple(HttpState)),
    ?assert(element(1, HttpState) =:= state),
    ok = gen_server:stop(HttpPid),

    ok.


transport_opts_type(Config) ->
    % Test transport options type compatibility
    % These should all be valid transport_opts types
    StdioOpts = #{owner => self()},
    TcpOpts =
        #{host => "localhost",
          port => 8080,
          owner => self()},
    HttpOpts = #{url => "http://example.com", owner => self()},

    ?assertEqual(ok, erlmcp_transport_behavior:validate_transport_opts(stdio, StdioOpts)),
    ?assertEqual(ok, erlmcp_transport_behavior:validate_transport_opts(tcp, TcpOpts)),
    ?assertEqual(ok, erlmcp_transport_behavior:validate_transport_opts(http, HttpOpts)),
    ok.

transport_message_type(Config) ->
    % Test transport message type compliance
    % Create various message types
    Message1 = erlmcp_transport_behavior:create_message(<<"test">>, #{}, 1),
    Message2 = erlmcp_transport_behavior:create_notification(<<"notify">>, #{}),
    Message3 = erlmcp_transport_behavior:create_response(1, #{result => ok}),
    Message4 = erlmcp_transport_behavior:create_error_response(1, -32600, <<"Error">>, undefined),

    % All should be valid transport messages
    ?assertEqual(ok, erlmcp_transport_behavior:validate_message(Message1)),
    ?assertEqual(ok, erlmcp_transport_behavior:validate_message(Message2)),
    ?assertEqual(ok, erlmcp_transport_behavior:validate_message(Message3)),
    ?assertEqual(ok, erlmcp_transport_behavior:validate_message(Message4)),
    ok.

transport_info_type(Config) ->
    % Test transport info type structure
    % Mock transport info
    MockInfo =
        #{type => test_transport,
          version => <<"1.0.0">>,
          capabilities => [send, 'receive'],
          connection_state => connected,
          statistics => #{messages_sent => 10, messages_received => 5}},

    % Should have expected structure
    ?assert(maps:is_key(type, MockInfo)),
    ?assert(maps:is_key(connection_state, MockInfo)),
    ok.

%%====================================================================
%% Test Cases - Validation Functions
%%====================================================================

url_validation_functions(Config) ->
    % Test URL validation helper functions
    % Valid HTTP URLs
    ValidHttpUrls =
        ["http://example.com", "https://secure.example.com", "http://localhost:8080/path"],

    % Valid WebSocket URLs
    ValidWsUrls = ["ws://example.com/ws", "wss://secure.example.com/ws"],

    % Test the validation functions exist and work
    % Note: These are internal functions, so we test through public interface
    lists:foreach(fun(Url) ->
                     HttpOpts = #{url => Url, owner => self()},
                     ?assertEqual(ok, erlmcp_transport_behavior:validate_transport_opts(http, HttpOpts))
                  end,
                  ValidHttpUrls),

    lists:foreach(fun(Url) ->
                     WsOpts = #{url => Url, owner => self()},
                     ?assertEqual(ok, erlmcp_transport_behavior:validate_transport_opts(websocket, WsOpts))
                  end,
                  ValidWsUrls),
    ok.

host_validation_functions(Config) ->
    % Test host validation helper functions
    ValidHosts =
        ["localhost", "example.com", "192.168.1.1", {127, 0, 0, 1}, {192, 168, 1, 1}],

    lists:foreach(fun(Host) ->
                     TcpOpts =
                         #{host => Host,
                           port => 8080,
                           owner => self()},
                     ?assertEqual(ok, erlmcp_transport_behavior:validate_transport_opts(tcp, TcpOpts))
                  end,
                  ValidHosts),

    % Test invalid hosts
    InvalidHosts =
        [{256, 0, 0, 1}, % Invalid IP
         {}, % Wrong tuple format
         123, % Not a string or IP tuple
         ""],  % Empty string

    lists:foreach(fun(Host) ->
                     TcpOpts =
                         #{host => Host,
                           port => 8080,
                           owner => self()},
                     ?assertMatch({error, _},
                                  erlmcp_transport_behavior:validate_transport_opts(tcp, TcpOpts))
                  end,
                  InvalidHosts),
    ok.

message_content_validation(Config) ->
    % Test message content validation functions
    % Valid message contents
    ValidMessages =
        [#{<<"jsonrpc">> => <<"2.0">>,
           <<"method">> => <<"test">>,
           <<"id">> => 1},
         #{<<"jsonrpc">> => <<"2.0">>,
           <<"result">> => <<"ok">>,
           <<"id">> => 1},
         #{<<"jsonrpc">> => <<"2.0">>,
           <<"error">> => #{<<"code">> => -32600, <<"message">> => <<"Error">>},
           <<"id">> => 1}],

    lists:foreach(fun(Message) -> ?assertEqual(ok, erlmcp_transport_behavior:validate_message(Message))
                  end,
                  ValidMessages),

    % Invalid message contents
    InvalidMessages =
        [#{<<"method">> => <<"test">>}, % Missing jsonrpc
         #{<<"jsonrpc">> => <<"1.0">>}, % Wrong version
         #{<<"jsonrpc">> => <<"2.0">>}],  % Missing content

    lists:foreach(fun(Message) ->
                     ?assertMatch({error, _}, erlmcp_transport_behavior:validate_message(Message))
                  end,
                  InvalidMessages),

behavior_lifecycle(Config) ->
    % Test complete behavior lifecycle
    TransportId = test_behavior_lifecycle,

    % 1. Initialize
    StdioOpts = #{test_mode => true},
    {ok, Pid} = erlmcp_transport_stdio:start_link(self(), StdioOpts#{transport_id => TransportId}),
    ?assert(is_process_alive(Pid)),

    % 2. Test send via Pid (API sends to stdout)
    ?assertEqual(ok, erlmcp_transport_stdio:send(Pid, <<"test message">>)),

    % 3. Test close via Pid
    ?assertEqual(ok, erlmcp_transport_stdio:close(Pid)),

    % 4. Verify process is terminated
    timer:sleep(100),
    ?assertNot(is_process_alive(Pid)),
    ok.

%%====================================================================
%% Helper Functions
%%====================================================================

% No additional helper functions needed for this test suite
