%%%-------------------------------------------------------------------
%%% @doc
%%% Connection Leak Tests for TCP Transport
%%%
%%% Tests that connection slots are properly released on ALL exit paths:
%%% - Normal termination
%%% - Handler initialization failure
%%% - Early handler crash after start
%%% - Connection lease timeout
%%% - Socket errors during handshake
%%% - Owner process death
%%%
%%% @end
%%%-------------------------------------------------------------------
-module(erlmcp_transport_tcp_leak_tests).
-author("erlmcp").

-include_lib("eunit/include/eunit.hrl").
-include_lib("erlmcp.hrl").

%% Test fixtures
-define(TEST_SERVER_ID, tcp_leak_test_server).
-define(TEST_PORT, 0).
-define(TEST_TIMEOUT, 10000).

%%%====================================================================
%%% Test Setup and Teardown
%%%====================================================================

setup() ->
    %% Start connection limiter
    {ok, LimiterPid} = erlmcp_connection_limiter:start_link(),
    %% Set a low limit for testing
    ok = erlmcp_connection_limiter:set_limit(100),
    %% Enable connection limiting
    application:set_env(erlmcp, connection_limiting, #{
        max_connections => 100,
        alert_threshold => 0.7,
        enabled => true
    }),
    LimiterPid.

cleanup(_LimiterPid) ->
    %% Stop connection limiter
    erlmcp_connection_limiter:stop(),
    %% Clean up any remaining handlers
    lists:foreach(fun(Pid) ->
        catch exit(Pid, kill)
    end, processes_where(fun(P) ->
        case process_info(P, dictionary) of
            {dictionary, Dict} ->
                lists:any(fun({K, _V}) ->
                    K =:= '$initial_call' andalso
                    (element(1, proplists:get_value(K, Dict)) =:= erlmcp_transport_tcp)
                end, Dict);
            _ ->
                false
        end
    end)),
    ok.

%%%====================================================================
%%% Connection Leak Tests
%%%====================================================================

connection_leak_test_() ->
    {setup,
     fun setup/0,
     fun cleanup/1,
     [
        {"Normal handler lifecycle releases slot", fun normal_lifecycle_releases_slot/0},
        {"Handler init failure releases slot", fun init_failure_releases_slot/0},
        {"Early handler crash releases slot", fun early_crash_releases_slot/0},
        {"Handshake failure releases slot", fun handshake_failure_releases_slot/0},
        {"Owner death releases slot", fun owner_death_releases_slot/0},
        {"Socket error during init releases slot", fun socket_error_releases_slot/0},
        {"Concurrent connections don't leak slots", fun concurrent_connections_no_leak/0},
        {"Connection limit enforced correctly", fun connection_limit_enforced/0},
        {"Slot reuse after handler termination", fun slot_reuse_after_termination/0}
     ]}.

%%%-------------------------------------------------------------------
%%% Test Cases
%%%-------------------------------------------------------------------

%% @doc Test that normal handler lifecycle properly releases the slot
normal_lifecycle_releases_slot() ->
    %% Get initial connection count
    InitialCount = erlmcp_connection_limiter:get_connection_count(),

    %% Start a TCP server
    {ok, ServerPid} = erlmcp_transport_tcp:start_server(#{
        port => ?TEST_PORT,
        server_id => ?TEST_SERVER_ID,
        owner => self()
    }),

    %% Accept a connection
    {ok, _Socket} = gen_tcp:connect({127,0,0,1}, get_server_port(ServerPid), []),

    %% Wait for handler to start
    timer:sleep(100),

    %% Verify slot was taken
    AfterAccept = erlmcp_connection_limiter:get_connection_count(),
    ?assertEqual(InitialCount + 1, AfterAccept),

    %% Close the connection
    gen_tcp:close(ServerPid),
    timer:sleep(100),

    %% Verify slot was released
    AfterClose = erlmcp_connection_limiter:get_connection_count(),
    ?assertEqual(InitialCount, AfterClose).

%% @doc Test that handler initialization failure releases the slot
init_failure_releases_slot() ->
    %% Get initial connection count
    InitialCount = erlmcp_connection_limiter:get_connection_count(),

    %% This test simulates init failure by using invalid options
    %% that will cause handshake to fail

    %% We'll test by monitoring the start_link process
    Parent = self(),
    SpawnFun = fun() ->
        %% Try to start a handler that will fail during init
        Result = erlmcp_transport_tcp:start_link(#{
            mode => server,
            ranch_ref => make_ref(),
            protocol_opts => #{
                server_id => ?TEST_SERVER_ID,
                owner => Parent
            }
        }),
        Parent ! {init_result, Result}
    end,

    spawn(SpawnFun),

    %% Wait for init to complete/fail
    receive
        {init_result, {error, _Reason}} ->
            ok
    after 1000 ->
        ?assert(timeout_did_not_occur, false)
    end,

    %% Give cleanup time
    timer:sleep(100),

    %% Verify slot was released despite init failure
    FinalCount = erlmcp_connection_limiter:get_connection_count(),
    ?assertEqual(InitialCount, FinalCount).

%% @doc Test that early handler crash releases the slot
early_crash_releases_slot() ->
    %% Get initial connection count
    InitialCount = erlmcp_connection_limiter:get_connection_count(),

    %% Start a server
    {ok, ServerPid} = erlmcp_transport_tcp:start_server(#{
        port => ?TEST_PORT,
        server_id => ?TEST_SERVER_ID,
        owner => self()
    }),

    %% Accept a connection
    {ok, ClientSocket} = gen_tcp:connect(
        {127,0,0,1},
        get_server_port(ServerPid),
        []
    ),

    %% Wait for handler to start
    timer:sleep(100),

    %% Verify slot was taken
    AfterAccept = erlmcp_connection_limiter:get_connection_count(),
    ?assertEqual(InitialCount + 1, AfterAccept),

    %% Find and immediately kill the handler process
    HandlerPid = find_tcp_handler(ServerPid),
    case HandlerPid of
        undefined ->
            ?assert(handler_found, false);
        _ ->
            %% Kill the handler abruptly
            exit(HandlerPid, kill),
            timer:sleep(100),

            %% Verify slot was released
            AfterKill = erlmcp_connection_limiter:get_connection_count(),
            ?assertEqual(InitialCount, AfterKill)
    end,

    %% Cleanup
    gen_tcp:close(ClientSocket),
    catch exit(ServerPid, normal).

%% @doc Test that handshake failure releases the slot
handshake_failure_releases_slot() ->
    %% Get initial connection count
    InitialCount = erlmcp_connection_limiter:get_connection_count(),

    %% Simulate handshake failure by starting with invalid ranch ref
    %% This will cause ranch:handshake/1 to fail

    %% We test the start_link/3 ranch callback directly
    RanchRef = make_ref(),
    ProtocolOpts = #{
        server_id => ?TEST_SERVER_ID,
        owner => self()
    },

    %% This should fail during handshake
    Result = erlmcp_transport_tcp:start_link(
        RanchRef,
        ranch_tcp,
        ProtocolOpts
    ),

    %% Should get an error
    ?assertMatch({error, _}, Result),

    %% Give cleanup time
    timer:sleep(100),

    %% Verify slot was released
    FinalCount = erlmcp_connection_limiter:get_connection_count(),
    ?assertEqual(InitialCount, FinalCount).

%% @doc Test that owner death releases the slot
owner_death_releases_slot() ->
    %% Get initial connection count
    InitialCount = erlmcp_connection_limiter:get_connection_count(),

    %% Start a server
    {ok, ServerPid} = erlmcp_transport_tcp:start_server(#{
        port => ?TEST_PORT,
        server_id => ?TEST_SERVER_ID,
        owner => self()
    }),

    %% Create an owner process that will die
    Owner = spawn(fun() ->
        receive
            die -> ok
        end
    end),

    %% Start handler with this owner
    {ok, ClientSocket} = gen_tcp:connect(
        {127,0,0,1},
        get_server_port(ServerPid),
        []
    ),

    %% Wait for handler to start
    timer:sleep(100),

    %% Verify slot was taken
    AfterAccept = erlmcp_connection_limiter:get_connection_count(),
    ?assertEqual(InitialCount + 1, AfterAccept),

    %% Kill the owner
    Owner ! die,
    timer:sleep(100),

    %% Verify slot was released when owner died
    AfterOwnerDeath = erlmcp_connection_limiter:get_connection_count(),
    ?assertEqual(InitialCount, AfterOwnerDeath),

    %% Cleanup
    gen_tcp:close(ClientSocket),
    catch exit(ServerPid, normal).

%% @doc Test that socket error during init releases the slot
socket_error_releases_slot() ->
    %% Get initial connection count
    InitialCount = erlmcp_connection_limiter:get_connection_count(),

    %% Start a server
    {ok, ServerPid} = erlmcp_transport_tcp:start_server(#{
        port => ?TEST_PORT,
        server_id => ?TEST_SERVER_ID,
        owner => self()
    }),

    %% Connect and immediately send invalid data to trigger socket error
    {ok, ClientSocket} = gen_tcp:connect(
        {127,0,0,1},
        get_server_port(ServerPid),
        []
    ),

    %% Wait for handler to start
    timer:sleep(100),

    %% Verify slot was taken
    AfterAccept = erlmcp_connection_limiter:get_connection_count(),
    ?assertEqual(InitialCount + 1, AfterAccept),

    %% Close the socket abruptly to trigger error
    gen_tcp:close(ClientSocket),
    timer:sleep(100),

    %% Verify slot was released
    AfterError = erlmcp_connection_limiter:get_connection_count(),
    ?assertEqual(InitialCount, AfterError),

    %% Cleanup
    catch exit(ServerPid, normal).

%% @doc Test that concurrent connections don't leak slots
concurrent_connections_no_leak() ->
    %% Get initial connection count
    InitialCount = erlmcp_connection_limiter:get_connection_count(),

    %% Start a server
    {ok, ServerPid} = erlmcp_transport_tcp:start_server(#{
        port => ?TEST_PORT,
        server_id => ?TEST_SERVER_ID,
        owner => self()
    }),

    Port = get_server_port(ServerPid),

    %% Create 10 concurrent connections
    NumConns = 10,
    Clients = lists:map(fun(_) ->
        {ok, Socket} = gen_tcp:connect({127,0,0,1}, Port, []),
        Socket
    end, lists:seq(1, NumConns)),

    %% Wait for all handlers to start
    timer:sleep(200),

    %% Verify all slots were taken
    AfterAccept = erlmcp_connection_limiter:get_connection_count(),
    ?assertEqual(InitialCount + NumConns, AfterAccept),

    %% Close all connections
    lists:foreach(fun(Socket) ->
        gen_tcp:close(Socket)
    end, Clients),

    %% Wait for cleanup
    timer:sleep(200),

    %% Verify all slots were released
    AfterClose = erlmcp_connection_limiter:get_connection_count(),
    ?assertEqual(InitialCount, AfterClose),

    %% Cleanup
    catch exit(ServerPid, normal).

%% @doc Test that connection limit is enforced correctly
connection_limit_enforced() ->
    %% Set a very low limit
    ok = erlmcp_connection_limiter:set_limit(5),

    %% Get initial connection count
    InitialCount = erlmcp_connection_limiter:get_connection_count(),

    %% Start a server
    {ok, ServerPid} = erlmcp_transport_tcp:start_server(#{
        port => ?TEST_PORT,
        server_id => ?TEST_SERVER_ID,
        owner => self()
    }),

    Port = get_server_port(ServerPid),

    %% Create connections up to the limit
    Limit = 5,
    Clients = lists:map(fun(_) ->
        {ok, Socket} = gen_tcp:connect({127,0,0,1}, Port, []),
        Socket
    end, lists:seq(1, Limit)),

    %% Wait for handlers to start
    timer:sleep(200),

    %% Verify all slots are taken
    AtLimit = erlmcp_connection_limiter:get_connection_count(),
    ?assertEqual(InitialCount + Limit, AtLimit),

    %% Try to create one more connection - should be rejected
    {ok, ExtraSocket} = gen_tcp:connect({127,0,0,1}, Port, [
        {active, false},
        binary
    ]),

    %% Wait to see if connection is accepted
    timer:sleep(100),

    %% The connection should be closed by the server due to limit
    case gen_tcp:recv(ExtraSocket, 0, 500) of
        {error, closed} ->
            ok;  % Expected - connection was rejected
        {ok, _} ->
            %% Connection was accepted - check if handler started
            timer:sleep(100),
            OverLimit = erlmcp_connection_limiter:get_connection_count(),
            ?assert(OverLimit =< InitialCount + Limit)
    end,

    %% Cleanup
    gen_tcp:close(ExtraSocket),
    lists:foreach(fun(Socket) ->
        gen_tcp:close(Socket)
    end, Clients),
    timer:sleep(200),
    catch exit(ServerPid, normal),

    %% Reset limit
    ok = erlmcp_connection_limiter:set_limit(100).

%% @doc Test that slots can be reused after handler termination
slot_reuse_after_termination() ->
    %% Get initial connection count
    InitialCount = erlmcp_connection_limiter:get_connection_count(),

    %% Start a server
    {ok, ServerPid} = erlmcp_transport_tcp:start_server(#{
        port => ?TEST_PORT,
        server_id => ?TEST_SERVER_ID,
        owner => self()
    }),

    Port = get_server_port(ServerPid),

    %% Create and close a connection multiple times
    lists:foreach(fun(_Iter) ->
        %% Connect
        {ok, Socket} = gen_tcp:connect({127,0,0,1}, Port, []),
        timer:sleep(50),

        %% Disconnect
        gen_tcp:close(Socket),
        timer:sleep(50)
    end, lists:seq(1, 10)),

    %% Wait for final cleanup
    timer:sleep(200),

    %% Verify we're back to initial count (no leaks)
    FinalCount = erlmcp_connection_limiter:get_connection_count(),
    ?assertEqual(InitialCount, FinalCount),

    %% Cleanup
    catch exit(ServerPid, normal).

%%%====================================================================
%%% Helper Functions
%%%====================================================================

%% @doc Get the actual port of a server (when port was 0)
get_server_port(ServerPid) ->
    case erlmcp_transport_tcp:connect(ServerPid, #{}) of
        {error, _} ->
            %% Try to get port from state
            try
                {ok, State} = gen_server:call(ServerPid, get_state),
                State#state.port
            catch
                _:_ ->
                    %% Fallback: try to find listening port
                    {ok, Ports} = inet:ports(),
                    TcpPorts = lists:filter(fun(P) ->
                        case inet:port(P) of
                            {ok, PortNum} when PortNum > 1024 ->
                                true;
                            _ ->
                                false
                        end
                    end, Ports),
                    case TcpPorts of
                        [Port | _] ->
                            {ok, PortNum} = inet:port(Port),
                            PortNum;
                        _ ->
                            0
                        end
            end;
        ok ->
            %% Connection attempt succeeded, find the port
            {ok, Ports} = inet:ports(),
            lists:foldl(fun(P, Acc) ->
                case inet:port(P) of
                    {ok, PortNum} when PortNum > 1024 ->
                        PortNum;
                    _ ->
                        Acc
                end
            end, 0, Ports)
    end.

%% @doc Find a TCP handler process for a server
find_tcp_handler(ServerPid) ->
    %% Get all processes and find one that's a TCP handler
    AllProcesses = processes(),
    lists:foldl(fun(Pid, Acc) ->
        case Acc of
            undefined ->
                case process_info(Pid, initial_call) of
                    {initial_call, {erlmcp_transport_tcp, init, _}} ->
                        case process_info(Pid, dictionary) of
                            {dictionary, Dict} ->
                                case proplists:get_value('$ancestors', Dict) of
                                    [ServerPid | _] ->
                                        Pid;
                                    _ ->
                                        Acc
                                end;
                            _ ->
                                Acc
                        end;
                    _ ->
                        Acc
                end;
            _ ->
                Acc
        end
    end, undefined, AllProcesses).

%% @doc Filter processes matching a predicate
processes_where(Pred) ->
    lists:filter(Pred, processes()).
