%%%-------------------------------------------------------------------
%%% @doc
%%% GraphQL Resolvers for MCP Operations
%%%
%%% Implements GraphQL query, mutation, and subscription resolvers
%%% that bridge GraphQL requests to MCP protocol operations.
%%%
%%% Features:
%%% - Query resolvers (tools, resources, prompts)
%%% - Mutation resolvers (tool calls)
%%% - Subscription resolvers (resource updates)
%%% - DataLoader integration for N+1 query prevention
%%% - Error handling and formatting
%%% @end
%%%-------------------------------------------------------------------
-module(erlmcp_graphql_resolver).

-include("erlmcp.hrl").
-include_lib("kernel/include/logger.hrl").

%% API exports
-export([
    %% Query resolvers
    resolve_tools/2,
    resolve_tool/2,
    resolve_resources/2,
    resolve_resource/2,
    resolve_resource_read/2,
    resolve_prompts/2,
    resolve_prompt/2,
    resolve_prompt_get/2,

    %% Mutation resolvers
    resolve_call_tool/2,

    %% Subscription resolvers
    subscribe_resource_updated/2,

    %% Helper functions
    format_error/1,
    validate_args/2
]).

%% Types
-type context() :: #{
    server_id := atom(),
    server_pid := pid(),
    transport_id := atom(),
    atom() => term()
}.

-type resolver_result() ::
    {ok, term()} |
    {error, binary() | map()}.

-export_type([context/0, resolver_result/0]).

%%====================================================================
%% Query Resolvers
%%====================================================================

%% @doc Resolve tools query - list all available tools
-spec resolve_tools(context(), map()) -> resolver_result().
resolve_tools(#{server_pid := ServerPid}, _Args) ->
    ?LOG_DEBUG("Resolving tools query", []),
    try
        %% Call MCP server to get tools list
        case gen_server:call(ServerPid, {graphql_list_tools}) of
            {ok, Tools} ->
                {ok, Tools};
            {error, Reason} ->
                {error, format_error(Reason)}
        end
    catch
        Class:Reason:Stack ->
            ?LOG_ERROR("Error resolving tools: ~p:~p~n~p", [Class, Reason, Stack]),
            {error, <<"Failed to list tools">>}
    end.

%% @doc Resolve tool query - get specific tool by name
-spec resolve_tool(context(), map()) -> resolver_result().
resolve_tool(#{server_pid := ServerPid}, #{<<"name">> := Name}) ->
    ?LOG_DEBUG("Resolving tool query for: ~p", [Name]),
    try
        case gen_server:call(ServerPid, {graphql_get_tool, Name}) of
            {ok, Tool} ->
                {ok, Tool};
            {error, not_found} ->
                {error, #{message => <<"Tool not found">>, code => <<"TOOL_NOT_FOUND">>}};
            {error, Reason} ->
                {error, format_error(Reason)}
        end
    catch
        Class:Reason:Stack ->
            ?LOG_ERROR("Error resolving tool ~p: ~p:~p~n~p", [Name, Class, Reason, Stack]),
            {error, <<"Failed to get tool">>}
    end.

%% @doc Resolve resources query - list all available resources
-spec resolve_resources(context(), map()) -> resolver_result().
resolve_resources(#{server_pid := ServerPid}, _Args) ->
    ?LOG_DEBUG("Resolving resources query", []),
    try
        case gen_server:call(ServerPid, {graphql_list_resources}) of
            {ok, Resources} ->
                {ok, Resources};
            {error, Reason} ->
                {error, format_error(Reason)}
        end
    catch
        Class:Reason:Stack ->
            ?LOG_ERROR("Error resolving resources: ~p:~p~n~p", [Class, Reason, Stack]),
            {error, <<"Failed to list resources">>}
    end.

%% @doc Resolve resource query - get specific resource by URI
-spec resolve_resource(context(), map()) -> resolver_result().
resolve_resource(#{server_pid := ServerPid}, #{<<"uri">> := Uri}) ->
    ?LOG_DEBUG("Resolving resource query for: ~p", [Uri]),
    try
        case gen_server:call(ServerPid, {graphql_get_resource, Uri}) of
            {ok, Resource} ->
                {ok, Resource};
            {error, not_found} ->
                {error, #{message => <<"Resource not found">>, code => <<"RESOURCE_NOT_FOUND">>}};
            {error, Reason} ->
                {error, format_error(Reason)}
        end
    catch
        Class:Reason:Stack ->
            ?LOG_ERROR("Error resolving resource ~p: ~p:~p~n~p", [Uri, Class, Reason, Stack]),
            {error, <<"Failed to get resource">>}
    end.

%% @doc Resolve resource read - read resource content
-spec resolve_resource_read(context(), map()) -> resolver_result().
resolve_resource_read(#{server_pid := ServerPid, transport_id := TransportId}, #{<<"uri">> := Uri}) ->
    ?LOG_DEBUG("Resolving resource read for: ~p", [Uri]),
    try
        %% Generate unique request ID
        RequestId = erlang:unique_integer([positive]),

        %% Create MCP resources/read request
        Params = #{?MCP_PARAM_URI => Uri},
        Request = #{
            <<"jsonrpc">> => ?JSONRPC_VERSION,
            <<"id">> => RequestId,
            <<"method">> => ?MCP_METHOD_RESOURCES_READ,
            <<"params">> => Params
        },

        %% Send to server via internal call
        case gen_server:call(ServerPid, {graphql_resource_read, TransportId, Request}) of
            {ok, Contents} ->
                {ok, #{<<"contents">> => Contents}};
            {error, Reason} ->
                {error, format_error(Reason)}
        end
    catch
        Class:Reason:Stack ->
            ?LOG_ERROR("Error reading resource ~p: ~p:~p~n~p", [Uri, Class, Reason, Stack]),
            {error, <<"Failed to read resource">>}
    end.

%% @doc Resolve prompts query - list all available prompts
-spec resolve_prompts(context(), map()) -> resolver_result().
resolve_prompts(#{server_pid := ServerPid}, _Args) ->
    ?LOG_DEBUG("Resolving prompts query", []),
    try
        case gen_server:call(ServerPid, {graphql_list_prompts}) of
            {ok, Prompts} ->
                {ok, Prompts};
            {error, Reason} ->
                {error, format_error(Reason)}
        end
    catch
        Class:Reason:Stack ->
            ?LOG_ERROR("Error resolving prompts: ~p:~p~n~p", [Class, Reason, Stack]),
            {error, <<"Failed to list prompts">>}
    end.

%% @doc Resolve prompt query - get specific prompt by name
-spec resolve_prompt(context(), map()) -> resolver_result().
resolve_prompt(#{server_pid := ServerPid}, #{<<"name">> := Name}) ->
    ?LOG_DEBUG("Resolving prompt query for: ~p", [Name]),
    try
        case gen_server:call(ServerPid, {graphql_get_prompt, Name}) of
            {ok, Prompt} ->
                {ok, Prompt};
            {error, not_found} ->
                {error, #{message => <<"Prompt not found">>, code => <<"PROMPT_NOT_FOUND">>}};
            {error, Reason} ->
                {error, format_error(Reason)}
        end
    catch
        Class:Reason:Stack ->
            ?LOG_ERROR("Error resolving prompt ~p: ~p:~p~n~p", [Name, Class, Reason, Stack]),
            {error, <<"Failed to get prompt">>}
    end.

%% @doc Resolve prompt get - execute prompt with arguments
-spec resolve_prompt_get(context(), map()) -> resolver_result().
resolve_prompt_get(#{server_pid := ServerPid, transport_id := TransportId}, Args) ->
    Name = maps:get(<<"name">>, Args),
    Arguments = maps:get(<<"arguments">>, Args, #{}),

    ?LOG_DEBUG("Resolving prompt get for: ~p with args: ~p", [Name, Arguments]),

    try
        %% Generate unique request ID
        RequestId = erlang:unique_integer([positive]),

        %% Create MCP prompts/get request
        Params = #{
            ?MCP_PARAM_NAME => Name,
            ?MCP_PARAM_ARGUMENTS => Arguments
        },
        Request = #{
            <<"jsonrpc">> => ?JSONRPC_VERSION,
            <<"id">> => RequestId,
            <<"method">> => ?MCP_METHOD_PROMPTS_GET,
            <<"params">> => Params
        },

        %% Send to server via internal call
        case gen_server:call(ServerPid, {graphql_prompt_get, TransportId, Request}) of
            {ok, Messages} ->
                {ok, #{<<"messages">> => Messages}};
            {error, Reason} ->
                {error, format_error(Reason)}
        end
    catch
        Class:Reason:Stack ->
            ?LOG_ERROR("Error getting prompt ~p: ~p:~p~n~p", [Name, Class, Reason, Stack]),
            {error, <<"Failed to get prompt">>}
    end.

%%====================================================================
%% Mutation Resolvers
%%====================================================================

%% @doc Resolve callTool mutation - execute a tool
-spec resolve_call_tool(context(), map()) -> resolver_result().
resolve_call_tool(#{server_pid := ServerPid, transport_id := TransportId}, Args) ->
    Name = maps:get(<<"name">>, Args),
    Arguments = maps:get(<<"arguments">>, Args, #{}),

    ?LOG_DEBUG("Resolving callTool mutation for: ~p with args: ~p", [Name, Arguments]),

    try
        %% Validate arguments
        case validate_tool_args(Name, Arguments) of
            ok ->
                %% Generate unique request ID
                RequestId = erlang:unique_integer([positive]),

                %% Create MCP tools/call request
                Params = #{
                    ?MCP_PARAM_NAME => Name,
                    ?MCP_PARAM_ARGUMENTS => Arguments
                },
                Request = #{
                    <<"jsonrpc">> => ?JSONRPC_VERSION,
                    <<"id">> => RequestId,
                    <<"method">> => ?MCP_METHOD_TOOLS_CALL,
                    <<"params">> => Params
                },

                %% Send to server via internal call
                case gen_server:call(ServerPid, {graphql_call_tool, TransportId, Request}, 30000) of
                    {ok, Content} ->
                        {ok, #{
                            <<"content">> => Content,
                            <<"isError">> => false
                        }};
                    {error, Reason} ->
                        {error, format_error(Reason)}
                end;
            {error, ValidationError} ->
                {error, format_error(ValidationError)}
        end
    catch
        Class:Reason:Stack ->
            ?LOG_ERROR("Error calling tool ~p: ~p:~p~n~p", [Name, Class, Reason, Stack]),
            {error, <<"Failed to call tool">>}
    end.

%%====================================================================
%% Subscription Resolvers
%%====================================================================

%% @doc Subscribe to resource updates
-spec subscribe_resource_updated(context(), map()) -> resolver_result().
subscribe_resource_updated(#{server_pid := ServerPid}, Args) ->
    Uri = maps:get(<<"uri">>, Args, undefined),

    ?LOG_DEBUG("Subscribing to resource updates for: ~p", [Uri]),

    try
        %% Create subscription stream
        StreamPid = spawn_link(fun() ->
            subscription_loop(ServerPid, Uri)
        end),

        {ok, StreamPid}
    catch
        Class:Reason:Stack ->
            ?LOG_ERROR("Error subscribing to resource: ~p:~p~n~p", [Class, Reason, Stack]),
            {error, <<"Failed to subscribe to resource">>}
    end.

%%====================================================================
%% Helper Functions
%%====================================================================

%% @doc Format error for GraphQL response
-spec format_error(term()) -> binary() | map().
format_error(not_found) ->
    #{message => <<"Not found">>, code => <<"NOT_FOUND">>};
format_error({Code, Message}) when is_integer(Code), is_binary(Message) ->
    #{message => Message, code => integer_to_binary(Code)};
format_error(Reason) when is_binary(Reason) ->
    #{message => Reason, code => <<"ERROR">>};
format_error(Reason) when is_atom(Reason) ->
    #{message => atom_to_binary(Reason, utf8), code => <<"ERROR">>};
format_error(Reason) ->
    #{message => iolist_to_binary(io_lib:format("~p", [Reason])), code => <<"ERROR">>}.

%% @doc Validate GraphQL arguments
-spec validate_args(map(), [atom()]) -> ok | {error, binary()}.
validate_args(Args, RequiredFields) ->
    Missing = [F || F <- RequiredFields, not maps:is_key(atom_to_binary(F, utf8), Args)],
    case Missing of
        [] -> ok;
        Fields ->
            FieldNames = string:join([atom_to_list(F) || F <- Fields], ", "),
            {error, iolist_to_binary(io_lib:format("Missing required fields: ~s", [FieldNames]))}
    end.

%% @doc Validate tool arguments
-spec validate_tool_args(binary(), map()) -> ok | {error, binary()}.
validate_tool_args(_Name, Args) when is_map(Args) ->
    %% Basic validation - could be extended with schema validation
    ok;
validate_tool_args(_Name, _Args) ->
    {error, <<"Invalid tool arguments">>}.

%%====================================================================
%% Internal Functions - Subscription
%%====================================================================

%% @private
%% Subscription loop for resource updates
-spec subscription_loop(pid(), binary() | undefined) -> no_return().
subscription_loop(ServerPid, Uri) ->
    %% Subscribe to resource updates
    case Uri of
        undefined ->
            %% Subscribe to all resources
            ok = gen_server:call(ServerPid, {graphql_subscribe_all_resources});
        _ ->
            %% Subscribe to specific resource
            ok = gen_server:call(ServerPid, {graphql_subscribe_resource, Uri})
    end,

    %% Wait for updates and forward to GraphQL subscription handler
    subscription_receive_loop(Uri).

%% @private
%% Receive loop for subscription updates
-spec subscription_receive_loop(binary() | undefined) -> no_return().
subscription_receive_loop(Uri) ->
    receive
        {resource_updated, UpdatedUri, _Metadata} when Uri =:= undefined; Uri =:= UpdatedUri ->
            %% Forward update to GraphQL subscription system
            %% (This would integrate with graphql-erlang's subscription mechanism)
            ?LOG_DEBUG("Resource updated: ~p", [UpdatedUri]),
            subscription_receive_loop(Uri);

        {resource_updated, _OtherUri, _Metadata} ->
            %% Ignore updates for other resources
            subscription_receive_loop(Uri);

        stop ->
            ?LOG_DEBUG("Stopping subscription loop", []),
            ok;

        _Other ->
            subscription_receive_loop(Uri)
    after 30000 ->
        %% Keepalive
        subscription_receive_loop(Uri)
    end.
