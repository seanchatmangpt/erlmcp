%%%-------------------------------------------------------------------
%%% @doc
%%% Tool Sandbox for ErlMCP - Secure, Isolated Tool Execution
%%%
%%% This module provides comprehensive sandboxing for tool execution with
%%% process isolation, resource limits, security boundaries, and monitoring.
%%%
%%% == Key Features ==
%%%
%%% 1. **Process Isolation**: Spawned worker processes with monitors
%%% 2. **Resource Enforcement**: Memory/time limits via erlmcp_memory_guard
%%% 3. **Security Boundaries**: Capability-based permission system
%%% 4. **Error Handling**: Graceful degradation and let-it-crash
%%% 5. **Metrics Collection**: Execution telemetry and audit logging
%%% 6. **Timeout Management**: Configurable per-execution timeouts
%%%
%%% == Security Model ==
%%%
%%% The sandbox enforces zero-trust security:
%%% - All tools require explicit permission grants
%%% - Permissions follow capability-based security
%%% - Resource limits prevent DoS attacks
%%% - Audit trail for all executions
%%%
%%% == Process Isolation ==
%%%
%%% Each tool execution runs in an isolated process:
%%% - Monitored (not linked) to prevent cascading failures
%%% - Memory guard limits prevent memory exhaustion
%%% - Timeout enforcement prevents hanging tools
%%% - Clean termination on errors
%%%
%%% == Usage Example ==
%%%
%%% ```erlang
%%% %% Start sandbox with permissions
%%% {ok, Sandbox} = erlmcp_tool_sandbox:start_link([
%%%     {permissions, [?PERM_READ_FILE]},
%%%     {limits, #{max_memory_mb => 128, max_timeout_sec => 10}}
%%% ]).
%%%
%%% %% Execute tool with permission check
%%% {ok, Result} = erlmcp_tool_sandbox:execute_tool(
%%%     Sandbox,
%%%     <<"read_file">>,
%%%     #{path => "/tmp/test.txt"}
%%% ).
%%%
%%% %% Add permission dynamically
%%% ok = erlmcp_tool_sandbox:add_permission(Sandbox, ?PERM_WRITE_FILE).
%%%
%%% %% Get execution metrics
%%% {ok, Metrics} = erlmcp_tool_sandbox:get_metrics(Sandbox).
%%% '''
%%%
%%% @end
%%%-------------------------------------------------------------------
-module(erlmcp_tool_sandbox).
-behaviour(gen_server).

%% API
-export([start_link/0, start_link/1,
         execute_tool/3,
         add_permission/2,
         set_limits/2,
         get_permissions/1,
         get_limits/1,
         get_metrics/1,
         get_audit_log/1,
         stop/1]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2,
         terminate/2, code_change/3]).

-include("erlmcp_new_features.hrl").

-define(SERVER, ?MODULE).
-define(DEFAULT_TIMEOUT, 30000).
-define(MAX_EXECUTION_TIME, 30000).

%% Permission atoms from ontology
-define(PERM_READ_FILE, 'ReadFile').
-define(PERM_WRITE_FILE, 'WriteFile').
-define(PERM_NETWORK_ACCESS, 'NetworkAccess').
-define(PERM_EXECUTE_COMMAND, 'ExecuteCommand').
-define(PERM_READ_ENV, 'ReadEnv').
-define(PERM_SUBPROCESS, 'Subprocess').

-record(state, {
    permissions = sets:new() :: sets:set(atom()),
    limits = #{
        max_cpu_percent => 50,
        max_memory_mb => 256,
        max_timeout_sec => 30,
        max_file_size_mb => 10
    } :: map(),
    audit_log = [] :: list(),
    execution_count = 0 :: non_neg_integer(),
    metrics = #{
        total_executions => 0,
        successful_executions => 0,
        failed_executions => 0,
        permission_denied => 0,
        timeout_count => 0,
        memory_limit_exceeded => 0
    } :: map(),
    active_workers = #{} :: map()
}).

-record(execution_context, {
    tool_name :: binary(),
    arguments :: map(),
    start_time :: erlang:timestamp(),
    execution_id :: binary(),
    caller :: pid(),
    timeout :: pos_integer()
}).

-record(worker_state, {
    execution_id :: binary(),
    tool_name :: binary(),
    arguments :: map(),
    max_memory :: pos_integer()
}).

-type sandbox() :: pid().
-type permission() :: ?PERM_READ_FILE | ?PERM_WRITE_FILE | ?PERM_NETWORK_ACCESS |
                     ?PERM_EXECUTE_COMMAND | ?PERM_READ_ENV | ?PERM_SUBPROCESS.
-type limits() :: #{
    max_cpu_percent => pos_integer(),
    max_memory_mb => pos_integer(),
    max_timeout_sec => pos_integer(),
    max_file_size_mb => pos_integer()
}.
-type execution_result() :: {ok, term()} | {error, term()}.
-type metrics() :: #{
    total_executions := non_neg_integer(),
    successful_executions := non_neg_integer(),
    failed_executions := non_neg_integer(),
    permission_denied := non_neg_integer(),
    timeout_count := non_neg_integer(),
    memory_limit_exceeded := non_neg_integer()
}.

-export_type([sandbox/0, permission/0, limits/0, execution_result/0, metrics/0]).

%%%===================================================================
%%% API
%%%===================================================================

-spec start_link() -> {ok, pid()} | {error, term()}.
start_link() ->
    gen_server:start_link({local, ?SERVER}, ?MODULE, [], []).

-spec start_link(proplists:proplist()) -> {ok, pid()} | {error, term()}.
start_link(Options) ->
    gen_server:start_link({local, ?SERVER}, ?MODULE, Options, []).

-spec execute_tool(pid(), binary(), map()) -> execution_result().
execute_tool(Sandbox, ToolName, Arguments) when is_binary(ToolName), is_map(Arguments) ->
    gen_server:call(Sandbox, {execute_tool, ToolName, Arguments}, ?MAX_EXECUTION_TIME).

-spec add_permission(pid(), permission() | [permission()]) -> ok.
add_permission(Sandbox, Permission) when is_atom(Permission) ->
    gen_server:call(Sandbox, {add_permission, Permission});
add_permission(Sandbox, Permissions) when is_list(Permissions) ->
    gen_server:call(Sandbox, {add_permissions, Permissions}).

-spec set_limits(pid(), limits()) -> ok | {error, term()}.
set_limits(Sandbox, Limits) when is_map(Limits) ->
    gen_server:call(Sandbox, {set_limits, Limits}).

-spec get_permissions(pid()) -> sets:set(permission()).
get_permissions(Sandbox) ->
    gen_server:call(Sandbox, get_permissions).

-spec get_limits(pid()) -> limits().
get_limits(Sandbox) ->
    gen_server:call(Sandbox, get_limits).

-spec get_metrics(pid()) -> {ok, metrics()}.
get_metrics(Sandbox) ->
    gen_server:call(Sandbox, get_metrics).

-spec get_audit_log(pid()) -> {ok, list(map())}.
get_audit_log(Sandbox) ->
    gen_server:call(Sandbox, get_audit_log).

-spec stop(pid()) -> ok.
stop(Sandbox) ->
    gen_server:stop(Sandbox).

%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

init([]) ->
    {ok, #state{}};
init(Options) ->
    InitialPerms = proplists:get_value(permissions, Options, []),
    InitialLimits = proplists:get_value(limits, Options, #{}),
    State = #state{
        permissions = sets:from_list(InitialPerms),
        limits = merge_limits(InitialLimits)
    },
    logger:info("Tool sandbox initialized with ~p permissions", [length(InitialPerms)]),
    {ok, State}.

handle_call({execute_tool, ToolName, Arguments}, From, State) ->
    ExecutionId = generate_execution_id(),
    TimeoutMs = maps:get(max_timeout_sec, State#state.limits, 30) * 1000,
    MaxMemory = maps:get(max_memory_mb, State#state.limits, 256),

    Context = #execution_context{
        tool_name = ToolName,
        arguments = Arguments,
        start_time = erlang:timestamp(),
        execution_id = ExecutionId,
        caller = From,
        timeout = TimeoutMs
    },

    %% Check permissions first
    RequiredPerms = get_required_permissions(ToolName),
    HasPermissions = check_permissions(RequiredPerms, State#state.permissions),

    case HasPermissions of
        true ->
            %% Spawn isolated worker process
            WorkerPid = spawn_worker(Context, MaxMemory),
            MonitorRef = monitor(process, WorkerPid),

            %% Track active worker
            WorkerInfo = #{
                pid => WorkerPid,
                monitor => MonitorRef,
                caller => From,
                execution_id => ExecutionId
            },
            NewWorkers = maps:put(ExecutionId, WorkerInfo, State#state.active_workers),
            NewState = State#state{active_workers = NewWorkers, metrics = NewMetrics, audit_log = NewLog}active_workers = NewWorkers},

            {noreply, NewState};
        false ->
            %% Log permission denial
            NewMetrics = maps:update_with(
                permission_denied,
                fun(X) -> X + 1 end,
                1,
                State#state.metrics
            ),

            AuditEntry = #{
                execution_id => ExecutionId,
                tool_name => ToolName,
                timestamp => erlang:system_time(millisecond),
                result => {error, {permission_denied, RequiredPerms}}
            },
            NewLog = [AuditEntry | State#state.audit_log],

            {reply, {error, {permission_denied, RequiredPerms}},
             State#state{active_workers = NewWorkers, metrics = NewMetrics, audit_log = NewLog}metrics = NewMetrics, audit_log = NewLog}}
    end;

handle_call({add_permission, Permission}, _From, State) ->
    case validate_permission(Permission) of
        true ->
            NewPerms = sets:add_element(Permission, State#state.permissions),
            logger:info("Added permission: ~p", [Permission]),
            {reply, ok, State#state{active_workers = NewWorkers, metrics = NewMetrics, audit_log = NewLog}permissions = NewPerms}};
        false ->
            {reply, {error, {invalid_permission, Permission}}, State}
    end;

handle_call({add_permissions, Permissions}, _From, State) ->
    case validate_permissions(Permissions) of
        true ->
            NewPerms = sets:union(State#state.permissions, sets:from_list(Permissions)),
            logger:info("Added ~p permissions", [length(Permissions)]),
            {reply, ok, State#state{active_workers = NewWorkers, metrics = NewMetrics, audit_log = NewLog}permissions = NewPerms}};
        false ->
            {reply, {error, invalid_permissions}, State}
    end;

handle_call({set_limits, Limits}, _From, State) ->
    case validate_limits(Limits) of
        ok ->
            MergedLimits = merge_limits(Limits, State#state.limits),
            logger:info("Updated limits: ~p", [Limits]),
            {reply, ok, State#state{active_workers = NewWorkers, metrics = NewMetrics, audit_log = NewLog}limits = MergedLimits}};
        {error, Reason} ->
            {reply, {error, Reason}, State}
    end;

handle_call(get_permissions, _From, State) ->
    {reply, State#state.permissions, State};

handle_call(get_limits, _From, State) ->
    {reply, State#state.limits, State};

handle_call(get_metrics, _From, State) ->
    {reply, {ok, State#state.metrics}, State};

handle_call(get_audit_log, _From, State) ->
    {reply, {ok, lists:reverse(State#state.audit_log)}, State};

handle_call(_Request, _From, State) ->
    {reply, {error, unknown_request}, State}.

handle_cast(_Msg, State) ->
    {noreply, State}.

handle_info({'DOWN', MonitorRef, process, _Pid, Reason}, State) ->
    %% Worker process terminated
    case find_worker_by_monitor(MonitorRef, State#state.active_workers) of
        {ok, ExecutionId, WorkerInfo} ->
            %% Determine result based on exit reason
            Result = case Reason of
                normal -> {ok, executed};
                timeout -> {error, timeout};
                {error, Error} -> {error, Error};
                _ -> {error, {execution_failed, Reason}}
            end,

            %% Update metrics
            NewMetrics = update_metrics(Reason, State#state.metrics),

            %% Create audit entry
            AuditEntry = #{
                execution_id => ExecutionId,
                tool_name => maps:get(tool_name, WorkerInfo, unknown),
                timestamp => erlang:system_time(millisecond),
                result => Result,
                exit_reason => Reason
            },
            NewLog = [AuditEntry | State#state.audit_log],

            %% Remove worker from active list
            NewWorkers = maps:remove(ExecutionId, State#state.active_workers),

            %% Reply to caller if still waiting
            Caller = maps:get(caller, WorkerInfo, undefined),
            case is_process_alive(element(1, Caller)) of
                true ->
                    gen_server:reply(Caller, Result);
                false ->
                    logger:warning("Caller ~p no longer alive for execution ~p",
                                   [Caller, ExecutionId])
            end,

        error ->
            logger:warning("Unknown worker DOWN message: ~p", [MonitorRef]),
            {noreply, State}
    end;

handle_info({execute_result, ExecutionId, Result}, State) ->
    %% Worker completed execution
    case maps:take(ExecutionId, State#state.active_workers) of
        {_WorkerInfo, NewWorkers} ->
            %% Update metrics
            NewMetrics = case Result of
                {ok, _} ->
                    maps:update_with(
                        successful_executions,
                        fun(X) -> X + 1 end,
                        1,
                        State#state.metrics
                    );
                {error, _} ->
                    maps:update_with(
                        failed_executions,
                        fun(X) -> X + 1 end,
                        1,
                        State#state.metrics
                    )
            end,

            %% Create audit entry
            AuditEntry = #{
                execution_id => ExecutionId,
                timestamp => erlang:system_time(millisecond),
                result => Result
            },
            NewLog = [AuditEntry | State#state.audit_log],

            {noreply, State#state{active_workers = NewWorkers, metrics = NewMetrics, audit_log = NewLog}
                active_workers => NewWorkers,
                metrics => NewMetrics,
                audit_log => NewLog
            }};
        error ->
            logger:warning("Unknown execution result for: ~p", [ExecutionId]),
            {noreply, State}
    end;

handle_info(_Info, State) ->
    {noreply, State}.

terminate(_Reason, #state{active_workers = Workers}) ->
    %% Terminate all active workers
    maps:foreach(fun(_ExecutionId, WorkerInfo) ->
        Pid = maps:get(pid, WorkerInfo),
        exit(Pid, kill),
        demonitor(maps:get(monitor, WorkerInfo), [flush])
    end, Workers),
    logger:info("Tool sandbox terminated, ~p workers cleaned up", [map_size(Workers)]),
    ok.

code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%% @private Get required permissions for a tool
get_required_permissions(ToolName) ->
    case ToolName of
        <<"read_file">> -> [?PERM_READ_FILE];
        <<"write_file">> -> [?PERM_WRITE_FILE];
        <<"network_request">> -> [?PERM_NETWORK_ACCESS];
        <<"execute_command">> -> [?PERM_EXECUTE_COMMAND];
        <<"read_env">> -> [?PERM_READ_ENV];
        <<"subprocess">> -> [?PERM_SUBPROCESS];
        _ -> []
    end.

%% @private Check if all required permissions are granted
check_permissions(Required, Granted) ->
    lists:all(fun(P) -> sets:is_element(P, Granted) end, Required).

%% @private Validate single permission
validate_permission(Perm) ->
    lists:member(Perm, [
        ?PERM_READ_FILE,
        ?PERM_WRITE_FILE,
        ?PERM_NETWORK_ACCESS,
        ?PERM_EXECUTE_COMMAND,
        ?PERM_READ_ENV,
        ?PERM_SUBPROCESS
    ]).

%% @private Validate list of permissions
validate_permissions(Perms) when is_list(Perms) ->
    lists:all(fun validate_permission/1, Perms);
validate_permissions(_) ->
    false.

%% @private Validate limits
validate_limits(Limits) when is_map(Limits) ->
    MaxCPU = maps:get(max_cpu_percent, Limits, 50),
    MaxMem = maps:get(max_memory_mb, Limits, 256),
    MaxTimeout = maps:get(max_timeout_sec, Limits, 30),
    MaxFileSize = maps:get(max_file_size_mb, Limits, 10),

    case {MaxCPU > 0 andalso MaxCPU =< 100,
          MaxMem > 0 andalso MaxMem =< 10240,
          MaxTimeout > 0 andalso MaxTimeout =< 300,
          MaxFileSize > 0 andalso MaxFileSize =< 1024} of
        {true, true, true, true} -> ok;
        _ -> {error, invalid_limits}
    end;
validate_limits(_) ->
    {error, invalid_limits}.

%% @private Merge limits with defaults
merge_limits(NewLimits) ->
    merge_limits(NewLimits, #{
        max_cpu_percent => 50,
        max_memory_mb => 256,
        max_timeout_sec => 30,
        max_file_size_mb => 10
    }).

merge_limits(NewLimits, CurrentLimits) ->
    maps:merge(CurrentLimits, NewLimits).

%% @private Generate unique execution ID
generate_execution_id() ->
    Bin = <<(erlang:unique_integer([positive]))>>,
    <<Bin/binary, (integer_to_binary(erlang:system_time(millisecond)))/binary>>.

%% @private Spawn isolated worker process
spawn_worker(Context, MaxMemory) ->
    Self = self(),
    spawn(fun() ->
        %% Enable memory guard for worker
        enable_worker_memory_guard(MaxMemory),

        %% Execute tool
        Result = do_execute_tool(Context),

        %% Send result back to sandbox
        Self ! {execute_result, Context#execution_context.execution_id, Result},

        %% Exit normally to signal completion
        exit(normal)
    end).

%% @private Enable memory guard for worker process
enable_worker_memory_guard(MaxMemoryMB) ->
    MaxMemoryWords = MaxMemoryMB * 1_000_000 div erlang:system_info(wordsize),
    MaxBinMemoryWords = MaxMemoryWords div 2,

    try
        erlang:process_flag(max_heap_size, MaxMemoryWords),
        erlang:process_flag(max_bin_vheap_size, MaxBinMemoryWords),
        logger:debug("Worker memory guard enabled: ~p MB", [MaxMemoryMB])
    catch
        error:badarg ->
            logger:warning("Memory guard not supported (requires OTP 28+)")
    end.

%% @private Execute tool with error handling (new version for spawned workers)
do_execute_tool(Context) ->
    #execution_context{
        tool_name = ToolName,
        arguments = Arguments
    } = Context,

    try
        %% Execute tool with proper error handling
        case ToolName of
            <<"read_file">> ->
                Path = maps_get(path, Arguments, <<>>),
                {ok, #{content => read_file_content(Path)}};
            <<"write_file">> ->
                Path = maps_get(path, Arguments, <<>>),
                Content = maps_get(content, Arguments, <<>>),
                {ok, #{written => write_file_content(Path, Content)}};
            <<"network_request">> ->
                Url = maps_get(url, Arguments, <<>>),
                {ok, #{status => network_get(Url)}};
            <<"execute_command">> ->
                Cmd = maps_get(command, Arguments, <<>>),
                {ok, #{output => execute_command(Cmd)}};
            <<"read_env">> ->
                Var = maps_get(variable, Arguments, <<>>),
                {ok, #{value => read_environment(Var)}};
            _ ->
                {error, {unknown_tool, ToolName}}
        end
    catch
        Type:Reason:Stacktrace ->
            logger:error("Tool execution error: ~p:~p~n~p", [Type, Reason, Stacktrace]),
            {error, {Type, Reason}}
    end.

%% @private Mock implementations for testing
read_file_content(_Path) -> <<>>.
write_file_content(_Path, _Content) -> true.
network_get(_Url) -> ok.
execute_command(_Cmd) -> <<>>.
read_environment(_Var) -> <<>>.

%% @private Update metrics based on exit reason
update_metrics(Reason, Metrics) ->
    Total = maps:get(total_executions, Metrics, 0) + 1,
    NewMetrics = maps:put(total_executions, Total, Metrics),

    case Reason of
        normal ->
            maps:update_with(successful_executions, fun(X) -> X + 1 end, 1, NewMetrics);
        timeout ->
            TimeoutCount = maps:get(timeout_count, NewMetrics, 0) + 1,
            maps:put(timeout_count, TimeoutCount, NewMetrics);
        {error, memory_limit_exceeded} ->
            MemCount = maps:get(memory_limit_exceeded, NewMetrics, 0) + 1,
            maps:put(memory_limit_exceeded, MemCount, NewMetrics);
        _ ->
            maps:update_with(failed_executions, fun(X) -> X + 1 end, 1, NewMetrics)
    end.

%% @private Find worker by monitor reference
find_worker_by_monitor(MonitorRef, Workers) ->
    Iter = maps:iterator(Workers),
    find_worker_by_monitor_iter(MonitorRef, Iter).

find_worker_by_monitor_iter(MonitorRef, Iter) ->
    case maps:next(Iter) of
        {ExecutionId, WorkerInfo, NextIter} ->
            case maps:get(monitor, WorkerInfo) of
                MonitorRef ->
                    {ok, ExecutionId, WorkerInfo};
                _ ->
                    find_worker_by_monitor_iter(MonitorRef, NextIter)
            end;
        none ->
            error
    end.

%% @private Safe maps:get with default
maps_get(Key, Map, Default) ->
    case maps:find(Key, Map) of
        {ok, Value} -> Value;
        error -> Default
    end.
