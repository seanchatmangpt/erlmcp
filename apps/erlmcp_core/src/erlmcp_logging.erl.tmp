%%%-------------------------------------------------------------------
%%% @doc
%%% Logging capability implementation for MCP protocol.
%%%
%%% This module implements the logging capability as specified in the
%%% MCP 2025-11-25 specification. It provides:
%%%
%%% - Per-client log buffers with configurable size limits
%%% - Dynamic log level configuration (debug, info, warning, error)
%%% - Structured JSON log entries with timestamps
%%% - Log filtering by level and component
%%% - Automatic cleanup on client disconnect
%%%
%%% @end
%%%-------------------------------------------------------------------
-module(erlmcp_logging).
-behaviour(gen_server).

%% API
-export([
    start_link/0,
    log/5,
    set_level/2,
    get_logs/2,
    create_client_buffer/1,
    delete_client_buffer/1,
    clear_client_buffer/1,
    get_stats/0
]).

%% gen_server callbacks
-export([
    init/1,
    handle_call/3,
    handle_cast/2,
    handle_info/2,
    terminate/2,
    code_change/3
]).

%% Type exports
-export_type([
    log_level/0,
    log_entry/0,
    log_options/0
]).

-include("erlmcp.hrl").

%% Constants
-define(MAX_LOGS_PER_CLIENT, 1000).
-define(LOG_LEVELS, [debug, info, notice, warning, error, critical, alert, emergency]).
-define(DEFAULT_LEVEL, info).

%% State record
-record(state, {
    client_buffers = #{} :: #{pid() => [log_entry()]},
    global_level = ?DEFAULT_LEVEL :: atom(),
    client_levels = #{} :: #{pid() => atom()},
    stats = #{
        total_logs => 0,
        total_clients => 0,
        buffer_overflows => 0
    }
}).

%% Type definitions
-type log_level() :: debug | info | notice | warning | error | critical | alert | emergency.
-type log_entry() :: map().
-type log_options() :: map().
-type state() :: #state{}.

%%%===================================================================
%%% API Functions
%%%===================================================================

%% @doc Start the logging server.
-spec start_link() -> {ok, pid()} | {error, term()}.
start_link() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).

%% @doc Log a message for a client.
%% This is the main logging API used by the server and other components.
-spec log(pid(), atom(), binary(), binary(), map() | undefined) -> ok.
log(ClientPid, Level, Component, Message, Data) ->
    gen_server:cast(?MODULE, {log, ClientPid, Level, Component, Message, Data}),
    ok.

%% @doc Set log level for a specific client.
%% Overrides the global level for this client.
-spec set_level(pid(), atom()) -> ok | {error, term()}.
set_level(ClientPid, Level) when is_atom(Level) ->
    case lists:member(Level, ?LOG_LEVELS) of
        true -> gen_server:call(?MODULE, {set_level, ClientPid, Level});
        false -> {error, {invalid_level, Level}}
    end.

%% @doc Get logs for a client with optional filtering.
%% Options can include:
%%   - level: Filter by minimum log level
%%   - component: Filter by component name
%%   - limit: Maximum number of logs to return
%%   - offset: Number of logs to skip
-spec get_logs(pid(), log_options()) -> {ok, [log_entry()]} | {error, term()}.
get_logs(ClientPid, Options) ->
    gen_server:call(?MODULE, {get_logs, ClientPid, Options}).

%% @doc Create a log buffer for a new client.
%% Called when a new client connects.
-spec create_client_buffer(pid()) -> ok.
create_client_buffer(ClientPid) ->
    gen_server:cast(?MODULE, {create_buffer, ClientPid}),
    ok.

%% @doc Delete a client's log buffer.
%% Called when a client disconnects.
-spec delete_client_buffer(pid()) -> ok.
delete_client_buffer(ClientPid) ->
    gen_server:cast(?MODULE, {delete_buffer, ClientPid}),
    ok.

%% @doc Clear all logs for a client.
%% Useful for testing or manual cleanup.
-spec clear_client_buffer(pid()) -> ok.
clear_client_buffer(ClientPid) ->
    gen_server:cast(?MODULE, {clear_buffer, ClientPid}),
    ok.

%% @doc Get logging statistics.
-spec get_stats() -> {ok, map()}.
get_stats() ->
    gen_server:call(?MODULE, get_stats).

%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

%% @private
-spec init([]) -> {ok, #state{}}.
init([]) ->
    logger:info("Starting MCP logging server"),
    {ok, #state{}}.

%% @private
-spec handle_call(term(), {pid(), term()}, #state{}) ->
    {reply, term(), #state{}}.
handle_call({set_level, ClientPid, Level}, _From, State) ->
    NewLevels = maps:put(ClientPid, Level, State#state.client_levels),
    {reply, ok, State#state{client_levels = NewLevels}};

handle_call({get_logs, ClientPid, Options}, _From, State) ->
    case maps:get(ClientPid, State#state.client_buffers, undefined) of
        undefined ->
            {reply, {error, no_buffer}, State};
        Logs ->
            FilteredLogs = filter_logs(Logs, Options),
            PaginatedLogs = paginate_logs(FilteredLogs, Options),
            {reply, {ok, PaginatedLogs}, State}
    end;

handle_call(get_stats, _From, State) ->
    #state{
        stats = Stats
    } = State,
    ClientCount = maps:size(State#state.client_buffers),
    StatsWithClients = Stats#{total_clients => ClientCount},
    {reply, {ok, StatsWithClients}, State};

handle_call(_Request, _From, State) ->
    {reply, {error, unknown_request}, State}.

%% @private
-spec handle_cast(term(), term()) -> {noreply, tuple()}.
handle_cast({log, ClientPid, Level, Component, Message, Data}, State) ->
    NewState = do_log(ClientPid, Level, Component, Message, Data, State),
    {noreply, NewState};

handle_cast({create_buffer, ClientPid}, State) ->
    Buffers = State#state.client_buffers,
    case maps:is_key(ClientPid, Buffers) of
        true ->
            logger:warning("Log buffer already exists for ~p", [ClientPid]),
            {noreply, State};
        false ->
            logger:info("Creating log buffer for client ~p", [ClientPid]),
            NewBuffers = maps:put(ClientPid, [], Buffers),
            {noreply, State#state{client_buffers = NewBuffers}}
    end;

handle_cast({delete_buffer, ClientPid}, #state{client_buffers = Buffers} = State) ->
    case maps:is_key(ClientPid, Buffers) of
        true ->
            logger:info("Deleting log buffer for client ~p", [ClientPid]),
            NewBuffers = maps:remove(ClientPid, Buffers),
            NewLevels = maps:remove(ClientPid, State#state.client_levels),
            {noreply, State#state{
                client_buffers = NewBuffers,
                client_levels = NewLevels
            }};
        false ->
            {noreply, State}
    end;

handle_cast({clear_buffer, ClientPid}, State) ->
    Buffers = State#state.client_buffers,
    case maps:is_key(ClientPid, Buffers) of
        true ->
            NewBuffers = maps:put(ClientPid, [], Buffers),
            {noreply, State#state{client_buffers = NewBuffers}};
        false ->
            {noreply, State}
    end;

handle_cast(_Msg, State) ->
    {noreply, State}.

%% @private
-spec handle_info(term(), term()) -> {noreply, tuple()}.
handle_info(_Info, State) ->
    {noreply, State}.

%% @private
-spec terminate(term(), term()) -> ok.
terminate(_Reason, #state{client_buffers = Buffers}) ->
    logger:info("MCP logging server terminating (~p clients)", [maps:size(Buffers)]),
    ok.

%% @private
-spec code_change(term(), term(), tuple()) -> {ok, tuple()}.
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%% @doc Internal log implementation with level checking.
-spec do_log(pid(), atom(), binary(), binary(), map() | undefined, tuple()) -> tuple().
do_log(ClientPid, Level, Component, Message, Data, State) ->
    case should_log(Level, ClientPid, State) of
        true ->
            Entry = #{
                <<"timestamp">> => erlang:system_time(millisecond),
                <<"level">> => atom_to_binary(Level, utf8),
                <<"component">> => Component,
                <<"message">> => Message,
                <<"data">> => Data
            },
            Buffers = State#state.client_buffers,
            ClientLogs = maps:get(ClientPid, Buffers, []),
            {NewClientLogs, Overflow} = append_log(Entry, ClientLogs),
            NewBuffers = maps:put(ClientPid, NewClientLogs, Buffers),
            NewStats = case Overflow of
                true ->
                    increment_stat(State#state.stats, buffer_overflows);
                false ->
                    increment_stat(State#state.stats, total_logs)
            end,
            State#state{client_buffers = NewBuffers, stats = NewStats};
        false ->
            State
    end.

%% @doc Check if a log entry should be recorded based on level.
-spec should_log(atom(), pid(), tuple()) -> boolean().
should_log(Level, ClientPid, #state{global_level = GlobalLevel, client_levels = ClientLevels}) ->
    EffectiveLevel = case maps:get(ClientPid, ClientLevels, undefined) of
        undefined -> GlobalLevel;
        ClientLevel -> ClientLevel
    end,
    level_compare(Level, EffectiveLevel) =< 0.

%% @doc Compare log levels (lower = more severe).
%% Returns negative if Level1 is more severe than Level2.
-spec level_compare(atom(), atom()) -> integer().
level_compare(Level1, Level2) ->
    LevelOrder = [
        emergency,  % 0 - most severe
        alert,      % 1
        critical,   % 2
        error,      % 3
        warning,    % 4
        notice,     % 5
        info,       % 6
        debug       % 7 - least severe
    ],
    Index1 = index_of(Level1, LevelOrder),
    Index2 = index_of(Level2, LevelOrder),
    Index1 - Index2.

%% @doc Get index of element in list.
-spec index_of(tuple(), [tuple()]) -> non_neg_integer().
index_of(Element, List) ->
    index_of(Element, List, 0).
index_of(_Element, [], _Index) ->
    0;
index_of(Element, [Element | _], Index) ->
    Index;
index_of(Element, [_ | Rest], Index) ->
    index_of(Element, Rest, Index + 1).

%% @doc Append log entry to buffer, enforcing size limit.
-spec append_log(log_entry(), [log_entry()]) -> {[log_entry()], boolean()}.
append_log(Entry, Logs) when length(Logs) >= ?MAX_LOGS_PER_CLIENT ->
    {[Entry | lists:sublist(Logs, ?MAX_LOGS_PER_CLIENT - 1)], true};
append_log(Entry, Logs) ->
    {[Entry | Logs], false}.

%% @doc Filter logs based on options.
-spec filter_logs([log_entry()], log_options()) -> [log_entry()].
filter_logs(Logs, Options) ->
    MinLevel = maps:get(level, Options, ?DEFAULT_LEVEL),
    Component = maps:get(component, Options, undefined),

    Filtered = lists:filter(fun(Entry) ->
        LevelBin = maps:get(<<"level">>, Entry),
        Level = binary_to_existing_atom(LevelBin, utf8),

        LevelCheck = level_compare(Level, MinLevel) =< 0,

        ComponentCheck = case Component of
            undefined -> true;
            _ -> maps:get(<<"component">>, Entry) =:= Component
        end,

        LevelCheck andalso ComponentCheck
    end, Logs),

    lists:reverse(Filtered).

%% @doc Paginate logs based on options.
-spec paginate_logs([log_entry()], log_options()) -> [log_entry()].
paginate_logs(Logs, Options) ->
    Offset = maps:get(offset, Options, 0),
    Limit = maps:get(limit, Options, all),

    Start = min(Offset + 1, length(Logs) + 1),

    case Limit of
        all ->
            lists:sublist(Logs, Start, length(Logs) - Offset);
        _ when is_integer(Limit) ->
            lists:sublist(Logs, Start, min(Limit, length(Logs) - Offset + 1))
    end.

%% @doc Increment a counter in the stats map.
-spec increment_stat(map(), atom()) -> map().
increment_stat(Stats, Key) ->
    Current = maps:get(Key, Stats, 0),
    maps:put(Key, Current + 1, Stats).
