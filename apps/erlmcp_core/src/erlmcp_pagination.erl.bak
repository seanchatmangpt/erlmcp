%%%-------------------------------------------------------------------
%%% @doc
%%% Pagination support for list operations.
%%% Implements cursor-based pagination with page size limits.
%%% @end
%%%-------------------------------------------------------------------
-module(erlmcp_pagination).
-behaviour(gen_server).

%% API
-export([
    start_link/0,
    paginate/4,
    encode_cursor/1,
    decode_cursor/1,
    calculate_has_more/3,
    validate_page_size/1,
    get_default_page_size/0,
    get_max_page_size/0,
    set_page_size_limits/2
]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2,
         terminate/2, code_change/3]).

%% Type definitions
-record(cursor, {
    offset = 0 :: non_neg_integer(),
    timestamp :: integer()
}).

-record(state, {
    default_page_size = 50 :: pos_integer(),
    max_page_size = 1000 :: pos_integer()
}).

-type state() :: #state{}.
-type cursor() :: #cursor{}.
%% Page info map with keys:
%%   - <<"cursor">> => binary() | null
%%   - <<"hasMore">> => boolean()
%%   - <<"total">> => integer() | undefined
-type page_info() :: #{
    <<"cursor">> => binary() | null,
    <<"hasMore">> => boolean(),
    <<"total">> => integer() | undefined
}.
-type config() :: #{
    default_page_size => pos_integer(),
    max_page_size => pos_integer()
}.

-export_type([cursor/0, page_info/0, config/0]).

%%%===================================================================
%%% API
%%%===================================================================

%% @doc Start the pagination configuration server.
-spec start_link() -> {ok, pid()} | {error, term()}.
start_link() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).

%% @doc Paginate a list of items with cursor-based pagination.
%%
%% Parameters:
%%   - Items: Full list of items to paginate
%%   - PageSize: Number of items per page (bounded by max_page_size)
%%   - CursorBin: Base64-encoded cursor from previous page (or null for first page)
%%   - TotalCount: Total count of items (undefined if unknown)
%%
%% Returns:
%%   - {PageItems, PageInfo}: Page items and pagination metadata
-spec paginate([term()], pos_integer() | undefined, binary() | null, integer() | undefined) ->
    {[term()], page_info()}.
paginate(Items, PageSize, CursorBin, TotalCount) ->
    %% Get configuration
    DefaultPageSize = get_default_page_size(),
    MaxPageSize = get_max_page_size(),

    %% Validate and bound page size
    ValidPageSize = validate_and_bound_page_size(PageSize, DefaultPageSize, MaxPageSize),

    %% Decode cursor
    Cursor = decode_cursor(CursorBin),

    %% Get items for this page
    TotalItems = length(Items),
    StartOffset = Cursor#cursor.offset,
    EndOffset = min(StartOffset + ValidPageSize, TotalItems),

    PageItems = case StartOffset < TotalItems of
        true -> lists:sublist(Items, StartOffset + 1, EndOffset - StartOffset);
        false -> []
    end,

    %% Calculate next cursor
    NextCursor = if
        EndOffset >= TotalItems -> null;
        true -> encode_cursor(#cursor{
            offset = EndOffset,
            timestamp = erlang:system_time(millisecond)
        })
    end,

    %% Calculate hasMore flag
    HasMore = EndOffset < TotalItems,

    %% Build page info
    PageInfo = #{
        <<"cursor">> => NextCursor,
        <<"hasMore">> => HasMore,
        <<"total">> => case TotalCount of
            undefined -> undefined;
            _ -> TotalCount
        end
    },

    {PageItems, PageInfo}.

%% @doc Encode cursor to base64 string.
-spec encode_cursor(cursor()) -> binary().
encode_cursor(#cursor{offset = Offset, timestamp = Timestamp}) ->
    Term = {Offset, Timestamp},
    Binary = term_to_binary(Term, [compressed]),
    base64:encode(Binary).

%% @doc Decode cursor from base64 string.
-spec decode_cursor(binary() | null) -> cursor().
decode_cursor(null) ->
    #cursor{offset = 0, timestamp = 0};
decode_cursor(CursorBin) when is_binary(CursorBin) ->
    try
        Binary = base64:decode(CursorBin),
        {Offset, Timestamp} = binary_to_term(Binary, [safe]),
        #cursor{offset = Offset, timestamp = Timestamp}
    catch
        _:_ ->
            %% Invalid cursor, start from beginning
            #cursor{offset = 0, timestamp = 0}
    end.

%% @doc Calculate if more pages available.
-spec calculate_has_more(non_neg_integer(), pos_integer(), integer() | undefined) ->
    boolean() | undefined.
calculate_has_more(_Offset, _PageSize, undefined) ->
    undefined;
calculate_has_more(Offset, PageSize, Total) when is_integer(Total) ->
    (Offset + PageSize) < Total.

%% @doc Validate page size parameter.
-spec validate_page_size(term()) -> boolean().
validate_page_size(PageSize) when is_integer(PageSize), PageSize > 0 ->
    MaxPageSize = get_max_page_size(),
    PageSize =< MaxPageSize;
validate_page_size(_) ->
    false.

%% @doc Get default page size from configuration.
-spec get_default_page_size() -> pos_integer().
get_default_page_size() ->
    case gen_server:call(?MODULE, get_default_page_size) of
        {ok, PageSize} -> PageSize;
        _ -> 50
    end.

%% @doc Get maximum page size from configuration.
-spec get_max_page_size() -> pos_integer().
get_max_page_size() ->
    case gen_server:call(?MODULE, get_max_page_size) of
        {ok, PageSize} -> PageSize;
        _ -> 1000
    end.

%% @doc Set page size limits.
-spec set_page_size_limits(pos_integer(), pos_integer()) -> ok | {error, term()}.
set_page_size_limits(Default, Max) when is_integer(Default), Default > 0,
                                         is_integer(Max), Max >= Default ->
    gen_server:call(?MODULE, {set_limits, Default, Max});
set_page_size_limits(_Default, _Max) ->
    {error, invalid_limits}.

%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

%% @private
-spec init([]) -> {ok, state()}.
init([]) ->
    %% Load configuration from application environment
    DefaultPageSize = application:get_env(erlmcp, default_page_size, 50),
    MaxPageSize = application:get_env(erlmcp, max_page_size, 1000),

    State = #state{
        default_page_size = DefaultPageSize,
        max_page_size = MaxPageSize
    },

    logger:info("Pagination module initialized: default=~p, max=~p",
                [DefaultPageSize, MaxPageSize]),

    {ok, State}.

%% @private
-spec handle_call(term(), {pid(), term()}, state()) ->
    {reply, term(), state()}.
handle_call(get_default_page_size, _From, State) ->
    {reply, {ok, State#state.default_page_size}, State};

handle_call(get_max_page_size, _From, State) ->
    {reply, {ok, State#state.max_page_size}, State};

handle_call({set_limits, Default, Max}, _From, State) ->
    NewState = State#state{
        default_page_size = Default,
        max_page_size = Max
    },
    logger:info("Pagination limits updated: default=~p, max=~p", [Default, Max]),
    {reply, ok, NewState};

handle_call(_Request, _From, State) ->
    {reply, {error, unknown_request}, State}.

%% @private
-spec handle_cast(term(), state()) -> {noreply, state()}.
handle_cast(_Msg, State) ->
    {noreply, State}.

%% @private
-spec handle_info(term(), state()) -> {noreply, state()}.
handle_info(_Info, State) ->
    {noreply, State}.

%% @private
-spec terminate(term(), state()) -> ok.
terminate(_Reason, _State) ->
    ok.

%% @private
-spec code_change(term(), state(), term()) -> {ok, state()}.
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%% @doc Validate and bound page size to configured limits.
-spec validate_and_bound_page_size(term(), pos_integer(), pos_integer()) -> pos_integer().
validate_and_bound_page_size(PageSize, Default, Max) when is_integer(PageSize), PageSize > 0 ->
    min(PageSize, Max);
validate_and_bound_page_size(_, Default, _Max) ->
    Default.
