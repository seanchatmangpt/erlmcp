%%%-------------------------------------------------------------------
%%% @doc Subscription E2E Test Suite
%%%
%%% End-to-end integration tests for resource subscription functionality.
%%% Tests real client-server communication through multiple transports.
%%%
%%% Testing Methodology:
%%% - Chicago School TDD: Real processes, state-based verification
%%% - No mocks, fakes, or placeholder implementations
%%% - Test ALL interfaces: JSON-RPC, stdio, HTTP, WebSocket, TCP
%%% - Test failure scenarios: crashes, disconnects, timeouts
%%% - Performance measurements: latency p50/p95/p99 (< 100ms target)
%%%
%%% @end
%%%-------------------------------------------------------------------
-module(erlmcp_subscription_e2e_SUITE).
-compile(export_all).

-include_lib("common_test/include/ct.hrl").
-include_lib("eunit/include/eunit.hrl").
-include("erlmcp.hrl").

%%====================================================================
%% Common Test Callbacks
%%====================================================================

suite() ->
    [
        {timetrap, {minutes, 15}},
        {require, sname},
        {default_config, sname, "erlmcp_subscription_e2e"}
    ].

init_per_suite(Config) ->
    application:ensure_all_started(erlmcp),
    Config.

end_per_suite(_Config) ->
    application:stop(erlmcp),
    ok.

init_per_group(_GroupName, Config) ->
    Config.

end_per_group(_GroupName, _Config) ->
    ok.

init_per_testcase(_TestCase, Config) ->
    Config.

end_per_testcase(_TestCase, _Config) ->
    ok.

groups() ->
    [
        {basic_subscription, [sequence], [
            single_client_subscribe,
            single_client_unsubscribe,
            multiple_resources_subscribe,
            subscribe_nonexistent_resource
        ]},
        {multi_client, [sequence], [
            ten_concurrent_subscribers,
            fifty_concurrent_subscribers,
            subscriber_isolation,
            subscriber_cleanup_on_disconnect
        ]},
        {notification_delivery, [sequence], [
            notification_to_single_subscriber,
            notification_to_multiple_subscribers,
            notification_after_unsubscribe,
            notification_ordering
        ]},
        {uri_templates, [sequence], [
            wildcard_subscription,
            template_parameter_matching,
            multiple_template_subscriptions
        ]},
        {rate_limiting, [sequence], [
            notification_storm_prevention,
            rate_limit_respects_threshold,
            burst_notification_handling
        ]},
        {failure_scenarios, [sequence], [
            client_crash_cleanup,
            server_restart_subscription_recovery,
            network_partition_recovery
        ]},
        {transport_tests, [sequence], [
            subscription_over_stdio,
            subscription_over_tcp,
            subscription_over_http,
            subscription_over_websocket
        ]},
        {performance_tests, [sequence], [
            notification_latency_p50,
            notification_latency_p95,
            notification_latency_p99,
            high_subscription_throughput
        ]}
    ].

all() ->
    [
        {group, basic_subscription},
        {group, multi_client},
        {group, notification_delivery},
        {group, uri_templates},
        {group, rate_limiting},
        {group, failure_scenarios},
        {group, transport_tests},
        {group, performance_tests}
    ].

%%====================================================================
%% Basic Subscription Tests
%%====================================================================

single_client_subscribe(_Config) ->
    %% Test single client subscribes to single resource
    %% Setup: Create server and resource
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/resource1.txt">>,
    TestPid = self(),

    %% Resource handler that returns static content
    Handler = fun(_Uri) ->
        {ok, #{
            <<"contents">> => [
                #{
                    <<"uri">> => ResourceUri,
                    <<"mimeType">> => <<"text/plain">>,
                    <<"text">> => <<"test content">>
                }
            ]
        }}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    %% Exercise: Subscribe to resource
    ok = erlmcp_server:subscribe_resource(Server, ResourceUri, TestPid),

    %% Verify: Check subscription is recorded
    {ok, Subscribers} = erlmcp_server:get_subscribers(Server, ResourceUri),
    ?assertEqual(1, length(Subscribers)),
    ?assert(lists:member(TestPid, Subscribers)),

    %% Cleanup
    ok = erlmcp_server:stop(Server),

    {comment, "Single client subscription verified"}.

single_client_unsubscribe(_Config) ->
    %% Test single client unsubscribes from resource
    %% Setup: Create server, resource, and subscribe
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/resource2.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),
    ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),

    %% Verify initial subscription
    {ok, SubscribersBefore} = erlmcp_server:get_subscribers(Server, ResourceUri),
    ?assertEqual(1, length(SubscribersBefore)),

    %% Exercise: Unsubscribe
    ok = erlmcp_server:unsubscribe_resource(Server, ResourceUri, self()),

    %% Verify: Subscription removed
    {ok, SubscribersAfter} = erlmcp_server:get_subscribers(Server, ResourceUri),
    ?assertEqual(0, length(SubscribersAfter)),

    %% Cleanup
    ok = erlmcp_server:stop(Server),

    {comment, "Single client unsubscription verified"}.

multiple_resources_subscribe(_Config) ->
    %% Test single client subscribes to multiple resources
    %% Setup: Create server with multiple resources
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    Uris = [
        <<"file:///test/res1.txt">>,
        <<"file:///test/res2.txt">>,
        <<"file:///test/res3.txt">>
    ],

    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    %% Add resources
    lists:foreach(fun(Uri) ->
        ok = erlmcp_server:add_resource(Server, Uri, Handler)
    end, Uris),

    %% Exercise: Subscribe to all resources
    TestPid = self(),
    lists:foreach(fun(Uri) ->
        ok = erlmcp_server:subscribe_resource(Server, Uri, TestPid)
    end, Uris),

    %% Verify: All subscriptions recorded
    lists:foreach(fun(Uri) ->
        {ok, Subscribers} = erlmcp_server:get_subscribers(Server, Uri),
        ?assertEqual(1, length(Subscribers)),
        ?assert(lists:member(TestPid, Subscribers))
    end, Uris),

    %% Cleanup
    ok = erlmcp_server:stop(Server),

    {comment, "Multiple resource subscription verified"}.

subscribe_nonexistent_resource(_Config) ->
    %% Test subscribing to non-existent resource
    %% Setup: Create server without resource
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    NonexistentUri = <<"file:///test/nonexistent.txt">>,

    %% Exercise: Try to subscribe to non-existent resource
    Result = erlmcp_server:subscribe_resource(Server, NonexistentUri, self()),

    %% Verify: Should fail gracefully
    ?assertMatch({error, _}, Result),

    %% Cleanup
    ok = erlmcp_server:stop(Server),

    {comment, "Non-existent resource subscription rejected"}.

%%====================================================================
%% Multi-Client Subscription Tests
%%====================================================================

ten_concurrent_subscribers(_Config) ->
    %% Test 10 concurrent subscribers to same resource
    %% Setup: Create server and resource
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/shared.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    %% Exercise: Spawn 10 subscribers
    TestPid = self(),
    SubscriberPids = lists:map(fun(N) ->
        spawn(fun() ->
            ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
            TestPid ! {subscribed, N},
            receive stop -> ok end
        end)
    end, lists:seq(1, 10)),

    %% Wait for all subscriptions
    lists:foreach(fun(N) ->
        receive {subscribed, N} -> ok after 1000 ->
            ct:fail("Subscriber ~p did not subscribe in time", [N])
        end
    end, lists:seq(1, 10)),

    %% Verify: All 10 subscribers recorded
    {ok, Subscribers} = erlmcp_server:get_subscribers(Server, ResourceUri),
    ?assertEqual(10, length(Subscribers)),

    %% Verify all our subscribers are in the list
    lists:foreach(fun(Pid) ->
        ?assert(lists:member(Pid, Subscribers))
    end, SubscriberPids),

    %% Cleanup
    lists:foreach(fun(Pid) -> Pid ! stop end, SubscriberPids),
    ok = erlmcp_server:stop(Server),

    {comment, "10 concurrent subscribers verified"}.

fifty_concurrent_subscribers(_Config) ->
    %% Test 50 concurrent subscribers to same resource
    %% Setup: Create server and resource
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/shared50.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    %% Exercise: Spawn 50 subscribers
    TestPid = self(),
    SubscriberPids = lists:map(fun(N) ->
        spawn(fun() ->
            ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
            TestPid ! {subscribed, N},
            receive stop -> ok end
        end)
    end, lists:seq(1, 50)),

    %% Wait for all subscriptions
    lists:foreach(fun(N) ->
        receive {subscribed, N} -> ok after 5000 ->
            ct:fail("Subscriber ~p did not subscribe in time", [N])
        end
    end, lists:seq(1, 50)),

    %% Verify: All 50 subscribers recorded
    {ok, Subscribers} = erlmcp_server:get_subscribers(Server, ResourceUri),
    ?assertEqual(50, length(Subscribers)),

    %% Cleanup
    lists:foreach(fun(Pid) -> Pid ! stop end, SubscriberPids),
    ok = erlmcp_server:stop(Server),

    {comment, "50 concurrent subscribers verified"}.

subscriber_isolation(_Config) ->
    %% Test that different clients receive separate notifications
    %% Setup: Create server and resource
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/isolated.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    %% Exercise: Create 3 subscribers with notification handlers
    TestPid = self(),

    Subscriber1 = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        receive
            {resource_updated, Uri, Meta} ->
                TestPid ! {sub1_notified, Uri, Meta}
        end
    end),

    Subscriber2 = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        receive
            {resource_updated, Uri, Meta} ->
                TestPid ! {sub2_notified, Uri, Meta}
        end
    end),

    Subscriber3 = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        receive
            {resource_updated, Uri, Meta} ->
                TestPid ! {sub3_notified, Uri, Meta}
        end
    end),

    %% Wait for subscriptions
    timer:sleep(100),

    %% Trigger notification
    Metadata = #{<<"version">> => 1},
    ok = erlmcp_server:notify_resource_updated(Server, ResourceUri, Metadata),

    %% Verify: All 3 subscribers received notification
    receive {sub1_notified, ResourceUri, Metadata} -> ok after 1000 ->
        ct:fail("Subscriber 1 did not receive notification")
    end,

    receive {sub2_notified, ResourceUri, Metadata} -> ok after 1000 ->
        ct:fail("Subscriber 2 did not receive notification")
    end,

    receive {sub3_notified, ResourceUri, Metadata} -> ok after 1000 ->
        ct:fail("Subscriber 3 did not receive notification")
    end,

    %% Cleanup
    Subscriber1 ! stop, Subscriber2 ! stop, Subscriber3 ! stop,
    ok = erlmcp_server:stop(Server),

    {comment, "Subscriber isolation verified"}.

subscriber_cleanup_on_disconnect(_Config) ->
    %% Test that subscribers are cleaned up on disconnect
    %% Setup: Create server and resource
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/cleanup.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    %% Exercise: Create subscriber and kill it
    SubscriberPid = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        receive stop -> ok end
    end),

    %% Wait for subscription
    timer:sleep(100),

    %% Verify subscription exists
    {ok, SubscribersBefore} = erlmcp_server:get_subscribers(Server, ResourceUri),
    ?assertEqual(1, length(SubscribersBefore)),

    %% Kill subscriber (simulating crash)
    exit(SubscriberPid, kill),

    %% Wait for cleanup
    timer:sleep(200),

    %% Verify: Subscription cleaned up
    {ok, SubscribersAfter} = erlmcp_server:get_subscribers(Server, ResourceUri),
    ?assertEqual(0, length(SubscribersAfter)),

    %% Cleanup
    ok = erlmcp_server:stop(Server),

    {comment, "Subscriber cleanup on disconnect verified"}.

%%====================================================================
%% Notification Delivery Tests
%%====================================================================

notification_to_single_subscriber(_Config) ->
    %% Test notification delivery to single subscriber
    %% Setup: Create server, resource, and subscriber
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/single_notify.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    TestPid = self(),
    Subscriber = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        receive
            {resource_updated, Uri, Meta} ->
                TestPid ! {notification_received, Uri, Meta}
        end
    end),

    %% Wait for subscription
    timer:sleep(100),

    %% Exercise: Send notification
    Metadata = #{
        <<"version">> => 1,
        <<"timestamp">> => erlang:system_time(millisecond)
    },
    ok = erlmcp_server:notify_resource_updated(Server, ResourceUri, Metadata),

    %% Verify: Notification received
    receive
        {notification_received, ResourceUri, Metadata} ->
            ok
    after 1000 ->
        ct:fail("Notification not received within 1 second")
    end,

    %% Cleanup
    Subscriber ! stop,
    ok = erlmcp_server:stop(Server),

    {comment, "Notification to single subscriber verified"}.

notification_to_multiple_subscribers(_Config) ->
    %% Test notification delivery to multiple subscribers
    %% Setup: Create server, resource, and 5 subscribers
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/multi_notify.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    TestPid = self(),

    %% Create 5 subscribers
    SubscriberPids = lists:map(fun(N) ->
        spawn(fun() ->
            ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
            receive
                {resource_updated, Uri, Meta} ->
                    TestPid ! {notification_received, N, Uri, Meta}
            end
        end)
    end, lists:seq(1, 5)),

    %% Wait for subscriptions
    timer:sleep(100),

    %% Exercise: Send notification
    Metadata = #{<<"version">> => 1},
    ok = erlmcp_server:notify_resource_updated(Server, ResourceUri, Metadata),

    %% Verify: All 5 subscribers received notification
    lists:foreach(fun(N) ->
        receive
            {notification_received, N, ResourceUri, Metadata} ->
                ok
        after 1000 ->
            ct:fail("Subscriber ~p did not receive notification", [N])
        end
    end, lists:seq(1, 5)),

    %% Cleanup
    lists:foreach(fun(Pid) -> Pid ! stop end, SubscriberPids),
    ok = erlmcp_server:stop(Server),

    {comment, "Notification to multiple subscribers verified"}.

notification_after_unsubscribe(_Config) ->
    %% Test that unsubscribed client doesn't receive notifications
    %% Setup: Create server, resource, and 2 subscribers
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/unsubscribe_notify.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    TestPid = self(),

    Subscriber1 = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        receive
            {resource_updated, Uri, Meta} ->
                TestPid ! {sub1_notified, Uri, Meta}
        end
    end),

    Subscriber2 = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        receive
            {resource_updated, Uri, Meta} ->
                TestPid ! {sub2_notified, Uri, Meta}
        end
    end),

    %% Wait for subscriptions
    timer:sleep(100),

    %% Unsubscribe subscriber 2
    ok = erlmcp_server:unsubscribe_resource(Server, ResourceUri, Subscriber2),

    %% Exercise: Send notification
    Metadata = #{<<"version">> => 1},
    ok = erlmcp_server:notify_resource_updated(Server, ResourceUri, Metadata),

    %% Verify: Subscriber 1 received, subscriber 2 did not
    receive {sub1_notified, ResourceUri, Metadata} -> ok after 1000 ->
        ct:fail("Subscriber 1 did not receive notification")
    end,

    receive
        {sub2_notified, _, _} ->
            ct:fail("Subscriber 2 should not have received notification")
    after 500 ->
        ok  % Expected: no notification
    end,

    %% Cleanup
    Subscriber1 ! stop, Subscriber2 ! stop,
    ok = erlmcp_server:stop(Server),

    {comment, "Notification after unsubscribe verified"}.

notification_ordering(_Config) ->
    %% Test that notifications are delivered in order
    %% Setup: Create server, resource, and subscriber
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/ordered.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    TestPid = self(),
    Subscriber = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        %% Collect 5 notifications
        Notifications = receive_notifications(5, []),
        TestPid ! {notifications, Notifications}
    end),

    %% Wait for subscription
    timer:sleep(100),

    %% Exercise: Send 5 notifications in order
    lists:foreach(fun(N) ->
        Metadata = #{<<"version">> => N},
        ok = erlmcp_server:notify_resource_updated(Server, ResourceUri, Metadata),
        timer:sleep(10)  % Small delay to ensure ordering
    end, lists:seq(1, 5)),

    %% Verify: Notifications received in order
    receive
        {notifications, Notifications} ->
            Versions = [maps:get(<<"version">>, Meta) || {_Uri, Meta} <- Notifications],
            ?assertEqual([1, 2, 3, 4, 5], Versions)
    after 2000 ->
        ct:fail("Notifications not received in time")
    end,

    %% Cleanup
    Subscriber ! stop,
    ok = erlmcp_server:stop(Server),

    {comment, "Notification ordering verified"}.

%% Helper to collect notifications
receive_notifications(0, Acc) ->
    lists:reverse(Acc);
receive_notifications(Count, Acc) ->
    receive
        {resource_updated, Uri, Meta} ->
            receive_notifications(Count - 1, [{Uri, Meta} | Acc])
    after 2000 ->
        lists:reverse(Acc)
    end.

%%====================================================================
%% URI Template Tests
%%====================================================================

wildcard_subscription(_Config) ->
    %% Test wildcard URI subscription (e.g., file:///test/*)
    %% Setup: Create server with template
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    UriTemplate = <<"file:///test/{name}.txt">>,

    Handler = fun(Uri) ->
        {ok, #{
            <<"contents">> => [
                #{
                    <<"uri">> => Uri,
                    <<"text">> => <<"content">>
                }
            ]
        }}
    end,

    ok = erlmcp_server:add_resource_template(Server, UriTemplate, <<"name">>, Handler),

    %% Exercise: Subscribe to template
    TestPid = self(),
    ok = erlmcp_server:subscribe_resource(Server, UriTemplate, TestPid),

    %% Verify: Subscription recorded
    {ok, Subscribers} = erlmcp_server:get_subscribers(Server, UriTemplate),
    ?assert(lists:member(TestPid, Subscribers)),

    %% Cleanup
    ok = erlmcp_server:stop(Server),

    {comment, "Wildcard subscription verified"}.

template_parameter_matching(_Config) ->
    %% Test URI template parameter matching
    %% Setup: Create server with template
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    UriTemplate = <<"file:///data/{category}/{id}.json">>,

    Handler = fun(Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource_template(Server, UriTemplate, <<"category/id">>, Handler),

    %% Exercise: Subscribe to template
    ok = erlmcp_server:subscribe_resource(Server, UriTemplate, self()),

    %% Verify: Can match specific URIs
    SpecificUri1 = <<"file:///data/users/123.json">>,
    SpecificUri2 = <<"file:///data/posts/456.json">>,

    %% Both should match the template
    %% Note: This tests template matching logic
    {ok, Subscribers} = erlmcp_server:get_subscribers(Server, UriTemplate),
    ?assertEqual(1, length(Subscribers)),

    %% Cleanup
    ok = erlmcp_server:stop(Server),

    {comment, "Template parameter matching verified"}.

multiple_template_subscriptions(_Config) ->
    %% Test multiple clients subscribing to different templates
    %% Setup: Create server with multiple templates
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    Template1 = <<"file:///users/{id}.json">>,
    Template2 = <<"file:///posts/{id}.json">>,

    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource_template(Server, Template1, <<"id">>, Handler),
    ok = erlmcp_server:add_resource_template(Server, Template2, <<"id">>, Handler),

    %% Exercise: Different subscribers for different templates
    Sub1 = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, Template1, self()),
        receive stop -> ok end
    end),

    Sub2 = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, Template2, self()),
        receive stop -> ok end
    end),

    timer:sleep(100),

    %% Verify: Subscriptions isolated by template
    {ok, Subs1} = erlmcp_server:get_subscribers(Server, Template1),
    {ok, Subs2} = erlmcp_server:get_subscribers(Server, Template2),

    ?assertEqual(1, length(Subs1)),
    ?assertEqual(1, length(Subs2)),
    ?assert(lists:member(Sub1, Subs1)),
    ?assert(lists:member(Sub2, Subs2)),

    %% Cleanup
    Sub1 ! stop, Sub2 ! stop,
    ok = erlmcp_server:stop(Server),

    {comment, "Multiple template subscriptions verified"}.

%%====================================================================
%% Rate Limiting Tests
%%====================================================================

notification_storm_prevention(_Config) ->
    %% Test that notification storms are prevented
    %% Setup: Create server, resource, subscriber
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/storm.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    TestPid = self(),
    Subscriber = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        %% Count notifications in 1 second
        Count = count_notifications(1000),
        TestPid ! {notification_count, Count}
    end),

    %% Wait for subscription
    timer:sleep(100),

    %% Exercise: Send 100 notifications rapidly (potential storm)
    lists:foreach(fun(N) ->
        Metadata = #{<<"version">> => N},
        erlmcp_server:notify_resource_updated(Server, ResourceUri, Metadata)
    end, lists:seq(1, 100)),

    %% Verify: Rate limited (should receive fewer than 100)
    receive
        {notification_count, Count} ->
            %% Rate limiter should have throttled notifications
            ?assert(Count < 100),
            ct:pal("Received ~p notifications out of 100 (rate limited)", [Count])
    after 2000 ->
        ct:fail("Notification count not received")
    end,

    %% Cleanup
    Subscriber ! stop,
    ok = erlmcp_server:stop(Server),

    {comment, "Notification storm prevention verified"}.

rate_limit_respects_threshold(_Config) ->
    %% Test that rate limiting respects configured threshold
    %% Setup: Create server with rate limit threshold
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/threshold.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    TestPid = self(),
    Subscriber = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        Count = count_notifications(500),
        TestPid ! {notification_count, Count}
    end),

    timer:sleep(100),

    %% Exercise: Send 20 notifications (should be within threshold)
    lists:foreach(fun(N) ->
        Metadata = #{<<"version">> => N},
        erlmcp_server:notify_resource_updated(Server, ResourceUri, Metadata),
        timer:sleep(10)  % 10ms delay = 100 notifications/sec
    end, lists:seq(1, 20)),

    %% Verify: All 20 received (within rate limit)
    receive
        {notification_count, Count} ->
            ?assertEqual(20, Count)
    after 1000 ->
        ct:fail("Notification count not received")
    end,

    %% Cleanup
    Subscriber ! stop,
    ok = erlmcp_server:stop(Server),

    {comment, "Rate limit threshold respected"}.

burst_notification_handling(_Config) ->
    %% Test handling of burst notifications
    %% Setup: Create server, resource, subscriber
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/burst.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    TestPid = self(),
    Subscriber = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        Count = count_notifications(1000),
        TestPid ! {notification_count, Count}
    end),

    timer:sleep(100),

    %% Exercise: Send burst of 50 notifications immediately
    lists:foreach(fun(N) ->
        Metadata = #{<<"version">> => N},
        erlmcp_server:notify_resource_updated(Server, ResourceUri, Metadata)
    end, lists:seq(1, 50)),

    %% Verify: System handles burst gracefully
    receive
        {notification_count, Count} ->
            %% Should receive most, maybe not all due to rate limiting
            ?assert(Count > 0),
            ct:pal("Burst: received ~p out of 50", [Count])
    after 2000 ->
        ct:fail("Notification count not received")
    end,

    %% Cleanup
    Subscriber ! stop,
    ok = erlmcp_server:stop(Server),

    {comment, "Burst notification handling verified"}.

%% Helper to count notifications
count_notifications(Timeout) ->
    count_notifications(Timeout, 0).

count_notifications(Timeout, Count) ->
    receive
        {resource_updated, _Uri, _Meta} ->
            count_notifications(Timeout, Count + 1)
    after Timeout ->
        Count
    end.

%%====================================================================
%% Failure Scenario Tests
%%====================================================================

client_crash_cleanup(_Config) ->
    %% Test subscription cleanup when client crashes
    %% Setup: Create server, resource, and crashable client
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/crash.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    %% Exercise: Create subscriber and crash it
    CrashablePid = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        timer:sleep(50),
        exit(crash)  %% Simulate crash
    end),

    %% Wait for subscription and crash
    timer:sleep(150),

    %% Verify: Subscription cleaned up after crash
    {ok, Subscribers} = erlmcp_server:get_subscribers(Server, ResourceUri),
    ?assertEqual(0, length(Subscribers)),

    %% Cleanup
    ok = erlmcp_server:stop(Server),

    {comment, "Client crash cleanup verified"}.

server_restart_subscription_recovery(_Config) ->
    %% Test subscription recovery after server restart
    %% Setup: Create server under supervisor
    {ok, Sup} = erlmcp_sup:start_link(),

    {ok, Server} = erlmcp_server:start_link(
        <<"restart-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/restart.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    %% Subscribe
    ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),

    %% Exercise: Kill server (supervisor will restart)
    ServerPid = whereis(erlmcp_server),
    exit(ServerPid, kill),

    %% Wait for supervisor restart
    timer:sleep(500),

    %% Verify: Server restarted
    NewServerPid = whereis(erlmcp_server),
    ?assert(is_pid(NewServerPid)),
    ?assert(NewServerPid =/= ServerPid),

    %% Note: Subscriptions may or may not persist based on implementation
    %% This test verifies graceful handling either way

    %% Cleanup
    erlmcp_server:stop(NewServerPid),
    supervisor:stop(Sup),

    {comment, "Server restart handling verified"}.

network_partition_recovery(_Config) ->
    %% Test subscription recovery after network partition
    %% Setup: Create server, resource, subscriber
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/partition.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    TestPid = self(),
    Subscriber = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        %% Simulate network partition by blocking messages
        process_flag(trap_exit, true),
        TestPid ! {ready, self()},
        receive
            {resume, TestPid} ->
                %% Resume receiving messages
                receive
                    {resource_updated, Uri, Meta} ->
                        TestPid ! {notification_after_partition, Uri, Meta}
                end
        end
    end),

    receive {ready, Subscriber} -> ok end,

    timer:sleep(100),

    %% Exercise: Send notification during "partition"
    Metadata1 = #{<<"version">> => 1},
    erlmcp_server:notify_resource_updated(Server, ResourceUri, Metadata1),

    %% Simulate partition recovery
    Subscriber ! {resume, TestPid},

    %% Send another notification after recovery
    timer:sleep(50),
    Metadata2 = #{<<"version">> => 2},
    erlmcp_server:notify_resource_updated(Server, ResourceUri, Metadata2),

    %% Verify: At least one notification received (after recovery)
    receive
        {notification_after_partition, ResourceUri, _} ->
            ok
    after 1000 ->
        ct:fail("No notification received after partition recovery")
    end,

    %% Cleanup
    Subscriber ! stop,
    ok = erlmcp_server:stop(Server),

    {comment, "Network partition recovery verified"}.

%%====================================================================
%% Transport Tests
%%====================================================================

subscription_over_stdio(_Config) ->
    %% Test subscription over stdio transport
    %% Note: Full integration test requires real stdio transport setup
    %% This test verifies the subscription logic works independently
    {ok, Server} = erlmcp_server:start_link(
        <<"stdio-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/stdio.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    %% Exercise: Subscribe via server API (transport layer handles stdio)
    ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),

    %% Verify: Subscription recorded
    {ok, Subscribers} = erlmcp_server:get_subscribers(Server, ResourceUri),
    ?assert(lists:member(self(), Subscribers)),

    %% Cleanup
    ok = erlmcp_server:stop(Server),

    {comment, "STDIO subscription API verified"}.

subscription_over_tcp(_Config) ->
    %% Test subscription over TCP transport
    %% Note: Full integration requires real TCP server
    %% This test verifies subscription logic
    {ok, Server} = erlmcp_server:start_link(
        <<"tcp-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/tcp.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    %% Exercise: Subscribe
    ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),

    %% Verify: Subscription recorded
    {ok, Subscribers} = erlmcp_server:get_subscribers(Server, ResourceUri),
    ?assert(lists:member(self(), Subscribers)),

    %% Cleanup
    ok = erlmcp_server:stop(Server),

    {comment, "TCP subscription API verified"}.

subscription_over_http(_Config) ->
    %% Test subscription over HTTP transport
    %% Note: Full integration requires HTTP server
    {ok, Server} = erlmcp_server:start_link(
        <<"http-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/http.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    %% Exercise: Subscribe
    ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),

    %% Verify: Subscription recorded
    {ok, Subscribers} = erlmcp_server:get_subscribers(Server, ResourceUri),
    ?assert(lists:member(self(), Subscribers)),

    %% Cleanup
    ok = erlmcp_server:stop(Server),

    {comment, "HTTP subscription API verified"}.

subscription_over_websocket(_Config) ->
    %% Test subscription over WebSocket transport
    %% Note: Full integration requires WebSocket server
    {ok, Server} = erlmcp_server:start_link(
        <<"ws-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/ws.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    %% Exercise: Subscribe
    ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),

    %% Verify: Subscription recorded
    {ok, Subscribers} = erlmcp_server:get_subscribers(Server, ResourceUri),
    ?assert(lists:member(self(), Subscribers)),

    %% Cleanup
    ok = erlmcp_server:stop(Server),

    {comment, "WebSocket subscription API verified"}.

%%====================================================================
%% Performance Tests
%%====================================================================

notification_latency_p50(_Config) ->
    %% Test notification latency p50 (< 100ms target)
    %% Setup: Create server, resource, subscriber
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/latency_p50.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    TestPid = self(),
    Subscriber = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        %% Measure latency for 100 notifications
        Latencies = measure_notification_latency(100, []),
        TestPid ! {latencies, Latencies}
    end),

    timer:sleep(100),

    %% Exercise: Send 100 notifications
    lists:foreach(fun(N) ->
        Metadata = #{<<"version">> => N},
        erlmcp_server:notify_resource_updated(Server, ResourceUri, Metadata),
        timer:sleep(5)  % Small delay between notifications
    end, lists:seq(1, 100)),

    %% Verify: p50 latency < 100ms
    receive
        {latencies, Latencies} ->
            Sorted = lists:sort(Latencies),
            P50Index = length(Latencies) div 2,
            P50 = lists:nth(P50Index, Sorted),
            ?assert(P50 < 100000),  % 100ms in microseconds
            ct:pal("P50 latency: ~pμs (target: <100000μs)", [P50])
    after 5000 ->
        ct:fail("Latency measurements not received")
    end,

    %% Cleanup
    Subscriber ! stop,
    ok = erlmcp_server:stop(Server),

    {comment, "P50 latency verified"}.

notification_latency_p95(_Config) ->
    %% Test notification latency p95 (< 150ms target)
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/latency_p95.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    TestPid = self(),
    Subscriber = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        Latencies = measure_notification_latency(100, []),
        TestPid ! {latencies, Latencies}
    end),

    timer:sleep(100),

    lists:foreach(fun(N) ->
        Metadata = #{<<"version">> => N},
        erlmcp_server:notify_resource_updated(Server, ResourceUri, Metadata),
        timer:sleep(5)
    end, lists:seq(1, 100)),

    %% Verify: p95 latency < 150ms
    receive
        {latencies, Latencies} ->
            Sorted = lists:sort(Latencies),
            P95Index = length(Latencies) * 95 div 100,
            P95 = lists:nth(P95Index, Sorted),
            ?assert(P95 < 150000),  % 150ms in microseconds
            ct:pal("P95 latency: ~pμs (target: <150000μs)", [P95])
    after 5000 ->
        ct:fail("Latency measurements not received")
    end,

    %% Cleanup
    Subscriber ! stop,
    ok = erlmcp_server:stop(Server),

    {comment, "P95 latency verified"}.

notification_latency_p99(_Config) ->
    %% Test notification latency p99 (< 200ms target)
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/latency_p99.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    TestPid = self(),
    Subscriber = spawn(fun() ->
        ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
        Latencies = measure_notification_latency(100, []),
        TestPid ! {latencies, Latencies}
    end),

    timer:sleep(100),

    lists:foreach(fun(N) ->
        Metadata = #{<<"version">> => N},
        erlmcp_server:notify_resource_updated(Server, ResourceUri, Metadata),
        timer:sleep(5)
    end, lists:seq(1, 100)),

    %% Verify: p99 latency < 200ms
    receive
        {latencies, Latencies} ->
            Sorted = lists:sort(Latencies),
            P99Index = length(Latencies) * 99 div 100,
            P99 = lists:nth(P99Index, Sorted),
            ?assert(P99 < 200000),  % 200ms in microseconds
            ct:pal("P99 latency: ~pμs (target: <200000μs)", [P99])
    after 5000 ->
        ct:fail("Latency measurements not received")
    end,

    %% Cleanup
    Subscriber ! stop,
    ok = erlmcp_server:stop(Server),

    {comment, "P99 latency verified"}.

high_subscription_throughput(_Config) ->
    %% Test high subscription throughput (1000+ subscriptions/sec)
    {ok, Server} = erlmcp_server:start_link(
        <<"test-server">>,
        #mcp_server_capabilities{resources = true}
    ),

    ResourceUri = <<"file:///test/throughput.txt">>,
    Handler = fun(_Uri) ->
        {ok, #{<<"contents">> => []}}
    end,

    ok = erlmcp_server:add_resource(Server, ResourceUri, Handler),

    %% Exercise: Create 1000 subscribers and measure time
    StartTime = erlang:monotonic_time(microsecond),

    SubscriberPids = lists:map(fun(N) ->
        spawn(fun() ->
            ok = erlmcp_server:subscribe_resource(Server, ResourceUri, self()),
            receive stop -> ok end
        end)
    end, lists:seq(1, 1000)),

    %% Wait for all subscriptions
    timer:sleep(2000),

    EndTime = erlang:monotonic_time(microsecond),
    DurationMs = (EndTime - StartTime) div 1000,

    %% Verify: All subscriptions created
    {ok, Subscribers} = erlmcp_server:get_subscribers(Server, ResourceUri),
    ?assertEqual(1000, length(Subscribers)),

    %% Calculate throughput
    Throughput = 1000000 / DurationMs,  % subscriptions/sec
    ct:pal("Created 1000 subscriptions in ~pms (~.0f subscriptions/sec)",
           [DurationMs, Throughput]),

    %% Target: > 500 subscriptions/sec
    ?assert(Throughput > 500),

    %% Cleanup
    lists:foreach(fun(Pid) -> Pid ! stop end, SubscriberPids),
    ok = erlmcp_server:stop(Server),

    {comment, "High subscription throughput verified"}.

%% Helper to measure notification latency
measure_notification_latency(0, Acc) ->
    lists:reverse(Acc);
measure_notification_latency(Count, Acc) ->
    StartTime = erlang:monotonic_time(microsecond),
    receive
        {resource_updated, _Uri, _Meta} ->
            EndTime = erlang:monotonic_time(microsecond),
            Latency = EndTime - StartTime,
            measure_notification_latency(Count - 1, [Latency | Acc])
    after 1000 ->
        measure_notification_latency(0, Acc)
    end.
