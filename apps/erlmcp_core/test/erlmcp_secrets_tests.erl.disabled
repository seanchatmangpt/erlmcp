%%%-------------------------------------------------------------------
%%% @doc erlmcp_secrets tests - Unit tests for secrets management
%%% Tests Vault, AWS Secrets Manager, and local encrypted storage
%%% @end
%%%-------------------------------------------------------------------
-module(erlmcp_secrets_tests).
-include_lib("eunit/include/eunit.hrl").

%%====================================================================
%% Test fixtures
%%====================================================================

secrets_test_() ->
    {foreach,
     fun setup/0,
     fun cleanup/1,
     [
      fun local_storage_get_set/0,
      fun local_storage_delete/0,
      fun local_storage_list/0,
      fun local_storage_encryption/0,
      fun vault_config_parse/0,
      fun vault_config_token/0,
      fun vault_config_approle/0,
      fun vault_config_kubernetes/0,
      fun vault_path_build/0,
      fun vault_timestamp_calc/0,
      fun aws_credentials_access_key/0,
      fun aws_credentials_missing_keys/0,
      fun aws_sigv4_calculate/0,
      fun aws_date_formatting/0,
      fun aws_iso8601_parse/0
     ]}.

setup() ->
    % Start inets and ssl for HTTP tests
    case whereis(inets) of undefined -> inets:start(); _ -> ok end,
    case whereis(ssl_sup) of undefined -> ssl:start(); _ -> ok end,
    % Create temp storage path
    TmpDir = filename:basedir(user_cache, <<"erlmcp-test">>),
    filelib:ensure_dir(TmpDir ++ "/"),
    TmpDir.

cleanup(_TmpDir) ->
    ok.

%%====================================================================
%% Local Encrypted Storage Tests
%%====================================================================

local_storage_get_set() ->
    TmpDir = filename:basedir(user_cache, <<"erlmcp-test">>),
    StoragePath = TmpDir ++ "/test_secrets.enc",
    KeyPath = TmpDir ++ "/test_master.key",

    % Create test state
    State = #{
        backend => local_encrypted,
        backend_config => #{},
        encryption_key => crypto:strong_rand_bytes(32),
        ttl_seconds => 300,
        storage_path => StoragePath
    },

    % Clean up any existing test file
    file:delete(StoragePath),

    % Test set and get
    ok = local_set(<<"test_key">>, <<"test_value">>, State),
    {ok, <<"test_value">>} = local_get(<<"test_key">>, State),

    % Test not found
    {error, not_found} = local_get(<<"nonexistent">>, State),

    % Cleanup
    file:delete(StoragePath),

    ?assert(true).

local_storage_delete() ->
    TmpDir = filename:basedir(user_cache, <<"erlmcp-test">>),
    StoragePath = TmpDir ++ "/test_delete.enc",

    State = #{
        backend => local_encrypted,
        backend_config => #{},
        encryption_key => crypto:strong_rand_bytes(32),
        ttl_seconds => 300,
        storage_path => StoragePath
    },

    file:delete(StoragePath),

    % Set then delete
    ok = local_set(<<"delete_me">>, <<"value">>, State),
    ok = local_delete(<<"delete_me">>, State),
    {error, not_found} = local_get(<<"delete_me">>, State),

    % Delete non-existent should succeed
    ok = local_delete(<<"nonexistent">>, State),

    file:delete(StoragePath),

    ?assert(true).

local_storage_list() ->
    TmpDir = filename:basedir(user_cache, <<"erlmcp-test">>),
    StoragePath = TmpDir ++ "/test_list.enc",

    State = #{
        backend => local_encrypted,
        backend_config => #{},
        encryption_key => crypto:strong_rand_bytes(32),
        ttl_seconds => 300,
        storage_path => StoragePath
    },

    file:delete(StoragePath),

    % Add multiple secrets
    ok = local_set(<<"key1">>, <<"val1">>, State),
    ok = local_set(<<"key2">>, <<"val2">>, State),
    ok = local_set(<<"key3">>, <<"val3">>, State),

    % List all
    {ok, Keys} = local_list(State),
    ?assertEqual(3, length(Keys)),
    ?assert(lists:member(<<"key1">>, Keys)),
    ?assert(lists:member(<<"key2">>, Keys)),
    ?assert(lists:member(<<"key3">>, Keys)),

    file:delete(StoragePath),

    ?assert(true).

local_storage_encryption() ->
    % Test AES-256-GCM encryption/decryption
    Key = crypto:strong_rand_bytes(32),
    PlainText = <<"sensitive data">>,

    % Encrypt
    Encrypted = encrypt_aes_gcm(PlainText, Key),
    ?assert(byte_size(Encrypted) > byte_size(PlainText)),

    % Decrypt
    Decrypted = decrypt_aes_gcm(Encrypted, Key),
    ?assertEqual(PlainText, Decrypted),

    % Test wrong key
    WrongKey = crypto:strong_rand_bytes(32),
    ?assertError(_, decrypt_aes_gcm(Encrypted, WrongKey)),

    ?assert(true).

%%====================================================================
%% Vault Configuration Tests
%%====================================================================

vault_config_parse() ->
    Config = #{
        url => <<"https://vault.example.com:8200">>,
        mount => <<"secret">>,
        namespace => <<"ns1">>,
        timeout => 10000
    },

    {ok, _VaultState} = parse_vault_config(Config),

    ?assert(true).

vault_config_token() ->
    Config = #{
        url => <<"https://vault.example.com">>,
        token => <<"s.test-token">>,
        auth_method => token
    },

    {ok, VaultState} = parse_vault_config(Config),
    ?assertEqual(<<"s.test-token">>, VaultState#vault_state.token),
    ?assertEqual(token, VaultState#vault_state.auth_method),

    ?assert(true).

vault_config_approle() ->
    Config = #{
        url => <<"https://vault.example.com">>,
        auth_method => approle,
        role_id => <<"role-id-123">>,
        secret_id => <<"secret-id-456">>
    },

    {ok, VaultState} = parse_vault_config(Config),
    ?assertEqual(approle, VaultState#vault_state.auth_method),
    ?assertEqual(<<"role-id-123">>, VaultState#vault_state.role_id),
    ?assertEqual(<<"secret-id-456">>, VaultState#vault_state.secret_id),

    ?assert(true).

vault_config_kubernetes() ->
    Config = #{
        url => <<"https://vault.example.com">>,
        auth_method => kubernetes,
        k8s_jwt_path => <<"/var/run/secrets/kubernetes.io/serviceaccount/token">>
    },

    {ok, VaultState} = parse_vault_config(Config),
    ?assertEqual(kubernetes, VaultState#vault_state.auth_method),
    ?assertEqual(<<"/var/run/secrets/kubernetes.io/serviceaccount/token">>,
                 VaultState#vault_state.k8s_jwt_path),

    ?assert(true).

vault_path_build() ->
    % Test without namespace
    State1 = #vault_state{
        mount => <<"secret">>,
        namespace => undefined
    },
    Path1 = build_vault_path(<<"data">>, <<"my/secret">>, State1),
    ?assertEqual(<<"/v1/secret/data/my/secret">>, Path1),

    % Test with namespace
    State2 = #vault_state{
        mount => <<"secret">>,
        namespace => <<"ns1">>
    },
    Path2 = build_vault_path(<<"data">>, <<"my/secret">>, State2),
    ?assertEqual(<<"/v1/ns1/secret/data/my/secret">>, Path2),

    ?assert(true).

vault_timestamp_calc() ->
    % Test timestamp calculation
    Now = erlang:timestamp(),
    Future = seconds_to_future_timestamp(3600),

    ?assert(Future > Now),

    ?assert(true).

%%====================================================================
%% AWS Credentials Tests
%%====================================================================

aws_credentials_access_key() ->
    Config = #{
        access_key => <<"AKIAIOSFODNN7EXAMPLE">>,
        secret_key => <<"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY">>
    },

    {ok, Creds} = get_aws_credentials(access_key, Config),
    ?assertEqual(<<"AKIAIOSFODNN7EXAMPLE">>, Creds#aws_credentials.access_key_id),
    ?assertEqual(<<"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY">>,
                 Creds#aws_credentials.secret_access_key),

    ?assert(true).

aws_credentials_missing_keys() ->
    % Missing access key
    Config1 = #{secret_key => <<"test">>},
    {error, missing_access_key} = get_aws_credentials(access_key, Config1),

    % Missing secret key
    Config2 = #{access_key => <<"test">>},
    {error, missing_secret_key} = get_aws_credentials(access_key, Config2),

    ?assert(true).

%%====================================================================
%% AWS SigV4 Tests
%%====================================================================

aws_sigv4_calculate() ->
    Creds = #aws_credentials{
        access_key_id = <<"AKIAIOSFODNN7EXAMPLE">>,
        secret_access_key => <<"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY">>,
        token = undefined,
        expiration = undefined
    },

    Region = <<"us-east-1">>,
    Service = <<"secretsmanager">>,
    Host = <<"secretsmanager.us-east-1.amazonaws.com">>,
    Path = <<"/">>,

    Now = {{2025, 1, 30}, {12, 0, 0}},
    AmzDate = format_amz_date(Now),
    DateStamp = format_date_stamp(Now),

    Headers = calculate_sigv4(
        post, Host, Path, #{<<"X-Amz-Target">> => <<"secretsmanager.GetSecretValue">>},
        <<"{}">>, Region, Service, Creds, AmzDate, DateStamp
    ),

    % Verify authorization header exists and has correct format
    Auth = maps:get(<<"Authorization">>, Headers, <<>>),
    ?assertMatch(<<"AWS4-HMAC-SHA256", _/binary>>, Auth),
    ?assert(maps:is_key(<<"X-Amz-Date">>, Headers)),

    ?assert(true).

aws_date_formatting() ->
    DateTime = {{2025, 1, 30}, {14, 35, 22}},

    DateStamp = format_date_stamp(DateTime),
    ?assertEqual(<<"20250130">>, DateStamp),

    AmzDate = format_amz_date(DateTime),
    ?assertEqual(<<"20250130T143522Z">>, AmzDate),

    ?assert(true).

aws_iso8601_parse() ->
    % Valid timestamp
    Iso8601 = <<"2025-01-30T12:34:56Z">>,
    Timestamp = parse_iso8601(Iso8601),

    % Should be a reasonable Unix timestamp (around 1738235696)
    ?assert(Timestamp > 1700000000),
    ?assert(Timestamp < 1800000000),

    % Invalid timestamp should default to 1 hour from now
    Invalid = <<"invalid-timestamp">>,
    InvalidTimestamp = parse_iso8601(Invalid),
    Now = erlang:system_time(second),
    ?assert(InvalidTimestamp >= Now + 3590),
    ?assert(InvalidTimestamp =< Now + 3610),

    ?assert(true).

%%====================================================================
%% Helper Functions (copied from erlmcp_secrets)
%%====================================================================

-record(vault_state, {
    url :: binary(),
    token :: binary() | undefined,
    auth_method :: token | approle | kubernetes,
    mount :: binary(),
    namespace :: binary() | undefined,
    timeout :: pos_integer(),
    circuit_breaker :: closed | open | half_open,
    failure_count :: non_neg_integer(),
    last_failure :: erlang:timestamp() | undefined,
    token_expiry :: erlang:timestamp() | undefined,
    role_id :: binary() | undefined,
    secret_id :: binary() | undefined,
    k8s_jwt_path :: binary() | undefined
}).

-record(aws_credentials, {
    access_key_id :: binary(),
    secret_access_key :: binary(),
    token :: binary() | undefined,
    expiration :: integer() | undefined
}).

%% Local storage functions
local_get(Key, State) ->
    case load_encrypted_storage(State) of
        {ok, Secrets} ->
            case maps:get(Key, Secrets, undefined) of
                undefined -> {error, not_found};
                Value -> {ok, Value}
            end;
        {error, enoent} ->
            {error, not_found};
        Error ->
            Error
    end.

local_set(Key, Value, State) ->
    Secrets = case load_encrypted_storage(State) of
        {ok, S} -> S;
        {error, enoent} -> #{};
        {error, Reason} -> error({failed_to_load_secrets, Reason})
    end,
    NewSecrets = maps:put(Key, Value, Secrets),
    save_encrypted_storage(NewSecrets, State).

local_delete(Key, State) ->
    case load_encrypted_storage(State) of
        {ok, Secrets} ->
            NewSecrets = maps:remove(Key, Secrets),
            save_encrypted_storage(NewSecrets, State);
        {error, enoent} ->
            ok;
        Error ->
            Error
    end.

local_list(State) ->
    case load_encrypted_storage(State) of
        {ok, Secrets} ->
            {ok, maps:keys(Secrets)};
        {error, enoent} ->
            {ok, []};
        Error ->
            Error
    end.

load_encrypted_storage(State) ->
    StoragePath = maps:get(storage_path, State),
    case file:read_file(StoragePath) of
        {ok, EncryptedData} ->
            Key = maps:get(encryption_key, State),
            PlainData = decrypt_aes_gcm(EncryptedData, Key),
            Secrets = binary_to_term(PlainData),
            {ok, Secrets};
        Error ->
            Error
    end.

save_encrypted_storage(Secrets, State) ->
    StoragePath = maps:get(storage_path, State),
    Key = maps:get(encryption_key, State),
    PlainData = term_to_binary(Secrets),
    EncryptedData = encrypt_aes_gcm(PlainData, Key),
    file:write_file(StoragePath, EncryptedData).

encrypt_aes_gcm(PlainText, Key) ->
    IV = crypto:strong_rand_bytes(12),
    {CipherText, Tag} = crypto:crypto_one_time_aead(aes_256_gcm, Key, IV, PlainText, <<>>, true),
    <<IV/binary, Tag/binary, CipherText/binary>>.

decrypt_aes_gcm(<<IV:12/binary, Tag:16/binary, CipherText/binary>>, Key) ->
    crypto:crypto_one_time_aead(aes_256_gcm, Key, IV, CipherText, <<>>, Tag, false).

%% Vault config functions
parse_vault_config(Config) ->
    Url = maps:get(url, Config, <<"http://localhost:8200">>),
    AuthMethod = maps:get(auth_method, Config, token),
    Mount = maps:get(mount, Config, <<"secret">>),
    Namespace = maps:get(namespace, Config, undefined),
    Timeout = maps:get(timeout, Config, 5000),

    case AuthMethod of
        token ->
            Token = maps:get(token, Config, <<>>),
            case Token of
                <<>> -> {error, missing_token};
                _ -> {ok, #vault_state{
                    url = Url,
                    token = Token,
                    auth_method = token,
                    mount = Mount,
                    namespace = Namespace,
                    timeout = Timeout,
                    circuit_breaker = closed,
                    failure_count = 0,
                    last_failure = undefined,
                    token_expiry = undefined
                }}
            end;
        approle ->
            RoleId = maps:get(role_id, Config, <<>>),
            SecretId = maps:get(secret_id, Config, <<>>),
            case {RoleId, SecretId} of
                {<<>>, _} -> {error, missing_role_id};
                {_, <<>>} -> {error, missing_secret_id};
                _ -> {ok, #vault_state{
                    url = Url,
                    token = undefined,
                    auth_method = approle,
                    mount = Mount,
                    namespace = Namespace,
                    timeout = Timeout,
                    circuit_breaker = closed,
                    failure_count = 0,
                    last_failure = undefined,
                    token_expiry = undefined,
                    role_id = RoleId,
                    secret_id = SecretId
                }}
            end;
        kubernetes ->
            JwtPath = maps:get(k8s_jwt_path, Config, <<"/var/run/secrets/kubernetes.io/serviceaccount/token">>),
            {ok, #vault_state{
                url = Url,
                token = undefined,
                auth_method = kubernetes,
                mount = Mount,
                namespace = Namespace,
                timeout = Timeout,
                circuit_breaker = closed,
                failure_count = 0,
                last_failure = undefined,
                token_expiry = undefined,
                k8s_jwt_path = JwtPath
            }}
    end.

build_vault_path(Endpoint, Key, #vault_state{mount = Mount, namespace = undefined}) ->
    iolist_to_binary([<<"/v1/">>, Mount, <<"/">>, Endpoint, <<"/">>, Key]);
build_vault_path(Endpoint, Key, #vault_state{mount = Mount, namespace = Namespace}) ->
    iolist_to_binary([<<"/v1/">>, Namespace, <<"/">>, Mount, <<"/">>, Endpoint, <<"/">>, Key]).

seconds_to_future_timestamp(Seconds) ->
    {MegaSecs, Secs, MicroSecs} = erlang:timestamp(),
    TotalSeconds = MegaSecs * 1000000 + Secs + Seconds,
    NewMegaSecs = TotalSeconds div 1000000,
    NewSecs = TotalSeconds rem 1000000,
    {NewMegaSecs, NewSecs, MicroSecs}.

%% AWS functions
get_aws_credentials(access_key, Config) ->
    AccessKey = case maps:find(access_key, Config) of
        {ok, Val} -> Val;
        error -> <<>>
    end,
    SecretKey = case maps:find(secret_key, Config) of
        {ok, Val1} -> Val1;
        error -> <<>>
    end,

    case {AccessKey, SecretKey} of
        {<<>>, _} ->
            {error, missing_access_key};
        {_, <<>>} ->
            {error, missing_secret_key};
        {_, _} ->
            {ok, #aws_credentials{
                access_key_id = AccessKey,
                secret_access_key = SecretKey,
                token = undefined,
                expiration = undefined
            }}
    end.

calculate_sigv4(_Method, Host, _Path, ExtraHeaders, Body,
                Region, Service, Creds, AmzDate, DateStamp) ->
    CanonicalHeadersList = [
        {<<"content-type">>, <<"application/x-amz-json-1.1">>},
        {<<"host">>, Host},
        {<<"x-amz-date">>, AmzDate}
    ] ++ maps:to_list(ExtraHeaders),

    SortedHeaders = lists:sort(fun({A, _}, {B, _}) ->
            string:lowercase(binary_to_list(A)) =< string:lowercase(binary_to_list(B))
        end, CanonicalHeadersList),

    CanonicalHeaders = <<<< (list_to_binary(string:lowercase(binary_to_list(K))))/binary, ":", V/binary, "\n" >>
        || {K, V} <- SortedHeaders>>,

    SignedHeadersList = [string:lowercase(binary_to_list(K)) || {K, _} <- SortedHeaders],
    SignedHeaders = list_to_binary(string:join(SignedHeadersList, ";")),

    PayloadHash = crypto:hash(sha256, Body),

    CanonicalRequest = iolist_to_binary([
        <<"POST">>, "\n",
        <<"/">>, "\n",
        <<>>, "\n",
        CanonicalHeaders, "\n",
        SignedHeaders, "\n",
        hex_encode(PayloadHash)
    ]),

    Algorithm = <<"AWS4-HMAC-SHA256">>,
    CredentialScope = <<DateStamp/binary, "/", Region/binary, "/",
                        Service/binary, "/aws4_request">>,
    StringToSign = <<Algorithm/binary, "\n",
                     AmzDate/binary, "\n",
                     CredentialScope/binary, "\n",
                     (hex_encode(crypto:hash(sha256, CanonicalRequest)))/binary>>,

    KDate = hmac_sha256(<<"AWS4", (Creds#aws_credentials.secret_access_key)/binary>>, DateStamp),
    KRegion = hmac_sha256(KDate, Region),
    KService = hmac_sha256(KRegion, Service),
    KSigning = hmac_sha256(KService, <<"aws4_request">>),
    Signature = hmac_sha256(KSigning, StringToSign),

    Credential = <<(Creds#aws_credentials.access_key_id)/binary, "/", CredentialScope/binary>>,

    Authorization = <<Algorithm/binary, " Credential=", Credential/binary,
                      ", SignedHeaders=", SignedHeaders/binary,
                      ", Signature=", (hex_encode(Signature))/binary>>,

    Headers = #{
        <<"Authorization">> => Authorization,
        <<"X-Amz-Date">> => AmzDate,
        <<"Content-Type">> => <<"application/x-amz-json-1.1">>
    },

    case Creds#aws_credentials.token of
        undefined -> Headers;
        Token -> maps:put(<<"X-Amz-Security-Token">>, Token, Headers)
    end.

hmac_sha256(Key, Data) ->
    crypto:mac(hmac, sha256, Key, Data).

hex_encode(Bin) ->
    list_to_binary([io_lib:format("~2.16.0B", [B]) || <<B>> <= Bin]).

format_date_stamp({{Year, Month, Day}, _}) ->
    list_to_binary(io_lib:format("~4.10.0B~2.10.0B~2.10.0B", [Year, Month, Day])).

format_amz_date({{Year, Month, Day}, {Hour, Min, Sec}}) ->
    list_to_binary(io_lib:format("~4.10.0B~2.10.0B~2.10.0BT~2.10.0B~2.10.0B~2.10.0BZ",
                                 [Year, Month, Day, Hour, Min, Sec])).

parse_iso8601(Iso8601) ->
    case re:run(Iso8601, <<"^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})Z$">>,
                [{capture, all_but_first, list}]) of
        {match, [YearStr, MonthStr, DayStr, HourStr, MinStr, SecStr]} ->
            Year = list_to_integer(YearStr),
            Month = list_to_integer(MonthStr),
            Day = list_to_integer(DayStr),
            Hour = list_to_integer(HourStr),
            Min = list_to_integer(MinStr),
            Sec = list_to_integer(SecStr),
            Secs = calendar:datetime_to_gregorian_seconds({{Year, Month, Day}, {Hour, Min, Sec}}) -
                    calendar:datetime_to_gregorian_seconds({{1970, 1, 1}, {0, 0, 0}}),
            Secs;
        _ ->
            erlang:system_time(second) + 3600
    end.
