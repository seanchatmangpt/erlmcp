%% ============================================================================
%% ERLMCP Security Validator Tests
%% ============================================================================
%% Chicago School TDD: 60+ tests for comprehensive security validation.
%% Tests REAL validation logic, NO mocks.
%%
%% @author erlmcp
%% @version 1.0.0
%% ============================================================================

-module(erlmcp_security_validator_tests).
-include_lib("eunit/include/eunit.hrl").

%%%=============================================================================
%%% Test Setup and Utilities
%%%=============================================================================

%% Setup function to start the validator
setup() ->
    {ok, Pid} = erlmcp_security_validator:start_link([
        {max_size, 1024 * 1024},  % 1MB for testing
        {rate_limits, [
            {<<"default">>, {10, 60}},  % 10 requests per 60 seconds
            {<<"premium">>, {100, 60}}   % 100 requests per 60 seconds
        ]},
        {cors_origins, [<<"https://example.com">>, <<"https://app.example.com">>]}
    ]),
    Pid.

%% Cleanup function
cleanup(_Pid) ->
    gen_server:stop(erlmcp_security_validator).

%%%=============================================================================
%%% Input Size Validation Tests (8 tests)
%%%=============================================================================

validate_input_size_valid_test() ->
    Input = <<"Hello, World!">>,
    Result = erlmcp_security_validator:validate_input_size(Input, 1024),
    ?assertMatch({ok, #{size := 13, max_size := 1024, status := ok}}, Result).

validate_input_size_binary_test() ->
    Input = <<1:8000/unit:8>>,  % 1000 bytes
    Result = erlmcp_security_validator:validate_input_size(Input, 1024),
    ?assertMatch({ok, #{size := 1000}}, Result).

validate_input_size_exceeded_test() ->
    Input = <<1:2000/unit:8>>,  % 2000 bytes
    Result = erlmcp_security_validator:validate_input_size(Input, 1024),
    ?assertMatch({error, #{reason := size_exceeded, size := 2000}}, Result).

validate_input_size_map_test() ->
    Input = #{<<"key">> => <<"value">>},
    Result = erlmcp_security_validator:validate_input_size(Input, 1024),
    ?assertMatch({ok, #{size := _}}, Result).

validate_input_size_map_exceeded_test() ->
    Input = #{<<"data">> => <<1:2000/unit:8>>},
    Result = erlmcp_security_validator:validate_input_size(Input, 1024),
    ?assertMatch({error, #{reason := size_exceeded}}, Result).

validate_input_size_default_limit_test() ->
    Input = <<1:50000/unit:8>>,  % 50KB
    Result = erlmcp_security_validator:validate_input_size(Input, 100 * 1024 * 1024),
    ?assertMatch({ok, #{status := ok}}, Result).

validate_input_size_invalid_type_test() ->
    Input = 12345,
    Result = erlmcp_security_validator:validate_input_size(Input, 1024),
    ?assertMatch({error, #{reason := invalid_input_type}}, Result).

validate_input_size_empty_test() ->
    Input = <<>>,
    Result = erlmcp_security_validator:validate_input_size(Input, 1024),
    ?assertMatch({ok, #{size := 0}}, Result).

%%%=============================================================================
%%% SQL Injection Detection Tests (8 tests)
%%%=============================================================================

detect_sql_injection_basic_test() ->
    Input = <<"admin' OR '1'='1'--">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := sql_injection}}, Result).

detect_sql_injection_union_test() ->
    Input = <<"1' UNION SELECT * FROM users--">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := sql_injection}}, Result).

detect_sql_injection_drop_test() ->
    Input = <<"'; DROP TABLE users;--">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := sql_injection}}, Result).

detect_sql_injection_comment_test() ->
    Input = <<"admin'--">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := sql_injection}}, Result).

detect_sql_injection_hash_test() ->
    Input = <<"admin'#">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := sql_injection}}, Result).

detect_sql_injection_case_insensitive_test() ->
    Input = <<"Admin' Or '1'='1'--">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := sql_injection}}, Result).

detect_sql_injection_clean_input_test() ->
    Input = <<"SELECT username FROM users">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({ok, #{status := secure}}, Result).

detect_sql_injection_valid_text_test() ->
    Input = <<"The product is 'awesome' and I love it!">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({ok, #{status := secure}}, Result).

%%%=============================================================================
%%% XSS Detection Tests (8 tests)
%%%=============================================================================

detect_xss_script_tag_test() ->
    Input = <<"<script>alert('XSS')</script>">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := xss}}, Result).

detect_xss_javascript_protocol_test() ->
    Input = <<"javascript:alert('XSS')">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := xss}}, Result).

detect_xss_onclick_test() ->
    Input = <<"<div onclick=\"alert('XSS')\">Click me</div>">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := xss}}, Result).

detect_xss_onload_test() ->
    Input = <<"<img onload=\"alert('XSS')\" src=\"x\">">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := xss}}, Result).

detect_xss_iframe_test() ->
    Input = <<"<iframe src=\"http://evil.com\">">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := xss}}, Result).

detect_xss_case_insensitive_test() ->
    Input = <<"<SCRIPT>alert('XSS')</SCRIPT>">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := xss}}, Result).

detect_xss_clean_html_test() ->
    Input = <<"<div>This is safe HTML</div>">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({ok, #{status := secure}}, Result).

detect_xss_plain_text_test() ->
    Input = <<"This is just plain text with no HTML">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({ok, #{status := secure}}, Result).

%%%=============================================================================
%%% Path Traversal Detection Tests (6 tests)
%%%=============================================================================

detect_path_traversal_double_dot_test() ->
    Input = <<"../../../etc/passwd">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := path_traversal}}, Result).

detect_path_traversal_url_encoded_test() ->
    Input = <<"%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := path_traversal}}, Result).

detect_path_traversal_backslash_test() ->
    Input = <<"..\\..\\..\\windows\\system32">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := path_traversal}}, Result).

detect_path_traversal_mixed_test() ->
    Input = <<"../..\\windows/">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({error, #{type := path_traversal}}, Result).

detect_path_traversal_valid_path_test() ->
    Input = <<"/var/log/app.log">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({ok, #{status := secure}}, Result).

detect_path_traversal_normal_file_test() ->
    Input = <<"documents/report.pdf">>,
    Result = erlmcp_security_validator:detect_injection_patterns(Input),
    ?assertMatch({ok, #{status := secure}}, Result).

%%%=============================================================================
%%% JWT Validation Tests (8 tests)
%%%=============================================================================

validate_jwt_valid_structure_test() ->
    % HS256 token: header.payload.signature
    Header = jsx:encode(#{<<"alg">> => <<"HS256">>, <<"typ">> => <<"JWT">>}),
    Payload = jsx:encode(#{<<"sub">> => <<"user123">>, <<"exp">> => 9999999999}),
    HeaderB64 = base64:encode(Header),
    PayloadB64 = base64:encode(Payload),
    Signature = <<"signature_here">>,
    Token = <<HeaderB64/binary, $., PayloadB64/binary, $., Signature/binary>>,
    Result = erlmcp_security_validator:validate_auth_token(Token),
    ?assertMatch({ok, #{valid := true, algorithm := <<"HS256">>}}, Result).

validate_jwt_missing_parts_test() ->
    Token = <<"only.two">>,
    Result = erlmcp_security_validator:validate_auth_token(Token),
    ?assertMatch({error, #{reason := invalid_jwt_format}}, Result).

validate_jwt_invalid_encoding_test() ->
    Token = <<"invalid@token@format">>,
    Result = erlmcp_security_validator:validate_auth_token(Token),
    ?assertMatch({error, #{reason := invalid_jwt_encoding}}, Result).

validate_jwt_insecure_algorithm_test() ->
    Header = jsx:encode(#{<<"alg">> => <<"none">>, <<"typ">> => <<"JWT">>}),
    Payload = jsx:encode(#{<<"sub">> => <<"user123">>}),
    HeaderB64 = base64:encode(Header),
    PayloadB64 = base64:encode(Payload),
    Token = <<HeaderB64/binary, $., PayloadB64/binary, ".signature">>,
    Result = erlmcp_security_validator:validate_auth_token(Token),
    ?assertMatch({error, #{reason := insecure_algorithm}}, Result).

validate_jwt_expired_token_test() ->
    Header = jsx:encode(#{<<"alg">> => <<"HS256">>, <<"typ">> => <<"JWT">>}),
    Payload = jsx:encode(#{<<"sub">> => <<"user123">>, <<"exp">> => 1000000000}),
    HeaderB64 = base64:encode(Header),
    PayloadB64 = base64:encode(Payload),
    Token = <<HeaderB64/binary, $., PayloadB64/binary, ".signature">>,
    Result = erlmcp_security_validator:validate_auth_token(Token),
    ?assertMatch({error, #{reason := token_expired}}, Result).

validate_jwt_missing_algorithm_test() ->
    Header = jsx:encode(#{<<"typ">> => <<"JWT">>}),
    Payload = jsx:encode(#{<<"sub">> => <<"user123">>}),
    HeaderB64 = base64:encode(Header),
    PayloadB64 = base64:encode(Payload),
    Token = <<HeaderB64/binary, $., PayloadB64/binary, ".signature">>,
    Result = erlmcp_security_validator:validate_auth_token(Token),
    ?assertMatch({error, #{reason := missing_algorithm}}, Result).

validate_jwt_no_expiration_test() ->
    Header = jsx:encode(#{<<"alg">> => <<"HS256">>, <<"typ">> => <<"JWT">>}),
    Payload = jsx:encode(#{<<"sub">> => <<"user123">>}),
    HeaderB64 = base64:encode(Header),
    PayloadB64 = base64:encode(Payload),
    Token = <<HeaderB64/binary, $., PayloadB64/binary, ".signature">>,
    Result = erlmcp_security_validator:validate_auth_token(Token),
    ?assertMatch({ok, #{valid := true}}, Result).

validate_jwt_invalid_type_test() ->
    Result = erlmcp_security_validator:validate_auth_token(12345),
    ?assertMatch({error, #{reason := invalid_token_type}}, Result).

%%%=============================================================================
%%% Secret Detection Tests (8 tests)
%%%=============================================================================

detect_secret_aws_access_key_test() ->
    Input = <<"AWS_ACCESS_KEY=AKIA1234567890123456">>,
    Result = erlmcp_security_validator:detect_secrets_in_input(Input),
    ?assertMatch({error, #{reason := secrets_detected, detected := [_]}}, Result).

detect_secret_aws_secret_key_test() ->
    Input = <<"AWS_SECRET=abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJ">>,
    Result = erlmcp_security_validator:detect_secrets_in_input(Input),
    ?assertMatch({error, #{reason := secrets_detected}}, Result).

detect_secret_google_api_key_test() ->
    Input = <<"google_api_key=AIza0123456789abcdefghijklmnopqrstuvwxzy-01234567">>,
    Result = erlmcp_security_validator:detect_secrets_in_input(Input),
    ?assertMatch({error, #{reason := secrets_detected}}, Result).

detect_secret_github_token_test() ->
    Input = <<"GITHUB_TOKEN=ghp_1234567890abcdefghijklmnOPQRSTUVWXYZ123456">>,
    Result = erlmcp_security_validator:detect_secrets_in_input(Input),
    ?assertMatch({error, #{reason := secrets_detected}}, Result).

detect_secret_jwt_token_test() ->
    Input = <<"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c">>,
    Result = erlmcp_security_validator:detect_secrets_in_input(Input),
    ?assertMatch({error, #{reason := secrets_detected}}, Result).

detect_secret_api_key_pattern_test() ->
    Input = <<"api_key=1234567890abcdefghijklmnopqrstuvwxyz123456">>,
    Result = erlmcp_security_validator:detect_secrets_in_input(Input),
    ?assertMatch({error, #{reason := secrets_detected}}, Result).

detect_secret_slack_token_test() ->
    Input = <<"SLACK_TOKEN=xoxb-123456789012-123456789012-123456789012abcdefghijklmnopqrst">>,
    Result = erlmcp_security_validator:detect_secrets_in_input(Input),
    ?assertMatch({error, #{reason := secrets_detected}}, Result).

detect_secret_clean_input_test() ->
    Input = <<"This is just normal text with no secrets">>,
    Result = erlmcp_security_validator:detect_secrets_in_input(Input),
    ?assertMatch({ok, #{status := clean}}, Result).

%%%=============================================================================
%%% Command Injection Tests (6 tests)
%%%=============================================================================

check_command_injection_semicolon_test() ->
    Input = <<"filename; rm -rf /">>,
    Result = erlmcp_security_validator:check_command_injection(Input),
    ?assertMatch({error, #{reason := command_injection_detected}}, Result).

check_command_injection_pipe_test() ->
    Input = <<"file.txt | cat /etc/passwd">>,
    Result = erlmcp_security_validator:check_command_injection(Input),
    ?assertMatch({error, #{reason := command_injection_detected}}, Result).

check_command_injection_backtick_test() ->
    Input = <<"file`whoami`txt">>,
    Result = erlmcp_security_validator:check_command_injection(Input),
    ?assertMatch({error, #{reason := command_injection_detected}}, Result).

check_command_injection_dollar_test() ->
    Input = <<"file$(rm -rf /)txt">>,
    Result = erlmcp_security_validator:check_command_injection(Input),
    ?assertMatch({error, #{reason := command_injection_detected}}, Result).

check_command_injection_clean_test() ->
    Input = <<"file.txt">>,
    Result = erlmcp_security_validator:check_command_injection(Input),
    ?assertMatch({ok, #{status := clean}}, Result).

check_command_injection_normal_command_test() ->
    Input = <<"ls -la /home/user">>,
    Result = erlmcp_security_validator:check_command_injection(Input),
    ?assertMatch({ok, #{status := clean}}, Result).

%%%=============================================================================
%%% LDAP Injection Tests (4 tests)
%%%=============================================================================

check_ldap_injection_asterisk_test() ->
    Input = <<"user*)(uid=*">>,
    Result = erlmcp_security_validator:check_ldap_injection(Input),
    ?assertMatch({error, #{reason := ldap_injection_detected}}, Result).

check_ldap_injection_parentheses_test() ->
    Input = <<"(|(cn=*))))">>,
    Result = erlmcp_security_validator:check_ldap_injection(Input),
    ?assertMatch({error, #{reason := ldap_injection_detected}}, Result).

check_ldap_injection_operators_test() ->
    Input = <<"cn=admin & password=*">>,
    Result = erlmcp_security_validator:check_ldap_injection(Input),
    ?assertMatch({error, #{reason := ldap_injection_detected}}, Result).

check_ldap_injection_clean_test() ->
    Input = <<"cn=John Doe,ou=Users,dc=example,dc=com">>,
    Result = erlmcp_security_validator:check_ldap_injection(Input),
    ?assertMatch({ok, #{status := clean}}, Result).

%%%=============================================================================
%%% XPath Injection Tests (4 tests)
%%%=============================================================================

check_xpath_injection_or_test() ->
    Input = <<"' or '1'='1'">>,
    Result = erlmcp_security_validator:check_xpath_injection(Input),
    ?assertMatch({error, #{reason := xpath_injection_detected}}, Result).

check_xpath_injection_and_test() ->
    Input = <<"' and '1'='1'">>,
    Result = erlmcp_security_validator:check_xpath_injection(Input),
    ?assertMatch({error, #{reason := xpath_injection_detected}}, Result).

check_xpath_injection_axis_test() ->
    Input = <<"ancestor-or-self::*">>,
    Result = erlmcp_security_validator:check_xpath_injection(Input),
    ?assertMatch({error, #{reason := xpath_injection_detected}}, Result).

check_xpath_injection_clean_test() ->
    Input = <<"/users/user[id='123']">>,
    Result = erlmcp_security_validator:check_xpath_injection(Input),
    ?assertMatch({ok, #{status := clean}}, Result).

%%%=============================================================================
%%% URI Validation Tests (6 tests)
%%%=============================================================================

validate_uri_valid_http_test() ->
    URI = <<"https://example.com/path">>,
    Result = erlmcp_security_validator:validate_uri(URI),
    ?assertMatch({ok, #{status := valid}}, Result).

validate_uri_too_long_test() ->
    URI = <<"https://example.com/", (binary:copy(<<"a">>, 2500))/binary>>,
    Result = erlmcp_security_validator:validate_uri(URI),
    ?assertMatch({error, #{reason := uri_too_long}}, Result).

validate_uri_file_protocol_test() ->
    URI = <<"file:///etc/passwd">>,
    Result = erlmcp_security_validator:validate_uri(URI),
    ?assertMatch({error, #{reason := dangerous_protocol}}, Result).

validate_uri_javascript_protocol_test() ->
    URI = <<"javascript:alert('XSS')">>,
    Result = erlmcp_security_validator:validate_uri(URI),
    ?assertMatch({error, #{reason := dangerous_protocol}}, Result).

validate_uri_double_encoding_test() ->
    URI = <<"https://example.com/%252e%252e%252fetc">>,
    Result = erlmcp_security_validator:validate_uri(URI),
    ?assertMatch({error, #{reason := double_encoding_detected}}, Result).

validate_uri_invalid_type_test() ->
    Result = erlmcp_security_validator:validate_uri(12345),
    ?assertMatch({error, #{reason := invalid_uri_type}}, Result).

%%%=============================================================================
%%% JSON Structure Validation Tests (6 tests)
%%%=============================================================================

validate_json_valid_simple_test() ->
    Json = #{<<"key">> => <<"value">>},
    Result = erlmcp_security_validator:validate_json_structure(Json),
    ?assertMatch({ok, #{status := valid}}, Result).

validate_json_valid_nested_test() ->
    Json = #{<<"user">> => #{<<"profile">> => #{<<"settings">> => #{<<"theme">> => <<"dark">>}}}},
    Result = erlmcp_security_validator:validate_json_structure(Json),
    ?assertMatch({ok, #{status := valid}}, Result).

validate_json_too_deep_test() ->
    % Create a deeply nested JSON structure
    DeepJson = create_deep_json(150),
    Result = erlmcp_security_validator:validate_json_structure(DeepJson),
    ?assertMatch({error, #{reason := json_too_deep}}, Result).

validate_json_binary_valid_test() ->
    Json = jsx:encode(#{<<"key">> => <<"value">>}),
    Result = erlmcp_security_validator:validate_json_structure(Json),
    ?assertMatch({ok, #{status := valid}}, Result).

validate_json_binary_invalid_test() ->
    Json = <<"not valid json {">>,
    Result = erlmcp_security_validator:validate_json_structure(Json),
    ?assertMatch({error, #{reason := invalid_json}}, Result).

validate_json_invalid_type_test() ->
    Result = erlmcp_security_validator:validate_json_structure(12345),
    ?assertMatch({error, #{reason := invalid_json_type}}, Result).

%%%=============================================================================
%%% Input Sanitization Tests (4 tests)
%%%=============================================================================

sanitize_input_null_bytes_test() ->
    Input = <<"Hello\x00World">>,
    Result = erlmcp_security_validator:sanitize_input(Input),
    ?assertEqual(<<"HelloWorld">>, Result).

sanitize_input_control_chars_test() ->
    Input = <<"Hello\x01World\x02Test">>,
    Result = erlmcp_security_validator:sanitize_input(Input),
    ?assertEqual(<<"HelloWorldTest">>, Result).

sanitize_input_whitespace_test() ->
    Input = <<"Hello     World    Test">>,
    Result = erlmcp_security_validator:sanitize_input(Input),
    ?assertEqual(<<"Hello World Test">>, Result).

sanitize_input_preserve_newlines_test() ->
    Input = <<"Line1\nLine2\rLine3\tTabbed">>,
    Result = erlmcp_security_validator:sanitize_input(Input),
    ?assertEqual(<<"Line1 Line2 Line3 Tabbed">>, Result).

%%%=============================================================================
%%% CORS Header Validation Tests (6 tests)
%%%=============================================================================

validate_cors_valid_test() ->
    Headers = #{<<"Origin">> => <<"https://example.com">>},
    Result = erlmcp_security_validator:validate_cors_headers(Headers),
    ?assertMatch({ok, #{status := valid}}, Result).

validate_cors_null_origin_test() ->
    Headers = #{<<"Origin">> => <<"null">>},
    Result = erlmcp_security_validator:validate_cors_headers(Headers),
    ?assertMatch({error, #{reason := null_origin_not_allowed}}, Result).

validate_cors_wildcard_origin_test() ->
    Headers = #{<<"Access-Control-Allow-Origin">> => <<"*">>},
    Result = erlmcp_security_validator:validate_cors_headers(Headers),
    ?assertMatch({ok, #{status := valid}}, Result).

validate_cors_valid_methods_test() ->
    Headers = #{
        <<"Origin">> => <<"https://example.com">>,
        <<"Access-Control-Allow-Methods">> => <<"GET, POST, PUT, DELETE">>
    },
    Result = erlmcp_security_validator:validate_cors_headers(Headers),
    ?assertMatch({ok, #{status := valid}}, Result).

validate_cors_invalid_methods_test() ->
    Headers = #{
        <<"Origin">> => <<"https://example.com">>,
        <<"Access-Control-Allow-Methods">> => <<"GET, INVALID, POST">>
    },
    Result = erlmcp_security_validator:validate_cors_headers(Headers),
    ?assertMatch({error, #{reason := invalid_http_method}}, Result).

validate_cors_invalid_type_test() ->
    Result = erlmcp_security_validator:validate_cors_headers(12345),
    ?assertMatch({error, #{reason := invalid_headers_type}}, Result).

%%%=============================================================================
%%% OWASP Compliance Tests (10 tests)
%%%=============================================================================

check_owasp_access_control_test() ->
    Input = #{<<"root">> => true},
    Result = erlmcp_security_validator:check_owasp_compliance(Input),
    ?assertMatch({error, #{reason := owasp_compliance_failed}}, Result).

check_owasp_weak_password_test() ->
    Input = #{<<"password">> => <<"weak">>},
    Result = erlmcp_security_validator:check_owasp_compliance(Input),
    ?assertMatch({error, #{reason := owasp_compliance_failed}}, Result).

check_owasp_injection_test() ->
    Input = #{<<"input">> => <<"'; DROP TABLE users;--">>},
    Result = erlmcp_security_validator:check_owasp_compliance(Input),
    ?assertMatch({error, #{reason := owasp_compliance_failed}}, Result).

check_owasp_missing_security_headers_test() ->
    Input = #{<<"security_headers">> => false},
    Result = erlmcp_security_validator:check_owasp_compliance(Input),
    ?assertMatch({error, #{reason := owasp_compliance_failed}}, Result).

check_owasp_debug_mode_test() ->
    Input = #{<<"debug_mode">> => true},
    Result = erlmcp_security_validator:check_owasp_compliance(Input),
    ?assertMatch({error, #{reason := owasp_compliance_failed}}, Result).

check_owasp_missing_auth_test() ->
    Input = #{},
    Result = erlmcp_security_validator:check_owasp_compliance(Input),
    ?assertMatch({error, #{reason := owasp_compliance_failed}}, Result).

check_owasp_logging_disabled_test() ->
    Input = #{<<"audit_log">> => false},
    Result = erlmcp_security_validator:check_owasp_compliance(Input),
    ?assertMatch({error, #{reason := owasp_compliance_failed}}, Result).

check_owasp_internal_url_test() ->
    Input = #{<<"url">> => <<"http://localhost:8080">>},
    Result = erlmcp_security_validator:check_owasp_compliance(Input),
    ?assertMatch({error, #{reason := owasp_compliance_failed}}, Result).

check_owasp_compliant_test() ->
    Input = #{
        <<"password">> => <<"strong_password_123">>,
        <<"input">> => <<"safe input">>,
        <<"security_headers">> => true,
        <<"debug_mode">> => false,
        <<"auth_token">> => valid_jwt_token()
    },
    Result = erlmcp_security_validator:check_owasp_compliance(Input),
    ?assertMatch({ok, #{owasp_compliance := _}}, Result).

check_owasp_invalid_input_type_test() ->
    Result = erlmcp_security_validator:check_owasp_compliance(12345),
    ?assertMatch({error, #{reason := invalid_input_type}}, Result).

%%%=============================================================================
%%% Rate Limiting Tests (6 tests)
%%%=============================================================================

validate_rate_limit_under_limit_test() ->
    Pid = setup(),
    try
        Request = #{<<"client_id">> => <<"default">>},
        % Make 5 requests (under limit of 10)
        lists:foreach(fun(_) ->
            ?assertMatch({ok, #{remaining := _}}, erlmcp_security_validator:validate_rate_limit(Request))
        end, lists:seq(1, 5))
    after
        cleanup(Pid)
    end.

validate_rate_limit_exceeded_test() ->
    Pid = setup(),
    try
        Request = #{<<"client_id">> => <<"default">>},
        % Make 11 requests (over limit of 10)
        Results = [erlmcp_security_validator:validate_rate_limit(Request) || _ <- lists:seq(1, 11)],
        ?assertMatch({error, #{reason := rate_limit_exceeded}}, lists:nth(11, Results))
    after
        cleanup(Pid)
    end.

validate_rate_limit_premium_client_test() ->
    Pid = setup(),
    try
        Request = #{<<"client_id">> => <<"premium">>},
        % Make 50 requests (under limit of 100)
        lists:foreach(fun(_) ->
            ?assertMatch({ok, #{remaining := _}}, erlmcp_security_validator:validate_rate_limit(Request))
        end, lists:seq(1, 50))
    after
        cleanup(Pid)
    end.

validate_rate_limit_reset_after_window_test() ->
    % This test would need to mock time or wait 60 seconds
    % Skipping for practical reasons
    ok.

validate_rate_limit_different_clients_test() ->
    Pid = setup(),
    try
        Request1 = #{<<"client_id">> => <<"client1">>},
        Request2 = #{<<"client_id">> => <<"client2">>},
        % Each client should have independent counters
        lists:foreach(fun(_) ->
            ?assertMatch({ok, #{remaining := _}}, erlmcp_security_validator:validate_rate_limit(Request1)),
            ?assertMatch({ok, #{remaining := _}}, erlmcp_security_validator:validate_rate_limit(Request2))
        end, lists:seq(1, 5))
    after
        cleanup(Pid)
    end.

validate_rate_limit_missing_client_id_test() ->
    Pid = setup(),
    try
        Request = #{},  % Missing client_id, should use default
        ?assertMatch({ok, #{remaining := _}}, erlmcp_security_validator:validate_rate_limit(Request))
    after
        cleanup(Pid)
    end.

%%%=============================================================================
%%% Security Report Tests (2 tests)
%%%=============================================================================

get_security_report_test() ->
    Pid = setup(),
    try
        {ok, Report} = erlmcp_security_validator:get_security_report(),
        ?assert(maps:is_key(owasp_compliance, Report)),
        ?assert(maps:is_key(vulnerabilities, Report)),
        ?assert(maps:is_key(recommendations, Report))
    after
        cleanup(Pid)
    end.

get_security_report_has_recommendations_test() ->
    Pid = setup(),
    try
        {ok, Report} = erlmcp_security_validator:get_security_report(),
        Recommendations = maps:get(recommendations, Report),
        ?assert(is_list(Recommendations)),
        ?assert(length(Recommendations) > 0)
    after
        cleanup(Pid)
    end.

%%%=============================================================================
%%% Helper Functions
%%%=============================================================================

%% Create a deeply nested JSON structure for testing
create_deep_json(Depth) when Depth > 0 ->
    create_deep_json(#{}, Depth);
create_deep_json(_Depth) ->
    #{}.

create_deep_json(Acc, 0) ->
    Acc;
create_deep_json(Acc, Depth) ->
    create_deep_json(#{<<"nested">> => Acc}, Depth - 1).

%% Generate a valid JWT token for testing
valid_jwt_token() ->
    Header = jsx:encode(#{<<"alg">> => <<"HS256">>, <<"typ">> => <<"JWT">>}),
    Payload = jsx:encode(#{<<"sub">> => <<"user123">>, <<"exp">> => 9999999999}),
    HeaderB64 = base64:encode(Header),
    PayloadB64 = base64:encode(Payload),
    <<HeaderB64/binary, $., PayloadB64/binary, ".signature">>.
