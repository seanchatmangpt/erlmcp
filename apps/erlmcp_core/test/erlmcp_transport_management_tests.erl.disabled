-module(erlmcp_transport_management_tests).
-include_lib("eunit/include/eunit.hrl").
-include("erlmcp.hrl").

%%%===================================================================
%%% Test Suite for erlmcp_sup Transport Management APIs
%%%
%%% Joe Armstrong Principles:
%%%   - "Dynamic supervision" - add/remove children at runtime
%%%   - "One supervisor per domain" - transport supervisor
%%%   - Let supervisor manage child lifecycle
%%%
%%% Chicago School TDD Principles:
%%%   - Use REAL erlmcp_transport_sup processes (NO mocks)
%%%   - Test observable behavior through API boundaries
%%%   - Test dynamic start/stop/list operations
%%%   - NO internal state inspection (respect encapsulation)
%%%   - Files <500 lines each
%%%===================================================================

%%====================================================================
%% Test Fixtures
%%====================================================================

transport_management_test_() ->
    {foreach,
     fun setup/0,
     fun cleanup/1,
     [
      fun test_start_stdio_transport/1,
      fun test_start_tcp_transport/1,
      fun test_start_http_transport/1,
      fun test_start_ws_transport/1,
      fun test_start_sse_transport/1,
      fun test_stop_transport/1,
      fun test_stop_nonexistent_transport/1,
      fun test_list_transports_empty/1,
      fun test_list_transports_multiple/1,
      fun test_start_duplicate_transport_id/1,
      fun test_transport_lifecycle/1,
      fun test_start_transport_without_sup/1,
      fun test_concurrent_transport_operations/1
     ]}.

%%====================================================================
%% Setup and Cleanup
%%====================================================================

setup() ->
    % Start required applications
    application:ensure_all_started(gproc),
    application:ensure_all_started(erlmcp_transports),

    % Ensure transport supervisor is running
    case whereis(erlmcp_transport_sup) of
        undefined ->
            {error, transport_sup_not_started};
        _Pid ->
            ok
    end,

    % Clear any existing test transports
    cleanup_transports(),

    % Return setup state
    #{
        test_start_time => erlang:timestamp()
    }.

cleanup(_State) ->
    % Clean up any test transports
    cleanup_transports(),
    ok.

%%====================================================================
%% Internal Helper Functions
%%====================================================================

%% @private Clean up all test transports
cleanup_transports() ->
    case whereis(erlmcp_transport_sup) of
        undefined ->
            ok;
        SupPid ->
            % Get all children
            Children = supervisor:which_children(SupPid),

            % Terminate all test transports (ids starting with 'test_')
            lists:foreach(
                fun({Id, _Pid, _Type, _Modules}) when is_atom(Id) ->
                    case atom_to_list(Id) of
                        "test_" ++ _Rest ->
                            supervisor:terminate_child(SupPid, Id),
                            supervisor:delete_child(SupPid, Id);
                        _ ->
                            ok
                    end;
                   (_) ->
                    ok
                end,
                Children
            )
    end.

%% @private Generate unique transport ID
generate_transport_id() ->
    UniqueNum = erlang:unique_integer([positive]),
    list_to_atom("test_transport_" ++ integer_to_list(UniqueNum)).

%%====================================================================
%% Test Cases
%%====================================================================

%% @doc Test starting a stdio transport
test_start_stdio_transport(_State) ->
    TransportId = generate_transport_id(),
    Config = #{},

    % Start the transport
    Result = erlmcp_sup:start_transport(TransportId, stdio, Config),

    % Verify transport started successfully
    ?assertMatch({ok, _Pid}, Result),

    % Verify transport is in the list
    Transports = erlmcp_sup:list_transports(),
    ?assert(lists:keymember(TransportId, 1, Transports)),

    % Clean up
    ok = erlmcp_sup:stop_transport(TransportId),

    % Verify transport removed
    TransportsAfter = erlmcp_sup:list_transports(),
    ?assertNot(lists:keymember(TransportId, 1, TransportsAfter)).

%% @doc Test starting a tcp transport
test_start_tcp_transport(_State) ->
    TransportId = generate_transport_id(),
    Config = #{
        port => 0,  % OS-assigned port
        listen_options => []
    },

    % Start the transport
    Result = erlmcp_sup:start_transport(TransportId, tcp, Config),

    % Verify transport started successfully
    ?assertMatch({ok, _Pid}, Result),

    % Verify transport is in the list with correct type
    Transports = erlmcp_sup:list_transports(),
    case lists:keyfind(TransportId, 1, Transports) of
        {TransportId, _Pid, Type} ->
            ?assertEqual(tcp, Type);
        false ->
            ?assert(false, transport_not_found_in_list)
    end,

    % Clean up
    ok = erlmcp_sup:stop_transport(TransportId).

%% @doc Test starting an http transport
test_start_http_transport(_State) ->
    TransportId = generate_transport_id(),
    Config = #{
        port => 0,  % OS-assigned port
        handler_options => []
    },

    % Start the transport
    Result = erlmcp_sup:start_transport(TransportId, http, Config),

    % Verify transport started successfully
    ?assertMatch({ok, _Pid}, Result),

    % Verify transport is in the list
    Transports = erlmcp_sup:list_transports(),
    ?assert(lists:keymember(TransportId, 1, Transports)),

    % Clean up
    ok = erlmcp_sup:stop_transport(TransportId).

%% @doc Test starting a websocket transport
test_start_ws_transport(_State) ->
    TransportId = generate_transport_id(),
    Config = #{
        port => 0,  % OS-assigned port
        ws_options => []
    },

    % Start the transport
    Result = erlmcp_sup:start_transport(TransportId, ws, Config),

    % Verify transport started successfully
    ?assertMatch({ok, _Pid}, Result),

    % Verify transport type in list
    Transports = erlmcp_sup:list_transports(),
    case lists:keyfind(TransportId, 1, Transports) of
        {TransportId, _Pid, Type} ->
            ?assertEqual(ws, Type);
        false ->
            ?assert(false, transport_not_found_in_list)
    end,

    % Clean up
    ok = erlmcp_sup:stop_transport(TransportId).

%% @doc Test starting an SSE transport
test_start_sse_transport(_State) ->
    TransportId = generate_transport_id(),
    Config = #{
        port => 0,  % OS-assigned port
        sse_options => []
    },

    % Start the transport
    Result = erlmcp_sup:start_transport(TransportId, sse, Config),

    % Verify transport started successfully
    ?assertMatch({ok, _Pid}, Result),

    % Verify transport is in the list
    Transports = erlmcp_sup:list_transports(),
    ?assert(lists:keymember(TransportId, 1, Transports)),

    % Clean up
    ok = erlmcp_sup:stop_transport(TransportId).

%% @doc Test stopping a transport
test_stop_transport(_State) ->
    TransportId = generate_transport_id(),
    Config = #{},

    % Start the transport
    {ok, _Pid} = erlmcp_sup:start_transport(TransportId, stdio, Config),

    % Verify it's in the list
    TransportsBefore = erlmcp_sup:list_transports(),
    ?assert(lists:keymember(TransportId, 1, TransportsBefore)),

    % Stop the transport
    Result = erlmcp_sup:stop_transport(TransportId),

    % Verify stop succeeded
    ?assertEqual(ok, Result),

    % Verify it's removed from the list
    TransportsAfter = erlmcp_sup:list_transports(),
    ?assertNot(lists:keymember(TransportId, 1, TransportsAfter)).

%% @doc Test stopping a nonexistent transport
test_stop_nonexistent_transport(_State) ->
    TransportId = nonexistent_transport,

    % Try to stop a transport that doesn't exist
    Result = erlmcp_sup:stop_transport(TransportId),

    % Should return ok (idempotent)
    ?assertEqual(ok, Result).

%% @doc Test listing transports when empty
test_list_transports_empty(_State) ->
    % First clean up all test transports
    cleanup_transports(),

    % List should be empty or only contain non-test transports
    Transports = erlmcp_sup:list_transports(),

    % Filter out any non-test transports
    TestTransports = lists:filter(
        fun({Id, _Pid, _Type}) ->
            case atom_to_list(Id) of
                "test_" ++ _ -> true;
                _ -> false
            end
        end,
        Transports
    ),

    ?assertEqual([], TestTransports).

%% @doc Test listing multiple transports
test_list_transports_multiple(_State) ->
    % Start multiple transports
    Id1 = generate_transport_id(),
    Id2 = generate_transport_id(),
    Id3 = generate_transport_id(),

    Config = #{},

    {ok, _} = erlmcp_sup:start_transport(Id1, stdio, Config),
    {ok, _} = erlmcp_sup:start_transport(Id2, tcp, Config),
    {ok, _} = erlmcp_sup:start_transport(Id3, http, Config),

    % List transports
    Transports = erlmcp_sup:list_transports(),

    % Verify all are present
    ?assert(lists:keymember(Id1, 1, Transports)),
    ?assert(lists:keymember(Id2, 1, Transports)),
    ?assert(lists:keymember(Id3, 1, Transports)),

    % Verify types are correct
    {Id1, _Pid1, Type1} = lists:keyfind(Id1, 1, Transports),
    {Id2, _Pid2, Type2} = lists:keyfind(Id2, 1, Transports),
    {Id3, _Pid3, Type3} = lists:keyfind(Id3, 1, Transports),

    ?assertEqual(stdio, Type1),
    ?assertEqual(tcp, Type2),
    ?assertEqual(http, Type3),

    % Clean up
    ok = erlmcp_sup:stop_transport(Id1),
    ok = erlmcp_sup:stop_transport(Id2),
    ok = erlmcp_sup:stop_transport(Id3).

%% @doc Test starting transport with duplicate ID
test_start_duplicate_transport_id(_State) ->
    TransportId = generate_transport_id(),
    Config = #{},

    % Start first transport
    {ok, Pid1} = erlmcp_sup:start_transport(TransportId, stdio, Config),

    % Try to start second transport with same ID
    Result = erlmcp_sup:start_transport(TransportId, tcp, Config),

    % Should fail (duplicate child ID)
    ?assertMatch({error, _Reason}, Result),

    % First transport should still be running
    Transports = erlmcp_sup:list_transports(),
    {TransportId, Pid1, stdio} = lists:keyfind(TransportId, 1, Transports),

    % Clean up
    ok = erlmcp_sup:stop_transport(TransportId).

%% @doc Test complete transport lifecycle
test_transport_lifecycle(_State) ->
    TransportId = generate_transport_id(),
    Config = #{},

    % Initial state: transport not in list
    ?assertNot(lists:keymember(TransportId, 1,
                                erlmcp_sup:list_transports())),

    % Start transport
    {ok, Pid} = erlmcp_sup:start_transport(TransportId, stdio, Config),
    ?assert(is_pid(Pid)),

    % Verify in list
    ?assert(lists:keymember(TransportId, 1,
                            erlmcp_sup:list_transports())),

    % Stop transport
    ok = erlmcp_sup:stop_transport(TransportId),

    % Verify removed from list
    ?assertNot(lists:keymember(TransportId, 1,
                                erlmcp_sup:list_transports())).

%% @doc Test starting transport when supervisor not running
test_start_transport_without_sup(_State) ->
    % This test is tricky because we can't easily stop the supervisor
    % without affecting other tests. For now, we'll just verify
    % the error case is handled correctly.

    % We can't actually test this without breaking the test suite,
    % so we'll just verify the API handles the case
    TransportId = generate_transport_id(),

    % If supervisor is not running, should return error
    % (This is a compile-time check that the code handles this case)
    ?assertNotEqual({error, not_implemented},
                    erlmcp_sup:start_transport(TransportId, stdio, #{})).

%% @doc Test concurrent transport operations
test_concurrent_transport_operations(_State) ->
    % Generate multiple transport IDs
    NumTransports = 10,
    TransportIds = [generate_transport_id() || _ <- lists:seq(1, NumTransports)],
    Config = #{},

    % Start all transports concurrently
    StartResults = lists:map(
        fun(Id) ->
            spawn_monitor(fun() ->
                erlmcp_sup:start_transport(Id, stdio, Config)
            end)
        end,
        TransportIds
    ),

    % Wait for all to complete
    lists:foreach(
        fun({_Pid, Ref}) ->
            receive
                {'DOWN', Ref, process, _Pid, _Info} -> ok
            end
        end,
        StartResults
    ),

    % Verify all transports are in the list
    Transports = erlmcp_sup:list_transports(),
    lists:foreach(
        fun(Id) ->
            ?assert(lists:keymember(Id, 1, Transports))
        end,
        TransportIds
    ),

    % Stop all transports concurrently
    StopResults = lists:map(
        fun(Id) ->
            spawn_monitor(fun() ->
                erlmcp_sup:stop_transport(Id)
            end)
        end,
        TransportIds
    ),

    % Wait for all to complete
    lists:foreach(
        fun({_Pid, Ref}) ->
            receive
                {'DOWN', Ref, process, _Pid, _Info} -> ok
            end
        end,
        StopResults
    ),

    % Verify all transports are removed
    TransportsAfter = erlmcp_sup:list_transports(),
    lists:foreach(
        fun(Id) ->
            ?assertNot(lists:keymember(Id, 1, TransportsAfter))
        end,
        TransportIds
    ).
