%%%-------------------------------------------------------------------
%%% @doc
%%% Vulnerability Scanner for Dependency CVEs (FM-12)
%%%
%%% Automated dependency vulnerability scanning that:
%%% - Parses rebar.lock to extract dependencies
%%% - Queries NVD (National Vulnerability Database) for CVEs
%%% - Scores vulnerabilities using CVSS
%%% - Generates reports for CI/CD integration
%%% - Blocks builds on critical/high severity CVEs
%%%
%%% == Architecture ==
%%%
%%% Parse → Query → Score → Classify → Report → Block/Warn/Info
%%%
%%% == CVSS Severity Mapping ==
%%%
%%% - CVSS ≥ 9.0 → Critical (block build)
%%% - CVSS 7.0-8.9 → High (block build)
%%% - CVSS 4.0-6.9 → Medium (warn, don't block)
%%% - CVSS < 4.0 → Low (info only)
%%%
%%% == API ==
%%%
%%% - scan_dependencies/1,2 : Main entry point
%%% - parse_lock_file/1 : Parse rebar.lock
%%% - query_nvd/2 : Query NVD for CVEs
%%% - generate_report/1,2 : Generate scan report
%%%
%%% @end
%%%-------------------------------------------------------------------
-module(erlmcp_vulnerability_scanner).

%% API exports
-export([
    scan_dependencies/1,
    scan_dependencies/2,
    parse_lock_file/1,
    extract_dependencies/1,
    extract_dependencies/2,
    query_nvd/2,
    parse_nvd_response/1,
    classify_cve/1,
    classify_cve/2,
    classify_cves/1,
    highest_severity/1,
    generate_json_report/1,
    generate_summary/1,
    generate_ci_output/1,
    save_audit_trail/2
]).

-include_lib("kernel/include/logger.hrl").

%%%====================================================================
%%% API Functions
%%%====================================================================

%% @doc Scan all dependencies in rebar.lock for CVEs
-spec scan_dependencies(LockFile :: file:filename()) ->
    {ok, map()} | {error, term()}.
scan_dependencies(LockFile) ->
    scan_dependencies(LockFile, #{}).

%% @doc Scan dependencies with options
-spec scan_dependencies(LockFile :: file:filename(), Opts :: map()) ->
    {ok, map()} | {error, term()}.
scan_dependencies(LockFile, Opts) ->
    try
        %% Parse rebar.lock
        {ok, Parsed} = parse_lock_file(LockFile),

        %% Extract dependencies
        DirectOnly = maps:get(direct_only, Opts, false),
        ExtractOpts = case DirectOnly of
            true -> #{direct_only => true};
            false -> #{}
        end,
        Dependencies = extract_dependencies(Parsed, ExtractOpts),

        ?LOG_INFO("Scanning ~p dependencies for CVEs", [length(Dependencies)]),

        %% Query NVD for each dependency
        Mock = maps:get(mock, Opts, false),
        VulnerabilitiesPerDep = lists:map(fun(Dep) ->
            QueryOpts = case Mock of
                true -> Opts;
                false -> #{cache_dir => maps:get(cache_dir, Opts, "/tmp/nvd_cache")}
            end,
            case query_nvd(Dep, QueryOpts) of
                {ok, CVEs} when length(CVEs) > 0 ->
                    {Dep, CVEs};
                {ok, []} ->
                    {Dep, []};
                {error, Reason} ->
                    ?LOG_WARNING("Failed to query NVD for ~s: ~p",
                                [maps:get(name, Dep), Reason]),
                    {Dep, []}
            end
        end, Dependencies),

        %% Filter dependencies with vulnerabilities
        Vulnerable = [{Dep, CVEs} || {Dep, CVEs} <- VulnerabilitiesPerDep, CVEs =/= []],

        %% Classify overall severity
        AllCVEs = lists:flatten([CVEs || {_Dep, CVEs} <- Vulnerable]),
        OverallClassification = case AllCVEs of
            [] -> #{severity => none, action => pass};
            _ -> classify_cves(AllCVEs)
        end,

        %% Build scan results
        ScanResults = #{
            scanned_at => erlang:system_time(second),
            lock_file => LockFile,
            dependencies_scanned => length(Dependencies),
            vulnerabilities_found => length(Vulnerable),
            critical => count_severity(Vulnerable, critical),
            high => count_severity(Vulnerable, high),
            medium => count_severity(Vulnerable, medium),
            low => count_severity(Vulnerable, low),
            overall_severity => maps:get(severity, OverallClassification),
            overall_action => maps:get(action, OverallClassification),
            exit_code => case maps:get(action, OverallClassification) of
                block -> 1;
                _ -> 0
            end,
            vulnerable_dependencies => [
                #{
                    dependency => maps:get(name, Dep),
                    version => maps:get(version, Dep),
                    cves => CVEs
                } || {Dep, CVEs} <- Vulnerable
            ]
        },

        {ok, ScanResults}

    catch
        error:Reason:Stacktrace ->
            ?LOG_ERROR("Dependency scan failed: ~p~nStacktrace: ~p",
                      [Reason, Stacktrace]),
            {error, Reason}
    end.

%% @doc Parse rebar.lock file
-spec parse_lock_file(LockFile :: file:filename()) ->
    {ok, list()} | {error, term()}.
parse_lock_file(LockFile) ->
    try
        case file:consult(LockFile) of
            {ok, [_Version, Dependencies | _]} ->
                {ok, Dependencies};
            {ok, [Dependencies]} ->
                {ok, Dependencies};
            {error, Reason} ->
                {error, {parse_error, Reason}}
        end
    catch
        _:Reason ->
            {error, {exception, Reason}}
    end.

%% @doc Extract dependency information from parsed lock
-spec extract_dependencies(Parsed :: list()) -> list(map()).
extract_dependencies(Parsed) ->
    extract_dependencies(Parsed, #{}).

%% @doc Extract dependencies with options
-spec extract_dependencies(Parsed :: list(), Opts :: map()) -> list(map()).
extract_dependencies(Parsed, Opts) when is_list(Parsed) ->
    DirectOnly = maps:get(direct_only, Opts, false),

    lists:filtermap(fun(Entry) ->
        case Entry of
            {Name, {pkg, PkgName, Version}, Depth} ->
                %% Filter by depth if direct_only
                case DirectOnly andalso Depth > 0 of
                    true -> false;
                    false ->
                        {true, #{
                            name => Name,
                            package_name => PkgName,
                            version => Version,
                            depth => Depth,
                            package_type => pkg
                        }}
                end;
            _ ->
                false
        end
    end, Parsed);
extract_dependencies(_Parsed, _Opts) ->
    [].

%% @doc Query NVD for CVEs affecting a dependency
-spec query_nvd(Dependency :: map(), Opts :: map()) ->
    {ok, list(map())} | {error, term()}.
query_nvd(Dependency, #{mock := true} = Opts) ->
    %% Mock mode for testing
    MockResponse = maps:get(mock_response, Opts, []),
    {ok, MockResponse};
query_nvd(Dependency, Opts) ->
    %% Real NVD query
    Name = binary_to_list(maps:get(name, Dependency)),
    Version = binary_to_list(maps:get(version, Dependency)),

    %% Check cache first
    CacheDir = maps:get(cache_dir, Opts, "/tmp/nvd_cache"),
    CacheKey = lists:flatten(io_lib:format("~s_~s", [Name, Version])),
    CacheFile = filename:join(CacheDir, CacheKey ++ ".json"),

    case filelib:is_file(CacheFile) of
        true ->
            %% Load from cache
            case file:read_file(CacheFile) of
                {ok, CachedData} ->
                    {ok, Parsed} = jsx:decode(CachedData, [return_maps]),
                    {ok, maps:get(<<"cves">>, Parsed, [])};
                {error, _} ->
                    query_nvd_api(Dependency, Opts, CacheFile)
            end;
        false ->
            query_nvd_api(Dependency, Opts, CacheFile)
    end.

%% @private Query NVD API and cache result
query_nvd_api(Dependency, _Opts, CacheFile) ->
    Name = binary_to_list(maps:get(name, Dependency)),
    Version = binary_to_list(maps:get(version, Dependency)),

    %% NVD API endpoint (v2.0)
    APIKey = os:getenv("NVD_API_KEY", ""),
    BaseURL = "https://services.nvd.nist.gov/rest/json/cves/2.0",

    %% Build query parameters
    %% Search for CPE matching erlang package name
    Query = lists:flatten(io_lib:format("?keywordSearch=~s&keywordExactMatch", [Name])),
    URL = BaseURL ++ Query,

    %% HTTP request headers
    Headers = case APIKey of
        "" -> [];
        _ -> [{"apiKey", APIKey}]
    end,

    ?LOG_INFO("Querying NVD for ~s:~s", [Name, Version]),

    %% Make HTTP request
    case httpc:request(get, {URL, Headers}, [{timeout, 10000}], []) of
        {ok, {{_, 200, _}, _RespHeaders, Body}} ->
            %% Parse response
            {ok, JSONData} = jsx:decode(list_to_binary(Body), [return_maps]),
            CVEs = parse_nvd_response(JSONData),

            %% Filter CVEs affecting this version
            FilteredCVEs = filter_cves_by_version(CVEs, Version),

            %% Cache result
            filelib:ensure_dir(CacheFile),
            CacheData = jsx:encode(#{cves => FilteredCVEs}),
            file:write_file(CacheFile, CacheData),

            {ok, FilteredCVEs};

        {ok, {{_, StatusCode, _}, _, Body}} ->
            ?LOG_WARNING("NVD API returned ~p: ~s", [StatusCode, Body]),
            {ok, []};  % Treat as no CVEs found

        {error, Reason} ->
            ?LOG_ERROR("NVD API request failed: ~p", [Reason]),
            {error, Reason}
    end.

%% @doc Parse NVD API response
-spec parse_nvd_response(Response :: map()) -> list(map()).
parse_nvd_response(#{<<"vulnerabilities">> := Vulnerabilities}) when is_list(Vulnerabilities) ->
    lists:filtermap(fun(VulnEntry) ->
        try
            CVE = maps:get(<<"cve">>, VulnEntry),
            CVEID = maps:get(<<"id">>, CVE),

            %% Extract CVSS score
            Metrics = maps:get(<<"metrics">>, CVE, #{}),
            {CVSSScore, Severity} = extract_cvss(Metrics),

            %% Extract description
            Descriptions = maps:get(<<"descriptions">>, CVE, []),
            Description = extract_description(Descriptions),

            {true, #{
                cve_id => CVEID,
                cvss_score => CVSSScore,
                severity => Severity,
                description => Description
            }}
        catch
            _:_ ->
                %% Skip malformed CVE entries
                false
        end
    end, Vulnerabilities);
parse_nvd_response(_) ->
    [].

%% @doc Classify CVE severity and action
-spec classify_cve(CVE :: map()) -> map().
classify_cve(CVE) ->
    classify_cve(CVE, #{}).

%% @doc Classify CVE with override options
-spec classify_cve(CVE :: map(), Opts :: map()) -> map().
classify_cve(CVE, Opts) ->
    CVEID = maps:get(cve_id, CVE),
    CVSSScore = maps:get(cvss_score, CVE),
    BaseSeverity = maps:get(severity, CVE),

    %% Check for overrides
    Overrides = maps:get(overrides, Opts, []),
    Override = lists:keyfind(CVEID, 1, [{maps:get(cve_id, O), O} || O <- Overrides]),

    case Override of
        {_, OverrideData} ->
            %% Apply override
            #{
                cve_id => CVEID,
                cvss_score => CVSSScore,
                severity => maps:get(override_severity, OverrideData),
                action => maps:get(override_action, OverrideData),
                override_reason => maps:get(reason, OverrideData),
                overridden => true
            };
        false ->
            %% Standard classification
            {Severity, Action} = classify_by_cvss(CVSSScore),
            #{
                cve_id => CVEID,
                cvss_score => CVSSScore,
                severity => Severity,
                action => Action,
                base_severity => BaseSeverity,
                overridden => false
            }
    end.

%% @doc Classify multiple CVEs (use highest severity)
-spec classify_cves(CVEs :: list(map())) -> map().
classify_cves([]) ->
    #{severity => none, action => pass, max_cvss => 0.0};
classify_cves(CVEs) ->
    %% Find highest CVSS score
    MaxCVSS = lists:max([maps:get(cvss_score, CVE, 0.0) || CVE <- CVEs]),

    %% Classify based on highest score
    {Severity, Action} = classify_by_cvss(MaxCVSS),

    #{
        severity => Severity,
        action => Action,
        max_cvss => MaxCVSS,
        total_cves => length(CVEs)
    }.

%% @doc Find highest severity among CVEs
-spec highest_severity(CVEs :: list(map())) -> atom().
highest_severity(CVEs) ->
    Severities = [maps:get(severity, CVE) || CVE <- CVEs],
    case lists:member(critical, Severities) of
        true -> critical;
        false ->
            case lists:member(high, Severities) of
                true -> high;
                false ->
                    case lists:member(medium, Severities) of
                        true -> medium;
                        false -> low
                    end
            end
    end.

%% @doc Generate JSON report
-spec generate_json_report(ScanResults :: map()) -> {ok, binary()} | {error, term()}.
generate_json_report(ScanResults) ->
    try
        JSON = jsx:encode(ScanResults, [{space, 2}, {indent, 2}]),
        {ok, JSON}
    catch
        _:Reason ->
            {error, Reason}
    end.

%% @doc Generate human-readable summary
-spec generate_summary(ScanResults :: map()) -> binary().
generate_summary(ScanResults) ->
    DepsScanned = maps:get(dependencies_scanned, ScanResults),
    VulnsFound = maps:get(vulnerabilities_found, ScanResults),
    Critical = maps:get(critical, ScanResults, 0),
    High = maps:get(high, ScanResults, 0),
    Medium = maps:get(medium, ScanResults, 0),
    Low = maps:get(low, ScanResults, 0),

    Summary = io_lib:format(
        "Dependency Vulnerability Scan Results~n"
        "======================================~n"
        "Dependencies scanned: ~p~n"
        "Vulnerabilities found: ~p~n"
        "  Critical: ~p~n"
        "  High: ~p~n"
        "  Medium: ~p~n"
        "  Low: ~p~n",
        [DepsScanned, VulnsFound, Critical, High, Medium, Low]
    ),

    iolist_to_binary(Summary).

%% @doc Generate CI/CD integration output
-spec generate_ci_output(ScanResults :: map()) -> map().
generate_ci_output(ScanResults) ->
    ExitCode = maps:get(exit_code, ScanResults),
    Summary = generate_summary(ScanResults),

    #{
        exit_code => ExitCode,
        summary => Summary,
        should_block => (ExitCode =/= 0),
        vulnerabilities_found => maps:get(vulnerabilities_found, ScanResults)
    }.

%% @doc Save audit trail to file
-spec save_audit_trail(ScanResults :: map(), FilePath :: file:filename()) ->
    ok | {error, term()}.
save_audit_trail(ScanResults, FilePath) ->
    case generate_json_report(ScanResults) of
        {ok, JSON} ->
            filelib:ensure_dir(FilePath),
            file:write_file(FilePath, JSON);
        {error, Reason} ->
            {error, Reason}
    end.

%%%====================================================================
%%% Internal Functions
%%%====================================================================

%% @private Classify by CVSS score
classify_by_cvss(CVSS) when CVSS >= 9.0 ->
    {critical, block};
classify_by_cvss(CVSS) when CVSS >= 7.0 ->
    {high, block};
classify_by_cvss(CVSS) when CVSS >= 4.0 ->
    {medium, warn};
classify_by_cvss(_CVSS) ->
    {low, info}.

%% @private Extract CVSS score from metrics
extract_cvss(#{<<"cvssMetricV31">> := [Metric | _]}) ->
    CVSSData = maps:get(<<"cvssData">>, Metric),
    BaseScore = maps:get(<<"baseScore">>, CVSSData),
    BaseSeverity = maps:get(<<"baseSeverity">>, CVSSData),
    Severity = severity_from_string(BaseSeverity),
    {BaseScore, Severity};
extract_cvss(#{<<"cvssMetricV30">> := [Metric | _]}) ->
    CVSSData = maps:get(<<"cvssData">>, Metric),
    BaseScore = maps:get(<<"baseScore">>, CVSSData),
    BaseSeverity = maps:get(<<"baseSeverity">>, CVSSData),
    Severity = severity_from_string(BaseSeverity),
    {BaseScore, Severity};
extract_cvss(#{<<"cvssMetricV2">> := [Metric | _]}) ->
    CVSSData = maps:get(<<"cvssData">>, Metric),
    BaseScore = maps:get(<<"baseScore">>, CVSSData),
    %% CVSS v2 doesn't have severity string, derive from score
    Severity = case BaseScore of
        S when S >= 9.0 -> critical;
        S when S >= 7.0 -> high;
        S when S >= 4.0 -> medium;
        _ -> low
    end,
    {BaseScore, Severity};
extract_cvss(_) ->
    {0.0, low}.

%% @private Extract description
extract_description([#{<<"lang">> := <<"en">>, <<"value">> := Value} | _]) ->
    Value;
extract_description([#{<<"value">> := Value} | _]) ->
    Value;
extract_description(_) ->
    <<"No description available">>.

%% @private Convert severity string to atom
severity_from_string(<<"CRITICAL">>) -> critical;
severity_from_string(<<"HIGH">>) -> high;
severity_from_string(<<"MEDIUM">>) -> medium;
severity_from_string(<<"LOW">>) -> low;
severity_from_string(_) -> low.

%% @private Filter CVEs by version
filter_cves_by_version(CVEs, _Version) ->
    %% Simplified version matching
    %% In production, would parse CPE configurations and version ranges
    CVEs.

%% @private Count vulnerabilities by severity
count_severity(Vulnerable, Severity) ->
    length([1 || {_Dep, CVEs} <- Vulnerable,
                CVE <- CVEs,
                maps:get(severity, CVE) =:= Severity]).
