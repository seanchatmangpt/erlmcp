%%%-------------------------------------------------------------------
%%% @doc URI Validator for erlmcp
%%%
%%% Validates URIs according to RFC 3986 and prevents security issues:
%%% - RFC 3986 compliance checking
%%% - Injection prevention (SQL, command, path traversal)
%%% - SSRF prevention (Server-Side Request Forgery)
%%% - Private IP detection
%%%
%%% @end
%%%-------------------------------------------------------------------
-module(erlmcp_uri_validator).
-dialyzer({nowarn_function, [parse_uri/1]}).  

%% API exports
-export([
    validate_uri/1,
    validate_uri/2,
    is_safe_uri/1,
    is_safe_uri/2,
    parse_uri/1,
    check_ssrf/1,
    is_private_ip/1,
    validate_resource_uri_on_registration/1,
]).

%% Types
-type uri() :: binary().
-type validation_opts() :: #{
    allow_private_ips => boolean(),
    allowed_schemes => [binary()],
    max_length => non_neg_integer()
}.
-type validation_result() :: ok | {error, term()}.
-type uri_parts() :: #{
    scheme => binary(),
    host => binary(),
    port => non_neg_integer() | undefined,
    path => binary(),
    query => binary() | undefined,
    fragment => binary() | undefined
}.

-export_type([uri/0, validation_opts/0, validation_result/0, uri_parts/0]).

%%%===================================================================
%%% API Functions
%%%===================================================================

%% @doc Validate URI with default options
-spec validate_uri(uri()) -> validation_result().
validate_uri(Uri) ->
    validate_uri(Uri, #{}).

%% @doc Validate URI with custom options
-spec validate_uri(uri(), validation_opts()) -> validation_result().
validate_uri(Uri, Opts) when is_binary(Uri) ->
    MaxLength = maps:get(max_length, Opts, 2048),
    AllowedSchemes = maps:get(allowed_schemes, Opts, [<<"http">>, <<"https">>, <<"file">>]),
    AllowPrivateIPs = maps:get(allow_private_ips, Opts, false),

    %% Check length
    case byte_size(Uri) > MaxLength of
        true -> {error, uri_too_long};
        false ->
            %% Check for dangerous characters
            case check_dangerous_chars(Uri) of
                ok ->
                    %% Parse URI
                    case parse_uri(Uri) of
                        {ok, Parts} ->
                            %% Validate scheme
                            case validate_scheme(maps:get(scheme, Parts, undefined), AllowedSchemes) of
                                ok ->
                                    %% Check SSRF if HTTP/HTTPS
                                    case AllowPrivateIPs of
                                        true -> ok;
                                        false ->
                                            check_ssrf_parts(Parts)
                                    end;
                                {error, _} = Error -> Error
                            end;
                        {error, _} = Error -> Error
                    end;
                {error, _} = Error -> Error
            end
    end;
validate_uri(_Uri, _Opts) ->
    {error, not_binary}.

%% @doc Check if URI is safe (no injection, SSRF risks)
-spec is_safe_uri(uri()) -> boolean().
is_safe_uri(Uri) ->
    is_safe_uri(Uri, #{}).

%% @doc Check if URI is safe with options
-spec is_safe_uri(uri(), validation_opts()) -> boolean().
is_safe_uri(Uri, Opts) ->
    case validate_uri(Uri, Opts) of
        ok -> true;
        {error, _} -> false
    end.

%% @doc Validate resource URI during registration
%% Less strict than general URI validation - allows custom schemes
%% for testing and MCP-specific URIs (test://, mcp://, etc.)
-spec validate_resource_uri_on_registration(uri()) -> ok | {error, term()}.
validate_resource_uri_on_registration(Uri) when is_binary(Uri) ->
    % Check basic URI structure (scheme://something)
    case byte_size(Uri) of
        0 -> {error, empty_uri};
        _ ->
            case binary:split(Uri, <<"://">>) of
                [<<>>, _] -> {error, missing_scheme};
                [_, <<>>] -> {error, missing_path};
                [_Scheme, _Rest] -> ok
            end
    end;
validate_resource_uri_on_registration(_Uri) ->
    {error, not_binary}.

%% @doc Parse URI into components
-spec parse_uri(uri()) -> {ok, uri_parts()} | {error, term()}.
parse_uri(Uri) when is_binary(Uri) ->
    try
        %% Simple URI parsing (basic implementation)
        %% Format: scheme://host:port/path?query#fragment
        case binary:split(Uri, <<"://">>) of
            [Scheme, Rest] ->
                {HostPort, PathQueryFragment} = case binary:split(Rest, <<"/">>) of
                    [HP] -> {HP, <<"/">>};
                    [HP, PQF] -> {HP, <<"/", PQF/binary>>}
                end,

                {Host, Port} = case binary:split(HostPort, <<":">>) of
                    [H] -> {H, undefined};
                    [H, PortStr] ->
                        try
                            {H, binary_to_integer(PortStr)}
                        catch
                            _:_ -> {H, undefined}
                        end
                end,

                {Path, QueryFragment} = case binary:split(PathQueryFragment, <<"?">>) of
                    [PathOnly] -> {PathOnly, undefined};
                    [PathPart, QF1] -> {PathPart, QF1}
                end,

                {Query, Fragment} = split_fragment(QueryFragment),


                {ok, #{
                    scheme => string:lowercase(Scheme),
                    host => string:lowercase(Host),
                    port => Port,
                    path => Path,
                    query => Query,
                    fragment => Fragment
                }};
            [_] ->
                %% No scheme, might be relative URI
                {error, missing_scheme}
        end
    catch
        _:_ -> {error, parse_error}
    end;
parse_uri(_Uri) ->
    {error, not_binary}.

%% @doc Split query and fragment
-spec split_fragment(binary() | undefined) -> {binary() | undefined, binary() | undefined}.
split_fragment(undefined) -> {undefined, undefined};
split_fragment(QueryFrag) ->
    case binary:split(QueryFrag, <<"#">>) of
        [Q] -> {Q, undefined};
        [Q, F] -> {Q, F}
    end.

%% @doc Check for SSRF vulnerabilities
-spec check_ssrf(uri()) -> validation_result().
check_ssrf(Uri) ->
    case parse_uri(Uri) of
        {ok, Parts} ->
            check_ssrf_parts(Parts);
        {error, _} = Error -> Error
    end.

%% @doc Check if IP address is private/internal
-spec is_private_ip(binary()) -> boolean().
is_private_ip(Host) when is_binary(Host) ->
    %% Check for localhost
    case Host of
        <<"localhost">> -> true;
        <<"127.0.0.1">> -> true;
        <<"::1">> -> true;
        <<"[::1]">> -> true;
        _ ->
            %% Check for private IP ranges
            is_private_ipv4(Host) orelse is_private_ipv6(Host)
    end.

%%%===================================================================
%%% Internal Functions
%%%===================================================================

%% @private Check for dangerous characters (injection prevention)
check_dangerous_chars(Uri) ->
    DangerousPatterns = [
        <<0>>,           %% Null byte
        <<"\r\n">>,      %% CRLF injection
        <<"\r">>,        %% CR injection
        <<"\n">>,        %% LF injection
        <<"<script">>,   %% XSS
        <<"javascript:">>, %% JavaScript protocol
        <<"data:">>,     %% Data URI (can be used for XSS)
        <<"vbscript:">>, %% VBScript protocol
        <<"file:///etc">>, %% Path traversal attempt
        <<"../">>,       %% Path traversal
        <<"..\\">>       %% Windows path traversal
    ],

    case lists:any(fun(Pattern) -> binary:match(Uri, Pattern) =/= nomatch end, DangerousPatterns) of
        true -> {error, dangerous_characters};
        false -> ok
    end.

%% @private Validate URI scheme
validate_scheme(undefined, _AllowedSchemes) ->
    {error, missing_scheme};
validate_scheme(Scheme, AllowedSchemes) ->
    case lists:member(Scheme, AllowedSchemes) of
        true -> ok;
        false -> {error, {disallowed_scheme, Scheme}}
    end.

%% @private Check SSRF from parsed URI parts
check_ssrf_parts(#{host := Host} = _Parts) ->
    case is_private_ip(Host) of
        true -> {error, private_ip_not_allowed};
        false ->
            %% Check for DNS rebinding patterns
            case is_dns_rebinding_pattern(Host) of
                true -> {error, potential_dns_rebinding};
                false -> ok
            end
    end;
check_ssrf_parts(_Parts) ->
    ok.

%% @private Check if IPv4 is private
is_private_ipv4(Host) ->
    %% Parse IPv4 address
    case binary:split(Host, <<".">>, [global]) of
        [A, B, C, D] ->
            try
                [Ai, Bi, Ci, Di] = [binary_to_integer(X) || X <- [A, B, C, D]],
                %% Check private ranges
                %% 10.0.0.0/8
                (Ai =:= 10) orelse
                %% 172.16.0.0/12
                (Ai =:= 172 andalso Bi >= 16 andalso Bi =< 31) orelse
                %% 192.168.0.0/16
                (Ai =:= 192 andalso Bi =:= 168) orelse
                %% 169.254.0.0/16 (link-local)
                (Ai =:= 169 andalso Bi =:= 254) orelse
                %% 127.0.0.0/8 (loopback)
                (Ai =:= 127) orelse
                %% Catch variables to avoid unused warnings
                (Ci =:= Ci andalso Di =:= Di andalso false)
            catch
                _:_ -> false
            end;
        _ -> false
    end.

%% @private Check if IPv6 is private
is_private_ipv6(Host) ->
    %% Simple check for common private IPv6 patterns
    %% Remove brackets if present
    Host1 = case Host of
        <<"[", Rest/binary>> ->
            Size = byte_size(Rest) - 1,
            binary:part(Rest, {0, Size});
        _ -> Host
    end,

    %% Check for private IPv6 ranges
    %% fc00::/7 (unique local)
    %% fe80::/10 (link-local)
    %% ::1 (loopback)
    binary:match(Host1, <<"fc">>) =:= {0, 2} orelse
    binary:match(Host1, <<"fd">>) =:= {0, 2} orelse
    binary:match(Host1, <<"fe80">>) =:= {0, 4} orelse
    Host1 =:= <<"::1">>.

%% @private Check for DNS rebinding patterns
is_dns_rebinding_pattern(Host) ->
    %% Check for patterns like: 127.0.0.1.example.com
    %% or other DNS rebinding tricks
    Parts = binary:split(Host, <<".">>, [global]),
    length(Parts) > 4 andalso
    lists:any(fun(Part) ->
        Part =:= <<"127">> orelse
        Part =:= <<"localhost">> orelse
        Part =:= <<"169">>
    end, Parts).
