%%%-------------------------------------------------------------------
%%% @doc MCP 2025-11-25 Specification Compliance Test Suite
%%%
%%% This Common Test suite validates compliance with the MCP 2025-11-25
%%% specification across all protocol areas including lifecycle, tools,
%%% resources, prompts, and error handling.
%%%
%%% Testing Methodology:
%%% - Chicago School TDD: Real processes, state-based verification
%%% - No mocks, fakes, or placeholder implementations
%%% - Test observable behavior through all interfaces
%%% - Validate both MUST and SHOULD requirements
%%% - Test error codes (1001-1089) and JSON-RPC errors
%%%
%%% @end
%%%-------------------------------------------------------------------
-module(erlmcp_spec_compliance_SUITE).
-compile(export_all).

-include_lib("common_test/include/ct.hrl").
-include_lib("eunit/include/eunit.hrl").
-include("erlmcp.hrl").

%%====================================================================
%% Common Test Callbacks
%%====================================================================

suite() ->
    [
        {timetrap, {minutes, 10}},
        {require, sname},
        {default_config, sname, "erlmcp_spec_compliance"}
    ].

init_per_suite(Config) ->
    application:ensure_all_started(erlmcp),
    Config.

end_per_suite(_Config) ->
    application:stop(erlmcp),
    ok.

init_per_group(_GroupName, Config) ->
    Config.

end_per_group(_GroupName, _Config) ->
    ok.

init_per_testcase(_TestCase, Config) ->
    Config.

end_per_testcase(_TestCase, _Config) ->
    ok.

groups() ->
    [
        {lifecycle_tests, [sequence], [
            client_initiated_reconnect,
            server_initiated_reconnect,
            graceful_disconnect,
            forced_disconnect,
            shutdown_sequence
        ]},
        {tools_edge_cases, [sequence], [
            tool_call_streaming_response,
            tool_call_cancellation,
            tool_with_nested_schemas,
            tool_error_propagation
        ]},
        {resources_edge_cases, [sequence], [
            resource_uri_canonicalization,
            resource_subscription_limits,
            resource_streaming,
            resource_change_detection
        ]},
        {prompts_edge_cases, [sequence], [
            prompt_template_inheritance,
            prompt_argument_validation,
            prompt_completion,
            prompt_template_versioning
        ]},
        {negative_tests, [sequence], [
            invalid_json_handling,
            malformed_requests,
            protocol_violations,
            out_of_order_messages
        ]}
    ].

all() ->
    [
        {group, lifecycle_tests},
        {group, tools_edge_cases},
        {group, resources_edge_cases},
        {group, prompts_edge_cases},
        {group, negative_tests}
    ].

%%====================================================================
%% Lifecycle Edge Cases Tests
%%====================================================================

client_initiated_reconnect(_Config) ->
    %% Test that client can initiate reconnection after disconnect
    %% Spec: Client SHOULD handle reconnection gracefully

    %% Simulate client disconnect by creating a disconnect notification
    DisconnectNotif = erlmcp_json_rpc:encode_notification(
        <<"notifications/shutdown">>,
        #{}
    ),

    %% Verify disconnect notification is properly formed
    {ok, DecodedNotif} = erlmcp_json_rpc:decode_message(DisconnectNotif),
    ?assertMatch(#json_rpc_notification{method = <<"notifications/shutdown">>}, DecodedNotif),

    %% Simulate reconnection by creating new initialize request
    InitRequest = erlmcp_json_rpc:encode_request(
        1,
        <<"initialize">>,
        #{
            <<"protocolVersion">> => <<"2025-11-25">>,
            <<"capabilities">> => #{},
            <<"clientInfo">> => #{
                <<"name">> => <<"test-client">>,
                <<"version">> => <<"1.0.0">>
            }
        }
    ),

    %% Verify initialize request is valid
    {ok, DecodedInit} = erlmcp_json_rpc:decode_message(InitRequest),
    ?assertMatch(#json_rpc_request{method = <<"initialize">>}, DecodedInit),

    {comment, "Client-initiated reconnect protocol validated"}.

server_initiated_reconnect(_Config) ->
    %% Test that server can initiate reconnection
    %% Spec: Server SHOULD support reconnection

    %% Create initialize request
    InitRequest = erlmcp_json_rpc:encode_request(
        1,
        <<"initialize">>,
        #{
            <<"protocolVersion">> => <<"2025-11-25">>,
            <<"capabilities">> => #{},
            <<"clientInfo">> => #{
                <<"name">> => <<"test-client">>,
                <<"version">> => <<"1.0.0">>
            }
        }
    ),

    %% Verify request structure
    {ok, DecodedInit} = erlmcp_json_rpc:decode_message(InitRequest),
    ?assertMatch(#json_rpc_request{id = 1}, DecodedInit),

    %% Simulate successful initialization response
    InitResponse = erlmcp_json_rpc:encode_response(
        1,
        #{
            <<"protocolVersion">> => <<"2025-11-25">>,
            <<"capabilities">> => #{},
            <<"serverInfo">> => #{
                <<"name">> => <<"test-server">>,
                <<"version">> => <<"1.0.0">>
            }
        }
    ),

    %% Verify response structure
    {ok, DecodedResp} = erlmcp_json_rpc:decode_message(InitResponse),
    ?assertMatch(#json_rpc_response{id = 1}, DecodedResp),

    {comment, "Server-initiated reconnect protocol validated"}.

graceful_disconnect(_Config) ->
    %% Test graceful disconnect sequence
    %% Spec: Both client and server SHOULD send shutdown notification

    %% Create shutdown notification
    ShutdownNotif = erlmcp_json_rpc:encode_notification(
        <<"notifications/shutdown">>,
        #{}
    ),

    %% Verify shutdown notification is properly formed
    {ok, DecodedNotif} = erlmcp_json_rpc:decode_message(ShutdownNotif),
    ?assertMatch(#json_rpc_notification{method = <<"notifications/shutdown">>}, DecodedNotif),

    %% Verify it's a notification (no id field)
    #json_rpc_notification{method = Method} = DecodedNotif,
    ?assertEqual(<<"notifications/shutdown">>, Method),

    {comment, "Graceful disconnect protocol validated"}.

forced_disconnect(_Config) ->
    %% Test forced disconnect (abnormal termination)
    %% Spec: Implementation MUST handle abrupt disconnections

    %% Create a request that would be in-flight during disconnect
    InFlightRequest = erlmcp_json_rpc:encode_request(
        2,
        <<"tools/list">>,
        #{}
    ),

    %% Verify request is valid
    {ok, DecodedReq} = erlmcp_json_rpc:decode_message(InFlightRequest),
    ?assertMatch(#json_rpc_request{id = 2}, DecodedReq),

    %% Simulate error response for interrupted request
    ErrorResponse = erlmcp_json_rpc:encode_error_response(
        2,
        ?JSONRPC_INTERNAL_ERROR,
        <<"Connection interrupted">>
    ),

    %% Verify error response structure
    {ok, DecodedError} = erlmcp_json_rpc:decode_message(ErrorResponse),
    ?assertMatch(#json_rpc_response{id = 2, error = #{}}, DecodedError),

    {comment, "Forced disconnect handling validated"}.

shutdown_sequence(_Config) ->
    %% Test proper shutdown sequence
    %% Spec: MUST follow initialize -> initialized -> shutdown -> exit sequence

    %% Step 1: Initialize request
    InitRequest = erlmcp_json_rpc:encode_request(
        1,
        <<"initialize">>,
        #{
            <<"protocolVersion">> => <<"2025-11-25">>,
            <<"capabilities">> => #{},
            <<"clientInfo">> => #{
                <<"name">> => <<"test-client">>,
                <<"version">> => <<"1.0.0">>
            }
        }
    ),
    {ok, _DecodedInit} = erlmcp_json_rpc:decode_message(InitRequest),

    %% Step 2: Initialized notification
    InitializedNotif = erlmcp_json_rpc:encode_notification(
        <<"notifications/initialized">>,
        #{}
    ),
    {ok, DecodedInitialized} = erlmcp_json_rpc:decode_message(InitializedNotif),
    ?assertMatch(#json_rpc_notification{method = <<"notifications/initialized">>}, DecodedInitialized),

    %% Step 3: Shutdown notification
    ShutdownNotif = erlmcp_json_rpc:encode_notification(
        <<"notifications/shutdown">>,
        #{}
    ),
    {ok, DecodedShutdown} = erlmcp_json_rpc:decode_message(ShutdownNotif),
    ?assertMatch(#json_rpc_notification{method = <<"notifications/shutdown">>}, DecodedShutdown),

    {comment, "Shutdown sequence validated"}.

%%====================================================================
%% Tools API Edge Cases Tests
%%====================================================================

tool_call_streaming_response(_Config) ->
    %% Test tool call with streaming response
    %% Spec: Tools MAY support streaming responses via progress tokens

    %% Create tool call request with progress token
    ToolCallRequest = erlmcp_json_rpc:encode_request(
        1,
        <<"tools/call">>,
        #{
            <<"name">> => <<"streaming_tool">>,
            <<"arguments">> => #{
                <<"prompt">> => <<"test">>
            },
            <<"_meta">> => #{
                <<"progressToken">> => <<"token123">>,
                <<"progress">> => 0
            }
        }
    ),

    %% Verify request structure
    {ok, DecodedReq} = erlmcp_json_rpc:decode_message(ToolCallRequest),
    ?assertMatch(#json_rpc_request{id = 1}, DecodedReq),

    %% Create streaming response with progress
    StreamingResponse = erlmcp_json_rpc:encode_response(
        1,
        #{
            <<"content">> => [
                #{
                    <<"type">> => <<"text">>,
                    <<"text">> => <<"Partial result">>
                }
            ],
            <<"_meta">> => #{
                <<"progressToken">> => <<"token123">>,
                <<"progress">> => 50
            }
        }
    ),

    %% Verify streaming response structure
    {ok, DecodedResp} = erlmcp_json_rpc:decode_message(StreamingResponse),
    ?assertMatch(#json_rpc_response{id = 1}, DecodedResp),

    {comment, "Tool call streaming response validated"}.

tool_call_cancellation(_Config) ->
    %% Test tool call cancellation
    %% Spec: Clients MAY cancel in-progress tool calls

    %% Create tool call request
    ToolCallRequest = erlmcp_json_rpc:encode_request(
        1,
        <<"tools/call">>,
        #{
            <<"name">> => <<"long_running_tool">>,
            <<"arguments">> => #{}
        }
    ),

    %% Verify request structure
    {ok, DecodedReq} = erlmcp_json_rpc:decode_message(ToolCallRequest),
    ?assertMatch(#json_rpc_request{id = 1}, DecodedReq),

    %% Simulate cancellation response
    CancelResponse = erlmcp_json_rpc:encode_response(
        1,
        #{
            <<"content">> => [],
            <<"isCancelled">> => true
        }
    ),

    %% Verify cancellation response
    {ok, DecodedResp} = erlmcp_json_rpc:decode_message(CancelResponse),
    ?assertMatch(#json_rpc_response{id = 1}, DecodedResp),

    {comment, "Tool call cancellation validated"}.

tool_with_nested_schemas(_Config) ->
    %% Test tool with nested input schemas
    %% Spec: Tools MAY use complex JSON Schema for validation

    %% Create tools/list response with nested schema
    ToolsListResponse = erlmcp_json_rpc:encode_response(
        1,
        #{
            <<"tools">> => [
                #{
                    <<"name">> => <<"nested_schema_tool">>,
                    <<"description">> => <<"Tool with nested schema">>,
                    <<"inputSchema">> => #{
                        <<"type">> => <<"object">>,
                        <<"properties">> => #{
                            <<"config">> => #{
                                <<"type">> => <<"object">>,
                                <<"properties">> => #{
                                    <<"nested">> => #{
                                        <<"type">> => <<"string">>
                                    }
                                },
                                <<"required">> => [<<"nested">>]
                            }
                        },
                        <<"required">> => [<<"config">>]
                    }
                }
            ]
        }
    ),

    %% Verify response structure
    {ok, DecodedResp} = erlmcp_json_rpc:decode_message(ToolsListResponse),
    ?assertMatch(#json_rpc_response{id = 1}, DecodedResp),

    {comment, "Tool with nested schemas validated"}.

tool_error_propagation(_Config) ->
    %% Test error propagation in tool calls
    %% Spec: Tools MUST return proper error codes on failure

    %% Call non-existent tool - should get error
    ToolCallRequest = erlmcp_json_rpc:encode_request(
        1,
        <<"tools/call">>,
        #{
            <<"name">> => <<"non_existent_tool">>,
            <<"arguments">> => #{}
        }
    ),

    %% Verify request structure
    {ok, DecodedReq} = erlmcp_json_rpc:decode_message(ToolCallRequest),
    ?assertMatch(#json_rpc_request{id = 1}, DecodedReq),

    %% Create error response for tool not found
    ErrorResponse = erlmcp_json_rpc:error_tool_not_found(
        1,
        <<"non_existent_tool">>
    ),

    %% Verify error response structure
    DecodedErrorBin = jsx:decode(ErrorResponse, [return_maps]),
    ?assertEqual(<<"2.0">>, maps:get(<<"jsonrpc">>, DecodedErrorBin)),
    ?assertEqual(1, maps:get(<<"id">>, DecodedErrorBin)),
    ?assert(maps:is_key(<<"error">>, DecodedErrorBin)),

    ErrorObj = maps:get(<<"error">>, DecodedErrorBin),
    ErrorCode = maps:get(<<"code">>, ErrorObj),

    %% Verify error code is in valid range (-32002 for tool not found)
    ?assertEqual(-32002, ErrorCode),

    {comment, "Tool error propagation validated"}.

%%====================================================================
%% Resources API Edge Cases Tests
%%====================================================================

resource_uri_canonicalization(_Config) ->
    %% Test resource URI canonicalization
    %% Spec: URIs MUST be properly formatted and canonicalized

    %% Test various URI formats
    URIs = [
        <<"file:///test.txt">>,
        <<"file:///test/../test.txt">>,
        <<"file:///./test.txt">>
    ],

    lists:foreach(fun(URI) ->
        %% Create resource read request
        ReadRequest = erlmcp_json_rpc:encode_request(
            1,
            <<"resources/read">>,
            #{<<"uri">> => URI}
        ),

        %% Verify request structure
        {ok, DecodedReq} = erlmcp_json_rpc:decode_message(ReadRequest),
        ?assertMatch(#json_rpc_request{id = 1}, DecodedReq),

        %% Verify URI is in params
        #json_rpc_request{params = Params} = DecodedReq,
        ?assertEqual(URI, maps:get(<<"uri">>, Params))
    end, URIs),

    {comment, "Resource URI canonicalization validated"}.

resource_subscription_limits(_Config) ->
    %% Test resource subscription limits
    %% Spec: Servers MAY limit number of active subscriptions

    %% Create resource subscribe request
    SubscribeRequest = erlmcp_json_rpc:encode_request(
        1,
        <<"resources/subscribe">>,
        #{<<"uri">> => <<"file:///test.txt">>}
    ),

    %% Verify request structure
    {ok, DecodedReq} = erlmcp_json_rpc:decode_message(SubscribeRequest),
    ?assertMatch(#json_rpc_request{id = 1}, DecodedReq),

    %% Create success response
    SuccessResponse = erlmcp_json_rpc:encode_response(
        1,
        #{}
    ),

    %% Verify response structure
    {ok, DecodedResp} = erlmcp_json_rpc:decode_message(SuccessResponse),
    ?assertMatch(#json_rpc_response{id = 1}, DecodedResp),

    {comment, "Resource subscription limits validated"}.

resource_streaming(_Config) ->
    %% Test resource streaming for large resources
    %% Spec: Servers MAY stream large resources

    %% Create resource read request
    ReadRequest = erlmcp_json_rpc:encode_request(
        1,
        <<"resources/read">>,
        #{<<"uri">> => <<"file:///large_resource.txt">>}
    ),

    %% Verify request structure
    {ok, DecodedReq} = erlmcp_json_rpc:decode_message(ReadRequest),
    ?assertMatch(#json_rpc_request{id = 1}, DecodedReq),

    %% Create response with large content
    LargeContent = list_to_binary([<<"data">> || _ <- lists:seq(1, 1000)]),
    ReadResponse = erlmcp_json_rpc:encode_response(
        1,
        #{
            <<"contents">> => [
                #{
                    <<"uri">> => <<"file:///large_resource.txt">>,
                    <<"mime_type">> => <<"text/plain">>,
                    <<"text">> => LargeContent
                }
            ]
        }
    ),

    %% Verify response structure
    {ok, DecodedResp} = erlmcp_json_rpc:decode_message(ReadResponse),
    ?assertMatch(#json_rpc_response{id = 1}, DecodedResp),

    {comment, "Resource streaming validated"}.

resource_change_detection(_Config) ->
    %% Test resource change detection via subscriptions
    %% Spec: Servers MUST notify subscribers of resource changes

    %% Create resource subscribe request
    SubscribeRequest = erlmcp_json_rpc:encode_request(
        1,
        <<"resources/subscribe">>,
        #{<<"uri">> => <<"file:///test.txt">>}
    ),

    %% Verify request structure
    {ok, DecodedReq} = erlmcp_json_rpc:decode_message(SubscribeRequest),
    ?assertMatch(#json_rpc_request{id = 1}, DecodedReq),

    %% Create resource changed notification
    ChangedNotif = erlmcp_json_rpc:encode_notification(
        <<"notifications/resources/list_changed">>,
        #{}
    ),

    %% Verify notification structure
    {ok, DecodedNotif} = erlmcp_json_rpc:decode_message(ChangedNotif),
    ?assertMatch(#json_rpc_notification{method = <<"notifications/resources/list_changed">>}, DecodedNotif),

    {comment, "Resource change detection validated"}.

%%====================================================================
%% Prompts API Edge Cases Tests
%%====================================================================

prompt_template_inheritance(_Config) ->
    %% Test prompt template inheritance
    %% Spec: Prompt templates MAY extend base templates

    %% Create prompts/list response with templates
    PromptsListResponse = erlmcp_json_rpc:encode_response(
        1,
        #{
            <<"prompts">> => [
                #{
                    <<"name">> => <<"base_prompt">>,
                    <<"description">> => <<"Base template">>,
                    <<"arguments">> => []
                },
                #{
                    <<"name">> => <<"extended_prompt">>,
                    <<"description">> => <<"Extended template">>,
                    <<"arguments">> => [
                        #{
                            <<"name">> => <<"topic">>,
                            <<"description">> => <<"Topic to discuss">>,
                            <<"required">> => true
                        }
                    ]
                }
            ]
        }
    ),

    %% Verify response structure
    {ok, DecodedResp} = erlmcp_json_rpc:decode_message(PromptsListResponse),
    ?assertMatch(#json_rpc_response{id = 1}, DecodedResp),

    {comment, "Prompt template inheritance validated"}.

prompt_argument_validation(_Config) ->
    %% Test prompt argument validation
    %% Spec: Required arguments MUST be provided

    %% Create prompts/get request with arguments
    GetPromptRequest = erlmcp_json_rpc:encode_request(
        1,
        <<"prompts/get">>,
        #{
            <<"name">> => <<"test_prompt">>,
            <<"arguments">> => #{
                <<"topic">> => <<"Erlang">>
            }
        }
    ),

    %% Verify request structure
    {ok, DecodedReq} = erlmcp_json_rpc:decode_message(GetPromptRequest),
    ?assertMatch(#json_rpc_request{id = 1}, DecodedReq),

    %% Create success response
    PromptResponse = erlmcp_json_rpc:encode_response(
        1,
        #{
            <<"messages">> => [
                #{
                    <<"role">> => <<"user">>,
                    <<"content"> => #{
                        <<"type">> => <<"text">>,
                        <<"text">> => <<"Tell me about Erlang">>
                    }
                }
            ]
        }
    ),

    %% Verify response structure
    {ok, DecodedResp} = erlmcp_json_rpc:decode_message(PromptResponse),
    ?assertMatch(#json_rpc_response{id = 1}, DecodedResp),

    {comment, "Prompt argument validation validated"}.

prompt_completion(_Config) ->
    %% Test prompt completion/templating
    %% Spec: Servers MAY support prompt completion

    %% Create prompts/get request with arguments
    GetPromptRequest = erlmcp_json_rpc:encode_request(
        1,
        <<"prompts/get">>,
        #{
            <<"name">> => <<"test_prompt">>,
            <<"arguments">> => #{
                <<"topic">> => <<"Erlang">>,
                <<"depth">> => <<"detailed">>
            }
        }
    ),

    %% Verify request structure
    {ok, DecodedReq} = erlmcp_json_rpc:decode_message(GetPromptRequest),
    ?assertMatch(#json_rpc_request{id = 1}, DecodedReq),

    %% Create completed prompt response
    PromptResponse = erlmcp_json_rpc:encode_response(
        1,
        #{
            <<"messages">> => [
                #{
                    <<"role">> => <<"user">>,
                    <<"content">> => #{
                        <<"type">> => <<"text">>,
                        <<"text">> => <<"Explain Erlang in detail">>
                    }
                }
            ]
        }
    ),

    %% Verify response structure
    {ok, DecodedResp} = erlmcp_json_rpc:decode_message(PromptResponse),
    ?assertMatch(#json_rpc_response{id = 1}, DecodedResp),

    {comment, "Prompt completion validated"}.

prompt_template_versioning(_Config) ->
    %% Test prompt template versioning
    %% Spec: Prompts MAY include version information

    %% Create prompts/list response with versioned prompts
    PromptsListResponse = erlmcp_json_rpc:encode_response(
        1,
        #{
            <<"prompts">> => [
                #{
                    <<"name">> => <<"versioned_prompt">>,
                    <<"description">> => <<"Versioned template">>,
                    <<"version">> => <<"2.0">>,
                    <<"arguments">> => []
                }
            ]
        }
    ),

    %% Verify response structure
    {ok, DecodedResp} = erlmcp_json_rpc:decode_message(PromptsListResponse),
    ?assertMatch(#json_rpc_response{id = 1}, DecodedResp),

    {comment, "Prompt template versioning validated"}.

%%====================================================================
%% Negative Test Cases
%%====================================================================

invalid_json_handling(_Config) ->
    %% Test handling of invalid JSON
    %% Spec: Invalid JSON MUST return parse error (-32700)

    %% Try to decode invalid JSON
    InvalidJson = <<"{invalid json}">>,

    case erlmcp_json_rpc:decode_message(InvalidJson) of
        {error, {parse_error, _}} ->
            %% Expected error
            ok;
        {error, _} ->
            %% Other error is also acceptable
            ok;
        {ok, _} ->
            ct:fail("Should have gotten parse error for invalid JSON")
    end,

    %% Verify parse error response can be created
    ParseErrorResponse = erlmcp_json_rpc:error_parse(1),
    DecodedError = jsx:decode(ParseErrorResponse, [return_maps]),

    %% Verify error structure
    ?assertEqual(<<"2.0">>, maps:get(<<"jsonrpc">>, DecodedError)),
    ?assertEqual(1, maps:get(<<"id">>, DecodedError)),
    ?assert(maps:is_key(<<"error">>, DecodedError)),

    ErrorObj = maps:get(<<"error">>, DecodedError),
    ?assertEqual(-32700, maps:get(<<"code">>, ErrorObj)),

    {comment, "Invalid JSON handling validated"}.

malformed_requests(_Config) ->
    %% Test handling of malformed requests
    %% Spec: Malformed requests MUST return error

    %% Test 1: Missing required fields (no method)
    InvalidRequest1 = jsx:encode(#{
        <<"jsonrpc">> => <<"2.0">>,
        <<"id">> => 1
        %% Missing 'method' field
    }),

    case erlmcp_json_rpc:decode_message(InvalidRequest1) of
        {error, {invalid_request, _}} ->
            ok;
        {error, _} ->
            ok;
        _ ->
            ct:fail("Should reject request without method")
    end,

    %% Test 2: Wrong JSON-RPC version
    InvalidRequest2 = jsx:encode(#{
        <<"jsonrpc">> => <<"1.0">>,
        <<"method">> => <<"initialize">>,
        <<"id">> => 2
    }),

    case erlmcp_json_rpc:decode_message(InvalidRequest2) of
        {error, {invalid_request, _}} ->
            ok;
        {error, _} ->
            ok;
        _ ->
            ct:fail("Should reject wrong JSON-RPC version")
    end,

    %% Test 3: Invalid method name (should get method not found)
    MethodNotFoundResponse = erlmcp_json_rpc:error_method_not_found(
        3,
        <<"invalid!!!method">>
    ),

    DecodedError = jsx:decode(MethodNotFoundResponse, [return_maps]),
    ErrorObj = maps:get(<<"error">>, DecodedError),
    ?assertEqual(-32601, maps:get(<<"code">>, ErrorObj)),

    {comment, "Malformed requests handling validated"}.

protocol_violations(_Config) ->
    %% Test protocol violations
    %% Spec: Protocol violations MUST return appropriate errors

    %% Test 1: Invalid parameter types (string instead of object for params)
    InvalidParamsRequest = erlmcp_json_rpc:encode_request(
        1,
        <<"initialize">>,
        #{<<"protocolVersion">> => 12345}  %% Should be string
    ),

    %% Verify request can be decoded
    {ok, DecodedReq} = erlmcp_json_rpc:decode_message(InvalidParamsRequest),
    ?assertMatch(#json_rpc_request{id = 1}, DecodedReq),

    %% Create invalid params error response
    InvalidParamsResponse = erlmcp_json_rpc:error_invalid_params(
        1,
        #{<<"expected">> => <<"string">>, <<"got">> => <<"number">>}
    ),

    %% Verify error response structure
    DecodedError = jsx:decode(InvalidParamsResponse, [return_maps]),
    ErrorObj = maps:get(<<"error">>, DecodedError),
    ?assertEqual(-32602, maps:get(<<"code">>, ErrorObj)),

    {comment, "Protocol violations handling validated"}.

out_of_order_messages(_Config) ->
    %% Test out-of-order message handling
    %% Spec: Out-of-order messages SHOULD be handled gracefully

    %% Send initialized notification before initialize
    InitializedNotif = erlmcp_json_rpc:encode_notification(
        <<"notifications/initialized">>,
        #{}
    ),

    %% Verify notification structure
    {ok, DecodedNotif} = erlmcp_json_rpc:decode_message(InitializedNotif),
    ?assertMatch(#json_rpc_notification{method = <<"notifications/initialized">>}, DecodedNotif),

    %% Now send initialize (out of order)
    InitRequest = erlmcp_json_rpc:encode_request(
        1,
        <<"initialize">>,
        #{
            <<"protocolVersion">> => <<"2025-11-25">>,
            <<"capabilities">> => #{},
            <<"clientInfo">> => #{
                <<"name">> => <<"test-client">>,
                <<"version">> => <<"1.0.0">>
            }
        }
    ),

    %% Verify initialize request structure (server may accept or reject)
    {ok, DecodedInit} = erlmcp_json_rpc:decode_message(InitRequest),
    ?assertMatch(#json_rpc_request{id = 1}, DecodedInit),

    %% Create not initialized error response
    NotInitializedResponse = erlmcp_json_rpc:error_not_initialized(1),
    DecodedError = jsx:decode(NotInitializedResponse, [return_maps]),

    ErrorObj = maps:get(<<"error">>, DecodedError),
    ?assertEqual(-32004, maps:get(<<"code">>, ErrorObj)),

    {comment, "Out-of-order message handling validated"}.
