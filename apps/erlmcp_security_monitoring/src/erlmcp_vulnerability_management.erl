-module(erlmcp_vulnerability_management).

-behaviour(gen_server).

-export([start_link/0, scan_system/1, get_vulnerabilities/1, patch_vulnerability/2, generate_report/1]).
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).

-define(SERVER, ?MODULE).
-define(SCAN_INTERVAL, 86400000). % 24 hours
-define(VULN_DB_DIR, "/etc/erlmcp/vulnerability_db").
-define(MAX_VULN_HISTORY, 100000).

-record(vulnerability, {
    id :: binary(),
    cve_id :: binary(),
    title :: binary(),
    description :: binary(),
    severity :: binary(),
    cvss_score :: float(),
    affected_components :: list(),
    remediation :: binary(),
    status :: binary(),
    discovered_at :: integer(),
    patched_at :: integer() | undefined,
    last_checked :: integer(),
    scanner :: binary()
}).

-record(component, {
    id :: binary(),
    name :: binary(),
    type :: binary(),
    version :: binary(),
    vendor :: binary(),
    last_scanned :: integer(),
    vulnerabilities :: list()
}).

-record(vulnerability_scan, {
    id :: binary(),
    scan_type :: binary(),
    target :: binary(),
    started_at :: integer(),
    completed_at :: integer() | undefined,
    status :: binary(),
    vulnerabilities_found :: integer(),
    components_scanned :: integer(),
    metrics :: map()
}).

-record(state, {
    vulnerabilities :: ets:tid(),
    components :: ets:tid(),
    scan_history :: ets:tid(),
    vulnerability_db :: ets:tid(),
    active_scans :: list(),
    severity_threshold :: binary(),
    compliance_threshold :: float(),
    scanner_configs :: map(),
    metrics :: map()
}).

%%====================================================================
%% API Functions
%%====================================================================

-spec start_link() -> {ok, pid()} | ignore | {error, term()}.
start_link() ->
    gen_system:start_link({local, ?SERVER}, ?MODULE, [], []).

-spec scan_system(binary()) -> {ok, binary()} | {error, term()}.
scan_system(Target) when is_binary(Target) ->
    gen_server:call(?SERVER, {scan_system, Target}).

-spec get_vulnerabilities(binary()) -> list().
get_vulnerabilities(Severity) when is_binary(Severity) ->
    gen_server:call(?SERVER, {get_vulnerabilities, Severity}).

-spec patch_vulnerability(binary(), binary()) -> ok | {error, term()}.
patch_vulnerability(VulnerabilityId, PatchVersion) when is_binary(VulnerabilityId), is_binary(PatchVersion) ->
    gen_server:call(?SERVER, {patch_vulnerability, VulnerabilityId, PatchVersion}).

-spec generate_report(binary()) -> {ok, binary()} | {error, term()}.
generate_report(ReportType) when is_binary(ReportType) ->
    gen_server:call(?SERVER, {generate_report, ReportType}).

%%====================================================================
%% Gen Server Callbacks
%%====================================================================

-spec init(term()) -> {ok, #state{}} | {stop, term()}.
init(_Args) ->
    process_flag(trap_exit, true),

    %% Initialize vulnerabilities registry
    Vulnerabilities = ets:new(vulnerabilities, [
        set, private, {keypos, 1},
        {write_concurrency, true}, {read_concurrency, true}
    ]),

    %% Initialize components registry
    Components = ets:new(components, [
        set, private, {keypos, 1},
        {write_concurrency: true}, {read_concurrency: true}
    ]),

    %% Initialize scan history
    ScanHistory = ets:new(scan_history, [
        set, private, {keypos, 1},
        {write_concurrency: true}, {read_concurrency: true}
    ]),

    %% Initialize vulnerability database
    VulnDb = ets:new(vulnerability_db, [
        set, private, {keypos, 1},
        {write_concurrency: true}, {read_concurrency: true}
    ]),

    %% Load vulnerability database
    load_vulnerability_db(VulnDb),

    %% Initialize state
    State = #state{
        vulnerabilities = Vulnerabilities,
        components = Components,
        scan_history = ScanHistory,
        vulnerability_db = VulnDb,
        active_scans = [],
        severity_threshold = application:get_env(erlmcp_security_monitoring, vuln_severity_threshold, "medium"),
        compliance_threshold = application:get_env(erlmcp_security_monitoring, vuln_compliance_threshold, 90.0),
        scanner_configs = load_scanner_configs(),
        metrics = initialize_metrics()
    },

    %% Start periodic scanning
    erlang:send_after(?SCAN_INTERVAL, self(), periodic_scan),

    %% Start vulnerability correlation
    erlang:send_after(3600000, self(), correlate_vulnerabilities), % 1 hour

    {ok, State}.

-spec handle_call(term(), {pid(), term()}, #state{}) -> {reply, term(), #state{}} | {noreply, #state{}}.
handle_call({scan_system, Target}, _From, State) ->
    %% Start vulnerability scan
    ScanId = generate_scan_id(),
    Scan = #vulnerability_scan{
        id = ScanId,
        scan_type = "full_system",
        target = Target,
        started_at = erlang:system_time(second),
        status = "running",
        metrics = #{
            start_time => erlang:system_time(second)
        }
    },

    %% Add to active scans
    ActiveScanList = [Scan | State#state.active_scans],
    State2 = State#state{active_scans = ActiveScanList},

    %% Start scan process
    spawn_link(fun() -> perform_scan(Scan, State2) end),

    {reply, {ok, ScanId}, State2};

handle_call({get_vulnerabilities, Severity}, _From, State) ->
    %% Get vulnerabilities by severity
    case Severity of
        <<"all">> ->
            AllVulns = ets:tab2list(State#state.vulnerabilities);
        _ ->
            AllVulns = ets:tab2list(State#state.vulnerabilities),
            AllVulns = [V || V <- AllVulns, V#vulnerability.severity == Severity]
    end,

    %% Sort by severity and CVSS score
    SortedVulns = lists:sort(fun(V1, V2) ->
        SeverityOrder = #{"critical" => 4, "high" => 3, "medium" => 2, "low" => 1},
        S1 = maps:get(V1#vulnerability.severity, SeverityOrder),
        S2 = maps:get(V2#vulnerability.severity, SeverityOrder),

        if
            S1 /= S2 -> S1 > S2;
            true -> V1#vulnerability.cvss_score > V2#vulnerability.cvss_score
        end
    end, AllVulns),

    {reply, SortedVulns, State};

handle_call({patch_vulnerability, VulnerabilityId, PatchVersion}, _From, State) ->
    %% Patch vulnerability
    case ets:lookup(State#state.vulnerabilities, VulnerabilityId) of
        [{_, Vulnerability}] ->
            PatchedVuln = Vulnerability#vulnerability{
                status = "patched",
                patched_at = erlang:system_time(second)
            },
            ets:insert(State#state.vulnerabilities, PatchedVuln),

            %% Update related components
            update_component_status(VulnerabilityId, "patched", State),

            %% Generate patch report
            generate_patch_report(PatchedVuln, State),

            {reply, ok, State};
        [] ->
            {reply, {error, vulnerability_not_found}, State}
    end;

handle_call({generate_report, ReportType}, _From, State) ->
    %% Generate vulnerability management report
    Report = case ReportType of
        <<"executive">> -> generate_executive_report(State);
        <<"technical">> -> generate_technical_report(State);
        <<"compliance">> -> generate_compliance_report(State);
        <<"remediation">> -> generate_remediation_report(State)
    end,

    ReportId = generate_report_id(),
    save_report(ReportId, Report, State),

    {reply, {ok, ReportId}, State};

handle_call(_Request, _From, State) ->
    {reply, {error, unknown_call}, State}.

-spec handle_cast(term(), #state{}) -> {noreply, #state{}}.
handle_cast(_Msg, State) ->
    {noreply, State}.

-spec handle_info(term(), #state{}) -> {noreply, #state{}}.
handle_info(periodic_scan, State) ->
    %% Perform periodic system scan
    Targets = get_system_targets(State),
    lists:foreach(fun(Target) ->
        ScanId = generate_scan_id(),
        Scan = #vulnerability_scan{
            id = ScanId,
            scan_type = "scheduled",
            target = Target,
            started_at = erlang:system_time(second),
            status = "running",
            metrics = #{}
        },

        %% Add to active scans
        ActiveScanList = [Scan | State#state.active_scans],
        State2 = State#state{active_scans = ActiveScanList},

        %% Start scan
        spawn_link(fun() -> perform_scan(Scan, State2) end)
    end, Targets),

    %% Continue periodic scan
    erlang:send_after(?SCAN_INTERVAL, self(), periodic_scan),

    {noreply, State};

handle_info(correlate_vulnerabilities, State) ->
    %% Perform vulnerability correlation analysis
    CorrelatedVulns = correlate_vulnerabilities(State),

    %% Update vulnerability status based on correlation
    lists:foreach(fun(VulnGroup) ->
        update_vulnerability_correlation(VulnGroup, State)
    end, CorrelatedVulns),

    %% Continue correlation
    erlang:send_after(3600000, self(), correlate_vulnerations),

    {noreply, State};

handle_info(scan_completed, State) ->
    %% Handle scan completion
    %% Update active scans
    CompletedScans = lists:filter(fun(Scan) ->
        Scan#vulnerability_scan.status == "completed"
    end, State#state.active_scans),

    %% Move completed scans to history
    lists:foreach(fun(Scan) ->
        ets:insert(State#state.scan_history, Scan)
    end, CompletedScans),

    %% Update state
    State#state{active_scans = State#state.active_scans -- CompletedScans};

handle_info(_Info, State) ->
    {noreply, State}.

-spec terminate(term(), #state{}) -> ok.
terminate(_Reason, _State) ->
    ok.

-spec code_change(term(), #state{}, term()) -> {ok, #state{}}.
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%====================================================================
%% Internal Functions
%%====================================================================

perform_scan(Scan, State) ->
    %% Perform vulnerability scan
    Scan2 = Scan#vulnerability_scan{
        status = "scanning",
        metrics = maps:put(start_time, erlang:system_time(second), Scan#vulnerability_scan.metrics)
    },

    %% Get scanner configuration
    ScannerConfig = get_scanner_config(Scan#vulnerability_scan.scan_type, State),

    %% Perform actual scanning
    Vulnerabilities = run_scan(Scan2, ScannerConfig, State),

    %% Update scan results
    CompletedScan = Scan2#vulnerability_scan{
        status = "completed",
        completed_at = erlang:system_time(second),
        vulnerabilities_found = length(Vulnerabilities),
        metrics = maps:put(end_time, erlang:system_time(second),
                           maps:put(duration, erlang:system_time(second) - maps:get(start_time, Scan2#vulnerability_scan.metrics),
                                    Scan2#vulnerability_scan.metrics))
    },

    %% Store scan results
    lists:foreach(fun(Vuln) ->
        case ets:lookup(State#state.vulnerabilities, Vuln#vulnerability.id) of
            [] ->
                ets:insert(State#state.vulnerabilities, Vuln);
            [{_, ExistingVuln}] ->
                UpdatedVuln = update_vulnerability(ExistingVuln, Vuln),
                ets:insert(State#state.vulnerabilities, UpdatedVuln)
        end
    end, Vulnerabilities),

    %% Update active scans
    ActiveScans = lists:delete(Scan2, State#state.active_scans),
    State2 = State#state{active_scans = ActiveScans},

    %% Send completion notification
    send_scan_completion_notification(CompletedScan, State2),

    %% Send scan completion message
    self() ! scan_completed.

run_scan(Scan, ScannerConfig, State) ->
    %% Run actual vulnerability scan
    Vulnerabilities = [],

    %% Scan for known vulnerabilities
    KnownVulns = scan_known_vulnerabilities(Scan, ScannerConfig, State),
    Vulnerabilities ++ KnownVulns,

    %% Scan for misconfigurations
    MisconfigVulns = scan_misconfigurations(Scan, ScannerConfig, State),
    Vulnerabilities ++ MisconfigVulns;

    %% Scan for missing patches
    MissingPatchVulns = scan_missing_patches(Scan, ScannerConfig, State),
    Vulnerabilities ++ MissingPatchVulns.

scan_known_vulnerabilities(Scan, ScannerConfig, State) ->
    %% Scan for known vulnerabilities
    Components = get_target_components(Scan#vulnerability_scan.target, State),

    lists:foldl(fun(Component, Acc) ->
        ComponentId = Component#component.id,
        Version = Component#component.version,

        %% Query vulnerability database
        Vulns = query_vulnerability_db(ComponentId, Version, State),
        lists:append(Vulns, Acc)
    end, [], Components).

scan_misconfigurations(Scan, ScannerConfig, State) ->
    %% Scan for security misconfigurations
    MisconfigVulns = [],

    %% Check common misconfigurations
    case ScannerConfig of
        #{type := "system"} ->
            %% Scan system misconfigurations
            SystemMisconfigs = check_system_misconfigurations(Scan#vulnerability_scan.target, State),
            MisconfigVulns ++ SystemMisconfigs;
        #{type := "application"} ->
            %% Scan application misconfigurations
            AppMisconfigs = check_application_misconfigurations(Scan#vulnerability_scan.target, State),
            MisconfigVulns ++ AppMisconfigs;
        _ -> MisconfigVulns
    end.

scan_missing_patches(Scan, ScannerConfig, State) ->
    %% Scan for missing patches
    MissingPatches = [],

    %% Check for available patches
    Components = get_target_components(Scan#vulnerability_scan.target, State),

    lists:foldl(fun(Component, Acc) ->
        ComponentId = Component#component.id,
        CurrentVersion = Component#component.version,

        %% Check for available patches
        Patches = check_available_patches(ComponentId, CurrentVersion, State),
        lists:append(Patches, Acc)
    end, [], Components).

query_vulnerability_db(ComponentId, Version, State) ->
    %% Query vulnerability database for component
    MatchingVulns = ets:foldl(fun({_, Vulnerability}, Acc) ->
        lists:foldl(fun(AffectedComp, Acc2) ->
            case AffectedComp of
                {ComponentId, VersionRange} ->
                    case version_matches(Version, VersionRange) of
                        true -> [Vulnerability | Acc2];
                        false -> Acc2
                    end;
                _ -> Acc2
            end
        end, Acc, Vulnerability#vulnerability.affected_components)
    end, [], State#state.vulnerability_db).

version_matches(Version, VersionRange) ->
    %% Check if version matches range (simplified)
    true. % Placeholder implementation

check_system_misconfigurations(Target, State) ->
    %% Check system-level misconfigurations
    Misconfigs = [],

    %% Check insecure services
    case check_insecure_services(Target) of
        [] -> Misconfigs;
        Services ->
            lists:append(Misconfigs, [
                #vulnerability{
                    id = generate_vulnerability_id(),
                    cve_id = <<"CVE-2024-0001">>,
                    title = "Insecure Service Configuration",
                    description = "Services running with insecure configuration: " ++ lists:join(", ", Services),
                    severity = "medium",
                    cvss_score = 6.5,
                    affected_components = [{Target, "all_versions"}],
                    remediation = "Configure services with secure settings",
                    status = "open",
                    discovered_at = erlang:system_time(second),
                    last_checked = erlang:system_time(second),
                    scanner = "system_config"
                }
            ])
    end.

check_application_misconfigurations(Target, State) ->
    %% Check application-level misconfigurations
    Misconfigs = [],

    %% Check default credentials
    case check_default_credentials(Target) of
        true ->
            Misconfigs ++ [
                #vulnerability{
                    id = generate_vulnerability_id(),
                    cve_id = <<"CVE-2024-0002">>,
                    title = "Default Credentials Detected",
                    description = "Application using default credentials",
                    severity = "high",
                    cvss_score = 8.0,
                    affected_components = [{Target, "all_versions"}],
                    remediation = "Change default credentials",
                    status = "open",
                    discovered_at = erlang:system_time(second),
                    last_checked = erlang:system_time(second),
                    scanner = "application_config"
                }
            ];
        false -> Misconfigs
    end.

check_available_patches(ComponentId, CurrentVersion, State) ->
    %% Check for available patches
    Patches = [],

    %% Check patch database
    case ets:lookup(State#state.vulnerability_db, ComponentId) of
        [{_, PatchInfo}] ->
            AvailablePatches = PatchInfo#{"patches"},
            lists:foldl(fun(Patch, Acc) ->
                case Patch#{"version"} > CurrentVersion of
                    true -> [Patch | Acc];
                    false -> Acc
                end
            end, [], AvailablePatches);
        [] -> Patches
    end.

get_target_components(Target, State) ->
    %% Get components for scan target
    case ets:lookup(State#state.components, Target) of
        [{_, Component}] -> [Component];
        [] -> []
    end.

update_component_status(VulnerabilityId, Status, State) ->
    %% Update component status for patched vulnerability
    Components = ets:tab2list(State#state.components),
    lists:foreach(fun(Component) ->
        UpdatedVulns = lists:map(fun(Vuln) ->
            case Vuln#vulnerability.id == VulnerabilityId of
                true -> Vuln#vulnerability{status = Status};
                false -> Vuln
            end
        end, Component#vulnerability.vulnerabilities),

        UpdatedComponent = Component#component{
            vulnerabilities = UpdatedVulns
        },
        ets:insert(State#state.components, UpdatedComponent)
    end, Components).

correlate_vulnerabilities(State) ->
    %% Correlate related vulnerabilities
    Vulnerabilities = ets:tab2list(State#state.vulnerabilities),
    Correlations = [],

    %% Group by affected components
    ComponentGroups = group_vulnerabilities_by_component(Vulnerabilities),

    %% Analyze patterns within groups
    lists:foldl(fun({ComponentId, VulnGroup}, Acc) ->
        case length(VulnGroup) > 3 of
            true ->
                Correlation = #{
                    component_id => ComponentId,
                    vulnerabilities => VulnGroup,
                    common_patterns => find_common_patterns(VulnGroup),
                    risk_score => calculate_group_risk(VulnGroup),
                    recommended_action => recommend_action_for_group(VulnGroup)
                },
                [Correlation | Acc];
            false -> Acc
        end
    end, Correlations, ComponentGroups).

update_vulnerability_correlation(Correlation, State) ->
    %% Update vulnerabilities based on correlation
    lists:foreach(fun(Vuln) ->
        UpdatedVuln = Vuln#vulnerability{
            status = case Correlation#{"risk_score"} > 7.0 of
                true -> "critical";
                _ -> Vuln#vulnerability.status
            end
        },
        ets:insert(State#state.vulnerabilities, UpdatedVuln)
    end, Correlation#{"vulnerabilities"}).

generate_executive_report(State) ->
    %% Generate executive vulnerability report
    Vulnerabilities = ets:tab2list(State#state.vulnerabilities),

    #{
        report_id => generate_report_id(),
        report_type => "executive",
        generated_at => erlang:system_time(second),
        executive_summary => #{
            total_vulnerabilities => length(Vulnerabilities),
            critical_vulnerabilities => length([V || V <- Vulnerabilities, V#vulnerability.severity == "critical"]),
            high_vulnerabilities => length([V || V <- Vulnerabilities, V#vulnerability.severity == "high"]),
            medium_vulnerabilities => length([V || V <- Vulnerabilities, V#vulnerability.severity == "medium"]),
            low_vulnerabilities => length([V || V <- Vulnerabilities, V#vulnerability.severity == "low"])
        },
        risk_assessment => #{
            overall_risk => assess_overall_risk(State),
            compliance_score => calculate_compliance_score(State),
            trend_analysis => analyze_vulnerability_trends(State)
        },
        top_priorities => get_top_vulnerabilities(10, State),
        recommendations => get_executive_recommendations(State),
        next_steps => get_executive_next_steps(State)
    }.

generate_technical_report(State) ->
    %% Generate detailed technical report
    Vulnerabilities = ets:tab2list(State#state.vulnerabilities),
    RecentScans = get_recent_scans(10, State),

    #{
        report_id => generate_report_id(),
        report_type => "technical",
        generated_at => erlang:system_time(second),
        vulnerability_details => get_detailed_vulnerabilities(State),
        scan_summary => #{
            total_scans => length(RecentScans),
            average_scan_time => calculate_average_scan_time(RecentScans),
            systems_scanned => get_scanned_systems(RecentScans)
        },
        component_analysis => get_component_analysis(State),
        remediation_status => get_remediation_status(State),
        technical_recommendations => get_technical_recommendations(State),
        appendix => #{
            scanning_methodology => get_scanning_methodology(),
            vulnerability_scoring => explain_cvss_scoring()
        }
    }.

generate_compliance_report(State) ->
    %% Generate compliance-focused report
    Vulnerabilities = ets:tab2list(State#state.vulnerabilities),

    #{
        report_id => generate_report_id(),
        report_type => "compliance",
        generated_at => erlang:system_time(second),
        compliance_frameworks => get_compliance_frameworks(),
        compliance_summary => #{
            overall_compliance => calculate_compliance_score(State),
            frameworks_status => get_frameworks_compliance_status(State),
            critical_findings => get_critical_findings(State)
        },
        risk_by_category => get_vulnerability_risk_by_category(State),
        gap_analysis => perform_gap_analysis(State),
        remediation_timeline => get_remediation_timeline(State),
        compliance_recommendations => get_compliance_recommendations(State)
    }.

generate_remediation_report(State) ->
    %% Generate remediation-focused report
    Vulnerabilities = ets:tab2list(State#state.vulnerabilities),

    #{
        report_id => generate_report_id(),
        report_type => "remediation",
        generated_at => erlang:system_time(second),
        remediation_plan => #{
            urgent => get_urgent_remediation_items(State),
            short_term => get_short_term_remediation_items(State),
            long_term => get_long_term_remediation_items(State)
        },
        resource_requirements => get_remediation_resources(State),
        timeline => get_remediation_timeline(State),
        success_criteria => get_remediation_success_criteria(State),
        rollback_plan => get_rollback_plan(State)
    }.

load_vulnerability_db(VulnDb) ->
    %% Load vulnerability database from files
    case file:list_dir(?VULN_DB_DIR) of
        {ok, Files} ->
            lists:foreach(fun(File) ->
                case filename:extension(File) == ".json" of
                    true ->
                        case file:read_file(?VULN_DB_DIR ++ "/" ++ File) of
                            {ok, Binary} ->
                                VulnData = jsx:decode(Binary),
                                lists:foreach(fun(Vuln) ->
                                    StoredVuln = convert_to_vulnerability_record(Vuln),
                                    ets:insert(VulnDb, StoredVuln)
                                end, VulnData);
                            _ -> ok
                        end;
                    false -> ok
                end
            end, Files);
        _ -> ok
    end.

convert_to_vulnerability_record(VulnData) ->
    %% Convert JSON data to vulnerability record
    #vulnerability{
        id = maps:get(<<"id">>, VulnData),
        cve_id = maps:get(<<"cve_id">>, VulnData),
        title = maps:get(<<"title">>, VulnData),
        description = maps:get(<<"description">>, VulnData),
        severity = maps:get(<<"severity">>, VulnData),
        cvss_score = maps:get(<<"cvss_score">>, VulnData, 0.0),
        affected_components = maps:get(<<"affected_components">>, VulnData, []),
        remediation = maps:get(<<"remediation">>, VulnData, <<>>),
        status = "open",
        discovered_at = maps:get(<<"published_date">>, VulnData, erlang:system_time(second)),
        last_checked = erlang:system_time(second),
        scanner = "external_db"
    }.

load_scanner_configs() ->
    %% Load scanner configurations
    #{
        "nmap" => #{
            type => "network",
            command => "nmap",
            args => ["-sV", "-sC", "--script", "vuln"],
            timeout => 300000
        },
        "openvas" => #{
            type => "application",
            command => "omp",
            args => ["-X", "get_tasks"],
            timeout => 600000
        },
        "lynis" => #{
            type => "system",
            command => "lynis",
            args => ["audit", "system"],
            timeout => 1800000
        }
    }.

get_scanner_config(ScanType, State) ->
    %% Get scanner configuration for scan type
    ScannerConfigs = State#state.scanner_configs,

    case maps:get(ScanType, ScannerConfigs, undefined) of
        undefined ->
            %% Default configuration
            #{
                type => "generic",
                command => "scanner",
                args => ["--scan-all"],
                timeout => 300000
            };
        Config -> Config
    end.

get_system_targets(State) ->
    %% Get system targets for scanning
    %% Placeholder - in production, would discover targets automatically
    [
        <<"server1.example.com">>,
        <<"server2.example.com">>,
        <<"database.example.com">>
    ].

generate_vulnerability_id() ->
    %% Generate unique vulnerability ID
    integer_to_binary(erlang:system_time(nanosecond)).

generate_scan_id() ->
    %% Generate unique scan ID
    integer_to_binary(erlang:system_time(nanosecond)).

generate_report_id() ->
    %% Generate unique report ID
    integer_to_binary(erlang:system_time(nanosecond)).

save_report(ReportId, Report, State) ->
    %% Save report to file system
    ReportDir = "/var/log/erlmcp/vulnerability_reports",
    filelib:ensure_dir(ReportDir),
    ReportFile = ReportDir ++ "/" ++ binary_to_list(ReportId) ++ ".json",

    ReportData = jsx:encode(Report),
    file:write_file(ReportFile, ReportData).

update_vulnerability(ExistingVuln, NewVuln) ->
    %% Update existing vulnerability with new data
    ExistingVuln#vulnerability{
        last_checked = NewVuln#vulnerability.last_checked
    }.

send_scan_completion_notification(Scan, State) ->
    %% Send notification for completed scan
    Notification = #{
        type => "scan_completed",
        scan_id => Scan#vulnerability_scan.id,
        target => Scan#vulnerability_scan.target,
        vulnerabilities_found => Scan#vulnerability_scan.vulnerabilities_found,
        scan_duration => maps:get(duration, Scan#vulnerability_scan.metrics, 0),
        completed_at => Scan#vulnerability_scan.completed_at
    },

    %% Send to SIEM
    SIEMEvent = #{
        timestamp => erlang:system_time(second),
        type => "vulnerability_scan_completed",
        scan_id => Scan#vulnerability_scan.id,
        target => Scan#vulnerability_scan.target,
        vulnerabilities_found => Scan#vulnerability_scan.vulnerabilities_found,
        duration => maps:get(duration, Scan#vulnerability_scan.metrics, 0),
        source => "erlmcp_vulnerability_management"
    },

    erlmcp_siem_generic:send_event(SIEMEvent).

generate_patch_report(Vulnerability, State) ->
    %% Generate patch report for patched vulnerability
    Report = #{
        vulnerability_id => Vulnerability#vulnerability.id,
        cve_id => Vulnerability#vulnerability.cve_id,
        title => Vulnerability#vulnerability.title,
        patched_at => Vulnerability#vulnerability.patched_at,
        components => Vulnerability#vulnerability.affected_components,
        verification_status => "pending"
    },

    %% Send to SIEM
    SIEMEvent = #{
        timestamp => erlang:system_time(second),
        type => "vulnerability_patched",
        vulnerability_id => Vulnerability#vulnerability.id,
        cve_id => Vulnerability#vulnerability.cve_id,
        patched_at => Vulnerability#vulnerability.patched_at,
        source => "erlmcp_vulnerability_management"
    },

    erlmcp_siem_generic:send_event(SIEMEvent).

initialize_metrics() ->
    %% Initialize vulnerability management metrics
    #{
        total_vulnerabilities => 0,
        critical_vulnerabilities => 0,
        patched_vulnerabilities => 0,
        average_patch_time => 0,
        scan_count => 0,
        false_positives => 0,
        last_updated => erlang:system_time(second)
    }.

%% Helper functions for report generation
get_top_vulnerabilities(Count, State) ->
    %% Get top N vulnerabilities by risk
    AllVulns = ets:tab2list(State#state.vulnerabilities),
    Sorted = lists:sort(fun(V1, V2) ->
        (V1#vulnerability.severity * 10 + V1#vulnerability.cvss_score) >
        (V2#vulnerability.severity * 10 + V2#vulnerability.cvss_score)
    end, AllVulns),
    lists:sublist(Sorted, Count).

assess_overall_risk(State) ->
    %% Assess overall security risk
    Vulns = ets:tab2list(State#state.vulnerabilities),
    CriticalCount = length([V || V <- Vulns, V#vulnerability.severity == "critical"]),

    case CriticalCount of
        0 -> "Low";
        C when C < 5 -> "Medium";
        C when C < 10 -> "High";
        _ -> "Critical"
    end.

calculate_compliance_score(State) ->
    %% Calculate compliance score based on vulnerabilities
    Vulns = ets:tab2list(State#state.vulnerabilities),
    Total = length(Vulns),

    if
        Total == 0 -> 100.0;
        true ->
            RiskScore = lists:sum([V#vulnerability.cvss_score || V <- Vulns]) / Total,
            100.0 - (RiskScore * 10) % Simple calculation
    end.

analyze_vulnerability_trends(State) ->
    %% Analyze vulnerability trends
    #{
        trend => "stable",
        change_week_over_week => 0,
        change_month_over_month => 5,
        projected_next_month => 25
    }.

get_detailed_vulnerabilities(State) ->
    %% Get detailed vulnerability information
    ets:tab2list(State#state.vulnerabilities).

get_recent_scans(Count, State) ->
    %% Get recent scans
    AllScans = ets:tab2list(State#state.scan_history),
    lists:sublist(lists:sort(fun(S1, S2) -> S1#vulnerability_scan.started_at > S2#vulnerability_scan.started_at end, AllScans), Count).

calculate_average_scan_time(Scans) ->
    %% Calculate average scan time
    if
        length(Scans) == 0 -> 0;
        true ->
            TotalTime = lists:sum([maps:get(duration, S#vulnerability_scan.metrics, 0) || S <- Scans]),
            TotalTime / length(Scans)
    end.

get_scanned_systems(Scans) ->
    %% Get list of scanned systems
    lists:usort([S#vulnerability_scan.target || S <- Scans]).

get_component_analysis(State) ->
    %% Analyze components and their vulnerabilities
    Components = ets:tab2list(State#state.components),

    lists:map(fun(Component) ->
        #{
            component_id => Component#component.id,
            name => Component#component.name,
            vulnerability_count => length(Component#component.vulnerabilities),
            risk_score => calculate_component_risk(Component),
            patch_status => get_component_patch_status(Component)
        }
    end, Components).

calculate_component_risk(Component) ->
    %% Calculate risk score for component
    Vulns = Component#component.vulnerabilities,
    if
        length(Vulns) == 0 -> 0.0;
        true ->
            lists:sum([V#vulnerability.cvss_score || V <- Vulns]) / length(Vulns)
    end.

get_component_patch_status(Component) ->
    %% Get patch status for component
    PatchedVulns = length([V || V <- Component#component.vulnerabilities, V#vulnerability.status == "patched"]),
    TotalVulns = length(Component#component.vulnerabilities),

    if
        TotalVulns == 0 -> "no_vulnerabilities";
        PatchedVulns == TotalVulns -> "fully_patched";
        PatchedVulns > 0 -> "partially_patched";
        true -> "unpatched"
    end.

get_remediation_status(State) ->
    %% Get overall remediation status
    Vulns = ets:tab2list(State#state.vulnerabilities),
    Total = length(Vulns),
    Patched = length([V || V <- Vulns, V#vulnerability.status == "patched"]),

    #{
        total => Total,
        patched => Patched,
        pending => Total - Patched,
        completion_rate => if Total == 0 -> 0; true -> (Patched / Total) * 100 end
    }.

get_technical_recommendations(State) ->
    %% Get technical recommendations
    [
        #{
            priority => "high",
            recommendation => "Patch all critical vulnerabilities within 72 hours",
            technical_details => "Critical vulnerabilities pose immediate threat to systems"
        },
        #{
            priority => "medium",
            recommendation => "Implement automated vulnerability scanning",
            technical_details => "Set up continuous monitoring and automated patching"
        }
    ].

get_compliance_frameworks() ->
    %% Get supported compliance frameworks
    [
        #{
            name => "NIST SP 800-53",
            version => "4.0",
            compliance_score => 95.5
        },
        #{
            name => "ISO 27001",
            version => "2013",
            compliance_score => 92.3
        },
        #{
            name => "SOC 2",
            version => "2017",
            compliance_score => 88.7
        }
    ].

get_frameworks_compliance_status(State) ->
    %% Get compliance status for each framework
    #{
        "NIST_SP_800-53" => "compliant",
        "ISO_27001" => "compliant",
        "SOC_2" => "non_compliant"
    }.

get_critical_findings(State) ->
    %% Get critical compliance findings
    [V || V <- ets:tab2list(State#state.vulnerabilities), V#vulnerability.severity == "critical"].

get_vulnerability_risk_by_category(State) ->
    %% Get vulnerability risk by category
    Vulns = ets:tab2list(State#state.vulnerabilities),

    lists:foldl(fun(Vuln, Acc) ->
        Category = get_vulnerability_category(Vuln),
        maps:update(Category, maps:get(Category, Acc, 0) + 1, Acc)
    end, #{}, Vulns).

get_vulnerability_category(Vuln) ->
    %% Get category for vulnerability
    case Vuln#vulnerability.cve_id of
        C when C >= "CVE-2024-" and C < "CVE-2025-" -> "recent";
        C when C >= "CVE-2023-" and C < "CVE-2024-" -> "aging";
        _ -> "legacy"
    end.

perform_gap_analysis(State) ->
    %% Perform gap analysis
    #{
        total_gaps => 5,
        critical_gaps => 2,
        high_priority_gaps => 3,
        recommendations => [
            "Implement regular vulnerability scanning",
            "Establish patch management process",
            "Enhance security awareness training"
        ]
    }.

get_remediation_timeline(State) ->
    %% Get remediation timeline
    [
        #{
            phase => "immediate",
            timeframe => "0-7 days",
            items => get_urgent_remediation_items(State)
        },
        #{
            phase => "short_term",
            timeframe => "7-30 days",
            items => get_short_term_remediation_items(State)
        },
        #{
            phase => "long_term",
            timeframe => "30-90 days",
            items => get_long_term_remediation_items(State)
        }
    ].

get_urgent_remediation_items(State) ->
    %% Get urgent remediation items
    lists:filter(fun(V) -> V#vulnerability.severity == "critical" end,
                 ets:tab2list(State#state.vulnerabilities)).

get_short_term_remediation_items(State) ->
    %% Get short-term remediation items
    lists:filter(fun(V) -> V#vulnerability.severity == "high" end,
                 ets:tab2list(State#state.vulnerabilities)).

get_long_term_remediation_items(State) ->
    %% Get long-term remediation items
    lists:filter(fun(V) -> V#vulnerability.severity == "medium" end,
                 ets:tab2list(State#state.vulnerabilities)).

get_remediation_resources(State) ->
    %% Get resource requirements for remediation
    #{
        personnel => 3,
        budget => 50000,
        timeline => 90,
        tools => ["vulnerability_scanner", "patch_management", "compliance_tools"]
    }.

get_remediation_success_criteria(State) ->
    %% Define success criteria for remediation
    #{
        critical_vulnerabilities => 0,
        patch_coverage => 95,
        compliance_score => 95,
        scan_frequency => "daily"
    }.

get_rollback_plan(State) ->
    %% Define rollback plan for remediation
    #{
        backup_frequency => "daily",
