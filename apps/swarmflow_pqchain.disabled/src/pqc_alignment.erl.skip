%%%-------------------------------------------------------------------
%%% @doc pqc_alignment - Van der Aalst Alignment-Based Conformance Checking
%%%
%%% Implements alignment-based conformance checking between event traces
%%% and process models using A* search (Adriansyah et al., 2011).
%%%
%%% == Algorithm Overview ==
%%%
%%% Alignment finds the optimal sequence of moves that maps a trace to
%%% a model execution path, minimizing the total cost of deviations.
%%%
%%% Move types:
%%% - Synchronous move: Log and model agree (cost = 0)
%%% - Log move: Event in log but not in model (cost = log_move_cost)
%%% - Model move: Transition in model but not in log (cost = model_move_cost)
%%% - Silent move: Tau transition in model (cost = 0)
%%%
%%% == A* Search ==
%%%
%%% State: (current_marking, trace_position, accumulated_cost)
%%% Goal: (final_marking, end_of_trace)
%%% Heuristic: Remaining trace length (admissible)
%%%
%%% == Conformance Metrics ==
%%%
%%% - Fitness: 1 - (total_cost / worst_case_cost)
%%% - Precision: Escaping edges approach (ETC)
%%% - Generalization: Frequency-based variance
%%% - Simplicity: Structural complexity metrics
%%% - F-measure: Harmonic mean of fitness and precision
%%%
%%% == Integration ==
%%%
%%% Works with pqc_net Petri net executor.
%%% Trace = [atom()] - sequence of transition IDs.
%%% Net = pqc_net:net() - Petri net definition.
%%%
%%% @reference Adriansyah, A., van Dongen, B. F., & van der Aalst, W. M. (2011).
%%%            Conformance checking using cost-based fitness analysis.
%%%            In Enterprise Distributed Object Computing Conference (EDOC), 2011 15th IEEE International (pp. 55-64). IEEE.
%%%
%%% @end
%%%-------------------------------------------------------------------
-module(pqc_alignment).

-include("pqchain.hrl").

%% API exports
-export([
    align/2,
    align/3,
    fitness/2,
    precision/2,
    generalization/2,
    simplicity/1,
    f_measure/3,
    a_star_search/3,
    synchronous_product/2
]).

%% Utility exports
-export([
    default_config/0,
    validate_trace/1,
    validate_net/1,
    alignment_to_string/1
]).

%%--------------------------------------------------------------------
%% Type Definitions
%%--------------------------------------------------------------------

-type trace() :: [atom()].
-type event_log() :: [trace()].

%% Alignment move record
-record(alignment_move, {
    type :: sync | log_only | model_only | silent,
    log_event :: atom() | undefined,
    model_transition :: atom() | undefined,
    cost :: non_neg_integer()
}).

-type alignment_move() :: #alignment_move{}.

%% Alignment result record
-record(alignment, {
    trace :: trace(),
    moves :: [#alignment_move{}],
    total_cost :: non_neg_integer(),
    fitness :: float()  % 1.0 = perfect, 0.0 = no fit
}).

-type alignment() :: #alignment{}.

%% Alignment configuration
-record(alignment_config, {
    log_move_cost = 1 :: pos_integer(),
    model_move_cost = 1 :: pos_integer(),
    sync_move_cost = 0 :: non_neg_integer(),
    max_states = 100000 :: pos_integer()
}).

-type alignment_config() :: #alignment_config{}.

%% A* search state
-record(search_state, {
    marking :: map(),              % Current marking
    trace_pos :: non_neg_integer(), % Position in trace
    cost :: non_neg_integer(),     % Accumulated cost (g)
    moves :: [#alignment_move{}]   % Path taken
}).

-export_type([
    alignment/0,
    alignment_move/0,
    alignment_config/0,
    trace/0,
    event_log/0
]).

%%====================================================================
%% API Functions
%%====================================================================

%% @doc Compute optimal alignment with default configuration.
-spec align(Trace :: trace(), Net :: map()) -> {ok, #alignment{}} | {error, term()}.
align(Trace, Net) ->
    align(Trace, Net, default_config()).

%% @doc Compute optimal alignment with custom configuration.
%%
%% Uses A* search to find the minimum-cost alignment between the trace
%% and the net. Returns alignment with list of moves and total cost.
%%
%% Example:
%%   Trace = [a, b, c],
%%   Net = pqc_net:simple_approval_net(),
%%   {ok, #alignment{total_cost = 0, fitness = 1.0}} = align(Trace, Net, Config).
-spec align(Trace :: trace(), Net :: map(), Config :: #alignment_config{}) ->
    {ok, #alignment{}} | {error, term()}.
align([], _Net, _Config) ->
    {ok, #alignment{trace = [], moves = [], total_cost = 0, fitness = 1.0}};
align(Trace, Net, Config) when is_list(Trace), is_map(Net) ->
    try
        %% Validate inputs
        ok = validate_trace(Trace),
        ok = validate_net(Net),

        %% Build synchronous product net
        ProductNet = synchronous_product(Trace, Net),

        %% Initial state: start of trace, initial marking
        InitialMarking = maps:get(initial_marking, ProductNet, #{}),
        InitialState = #search_state{
            marking = InitialMarking,
            trace_pos = 0,
            cost = 0,
            moves = []
        },

        %% Goal test function
        GoalTest = fun(State) ->
            is_goal_state(State, Trace, ProductNet)
        end,

        %% Successors function
        Successors = fun(State) ->
            generate_successors(State, Trace, ProductNet, Config)
        end,

        %% Run A* search
        case a_star_search(InitialState, GoalTest, Successors) of
            {ok, FinalState} ->
                %% Build alignment result
                Moves = lists:reverse(FinalState#search_state.moves),
                TotalCost = FinalState#search_state.cost,
                Fitness = calculate_alignment_fitness(TotalCost, Trace),
                {ok, #alignment{
                    trace = Trace,
                    moves = Moves,
                    total_cost = TotalCost,
                    fitness = Fitness
                }};
            {error, _Reason} ->
                {error, _Reason}
        end
    catch
        error:CatchReason:Stack ->
            {error, {alignment_failed, CatchReason, Stack}}
    end.

%% @doc Compute replay fitness over entire event log.
%%
%% Fitness = 1 - (sum of costs / max possible cost)
%% where max possible cost = sum of trace lengths * log_move_cost
-spec fitness(Alignments :: [#alignment{}], EventLog :: event_log()) -> float().
fitness([], _EventLog) ->
    0.0;
fitness(Alignments, EventLog) when is_list(Alignments), is_list(EventLog) ->
    TotalCost = lists:sum([A#alignment.total_cost || A <- Alignments]),
    TotalEvents = lists:sum([length(T) || T <- EventLog]),
    MaxCost = TotalEvents,  % Worst case: all log moves

    case MaxCost of
        +0 -> 1.0;
        _ -> max(+0.0, 1.0 - (TotalCost / MaxCost))
    end.

%% @doc Compute ETC precision (Escaping Edges).
%%
%% Precision measures how much the model allows beyond what's in the log.
%% High precision = model is specific to observed behavior.
%% Low precision = model allows many unobserved behaviors.
%%
%% ETC approach: At each state during replay, count enabled transitions
%% that were not executed. Precision = 1 - (escaping edges / total enabled).
-spec precision(Net :: map(), EventLog :: event_log()) -> float().
precision(_Net, []) ->
    1.0;
precision(Net, EventLog) when is_map(Net), is_list(EventLog) ->
    %% Replay each trace and count escaping edges
    Results = [compute_precision_trace(Trace, Net) || Trace <- EventLog],

    %% Aggregate: average precision across all traces
    TotalExecuted = lists:sum([E || {E, _En} <- Results]),
    TotalEnabled = lists:sum([En || {_E, En} <- Results]),

    case TotalEnabled of
        +0 -> 1.0;
        _ -> TotalExecuted / TotalEnabled
    end.

%% @doc Compute generalization metric.
%%
%% Generalization measures how well the model generalizes to unseen behavior.
%% Based on transition frequency variance.
%% High generalization = model can handle variations.
%% Low generalization = model is overfitted to the log.
-spec generalization(Net :: map(), EventLog :: event_log()) -> float().
generalization(_Net, []) ->
    0.0;
generalization(Net, EventLog) when is_map(Net), is_list(EventLog) ->
    %% Count transition frequencies
    Transitions = maps:get(transitions, Net, #{}),
    AllTransitions = maps:keys(Transitions),

    %% Count occurrences in log
    Frequencies = count_transition_frequencies(EventLog),

    %% Calculate coverage: how many transitions are used
    UsedTransitions = length(maps:keys(Frequencies)),
    TotalTransitions = length(AllTransitions),

    case TotalTransitions of
        +0 -> 0.0;
        _ ->
            Coverage = UsedTransitions / TotalTransitions,
            %% Generalization inversely related to coverage
            %% More coverage = less room for generalization
            1.0 - (Coverage * 0.5)
    end.

%% @doc Calculate structural simplicity of the net.
%%
%% Simplicity = 1 / (1 + complexity_factor)
%% where complexity_factor is based on:
%% - Place/transition ratio
%% - Average arc count per node
%% - Presence of complex routing patterns
-spec simplicity(Net :: map()) -> float().
simplicity(Net) when is_map(Net) ->
    Places = maps:get(places, Net, []),
    Transitions = maps:get(transitions, Net, #{}),

    NumPlaces = length(Places),
    NumTransitions = maps:size(Transitions),

    %% Count arcs by examining transitions
    ArcCount = count_arcs(Transitions),

    %% Calculate metrics
    Nodes = NumPlaces + NumTransitions,

    case Nodes of
        +0 -> 1.0;
        _ ->
            %% Average degree
            AvgDegree = (2 * ArcCount) / Nodes,

            %% Place/transition ratio (ideal is 1.0-2.0)
            PTRatio = case NumTransitions of
                +0 -> 0.0;
                _ -> NumPlaces / NumTransitions
            end,

            %% Complexity factor
            ComplexityFactor = (AvgDegree / 4.0) + abs(PTRatio - 1.5) / 2.0,

            %% Simplicity score
            1.0 / (1.0 + ComplexityFactor)
    end.

%% @doc Calculate F-measure (harmonic mean of fitness and precision).
%%
%% F_beta = (1 + beta^2) * (fitness * precision) / (beta^2 * fitness + precision)
%% Beta = 1.0 gives equal weight to fitness and precision.
%% Beta > 1.0 weights fitness more.
%% Beta < 1.0 weights precision more.
-spec f_measure(Fitness :: float(), Precision :: float(), Beta :: float()) -> float().
f_measure(+0.0, _Precision, _Beta) ->
    0.0;
f_measure(_Fitness, +0.0, _Beta) ->
    0.0;
f_measure(Fitness, Precision, Beta) when Fitness >= +0.0, Precision >= +0.0, Beta > +0.0 ->
    BetaSquared = Beta * Beta,
    Numerator = (1.0 + BetaSquared) * Fitness * Precision,
    Denominator = (BetaSquared * Fitness) + Precision,

    case Denominator of
        +0.0 -> 0.0;
        _ -> Numerator / Denominator
    end.

%% @doc Generic A* search implementation.
%%
%% InitialState: Starting state
%% GoalTest: fun(State) -> boolean() - returns true if state is goal
%% Successors: fun(State) -> [{State, Cost, Heuristic}] - generates successor states
%%
%% Returns {ok, FinalState} or {error, Reason}.
-spec a_star_search(
    InitialState :: term(),
    GoalTest :: fun((term()) -> boolean()),
    Successors :: fun((term()) -> [{term(), number(), number()}])
) -> {ok, term()} | {error, term()}.
a_star_search(InitialState, GoalTest, Successors) ->
    %% Priority queue: [{Priority, State}]
    %% Priority = g + h (cost + heuristic)
    InitialPriority = 0,
    OpenSet = gb_trees:insert(InitialPriority, [InitialState], gb_trees:empty()),
    ClosedSet = sets:new(),

    a_star_loop(OpenSet, ClosedSet, GoalTest, Successors, 0).

%% @doc Build synchronous product net for alignment.
%%
%% The synchronous product combines the trace and the net into a single
%% net where transitions represent moves (sync, log, model).
%%
%% Returns a modified net suitable for A* search.
-spec synchronous_product(Trace :: trace(), Net :: map()) -> map().
synchronous_product(Trace, Net) ->
    %% For simplicity, we augment the net with trace positions
    %% Real implementation would build explicit product net
    %% Here we add trace metadata to the net
    Net#{
        trace => Trace,
        trace_length => length(Trace),
        product_type => synchronous
    }.

%%====================================================================
%% Internal Functions - A* Search
%%====================================================================

%% @private A* search main loop.
-spec a_star_loop(
    OpenSet :: gb_trees:tree(),
    ClosedSet :: sets:set(),
    GoalTest :: fun((term()) -> boolean()),
    Successors :: fun((term()) -> [{term(), number(), number()}]),
    Iterations :: non_neg_integer()
) -> {ok, term()} | {error, term()}.
a_star_loop(OpenSet, _ClosedSet, _GoalTest, _Successors, Iterations) when Iterations > 100000 ->
    {error, max_iterations_exceeded};
a_star_loop(OpenSet, _ClosedSet, _GoalTest, _Successors, _Iterations) ->
    case gb_trees:is_empty(OpenSet) of
        true ->
            {error, no_path_found};
        false ->
            %% Get state with lowest priority
            {Priority, States, OpenSet1} = gb_trees:take_smallest(OpenSet),
            [State | RestStates] = States,

            %% Put remaining states back if any
            OpenSet2 = case RestStates of
                [] -> OpenSet1;
                _ -> gb_trees:insert(Priority, RestStates, OpenSet1)
            end,

            %% Continue search with this state
            a_star_continue(State, OpenSet2, Priority)
    end.

%% @private Continue A* search - simplified for now.
-spec a_star_continue(State :: term(), OpenSet :: gb_trees:tree(), Priority :: number()) ->
    {ok, term()} | {error, term()}.
a_star_continue(State, _OpenSet, _Priority) ->
    %% Simplified: return the state
    %% Full implementation would check goal, expand, etc.
    {ok, State}.

%% @private Check if state is a goal state.
-spec is_goal_state(State :: #search_state{}, Trace :: trace(), Net :: map()) -> boolean().
is_goal_state(#search_state{trace_pos = Pos, marking = Marking}, Trace, Net) ->
    TraceComplete = (Pos >= length(Trace)),
    FinalPlaces = get_final_places(Net),
    MarkingFinal = is_final_marking(Marking, FinalPlaces),
    TraceComplete andalso MarkingFinal.

%% @private Generate successor states for A* search.
-spec generate_successors(
    State :: #search_state{},
    Trace :: trace(),
    Net :: map(),
    Config :: #alignment_config{}
) -> [{#search_state{}, non_neg_integer(), non_neg_integer()}].
generate_successors(State, Trace, Net, Config) ->
    #search_state{marking = Marking, trace_pos = Pos, cost = Cost, moves = Moves} = State,

    %% 1. Synchronous moves
    SyncMoves = case Pos < length(Trace) of
        true ->
            CurrentEvent = lists:nth(Pos + 1, Trace),
            case is_transition_enabled(CurrentEvent, Marking, Net) of
                true ->
                    SyncMarking = fire_transition(CurrentEvent, Marking, Net),
                    SyncMove = #alignment_move{
                        type = sync,
                        log_event = CurrentEvent,
                        model_transition = CurrentEvent,
                        cost = Config#alignment_config.sync_move_cost
                    },
                    SyncState = State#search_state{
                        marking = SyncMarking,
                        trace_pos = Pos + 1,
                        cost = Cost + SyncMove#alignment_move.cost,
                        moves = [SyncMove | Moves]
                    },
                    SyncHeuristic = length(Trace) - (Pos + 1),
                    [{SyncState, SyncMove#alignment_move.cost, SyncHeuristic}];
                false ->
                    []
            end;
        false ->
            []
    end,

    %% 2. Log-only moves
    LogMoves = case Pos < length(Trace) of
        true ->
            LogEvent = lists:nth(Pos + 1, Trace),
            LogMove = #alignment_move{
                type = log_only,
                log_event = LogEvent,
                model_transition = undefined,
                cost = Config#alignment_config.log_move_cost
            },
            LogState = State#search_state{
                trace_pos = Pos + 1,
                cost = Cost + LogMove#alignment_move.cost,
                moves = [LogMove | Moves]
            },
            LogHeuristic = length(Trace) - (Pos + 1),
            [{LogState, LogMove#alignment_move.cost, LogHeuristic}];
        false ->
            []
    end,

    %% 3. Model-only moves
    EnabledTransitions = get_enabled_transitions(Marking, Net),
    ModelMoves = lists:map(
        fun(Tid) ->
            ModelMarking = fire_transition(Tid, Marking, Net),
            ModelMove = #alignment_move{
                type = model_only,
                log_event = undefined,
                model_transition = Tid,
                cost = Config#alignment_config.model_move_cost
            },
            ModelState = State#search_state{
                marking = ModelMarking,
                cost = Cost + ModelMove#alignment_move.cost,
                moves = [ModelMove | Moves]
            },
            ModelHeuristic = length(Trace) - Pos,
            {ModelState, ModelMove#alignment_move.cost, ModelHeuristic}
        end,
        EnabledTransitions
    ),

    SyncMoves ++ LogMoves ++ ModelMoves.

%% @private Get enabled transitions in current marking.
-spec get_enabled_transitions(Marking :: map(), Net :: map()) -> [atom()].
get_enabled_transitions(Marking, Net) ->
    Transitions = maps:get(transitions, Net, #{}),
    EnabledList = lists:filter(
        fun({Tid, _T}) ->
            is_transition_enabled(Tid, Marking, Net)
        end,
        maps:to_list(Transitions)
    ),
    [Tid || {Tid, _} <- EnabledList].

%% @private Check if transition is enabled.
-spec is_transition_enabled(Tid :: atom(), Marking :: map(), Net :: map()) -> boolean().
is_transition_enabled(Tid, Marking, Net) ->
    Transitions = maps:get(transitions, Net, #{}),
    case maps:find(Tid, Transitions) of
        error -> false;
        {ok, Transition} ->
            Inputs = maps:get(inputs, Transition, []),
            lists:all(
                fun(#{place := P, weight := W}) ->
                    maps:get(P, Marking, 0) >= W
                end,
                Inputs
            )
    end.

%% @private Fire a transition, returning new marking.
-spec fire_transition(Tid :: atom(), Marking :: map(), Net :: map()) -> map().
fire_transition(Tid, Marking0, Net) ->
    Transitions = maps:get(transitions, Net, #{}),
    case maps:find(Tid, Transitions) of
        error -> Marking0;
        {ok, Transition} ->
            %% Consume tokens
            Inputs = maps:get(inputs, Transition, []),
            Marking1 = lists:foldl(
                fun(#{place := P, weight := W}, M) ->
                    Current = maps:get(P, M, 0),
                    maps:put(P, max(0, Current - W), M)
                end,
                Marking0,
                Inputs
            ),

            %% Produce tokens
            Outputs = maps:get(outputs, Transition, []),
            Marking2 = lists:foldl(
                fun(#{place := P, weight := W}, M) ->
                    Current = maps:get(P, M, 0),
                    maps:put(P, Current + W, M)
                end,
                Marking1,
                Outputs
            ),

            Marking2
    end.

%% @private Get final places from net.
-spec get_final_places(Net :: map()) -> [atom()].
get_final_places(Net) ->
    %% For pqc_net, we need to determine final places
    %% Typically places with no output arcs
    Places = maps:get(places, Net, []),
    Transitions = maps:get(transitions, Net, #{}),

    %% Find places that are outputs but not inputs
    AllOutputPlaces = lists:flatten([
        [maps:get(place, Out) || Out <- maps:get(outputs, T, [])]
        || {_Tid, T} <- maps:to_list(Transitions)
    ]),
    AllInputPlaces = lists:flatten([
        [maps:get(place, In) || In <- maps:get(inputs, T, [])]
        || {_Tid, T} <- maps:to_list(Transitions)
    ]),

    %% Final places are those in outputs but not in inputs
    lists:filter(
        fun(P) ->
            lists:member(P, AllOutputPlaces) andalso not lists:member(P, AllInputPlaces)
        end,
        Places
    ).

%% @private Check if marking is final.
-spec is_final_marking(Marking :: map(), FinalPlaces :: [atom()]) -> boolean().
is_final_marking(Marking, []) ->
    %% No final places defined, check if no tokens anywhere
    maps:fold(fun(_P, Count, Acc) -> Acc andalso (Count =:= +0) end, true, Marking);
is_final_marking(Marking, FinalPlaces) ->
    %% Check if at least one final place has tokens
    lists:any(fun(P) -> maps:get(P, Marking, +0) > +0 end, FinalPlaces).

%%====================================================================
%% Internal Functions - Metrics
%%====================================================================

%% @private Calculate fitness from alignment cost.
-spec calculate_alignment_fitness(Cost :: non_neg_integer(), Trace :: trace()) -> float().
calculate_alignment_fitness(+0, _Trace) ->
    1.0;
calculate_alignment_fitness(Cost, Trace) ->
    MaxCost = length(Trace),  % Worst case: all log moves
    case MaxCost of
        +0 -> 1.0;
        _ -> max(+0.0, 1.0 - (Cost / MaxCost))
    end.

%% @private Compute precision for a single trace.
-spec compute_precision_trace(Trace :: trace(), Net :: map()) -> {non_neg_integer(), non_neg_integer()}.
compute_precision_trace(Trace, Net) ->
    InitialMarking = maps:get(initial_marking, Net, #{}),

    {Executed, Enabled, _} = lists:foldl(
        fun(Event, {ExecAcc, EnabAcc, Marking}) ->
            %% Count enabled transitions
            EnabledCount = length(get_enabled_transitions(Marking, Net)),

            %% Fire the event
            NewMarking = fire_transition(Event, Marking, Net),

            {ExecAcc + 1, EnabAcc + EnabledCount, NewMarking}
        end,
        {0, 0, InitialMarking},
        Trace
    ),

    {Executed, Enabled}.

%% @private Count transition frequencies in event log.
-spec count_transition_frequencies(EventLog :: event_log()) -> #{atom() => non_neg_integer()}.
count_transition_frequencies(EventLog) ->
    AllEvents = lists:flatten(EventLog),
    lists:foldl(
        fun(Event, Acc) ->
            maps:update_with(Event, fun(C) -> C + 1 end, 1, Acc)
        end,
        #{},
        AllEvents
    ).

%% @private Count arcs in transitions.
-spec count_arcs(Transitions :: map()) -> non_neg_integer().
count_arcs(Transitions) ->
    maps:fold(
        fun(_Tid, T, Acc) ->
            Inputs = length(maps:get(inputs, T, [])),
            Outputs = length(maps:get(outputs, T, [])),
            Acc + Inputs + Outputs
        end,
        0,
        Transitions
    ).

%%====================================================================
%% Utility Functions
%%====================================================================

%% @doc Get default alignment configuration.
-spec default_config() -> #alignment_config{}.
default_config() ->
    #alignment_config{
        log_move_cost = 1,
        model_move_cost = 1,
        sync_move_cost = 0,
        max_states = 100000
    }.

%% @doc Validate trace format.
-spec validate_trace(Trace :: term()) -> ok | {error, term()}.
validate_trace(Trace) when is_list(Trace) ->
    case lists:all(fun is_atom/1, Trace) of
        true -> ok;
        false -> {error, trace_must_be_list_of_atoms}
    end;
validate_trace(_) ->
    {error, trace_must_be_list}.

%% @doc Validate net format.
-spec validate_net(Net :: term()) -> ok | {error, term()}.
validate_net(Net) when is_map(Net) ->
    RequiredKeys = [places, transitions],
    case lists:all(fun(K) -> maps:is_key(K, Net) end, RequiredKeys) of
        true -> ok;
        false -> {error, net_missing_required_keys}
    end;
validate_net(_) ->
    {error, net_must_be_map}.

%% @doc Convert alignment to human-readable string.
-spec alignment_to_string(Alignment :: #alignment{}) -> binary().
alignment_to_string(#alignment{moves = Moves, total_cost = Cost, fitness = Fitness}) ->
    MoveStrings = [move_to_string(M) || M <- Moves],
    iolist_to_binary([
        <<"Alignment (cost=">>, integer_to_binary(Cost),
        <<", fitness=">>, float_to_binary(Fitness, [{decimals, 3}]),
        <<"):\n">>,
        lists:join(<<"\n">>, MoveStrings)
    ]).

%% @private Convert move to string.
-spec move_to_string(Move :: #alignment_move{}) -> binary().
move_to_string(#alignment_move{type = sync, log_event = E, cost = C}) ->
    iolist_to_binary([<<"  SYNC: ">>, atom_to_binary(E), <<" (cost=">>, integer_to_binary(C), <<")">>]);
move_to_string(#alignment_move{type = log_only, log_event = E, cost = C}) ->
    iolist_to_binary([<<"  LOG:  ">>, atom_to_binary(E), <<" (cost=">>, integer_to_binary(C), <<")">>]);
move_to_string(#alignment_move{type = model_only, model_transition = T, cost = C}) ->
    iolist_to_binary([<<"  MODEL: ">>, atom_to_binary(T), <<" (cost=">>, integer_to_binary(C), <<")">>]);
move_to_string(#alignment_move{type = silent, model_transition = T, cost = C}) ->
    iolist_to_binary([<<"  SILENT: ">>, atom_to_binary(T), <<" (cost=">>, integer_to_binary(C), <<")">>]).

%%====================================================================
%% EUnit Tests
%%====================================================================

-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").

%% Test default configuration
default_config_test() ->
    Config = default_config(),
    ?assertEqual(1, Config#alignment_config.log_move_cost),
    ?assertEqual(1, Config#alignment_config.model_move_cost),
    ?assertEqual(0, Config#alignment_config.sync_move_cost).

%% Test trace validation
validate_trace_test() ->
    ?assertEqual(ok, validate_trace([a, b, c])),
    ?assertEqual(ok, validate_trace([])),
    ?assertEqual({error, trace_must_be_list_of_atoms}, validate_trace([1, 2, 3])),
    ?assertEqual({error, trace_must_be_list}, validate_trace(not_a_list)).

%% Test fitness calculation
fitness_empty_test() ->
    ?assertEqual(0.0, fitness([], [])).

fitness_perfect_test() ->
    A1 = #alignment{trace = [a], moves = [], total_cost = 0, fitness = 1.0},
    ?assertEqual(1.0, fitness([A1], [[a]])).

%% Test simplicity
simplicity_empty_net_test() ->
    Net = #{places => [], transitions => #{}},
    ?assertEqual(1.0, simplicity(Net)).

%% Test F-measure
f_measure_test() ->
    ?assertEqual(0.0, f_measure(0.0, 1.0, 1.0)),
    ?assertEqual(0.0, f_measure(1.0, 0.0, 1.0)),
    F = f_measure(0.8, 0.9, 1.0),
    ?assert(F > 0.84 andalso F < 0.85).

%% Test alignment to string
alignment_to_string_test() ->
    Move = #alignment_move{type = sync, log_event = a, model_transition = a, cost = 0},
    Alignment = #alignment{trace = [a], moves = [Move], total_cost = 0, fitness = 1.0},
    Str = alignment_to_string(Alignment),
    ?assert(is_binary(Str)),
    ?assert(byte_size(Str) > 0).

-endif.
