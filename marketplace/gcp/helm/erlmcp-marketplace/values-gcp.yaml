# ============================================================================
# GCP-Specific Values for erlmcp Helm Chart
# Overrides for Google Cloud Platform deployment (GKE 1.29+)
# Latest GKE features: Gateway API, Workload Identity Federation, GKE Autopilot
# ============================================================================

global:
  cloud:
    provider: "gcp"
    region: "us-central1"
    gcpServiceAccount: "erlmcp@project.iam.gserviceaccount.com"

  # GCP-specific environment variables
  gcp:
    project: "your-project-id"
    region: "us-central1"
    projectNumber: "123456789012"

    # Workload Identity Federation (recommended over legacy Workload Identity)
    workloadIdentity:
      enabled: true
      gsaEmail: "erlmcp@project.iam.gserviceaccount.com"
      # Workload Identity Federation for cross-project/cross-org access
      federation:
        enabled: false
        workloadIdentityPool: "projects/${project_number}/locations/global/workloadIdentityPools/gke-pool"
        workloadIdentityProvider: "projects/${project_number}/locations/global/workloadIdentityPools/gke-pool/providers/gke-provider"

# Service Account with Workload Identity
serviceAccount:
  create: true
  name: "erlmcp"
  annotations:
    # Workload Identity binding
    iam.gke.io/gcp-service-account: "erlmcp@project.iam.gserviceaccount.com"
    # Config Connector managed service account
    cnrm.cloud.google.com/project-id: "${project_id}"
    # Prevent privilege escalation
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: 'runtime/default'
  automountServiceAccountToken: true

# Pod configuration
pod:
  annotations:
    # Workload Identity
    iam.gke.io/gcp-service-account: "erlmcp@project.iam.gserviceaccount.com"
    # GKE Security Posture
    container.seccomp.security.alpha.kubernetes.io/erlmcp: "runtime/default"
    container.apparmor.security.beta.kubernetes.io/erlmcp: "runtime/default"
    # Autopilot optimization hints
    autopilot.gke.io/optimize-utilization: "true"
    autopilot.gke.io/workload-type: "general-purpose"

# Container image configuration
image:
  repository: "us-central1-docker.pkg.dev/your-project-id/erlmcp/erlmcp"
  tag: "3.0.0"
  pullPolicy: "IfNotPresent"
  # Binary Authorization policy for image verification
  binaryAuthorization:
    enabled: true
    policyName: "projects/${project_id}/policy"
    requireAttestations: true
    attestors:
      - "projects/${project_id}/attestors/build-verified"
      - "projects/${project_id}/attestors/security-scanned"

# Replica configuration
replicaCount: 3

# Resource configuration (GKE Autopilot-optimized)
# Autopilot enforces QoS class: Guaranteed (requests = limits)
resources:
  requests:
    cpu: "1000m"  # 1 vCPU minimum for production workloads
    memory: "2Gi"  # Must be whole Gi for Autopilot
    ephemeral-storage: "1Gi"  # Explicit ephemeral storage for /tmp
  limits:
    cpu: "2000m"  # 2 vCPU maximum
    memory: "4Gi"  # Must match request ratio for Autopilot
    ephemeral-storage: "2Gi"

# Autoscaling (GKE Autopilot with behavior policies)
autoscaling:
  enabled: true
  minReplicas: 3  # For high availability across zones
  maxReplicas: 50  # Increased for production scale
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

  # Advanced HPA behavior (stabilization windows)
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300  # 5 min cooldown
      policies:
        - type: Pods
          value: 1
          periodSeconds: 60
        - type: Percent
          value: 10  # Max 10% pods removed per minute
          periodSeconds: 60
      selectPolicy: Min  # Conservative scale-down
    scaleUp:
      stabilizationWindowSeconds: 0  # Immediate scale-up
      policies:
        - type: Pods
          value: 4  # Add 4 pods at once for burst traffic
          periodSeconds: 60
        - type: Percent
          value: 50  # Or 50% of current pods
          periodSeconds: 60
      selectPolicy: Max  # Aggressive scale-up

  # Custom metrics from GMP (Google Managed Prometheus)
  customMetrics:
    - type: Pods
      pods:
        metric:
          name: erlmcp_active_connections
        target:
          type: AverageValue
          averageValue: "100"  # Scale at 100 connections per pod
    - type: Pods
      pods:
        metric:
          name: erlmcp_request_latency_p99
        target:
          type: AverageValue
          averageValue: "500m"  # Scale if p99 latency > 500ms

# Service configuration
service:
  type: "ClusterIP"
  annotations:
    # NEG (Network Endpoint Group) for direct pod routing
    cloud.google.com/neg: '{"ingress": true}'
    # Backend config for health checks, CDN, IAP
    cloud.google.com/backend-config: '{"default":"erlmcp-backend-config"}'
    # Preserve client IP
    cloud.google.com/neg-status: '{"network_endpoint_groups":{"8080":"erlmcp-neg"}}'
  sessionAffinity: "ClientIP"  # Sticky sessions for WebSocket
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 10800  # 3 hours for long-lived connections

# Gateway API configuration (preferred over Ingress for GKE 1.27+)
gateway:
  enabled: true
  className: "gke-l7-global-external-managed"  # GKE managed Gateway
  gatewayName: "erlmcp-gateway"
  listenerName: "https"
  annotations:
    # Global external Application Load Balancer
    networking.gke.io/backend-config: "erlmcp-backend-config"
    # Cloud Armor security policy
    cloud.google.com/armor-config: '{"erlmcp":"erlmcp-security-policy"}'
    # Cloud CDN
    cloud.google.com/cdn-config: '{"enabled":true,"cachePolicy":"CACHE_ALL_STATIC"}'
  routes:
    - name: erlmcp-https-route
      hostnames:
        - "erlmcp.example.com"
      rules:
        - matches:
            - path:
                type: PathPrefix
                value: /
          backendRefs:
            - name: erlmcp
              port: 8080
              weight: 100
      # TLS with Google-managed certificates
      tls:
        mode: Terminate
        certificateRefs:
          - name: erlmcp-cert
            kind: Certificate
            group: networking.gke.io

# Legacy Ingress configuration (fallback, disable if using Gateway API)
ingress:
  enabled: false  # Prefer Gateway API
  className: "gce-internal"  # Internal ingress for private services
  annotations:
    kubernetes.io/ingress.class: "gce-internal"
    kubernetes.io/ingress.regional-static-ip-name: "erlmcp-internal-ip"
    networking.gke.io/managed-certificates: "erlmcp-cert"
    networking.gke.io/v1beta1.FrontendConfig: "erlmcp-frontend-config"
    # IAP (Identity-Aware Proxy) for authentication
    ingress.gcp.kubernetes.io/pre-shared-cert: "erlmcp-cert"
  hosts:
    - host: erlmcp.internal.example.com
      paths:
        - path: /
          pathType: Prefix
          backend:
            service:
              name: erlmcp
              port:
                number: 8080
  tls:
    - secretName: erlmcp-tls
      hosts:
        - erlmcp.internal.example.com

# GKE-specific configuration
gke:
  # Cluster mode: standard or autopilot
  mode: "autopilot"  # Autopilot = serverless, Google-managed nodes

  # Regional cluster configuration (multi-zone for HA)
  regionalCluster: true
  zones:
    - "us-central1-a"
    - "us-central1-b"
    - "us-central1-c"

  # Private cluster configuration (VPC-native)
  privateCluster:
    enabled: true
    masterIpv4CidrBlock: "172.16.0.0/28"
    masterGlobalAccess: true  # Allow global access for management
    enablePrivateEndpoint: false  # Public endpoint for CI/CD
    enablePrivateNodes: true  # Nodes have no public IPs

  # Workload Identity (v2 with Workload Identity Federation)
  workloadIdentity:
    enabled: true
    pool: "${project_id}.svc.id.goog"
    # Namespace mapping for multi-tenancy
    namespaceMapping:
      enabled: true
      namespaces:
        - namespace: default
          serviceAccount: erlmcp
          gcpServiceAccount: "erlmcp@${project_id}.iam.gserviceaccount.com"

  # GKE Security Posture (automated vulnerability management)
  securityPosture:
    enabled: true
    mode: "ENTERPRISE"  # BASIC, ENTERPRISE
    vulnerabilityMode: "VULNERABILITY_ENTERPRISE"  # Continuous scanning
    workloadPolicyController:
      enabled: true
      templateLibrary: "BASELINE"  # Pod Security Standards

  # Shielded GKE nodes (node integrity)
  shieldedNodes:
    enabled: true
    secureBoot: true
    integrityMonitoring: true
    enableIntegrityMonitoringAlerts: true

  # Binary Authorization (image attestation)
  binaryAuthorization:
    enabled: true
    evaluationMode: "REQUIRE_ATTESTATION"
    policy:
      defaultAdmissionRule:
        requireAttestationsBy:
          - "projects/${project_id}/attestors/build-verified"
          - "projects/${project_id}/attestors/vulnerability-scanned"
        enforcementMode: "ENFORCED_BLOCK_AND_AUDIT_LOG"

  # GKE Enterprise (formerly Anthos) features
  enterprise:
    enabled: true
    # Fleet membership for multi-cluster management
    fleet:
      enabled: true
      projectNumber: "${project_number}"
      membershipName: "erlmcp-cluster"
    # Config Management for GitOps
    configManagement:
      enabled: true
      gitRepo: "https://github.com/your-org/erlmcp-config"
      policyDir: "config-sync"
      syncBranch: "main"
    # Policy Controller (OPA Gatekeeper)
    policyController:
      enabled: true
      templateLibraryInstalled: true
      auditIntervalSeconds: 60
      referentialRulesEnabled: true
    # Service Mesh (Anthos Service Mesh / Istio)
    serviceMesh:
      enabled: false  # Enable for advanced traffic management
      controlPlaneVersion: "asm-managed"
      enableStackdriverMetrics: true

  # GKE Dataplane V2 (eBPF-based networking)
  dataplaneV2:
    enabled: true  # Required for Autopilot
    networkPolicyEnforcement: true

  # Node auto-provisioning (standard mode only)
  nodeAutoprovisioning:
    enabled: false  # N/A for Autopilot
    minCpu: 4
    maxCpu: 64
    minMemory: 16
    maxMemory: 256

  # Cost optimization
  costOptimization:
    # Spot VMs for non-critical workloads (standard mode only)
    spotVMs:
      enabled: false  # Autopilot manages this automatically
      tolerations:
        - key: cloud.google.com/gke-spot
          operator: Equal
          value: "true"
          effect: NoSchedule
    # Node auto-upgrade and auto-repair
    maintenanceWindow:
      enabled: true
      startTime: "2026-02-06T02:00:00Z"
      duration: "4h"
      recurrence: "FREQ=WEEKLY;BYDAY=SU"

  # Backup for GKE (automated backup/restore)
  backup:
    enabled: true
    backupPlanName: "erlmcp-backup-plan"
    schedule: "0 2 * * *"  # Daily at 2 AM
    retentionDays: 30
    includeVolumeData: true
    includeSecrets: false  # Secrets managed separately

# Secret Manager integration (CSI driver for automatic rotation)
secretManager:
  enabled: true
  project: "your-project-id"
  # Use CSI driver for automatic secret rotation
  csiDriver:
    enabled: true
    volumeName: "erlmcp-secrets"
    mountPath: "/var/secrets"
    rotationPollInterval: "120s"  # Check for updates every 2 minutes
  secrets:
    erlangCookie:
      name: "erlmcp-erlang-cookie"
      version: "latest"
      envName: "ERLANG_COOKIE"
    dbPassword:
      name: "erlmcp-db-password"
      version: "latest"
      envName: "DB_PASSWORD"
    redisPassword:
      name: "erlmcp-redis-password"
      version: "latest"
      envName: "REDIS_PASSWORD"
    tlsCert:
      name: "erlmcp-tls-cert"
      version: "latest"
      path: "tls.crt"
    tlsKey:
      name: "erlmcp-tls-key"
      version: "latest"
      path: "tls.key"
    # API keys with automatic rotation
    apiKey:
      name: "erlmcp-api-key"
      version: "latest"
      envName: "API_KEY"
      # Automatic rotation policy
      rotation:
        enabled: true
        rotationPeriod: "2592000s"  # 30 days
        nextRotationTime: "auto"

# Google Managed Prometheus (GMP) - preferred over self-managed Prometheus
prometheus:
  enabled: true
  managed: true  # Use GMP instead of self-hosted
  scrapeInterval: "30s"
  evaluationInterval: "30s"
  podMonitoring:
    enabled: true
    interval: "30s"
    path: "/metrics"
    port: "metrics"
    # Prometheus scrape annotations
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9090"
      prometheus.io/path: "/metrics"
  # Recording rules for efficient queries
  recordingRules:
    - name: erlmcp:http_requests:rate5m
      expr: rate(erlmcp_http_requests_total[5m])
    - name: erlmcp:http_latency:p95
      expr: histogram_quantile(0.95, rate(erlmcp_http_latency_seconds_bucket[5m]))
  # Alerting rules
  alertingRules:
    - name: HighErrorRate
      expr: rate(erlmcp_http_errors_total[5m]) > 0.05
      duration: 5m
      severity: warning
    - name: HighLatency
      expr: erlmcp:http_latency:p95 > 1.0
      duration: 5m
      severity: warning

# OpenTelemetry configuration for GCP Cloud Trace and Cloud Monitoring
otel:
  enabled: true
  # Cloud Trace endpoint
  endpoint: "cloudtrace.googleapis.com:443"
  # Use Workload Identity (no explicit credentials needed)
  authentication:
    method: "workload-identity"
  exporters:
    - googlecloud
  # Metrics export
  metrics:
    enabled: true
    exporters:
      - googlecloud
    interval: "60s"
    # Resource detection
    resourceDetectors:
      - gcp
      - env
      - system
  # Distributed tracing
  traces:
    enabled: true
    exporters:
      - googlecloud
    # Adaptive sampling for cost optimization
    sampling:
      strategy: "adaptive"
      rateLimiting:
        maxTracesPerSecond: 100
      tailBased:
        enabled: true
        policies:
          - name: errors
            type: status_code
            statusCode: ERROR
          - name: slow_requests
            type: latency
            latencyThreshold: 1000ms
          - name: sample_rate
            type: probabilistic
            probability: 0.1
  # Logs correlation
  logs:
    enabled: true
    exporters:
      - googlecloud
    includeTraceContext: true

# Cloud Logging configuration (structured logging)
cloudLogging:
  enabled: true
  logName: "projects/${project_id}/logs/erlmcp"
  # Structured logging for better querying
  format: "json"
  # Log severity mapping
  severityMapping:
    debug: "DEBUG"
    info: "INFO"
    notice: "NOTICE"
    warning: "WARNING"
    error: "ERROR"
    critical: "CRITICAL"
    alert: "ALERT"
    emergency: "EMERGENCY"
  # Resource attributes
  resource:
    type: "k8s_container"
    labels:
      project_id: "${project_id}"
      location: "${region}"
      cluster_name: "${cluster_name}"
      namespace_name: "${namespace}"
      pod_name: "${pod_name}"
      container_name: "erlmcp"
  # Log sampling for cost optimization
  sampling:
    enabled: true
    rate: 0.5  # Sample 50% of debug logs
    exceptions:
      - severity: "ERROR"
        rate: 1.0  # Always log errors
      - severity: "WARNING"
        rate: 1.0

# Cloud Monitoring configuration (custom metrics and dashboards)
cloudMonitoring:
  enabled: true
  # Custom metrics
  metrics:
    - name: "erlmcp/http/request_count"
      type: "custom.googleapis.com/erlmcp/http/requests"
      metricKind: "CUMULATIVE"
      valueType: "INT64"
      unit: "1"
    - name: "erlmcp/http/latency"
      type: "custom.googleapis.com/erlmcp/http/latency"
      metricKind: "GAUGE"
      valueType: "DISTRIBUTION"
      unit: "ms"
    - name: "erlmcp/connections/active"
      type: "custom.googleapis.com/erlmcp/connections/active"
      metricKind: "GAUGE"
      valueType: "INT64"
      unit: "1"
    - name: "erlmcp/erlang/processes"
      type: "custom.googleapis.com/erlmcp/erlang/processes"
      metricKind: "GAUGE"
      valueType: "INT64"
      unit: "1"
    - name: "erlmcp/erlang/memory"
      type: "custom.googleapis.com/erlmcp/erlang/memory"
      metricKind: "GAUGE"
      valueType: "INT64"
      unit: "By"
  # Alerting policies
  alerting:
    enabled: true
    notificationChannels:
      - "projects/${project_id}/notificationChannels/${channel_id}"
    policies:
      - name: "High Error Rate"
        condition: "metric.type=\"custom.googleapis.com/erlmcp/http/errors\" AND resource.type=\"k8s_container\""
        threshold: 0.05
        duration: "300s"
        comparison: "COMPARISON_GT"
      - name: "High Latency"
        condition: "metric.type=\"custom.googleapis.com/erlmcp/http/latency\" AND resource.type=\"k8s_container\""
        threshold: 1000
        duration: "300s"
        comparison: "COMPARISON_GT"
  # SLO (Service Level Objectives)
  slo:
    enabled: true
    objectives:
      - name: "availability"
        target: 0.999  # 99.9% availability
        window: "30d"
        method: "request-based"
      - name: "latency"
        target: 0.95  # 95% of requests < 500ms
        threshold: "500ms"
        window: "30d"
        method: "latency-based"

# Network Policy (GKE Dataplane V2 with eBPF)
networkPolicy:
  enabled: true
  provider: "GKE_DATAPLANE_V2"  # eBPF-based network policy
  # Default deny all traffic (zero-trust)
  defaultDeny:
    enabled: true
    ingress: true
    egress: true
  policies:
    # Allow ingress from Gateway/Load Balancer
    - name: erlmcp-ingress-gateway
      policyTypes:
        - Ingress
      podSelector:
        matchLabels:
          app: erlmcp
      ingress:
        # Allow from GKE load balancer health checks
        - from:
            - ipBlock:
                cidr: "35.191.0.0/16"  # GCP health check ranges
            - ipBlock:
                cidr: "130.211.0.0/22"
          ports:
            - protocol: TCP
              port: 8080
        # Allow from same namespace
        - from:
            - podSelector:
                matchLabels:
                  app: erlmcp
          ports:
            - protocol: TCP
              port: 8080
            - protocol: TCP
              port: 9100  # Erlang distribution
        # Allow metrics scraping from GMP
        - from:
            - namespaceSelector:
                matchLabels:
                  name: gmp-system
          ports:
            - protocol: TCP
              port: 9090

    # Allow egress (restrictive)
    - name: erlmcp-egress-allowed
      policyTypes:
        - Egress
      podSelector:
        matchLabels:
          app: erlmcp
      egress:
        # DNS resolution (kube-dns)
        - to:
            - namespaceSelector:
                matchLabels:
                  name: kube-system
            - podSelector:
                matchLabels:
                  k8s-app: kube-dns
          ports:
            - protocol: UDP
              port: 53
            - protocol: TCP
              port: 53
        # Database access
        - to:
            - podSelector:
                matchLabels:
                  app: postgres
          ports:
            - protocol: TCP
              port: 5432
        # Redis cache
        - to:
            - podSelector:
                matchLabels:
                  app: redis
          ports:
            - protocol: TCP
              port: 6379
        # GCP APIs (Cloud Logging, Monitoring, Trace, Secret Manager)
        - to:
            - ipBlock:
                cidr: "0.0.0.0/0"
                except:
                  - "169.254.169.254/32"  # Block metadata server
          ports:
            - protocol: TCP
              port: 443
        # Inter-pod communication for Erlang distribution
        - to:
            - podSelector:
                matchLabels:
                  app: erlmcp
          ports:
            - protocol: TCP
              port: 9100

# Cloud Armor (DDoS protection and WAF)
cloudArmor:
  enabled: true
  securityPolicy:
    name: "erlmcp-security-policy"
    description: "Security policy for erlmcp workload"
    # Default rule (allow all, then add restrictions)
    defaultRule:
      action: "allow"
      priority: 2147483647
    # Custom rules
    rules:
      # Block bad bots
      - priority: 1000
        description: "Block known bad user agents"
        match:
          expr:
            expression: "request.headers['user-agent'].contains('bad-bot')"
        action: "deny(403)"
        preview: false
      # Rate limiting (100 requests per minute per IP)
      - priority: 1100
        description: "Rate limit per IP"
        match:
          versionedExpr: "SRC_IPS_V1"
          config:
            srcIpRanges:
              - "*"
        rateLimitOptions:
          conformAction: "allow"
          exceedAction: "deny(429)"
          enforceOnKey: "IP"
          rateLimitThreshold:
            count: 100
            intervalSec: 60
      # Block SQL injection attempts
      - priority: 1200
        description: "Block SQL injection"
        match:
          expr:
            expression: "evaluatePreconfiguredExpr('sqli-stable')"
        action: "deny(403)"
        preview: false
      # Block XSS attempts
      - priority: 1300
        description: "Block XSS"
        match:
          expr:
            expression: "evaluatePreconfiguredExpr('xss-stable')"
        action: "deny(403)"
        preview: false
      # Geographic restrictions (optional)
      - priority: 1400
        description: "Allow only from specific regions"
        match:
          expr:
            expression: "origin.region_code in ['US', 'CA', 'EU']"
        action: "allow"
        preview: false
    # Adaptive protection (ML-based DDoS mitigation)
    adaptiveProtection:
      enabled: true
      autoDeployConfig:
        loadThreshold: 0.7
        confidenceThreshold: 0.5
        impactedBaselineThreshold: 0.1
        expirationSec: 7200  # 2 hours

# GKE Node Selector and Affinity (Standard mode only)
# For Autopilot, Google manages node selection automatically
nodeSelector:
  # Standard mode: select specific node pool
  cloud.google.com/gke-nodepool: "erlmcp-pool"
  # Compute-optimized nodes for Erlang VM
  node.kubernetes.io/instance-type: "c2-standard-4"
  # Preemptible/Spot VMs for cost optimization (dev/staging)
  # cloud.google.com/gke-spot: "true"

# Tolerations for Spot VMs and custom taints
tolerations:
  # Tolerate Spot VM evictions
  - key: "cloud.google.com/gke-spot"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"
  # Tolerate preemptible nodes
  - key: "cloud.google.com/gke-preemptible"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"
  # Tolerate Autopilot system pods
  - key: "kubernetes.io/arch"
    operator: "Equal"
    value: "amd64"
    effect: "NoSchedule"

# Affinity and anti-affinity rules
affinity:
  # Pod anti-affinity: spread across zones and nodes
  podAntiAffinity:
    # Required: never schedule on same node
    requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
            - key: app
              operator: In
              values:
                - erlmcp
        topologyKey: "kubernetes.io/hostname"
    # Preferred: spread across zones
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app
                operator: In
                values:
                  - erlmcp
          topologyKey: "topology.kubernetes.io/zone"
  # Node affinity: prefer specific machine types
  nodeAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      # Prefer compute-optimized nodes for Erlang
      - weight: 80
        preference:
          matchExpressions:
            - key: "cloud.google.com/machine-family"
              operator: In
              values:
                - "c2"  # Compute-optimized
                - "c2d"  # Compute-optimized AMD
      # Prefer nodes with local SSD for performance
      - weight: 60
        preference:
          matchExpressions:
            - key: "cloud.google.com/gke-local-ssd"
              operator: Exists
      # Avoid preemptible nodes in production
      - weight: 40
        preference:
          matchExpressions:
            - key: "cloud.google.com/gke-spot"
              operator: DoesNotExist

# Storage configuration (GKE Persistent Disks with CSI driver)
persistence:
  enabled: true
  # Storage class options:
  # - standard-rwo: Standard persistent disk (HDD)
  # - premium-rwo: SSD persistent disk (recommended)
  # - balanced-rwo: Balanced persistent disk (SSD, cost-effective)
  # - extreme-rwo: Extreme persistent disk (highest IOPS)
  storageClass: "premium-rwo"
  accessMode: ReadWriteOnce
  size: 20Gi  # Increased for production
  # Volume snapshot for backup
  snapshot:
    enabled: true
    schedule: "0 2 * * *"  # Daily at 2 AM
    retentionDays: 7
  # Volume expansion
  allowVolumeExpansion: true
  # Encryption at rest (CMEK - Customer Managed Encryption Key)
  encryption:
    enabled: true
    kmsKeyName: "projects/${project_id}/locations/${region}/keyRings/erlmcp/cryptoKeys/erlmcp-disk-key"
  # Performance optimization
  volumeMode: "Filesystem"
  fsType: "ext4"
  # Volume binding mode
  volumeBindingMode: "WaitForFirstConsumer"  # Topology-aware scheduling
  # Local SSD (ephemeral, high performance)
  localSSD:
    enabled: false  # Enable for extreme performance
    count: 1
    type: "scsi"  # or "nvme"

# Health Check configuration (GKE native health checks)
livenessProbe:
  httpGet:
    path: /health
    port: 8080
    scheme: HTTP
    httpHeaders:
      - name: X-Health-Check
        value: "liveness"
  initialDelaySeconds: 60  # Increased for Erlang VM startup
  periodSeconds: 10
  timeoutSeconds: 5
  successThreshold: 1
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: 8080
    scheme: HTTP
    httpHeaders:
      - name: X-Health-Check
        value: "readiness"
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 3
  successThreshold: 1
  failureThreshold: 3

startupProbe:
  httpGet:
    path: /startup
    port: 8080
    scheme: HTTP
    httpHeaders:
      - name: X-Health-Check
        value: "startup"
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 5
  successThreshold: 1
  failureThreshold: 30  # Allow 5 minutes for Erlang VM to start

# Pod Disruption Budget for GKE rolling updates and zone failures
podDisruptionBudget:
  enabled: true
  minAvailable: 2  # Keep at least 2 pods during disruptions
  # OR use maxUnavailable instead:
  # maxUnavailable: 1
  unhealthyPodEvictionPolicy: "AlwaysAllow"  # GKE 1.26+

# HPA configuration for GKE (v2 autoscaling API)
horizontalPodAutoscaler:
  enabled: true
  minReplicas: 3
  maxReplicas: 50
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
    # Custom metrics from GMP
    - type: Pods
      pods:
        metric:
          name: erlmcp_active_connections
        target:
          type: AverageValue
          averageValue: "100"
    - type: External
      external:
        metric:
          name: pubsub.googleapis.com|subscription|num_undelivered_messages
          selector:
            matchLabels:
              resource.labels.subscription_id: "erlmcp-queue"
        target:
          type: AverageValue
          averageValue: "50"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Pods
          value: 1
          periodSeconds: 60
        - type: Percent
          value: 10
          periodSeconds: 60
      selectPolicy: Min
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
        - type: Pods
          value: 4
          periodSeconds: 60
        - type: Percent
          value: 50
          periodSeconds: 60
      selectPolicy: Max

# VPA configuration (Vertical Pod Autoscaler)
verticalPodAutoscaler:
  enabled: true
  updatePolicy:
    updateMode: "Auto"  # Auto, Recreate, Initial, Off
    minReplicas: 2  # Ensure HA during VPA updates
  resourcePolicy:
    containerPolicies:
      - containerName: "erlmcp"
        minAllowed:
          cpu: "500m"
          memory: "1Gi"
        maxAllowed:
          cpu: "4000m"
          memory: "8Gi"
        controlledResources:
          - "cpu"
          - "memory"
        # Controlled values: RequestsAndLimits or RequestsOnly
        controlledValues: "RequestsAndLimits"
        # Don't evict pods during updates
        evictionRequirements:
          - resources: ["memory"]
            changeRequirement: "TargetHigherThanRequests"

# Multidimensional Pod Autoscaler (MPA) - GKE Autopilot
multidimensionalPodAutoscaler:
  enabled: false  # Experimental, combines HPA + VPA
  policies:
    - type: "cpu"
      resource:
        name: "cpu"
        target:
          type: "Utilization"
          averageUtilization: 70
    - type: "memory"
      resource:
        name: "memory"
        target:
          type: "Utilization"
          averageUtilization: 80

# PriorityClass for GKE scheduling (critical workloads)
priorityClassName: "high-priority"
priorityClass:
  create: true
  name: "high-priority"
  value: 1000000  # Higher = more important
  globalDefault: false
  description: "High priority for erlmcp production workloads"
  preemptionPolicy: "PreemptLowerPriority"

# ============================================================================
# Advanced GKE Features (GKE 1.29+)
# ============================================================================

# Config Connector (declarative GCP resource management)
configConnector:
  enabled: true
  mode: "cluster"  # cluster or namespaced
  googleServiceAccount: "erlmcp-config-connector@${project_id}.iam.gserviceaccount.com"
  resources:
    # Cloud SQL instance
    - kind: SQLInstance
      name: erlmcp-postgres
      spec:
        databaseVersion: "POSTGRES_15"
        region: "us-central1"
        settings:
          tier: "db-custom-2-7680"
          availabilityType: "REGIONAL"
          backupConfiguration:
            enabled: true
            startTime: "02:00"
            pointInTimeRecoveryEnabled: true
          ipConfiguration:
            privateNetwork: "projects/${project_id}/global/networks/vpc"
            requireSsl: true
    # Cloud Memorystore (Redis)
    - kind: RedisInstance
      name: erlmcp-redis
      spec:
        tier: "STANDARD_HA"
        memorySizeGb: 5
        region: "us-central1"
        redisVersion: "REDIS_7_0"
        transitEncryptionMode: "SERVER_AUTHENTICATION"

# Service Mesh (Cloud Service Mesh / Istio)
serviceMesh:
  enabled: false  # Enable for advanced traffic management
  provider: "asm"  # asm (Anthos Service Mesh) or istio
  version: "asm-managed-rapid"
  # Sidecar injection
  sidecar:
    enabled: true
    resources:
      requests:
        cpu: "100m"
        memory: "128Mi"
      limits:
        cpu: "2000m"
        memory: "1Gi"
  # Traffic management
  trafficManagement:
    # Circuit breaker
    circuitBreaker:
      enabled: true
      consecutiveErrors: 5
      interval: "30s"
      baseEjectionTime: "30s"
      maxEjectionPercent: 50
    # Retry policy
    retries:
      attempts: 3
      perTryTimeout: "2s"
      retryOn: "5xx,reset,connect-failure,refused-stream"
    # Timeout
    timeout: "30s"
  # Mutual TLS
  mtls:
    mode: "STRICT"  # STRICT, PERMISSIVE, or DISABLE
  # Observability
  telemetry:
    enabled: true
    accessLogging: true
    metrics: true
    tracing:
      sampling: 1.0  # 100% for service mesh

# Security Context (Pod Security Standards)
securityContext:
  # Pod-level security
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
    fsGroupChangePolicy: "OnRootMismatch"
    seccompProfile:
      type: "RuntimeDefault"
    supplementalGroups: []
  # Container-level security
  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1000
    capabilities:
      drop:
        - ALL
      add: []
    seccompProfile:
      type: "RuntimeDefault"

# Deployment Strategy (Rolling update configuration)
deployment:
  strategy:
    type: "RollingUpdate"
    rollingUpdate:
      maxSurge: "25%"  # Max 25% extra pods during rollout
      maxUnavailable: "0%"  # Zero downtime deployment
  # Revision history
  revisionHistoryLimit: 10
  # Progress deadline (10 minutes)
  progressDeadlineSeconds: 600
  # Termination grace period (for graceful shutdown)
  terminationGracePeriodSeconds: 60
  # Lifecycle hooks
  lifecycle:
    preStop:
      exec:
        command:
          - "/bin/sh"
          - "-c"
          - "sleep 15"  # Allow time for load balancer to drain

# Multi-cluster and Fleet Management
fleet:
  enabled: false  # Enable for multi-cluster deployments
  projectNumber: "${project_number}"
  membershipName: "erlmcp-cluster"
  # Multi-cluster ingress
  multiClusterIngress:
    enabled: false
    configCluster: "projects/${project_id}/locations/global/memberships/config-cluster"
  # Multi-cluster services
  multiClusterServices:
    enabled: false

# Cost Optimization Features
costOptimization:
  # Spot VMs for non-critical workloads (Standard mode)
  spotVMs:
    enabled: false
    percentage: 50  # 50% of nodes can be Spot VMs
    nodeSelector:
      cloud.google.com/gke-spot: "true"
    tolerations:
      - key: "cloud.google.com/gke-spot"
        operator: "Equal"
        value: "true"
        effect: "NoSchedule"
  # Resource quotas per namespace
  resourceQuotas:
    enabled: true
    hard:
      requests.cpu: "100"
      requests.memory: "200Gi"
      persistentvolumeclaims: "50"
      pods: "100"
  # Limit ranges
  limitRanges:
    enabled: true
    limits:
      - type: "Container"
        max:
          cpu: "4"
          memory: "8Gi"
        min:
          cpu: "100m"
          memory: "128Mi"
        default:
          cpu: "1"
          memory: "2Gi"
        defaultRequest:
          cpu: "500m"
          memory: "1Gi"

# Disaster Recovery and High Availability
disasterRecovery:
  # Regional cluster (multi-zone)
  regionalCluster: true
  zones:
    - "us-central1-a"
    - "us-central1-b"
    - "us-central1-c"
  # Backup strategy
  backup:
    enabled: true
    provider: "gke-backup"  # or "velero"
    schedule: "0 2 * * *"
    retentionDays: 30
    includeVolumes: true
    includeSecrets: false
  # Cross-region replication
  replication:
    enabled: false
    targetRegion: "us-east1"
    replicationMode: "async"

# Compliance and Governance
compliance:
  # Policy Controller (OPA Gatekeeper)
  policyController:
    enabled: true
    templateLibrary: "BASELINE"  # or ENTERPRISE
    auditIntervalSeconds: 60
    constraintViolationsLimit: 100
    referentialRulesEnabled: true
  # Binary Authorization
  binaryAuthorization:
    enabled: true
    mode: "PROJECT_SINGLETON_POLICY_ENFORCE"
  # Pod Security Policy (deprecated, use Pod Security Standards)
  podSecurityStandards:
    enabled: true
    enforce: "restricted"  # privileged, baseline, restricted
    audit: "restricted"
    warn: "restricted"
  # Audit logging
  auditLogging:
    enabled: true
    logName: "projects/${project_id}/logs/cloudaudit.googleapis.com%2Factivity"

# Developer Experience
developerExperience:
  # Cloud Code integration
  cloudCode:
    enabled: true
    debugger: true
  # Cloud Build integration
  cloudBuild:
    enabled: true
    triggerName: "erlmcp-build-trigger"
    substitutions:
      _REGION: "us-central1"
      _CLUSTER: "erlmcp-cluster"
  # Artifact Registry
  artifactRegistry:
    enabled: true
    location: "us-central1"
    repository: "erlmcp"
    format: "DOCKER"

# Monitoring and Alerting Dashboards
dashboards:
  enabled: true
  # Pre-built dashboards for Cloud Monitoring
  templates:
    - name: "erlmcp-overview"
      displayName: "erlmcp Overview"
      widgets:
        - title: "Request Rate"
          scorecard:
            timeSeriesQuery:
              timeSeriesFilter:
                filter: 'metric.type="custom.googleapis.com/erlmcp/http/requests"'
        - title: "Error Rate"
          scorecard:
            timeSeriesQuery:
              timeSeriesFilter:
                filter: 'metric.type="custom.googleapis.com/erlmcp/http/errors"'
        - title: "Latency p99"
          scorecard:
            timeSeriesQuery:
              timeSeriesFilter:
                filter: 'metric.type="custom.googleapis.com/erlmcp/http/latency"'
                aggregation:
                  perSeriesAligner: "ALIGN_DELTA"
                  crossSeriesReducer: "REDUCE_PERCENTILE_99"
