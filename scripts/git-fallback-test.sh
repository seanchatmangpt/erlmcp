#!/usr/bin/env bash
# git-fallback-test.sh - Test git-based dependency fallback
# Purpose: Convert hex dependencies to git repos for fallback when hex.pm is unavailable
# Usage: ./git-fallback-test.sh [--dry-run]

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
LOG_DIR="${PROJECT_ROOT}/log/git-fallback-test"
BACKUP_DIR="${PROJECT_ROOT}/.rebar-backup"

DRY_RUN=false
if [ "${1:-}" == "--dry-run" ]; then
    DRY_RUN=true
fi

mkdir -p "${LOG_DIR}" "${BACKUP_DIR}"

log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $*" | tee -a "${LOG_DIR}/test.log"
}

log_success() {
    echo -e "${GREEN}✓${NC} $*" | tee -a "${LOG_DIR}/test.log"
}

log_error() {
    echo -e "${RED}✗${NC} $*" | tee -a "${LOG_DIR}/test.log"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $*" | tee -a "${LOG_DIR}/test.log"
}

# Map of hex packages to their git repositories
declare -A GIT_REPOS=(
    ["jsx"]="https://github.com/talentdeficit/jsx.git"
    ["jesse"]="https://github.com/for-GET/jesse.git"
    ["gproc"]="https://github.com/uwiger/gproc.git"
    ["gun"]="https://github.com/ninenines/gun.git"
    ["ranch"]="https://github.com/ninenines/ranch.git"
    ["poolboy"]="https://github.com/devinus/poolboy.git"
    ["cowboy"]="https://github.com/ninenines/cowboy.git"
    ["bbmustache"]="https://github.com/soranoba/bbmustache.git"
    ["jose"]="https://github.com/potatosalad/erlang-jose.git"
    ["opentelemetry_api"]="https://github.com/open-telemetry/opentelemetry-erlang.git"
    ["opentelemetry"]="https://github.com/open-telemetry/opentelemetry-erlang.git"
    ["opentelemetry_exporter"]="https://github.com/open-telemetry/opentelemetry-erlang.git"
    ["proper"]="https://github.com/proper-testing/proper.git"
    ["meck"]="https://github.com/eproxus/meck.git"
)

# Map packages to git tags (version -> tag format)
declare -A GIT_TAGS=(
    ["jsx"]="v3.1.0"
    ["jesse"]="1.8.1"
    ["gproc"]="0.9.0"
    ["gun"]="2.0.1"
    ["ranch"]="2.1.0"
    ["poolboy"]="1.5.2"
    ["cowboy"]="2.10.0"
    ["bbmustache"]="v1.12.2"
    ["jose"]="1.11.1"
    ["proper"]="v1.4.0"
    ["meck"]="0.9.2"
)

# Test git repo accessibility
test_git_repo() {
    local package="$1"
    local repo_url="$2"
    local tag="${GIT_TAGS[$package]:-master}"
    
    log "Testing git repo: ${package} from ${repo_url}"
    
    # Test 1: Repo is accessible
    if ! git ls-remote --exit-code "${repo_url}" >/dev/null 2>&1; then
        log_error "${package}: Repository not accessible"
        return 1
    fi
    
    log_success "${package}: Repository accessible"
    
    # Test 2: Tag/branch exists
    if git ls-remote --tags "${repo_url}" | grep -q "refs/tags/${tag}"; then
        log_success "${package}: Tag ${tag} exists"
        return 0
    else
        log_warning "${package}: Tag ${tag} not found, will use master"
        return 0
    fi
}

# Clone and verify package
test_clone_and_build() {
    local package="$1"
    local repo_url="$2"
    local tag="${GIT_TAGS[$package]:-master}"
    local clone_dir="${LOG_DIR}/${package}"
    
    log "Cloning and testing build: ${package}"
    
    # Clean previous clone
    rm -rf "${clone_dir}"
    
    # Clone
    if ! git clone --depth 1 --branch "${tag}" "${repo_url}" "${clone_dir}" >/dev/null 2>&1; then
        # Try without tag
        if ! git clone --depth 1 "${repo_url}" "${clone_dir}" >/dev/null 2>&1; then
            log_error "${package}: Clone failed"
            return 1
        fi
    fi
    
    log_success "${package}: Cloned successfully"
    
    # Test build
    cd "${clone_dir}"
    
    if [ -f "rebar.config" ] || [ -f "rebar3" ]; then
        if rebar3 compile >/dev/null 2>&1; then
            log_success "${package}: Compiled successfully"
            return 0
        else
            log_warning "${package}: Compilation issues (may still work as dependency)"
            return 0
        fi
    else
        log_success "${package}: No rebar.config (will be managed by rebar3)"
        return 0
    fi
}

# Generate git-based rebar.config
generate_git_config() {
    local -a successful_packages=("$@")
    local config_file="${PROJECT_ROOT}/rebar.config.git"
    
    log "Generating git-based rebar.config"
    
    # Read current config and convert deps
    cat > "${config_file}" << 'CONFIG_HEADER'
%% Generated by git-fallback-test.sh
%% Git-based dependencies (fallback for hex.pm issues)

{deps, [
CONFIG_HEADER

    local first=true
    for package in "${successful_packages[@]}"; do
        if [ "${first}" = true ]; then
            first=false
        else
            echo "," >> "${config_file}"
        fi
        
        local repo_url="${GIT_REPOS[$package]}"
        local tag="${GIT_TAGS[$package]:-master}"
        
        # Format: {package, {git, "url", {tag, "version"}}}
        if [ "${tag}" != "master" ]; then
            echo -n "  {${package}, {git, \"${repo_url}\", {tag, \"${tag}\"}}}" >> "${config_file}"
        else
            echo -n "  {${package}, {git, \"${repo_url}\", {branch, \"master\"}}}" >> "${config_file}"
        fi
    done
    
    cat >> "${config_file}" << 'CONFIG_FOOTER'

]}.

%% To use this config:
%% 1. Backup: cp rebar.config rebar.config.bak
%% 2. Replace: cp rebar.config.git rebar.config
%% 3. Clean: rm -rf _build
%% 4. Fetch: rebar3 get-deps
%% 5. Compile: rebar3 compile
CONFIG_FOOTER

    log_success "Git config saved to: ${config_file}"
}

# Generate mixed (hex + git) config
generate_mixed_config() {
    local -a failed_packages=("$@")
    local config_file="${PROJECT_ROOT}/rebar.config.mixed"
    
    log "Generating mixed hex+git rebar.config"
    
    cat > "${config_file}" << 'CONFIG_HEADER'
%% Generated by git-fallback-test.sh
%% Mixed hex + git dependencies (use git only for failing packages)

{deps, [
CONFIG_HEADER

    # Parse current rebar.config
    local in_deps=false
    local first=true
    
    while IFS= read -r line; do
        if echo "${line}" | grep -q "^{deps"; then
            in_deps=true
            continue
        fi
        
        if [ "${in_deps}" = true ]; then
            if echo "${line}" | grep -q "^]"; then
                break
            fi
            
            # Extract package name
            local package=$(echo "${line}" | grep -o '{[a-z_]*' | tr -d '{')
            
            if [ -n "${package}" ]; then
                # Check if package failed and has git repo
                if printf '%s\n' "${failed_packages[@]}" | grep -q "^${package}$"; then
                    if [ -n "${GIT_REPOS[$package]:-}" ]; then
                        # Use git
                        if [ "${first}" = true ]; then
                            first=false
                        else
                            echo "," >> "${config_file}"
                        fi
                        
                        local repo_url="${GIT_REPOS[$package]}"
                        local tag="${GIT_TAGS[$package]:-master}"
                        
                        if [ "${tag}" != "master" ]; then
                            echo -n "  {${package}, {git, \"${repo_url}\", {tag, \"${tag}\"}}}" >> "${config_file}"
                        else
                            echo -n "  {${package}, {git, \"${repo_url}\", {branch, \"master\"}}}" >> "${config_file}"
                        fi
                        
                        log "  ${package}: Using git (${repo_url})"
                    else
                        # Keep hex (no git alternative)
                        if [ "${first}" = true ]; then
                            first=false
                        else
                            echo "," >> "${config_file}"
                        fi
                        echo -n "  ${line}" >> "${config_file}"
                        log_warning "  ${package}: No git alternative, keeping hex"
                    fi
                else
                    # Keep hex
                    if [ "${first}" = true ]; then
                        first=false
                    else
                        echo "," >> "${config_file}"
                    fi
                    echo -n "  ${line}" >> "${config_file}"
                fi
            fi
        fi
    done < "${PROJECT_ROOT}/rebar.config"
    
    cat >> "${config_file}" << 'CONFIG_FOOTER'

]}.
CONFIG_FOOTER

    log_success "Mixed config saved to: ${config_file}"
}

# Test current hex deps with git fallback
test_all_packages() {
    log "Testing all packages for git fallback"
    
    declare -a successful_packages
    declare -a failed_packages
    
    for package in "${!GIT_REPOS[@]}"; do
        echo ""
        log "========================================="
        log "Testing: ${package}"
        log "========================================="
        
        if test_git_repo "${package}" "${GIT_REPOS[$package]}"; then
            if [ "${DRY_RUN}" = false ]; then
                if test_clone_and_build "${package}" "${GIT_REPOS[$package]}"; then
                    successful_packages+=("${package}")
                else
                    failed_packages+=("${package}")
                fi
            else
                successful_packages+=("${package}")
            fi
        else
            failed_packages+=("${package}")
        fi
    done
    
    # Summary
    echo ""
    log "========================================="
    log "SUMMARY"
    log "========================================="
    echo ""
    
    log "Successful packages (${#successful_packages[@]}):"
    for package in "${successful_packages[@]}"; do
        log_success "  ${package}"
    done
    
    echo ""
    
    if [ ${#failed_packages[@]} -gt 0 ]; then
        log "Failed packages (${#failed_packages[@]}):"
        for package in "${failed_packages[@]}"; do
            log_error "  ${package}"
        done
    fi
    
    echo ""
    
    # Generate configs
    if [ ${#successful_packages[@]} -gt 0 ]; then
        generate_git_config "${successful_packages[@]}"
        
        if [ ${#failed_packages[@]} -gt 0 ]; then
            generate_mixed_config "${failed_packages[@]}"
        fi
        
        echo ""
        log "Usage recommendations:"
        log "  1. Full git mode: cp rebar.config.git rebar.config"
        log "  2. Mixed mode: cp rebar.config.mixed rebar.config"
        log "  3. Always clean before switching: rm -rf _build"
    else
        log_error "No successful git packages found"
    fi
    
    log "Test completed at $(date)"
}

# Main
main() {
    log "Starting git fallback test"
    if [ "${DRY_RUN}" = true ]; then
        log "Running in DRY RUN mode (no cloning/building)"
    fi
    
    # Backup current config
    if [ -f "${PROJECT_ROOT}/rebar.config" ]; then
        cp "${PROJECT_ROOT}/rebar.config" "${BACKUP_DIR}/rebar.config.$(date +%Y%m%d_%H%M%S)"
        log "Backup created in ${BACKUP_DIR}"
    fi
    
    test_all_packages
}

main "$@"
