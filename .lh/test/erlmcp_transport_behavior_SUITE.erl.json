{
    "sourceFile": "test/erlmcp_transport_behavior_SUITE.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1756185314750,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756190592599,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,147 +9,112 @@\n -module(erlmcp_transport_behavior_SUITE).\n \n -include_lib(\"common_test/include/ct.hrl\").\n -include_lib(\"eunit/include/eunit.hrl\").\n+\n -include(\"erlmcp.hrl\").\n \n %% Suite callbacks\n--export([all/0, groups/0, init_per_suite/1, end_per_suite/1,\n-         init_per_group/2, end_per_group/2,\n-         init_per_testcase/2, end_per_testcase/2]).\n+-export([all/0, groups/0, init_per_suite/1, end_per_suite/1, init_per_group/2,\n+         end_per_group/2, init_per_testcase/2, end_per_testcase/2]).\n+%% Test cases\n+-export([behavior_module_exists/1, behavior_callbacks_defined/1,\n+         behavior_types_exported/1, behavior_optional_callbacks/1, validate_json_rpc_message/1,\n+         validate_transport_opts/1, message_creation_functions/1, error_message_creation/1,\n+         stdio_opts_validation/1, tcp_opts_validation/1, http_opts_validation/1,\n+         websocket_opts_validation/1, json_rpc_structure/1, notification_format/1,\n+         response_format/1, error_response_format/1, stdio_behavior_compliance/1,\n+         tcp_behavior_compliance/1, http_behavior_compliance/1, transport_state_type/1,\n+         transport_opts_type/1, transport_message_type/1, transport_info_type/1,\n+         url_validation_functions/1, host_validation_functions/1, message_content_validation/1,\n+         error_structure_validation/1, behavior_with_registry/1, behavior_error_handling/1,\n+         behavior_lifecycle/1]).    % Behavior validation\n \n-%% Test cases\n--export([\n-    % Behavior validation\n-    behavior_module_exists/1,\n-    behavior_callbacks_defined/1,\n-    behavior_types_exported/1,\n-    behavior_optional_callbacks/1,\n-    \n     % Message validation\n-    validate_json_rpc_message/1,\n-    validate_transport_opts/1,\n-    message_creation_functions/1,\n-    error_message_creation/1,\n-    \n+\n     % Transport options validation\n-    stdio_opts_validation/1,\n-    tcp_opts_validation/1,\n-    http_opts_validation/1,\n-    websocket_opts_validation/1,\n-    \n+\n     % Message format compliance\n-    json_rpc_structure/1,\n-    notification_format/1,\n-    response_format/1,\n-    error_response_format/1,\n-    \n+\n     % Behavior compliance tests\n-    stdio_behavior_compliance/1,\n-    tcp_behavior_compliance/1,\n-    http_behavior_compliance/1,\n-    \n+\n     % Type system validation\n-    transport_state_type/1,\n-    transport_opts_type/1,\n-    transport_message_type/1,\n-    transport_info_type/1,\n-    \n+\n     % Validation functions\n-    url_validation_functions/1,\n-    host_validation_functions/1,\n-    message_content_validation/1,\n-    error_structure_validation/1,\n-    \n+\n     % Integration testing\n-    behavior_with_registry/1,\n-    behavior_error_handling/1,\n-    behavior_lifecycle/1\n-]).\n \n %%====================================================================\n %% Suite Configuration\n %%====================================================================\n \n all() ->\n-    [\n-        {group, behavior_validation},\n-        {group, message_validation},\n-        {group, transport_options},\n-        {group, message_formats},\n-        {group, behavior_compliance},\n-        {group, type_system},\n-        {group, validation_functions},\n-        {group, integration}\n-    ].\n+    [{group, behavior_validation},\n+     {group, message_validation},\n+     {group, transport_options},\n+     {group, message_formats},\n+     {group, behavior_compliance},\n+     {group, type_system},\n+     {group, validation_functions},\n+     {group, integration}].\n \n groups() ->\n-    [\n-        {behavior_validation, [parallel], [\n-            behavior_module_exists,\n-            behavior_callbacks_defined,\n-            behavior_types_exported,\n-            behavior_optional_callbacks\n-        ]},\n-        {message_validation, [parallel], [\n-            validate_json_rpc_message,\n-            validate_transport_opts,\n-            message_creation_functions,\n-            error_message_creation\n-        ]},\n-        {transport_options, [parallel], [\n-            stdio_opts_validation,\n-            tcp_opts_validation,\n-            http_opts_validation,\n-            websocket_opts_validation\n-        ]},\n-        {message_formats, [parallel], [\n-            json_rpc_structure,\n-            notification_format,\n-            response_format,\n-            error_response_format\n-        ]},\n-        {behavior_compliance, [sequential], [\n-            stdio_behavior_compliance,\n-            tcp_behavior_compliance,\n-            http_behavior_compliance\n-        ]},\n-        {type_system, [parallel], [\n-            transport_state_type,\n-            transport_opts_type,\n-            transport_message_type,\n-            transport_info_type\n-        ]},\n-        {validation_functions, [parallel], [\n-            url_validation_functions,\n-            host_validation_functions,\n-            message_content_validation,\n-            error_structure_validation\n-        ]},\n-        {integration, [sequential], [\n-            behavior_with_registry,\n-            behavior_error_handling,\n-            behavior_lifecycle\n-        ]}\n-    ].\n+    [{behavior_validation,\n+      [parallel],\n+      [behavior_module_exists,\n+       behavior_callbacks_defined,\n+       behavior_types_exported,\n+       behavior_optional_callbacks]},\n+     {message_validation,\n+      [parallel],\n+      [validate_json_rpc_message,\n+       validate_transport_opts,\n+       message_creation_functions,\n+       error_message_creation]},\n+     {transport_options,\n+      [parallel],\n+      [stdio_opts_validation,\n+       tcp_opts_validation,\n+       http_opts_validation,\n+       websocket_opts_validation]},\n+     {message_formats,\n+      [parallel],\n+      [json_rpc_structure, notification_format, response_format, error_response_format]},\n+     {behavior_compliance,\n+      [sequential],\n+      [stdio_behavior_compliance, tcp_behavior_compliance, http_behavior_compliance]},\n+     {type_system,\n+      [parallel],\n+      [transport_state_type, transport_opts_type, transport_message_type, transport_info_type]},\n+     {validation_functions,\n+      [parallel],\n+      [url_validation_functions,\n+       host_validation_functions,\n+       message_content_validation,\n+       error_structure_validation]},\n+     {integration,\n+      [sequential],\n+      [behavior_with_registry, behavior_error_handling, behavior_lifecycle]}].\n \n %%====================================================================\n %% Suite Setup/Teardown\n %%====================================================================\n \n init_per_suite(Config) ->\n     ct:pal(\"Starting transport behavior test suite\"),\n-    \n+\n     % Start necessary applications\n     ok = application:ensure_started(crypto),\n     ok = application:ensure_started(sasl),\n-    \n+\n     % Start registry for integration tests\n     case erlmcp_registry:start_link() of\n-        {ok, _} -> ok;\n-        {error, {already_started, _}} -> ok\n+        {ok, _} ->\n+            ok;\n+        {error, {already_started, _}} ->\n+            ok\n     end,\n-    \n+\n     Config.\n \n end_per_suite(_Config) ->\n     ct:pal(\"Ending transport behavior test suite\"),\n@@ -176,45 +141,40 @@\n %%====================================================================\n \n behavior_module_exists(Config) ->\n     % Verify the behavior module exists and can be loaded\n-    ?assert(code:is_loaded(erlmcp_transport) =/= false orelse \n-            code:load_file(erlmcp_transport) =:= {module, erlmcp_transport}),\n-    \n+    ?assert(code:is_loaded(erlmcp_transport) =/= false\n+            orelse code:load_file(erlmcp_transport) =:= {module, erlmcp_transport}),\n+\n     % Verify it's a behavior module\n     Attributes = erlmcp_transport:module_info(attributes),\n-    ?assert(lists:member(behavior, proplists:get_keys(Attributes)) orelse\n-            lists:member(behaviour, proplists:get_keys(Attributes))),\n+    ?assert(lists:member(behavior, proplists:get_keys(Attributes))\n+            orelse lists:member(behaviour, proplists:get_keys(Attributes))),\n     ok.\n \n behavior_callbacks_defined(Config) ->\n     % Verify required callbacks are defined\n-    RequiredCallbacks = [\n-        {init, 1},\n-        {send, 2},\n-        {close, 1}\n-    ],\n-    \n+    RequiredCallbacks = [{init, 1}, {send, 2}, {close, 1}],\n+\n     Callbacks = erlmcp_transport:behaviour_info(callbacks),\n-    \n-    lists:foreach(fun(Callback) ->\n-        ?assert(lists:member(Callback, Callbacks))\n-    end, RequiredCallbacks),\n-    \n+\n+    lists:foreach(fun(Callback) -> ?assert(lists:member(Callback, Callbacks)) end,\n+                  RequiredCallbacks),\n+\n     % Verify optional callbacks are marked as optional\n     OptionalCallbacks = erlmcp_transport:behaviour_info(optional_callbacks),\n     ExpectedOptional = [{get_info, 1}, {handle_transport_call, 2}],\n-    \n-    lists:foreach(fun(OptCallback) ->\n-        ?assert(lists:member(OptCallback, OptionalCallbacks))\n-    end, ExpectedOptional),\n-    \n+\n+    lists:foreach(fun(OptCallback) -> ?assert(lists:member(OptCallback, OptionalCallbacks))\n+                  end,\n+                  ExpectedOptional),\n+\n     ok.\n \n behavior_types_exported(Config) ->\n     % Verify exported types\n     Exports = erlmcp_transport:module_info(exports),\n-    \n+\n     % Check for type information (may vary by Erlang version)\n     % At minimum, verify the module compiles and loads\n     ?assert(is_list(Exports)),\n     ?assert(length(Exports) > 0),\n@@ -222,65 +182,73 @@\n \n behavior_optional_callbacks(Config) ->\n     % Test optional callbacks behavior\n     OptionalCallbacks = [get_info, handle_transport_call],\n-    \n+\n     % These should be marked as optional\n     lists:foreach(fun(Callback) ->\n-        % Verify optional callback is properly defined\n-        ?assert(erlang:function_exported(erlmcp_transport, behaviour_info, 1))\n-    end, OptionalCallbacks),\n+                     % Verify optional callback is properly defined\n+                     ?assert(erlang:function_exported(erlmcp_transport, behaviour_info, 1))\n+                  end,\n+                  OptionalCallbacks),\n     ok.\n \n %%====================================================================\n %% Test Cases - Message Validation\n %%====================================================================\n \n validate_json_rpc_message(Config) ->\n     % Test valid JSON-RPC messages\n-    ValidMessages = [\n-        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"method\">> => <<\"test\">>, <<\"id\">> => 1},\n-        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"result\">> => <<\"ok\">>, <<\"id\">> => 1},\n-        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"method\">> => <<\"notify\">>}, % Notification\n-        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"error\">> => \n-            #{<<\"code\">> => -32600, <<\"message\">> => <<\"Invalid Request\">>}, <<\"id\">> => null}\n-    ],\n-    \n-    lists:foreach(fun(Message) ->\n-        ?assertEqual(ok, erlmcp_transport:validate_message(Message))\n-    end, ValidMessages),\n-    \n+    ValidMessages =\n+        [#{<<\"jsonrpc\">> => <<\"2.0\">>,\n+           <<\"method\">> => <<\"test\">>,\n+           <<\"id\">> => 1},\n+         #{<<\"jsonrpc\">> => <<\"2.0\">>,\n+           <<\"result\">> => <<\"ok\">>,\n+           <<\"id\">> => 1},\n+         #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"method\">> => <<\"notify\">>}, % Notification\n+         #{<<\"jsonrpc\">> => <<\"2.0\">>,\n+           <<\"error\">> => #{<<\"code\">> => -32600, <<\"message\">> => <<\"Invalid Request\">>},\n+           <<\"id\">> => null}],\n+\n+    lists:foreach(fun(Message) -> ?assertEqual(ok, erlmcp_transport:validate_message(Message))\n+                  end,\n+                  ValidMessages),\n+\n     % Test invalid messages\n-    InvalidMessages = [\n-        #{}, % Missing jsonrpc field\n-        #{<<\"jsonrpc\">> => <<\"1.0\">>}, % Wrong version\n-        #{<<\"jsonrpc\">> => <<\"2.0\">>}, % No method, result, or error\n-        \"not a map\", % Not a map\n-        42 % Not a map\n-    ],\n-    \n+    InvalidMessages =\n+        [#{}, % Missing jsonrpc field\n+         #{<<\"jsonrpc\">> => <<\"1.0\">>}, % Wrong version\n+         #{<<\"jsonrpc\">> => <<\"2.0\">>}, % No method, result, or error\n+         \"not a map\", % Not a map\n+         42], % Not a map\n+\n     lists:foreach(fun(Message) ->\n-        ?assertMatch({error, _}, erlmcp_transport:validate_message(Message))\n-    end, InvalidMessages),\n+                     ?assertMatch({error, _}, erlmcp_transport:validate_message(Message))\n+                  end,\n+                  InvalidMessages),\n     ok.\n \n validate_transport_opts(Config) ->\n     % Test stdio options validation\n     ValidStdioOpts = #{owner => self()},\n     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(stdio, ValidStdioOpts)),\n-    \n+\n     % Test TCP options validation\n-    ValidTcpOpts = #{host => \"localhost\", port => 8080, owner => self()},\n+    ValidTcpOpts =\n+        #{host => \"localhost\",\n+          port => 8080,\n+          owner => self()},\n     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, ValidTcpOpts)),\n-    \n-    % Test HTTP options validation  \n+\n+    % Test HTTP options validation\n     ValidHttpOpts = #{url => \"http://example.com/api\", owner => self()},\n     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, ValidHttpOpts)),\n-    \n+\n     % Test WebSocket options validation\n     ValidWsOpts = #{url => \"ws://example.com/ws\", owner => self()},\n     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(websocket, ValidWsOpts)),\n-    \n+\n     % Test invalid transport type\n     ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(invalid_type, #{})),\n     ok.\n \n@@ -288,23 +256,23 @@\n     % Test message creation functions\n     Method = <<\"test_method\">>,\n     Params = #{param1 => <<\"value1\">>},\n     Id = 123,\n-    \n+\n     % Test create_message/3\n     Message = erlmcp_transport:create_message(Method, Params, Id),\n     ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Message)),\n     ?assertEqual(Method, maps:get(<<\"method\">>, Message)),\n     ?assertEqual(Params, maps:get(<<\"params\">>, Message)),\n     ?assertEqual(Id, maps:get(<<\"id\">>, Message)),\n-    \n+\n     % Test create_notification/2\n     Notification = erlmcp_transport:create_notification(Method, Params),\n     ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Notification)),\n     ?assertEqual(Method, maps:get(<<\"method\">>, Notification)),\n     ?assertEqual(Params, maps:get(<<\"params\">>, Notification)),\n     ?assertNot(maps:is_key(<<\"id\">>, Notification)),\n-    \n+\n     % Test create_response/2\n     Result = #{result => <<\"success\">>},\n     Response = erlmcp_transport:create_response(Id, Result),\n     ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Response)),\n@@ -317,19 +285,19 @@\n     Id = 456,\n     Code = -32600,\n     Message = <<\"Invalid Request\">>,\n     Data = #{additional => <<\"info\">>},\n-    \n+\n     % Test with data\n     ErrorWithData = erlmcp_transport:create_error_response(Id, Code, Message, Data),\n     ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, ErrorWithData)),\n     ?assertEqual(Id, maps:get(<<\"id\">>, ErrorWithData)),\n-    \n+\n     ErrorObj = maps:get(<<\"error\">>, ErrorWithData),\n     ?assertEqual(Code, maps:get(<<\"code\">>, ErrorObj)),\n     ?assertEqual(Message, maps:get(<<\"message\">>, ErrorObj)),\n     ?assertEqual(Data, maps:get(<<\"data\">>, ErrorObj)),\n-    \n+\n     % Test without data\n     ErrorWithoutData = erlmcp_transport:create_error_response(Id, Code, Message, undefined),\n     ErrorObj2 = maps:get(<<\"error\">>, ErrorWithoutData),\n     ?assertNot(maps:is_key(<<\"data\">>, ErrorObj2)),\n@@ -340,175 +308,185 @@\n %%====================================================================\n \n stdio_opts_validation(Config) ->\n     % Valid stdio options\n-    ValidOpts = [\n-        #{owner => self()},\n-        #{owner => self(), test_mode => true},\n-        #{owner => self(), test_mode => false}\n-    ],\n-    \n+    ValidOpts =\n+        [#{owner => self()},\n+         #{owner => self(), test_mode => true},\n+         #{owner => self(), test_mode => false}],\n+\n     lists:foreach(fun(Opts) ->\n-        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(stdio, Opts))\n-    end, ValidOpts),\n-    \n+                     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(stdio, Opts))\n+                  end,\n+                  ValidOpts),\n+\n     % Invalid stdio options\n-    InvalidOpts = [\n-        #{}, % Missing owner\n-        #{owner => \"not_a_pid\"}, % Invalid owner type\n-        #{owner => self(), invalid_option => true} % Extra invalid option\n-    ],\n-    \n+    InvalidOpts =\n+        [#{}, % Missing owner\n+         #{owner => \"not_a_pid\"}, % Invalid owner type\n+         #{owner => self(), invalid_option => true}], % Extra invalid option\n+\n     lists:foreach(fun(Opts) ->\n-        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(stdio, Opts))\n-    end, InvalidOpts),\n+                     ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(stdio, Opts))\n+                  end,\n+                  InvalidOpts),\n     ok.\n \n tcp_opts_validation(Config) ->\n     % Valid TCP options\n-    ValidOpts = [\n-        #{host => \"localhost\", port => 8080, owner => self()},\n-        #{host => {127,0,0,1}, port => 8080, owner => self()},\n-        #{host => \"example.com\", port => 443, owner => self(), keepalive => true}\n-    ],\n-    \n+    ValidOpts =\n+        [#{host => \"localhost\",\n+           port => 8080,\n+           owner => self()},\n+         #{host => {127, 0, 0, 1},\n+           port => 8080,\n+           owner => self()},\n+         #{host => \"example.com\",\n+           port => 443,\n+           owner => self(),\n+           keepalive => true}],\n+\n     lists:foreach(fun(Opts) ->\n-        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, Opts))\n-    end, ValidOpts),\n-    \n+                     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, Opts))\n+                  end,\n+                  ValidOpts),\n+\n     % Invalid TCP options\n-    InvalidOpts = [\n-        #{}, % Missing required fields\n-        #{host => \"localhost\", owner => self()}, % Missing port\n-        #{host => \"localhost\", port => 0, owner => self()}, % Invalid port\n-        #{host => \"localhost\", port => 70000, owner => self()}, % Port too high\n-        #{host => invalid_host, port => 8080, owner => self()} % Invalid host\n-    ],\n-    \n+    InvalidOpts =\n+        [#{}, % Missing required fields\n+         #{host => \"localhost\", owner => self()}, % Missing port\n+         #{host => \"localhost\",\n+           port => 0,\n+           owner => self()}, % Invalid port\n+         #{host => \"localhost\",\n+           port => 70000,\n+           owner => self()}, % Port too high\n+         #{host => invalid_host,\n+           port => 8080,\n+           owner => self()}], % Invalid host\n+\n     lists:foreach(fun(Opts) ->\n-        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(tcp, Opts))\n-    end, InvalidOpts),\n+                     ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(tcp, Opts))\n+                  end,\n+                  InvalidOpts),\n     ok.\n \n http_opts_validation(Config) ->\n     % Valid HTTP options\n-    ValidOpts = [\n-        #{url => \"http://example.com/api\", owner => self()},\n-        #{url => \"https://secure.example.com/api\", owner => self()},\n-        #{url => <<\"http://example.com/api\">>, owner => self()},\n-        #{url => \"http://localhost:8080/api\", owner => self()}\n-    ],\n-    \n+    ValidOpts =\n+        [#{url => \"http://example.com/api\", owner => self()},\n+         #{url => \"https://secure.example.com/api\", owner => self()},\n+         #{url => <<\"http://example.com/api\">>, owner => self()},\n+         #{url => \"http://localhost:8080/api\", owner => self()}],\n+\n     lists:foreach(fun(Opts) ->\n-        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, Opts))\n-    end, ValidOpts),\n-    \n+                     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, Opts))\n+                  end,\n+                  ValidOpts),\n+\n     % Invalid HTTP options\n-    InvalidOpts = [\n-        #{}, % Missing required fields\n-        #{url => \"ftp://example.com\", owner => self()}, % Invalid protocol\n-        #{url => \"not-a-url\", owner => self()}, % Invalid URL format\n-        #{url => \"\", owner => self()} % Empty URL\n-    ],\n-    \n+    InvalidOpts =\n+        [#{}, % Missing required fields\n+         #{url => \"ftp://example.com\", owner => self()}, % Invalid protocol\n+         #{url => \"not-a-url\", owner => self()}, % Invalid URL format\n+         #{url => \"\", owner => self()}], % Empty URL\n+\n     lists:foreach(fun(Opts) ->\n-        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(http, Opts))\n-    end, InvalidOpts),\n+                     ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(http, Opts))\n+                  end,\n+                  InvalidOpts),\n     ok.\n \n websocket_opts_validation(Config) ->\n     % Valid WebSocket options\n-    ValidOpts = [\n-        #{url => \"ws://example.com/ws\", owner => self()},\n-        #{url => \"wss://secure.example.com/ws\", owner => self()},\n-        #{url => <<\"ws://example.com/ws\">>, owner => self()}\n-    ],\n-    \n+    ValidOpts =\n+        [#{url => \"ws://example.com/ws\", owner => self()},\n+         #{url => \"wss://secure.example.com/ws\", owner => self()},\n+         #{url => <<\"ws://example.com/ws\">>, owner => self()}],\n+\n     lists:foreach(fun(Opts) ->\n-        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(websocket, Opts))\n-    end, ValidOpts),\n-    \n+                     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(websocket, Opts))\n+                  end,\n+                  ValidOpts),\n+\n     % Invalid WebSocket options\n-    InvalidOpts = [\n-        #{}, % Missing required fields\n-        #{url => \"http://example.com\", owner => self()}, % Wrong protocol\n-        #{url => \"not-a-url\", owner => self()}, % Invalid URL format\n-        #{url => \"\", owner => self()} % Empty URL\n-    ],\n-    \n+    InvalidOpts =\n+        [#{}, % Missing required fields\n+         #{url => \"http://example.com\", owner => self()}, % Wrong protocol\n+         #{url => \"not-a-url\", owner => self()}, % Invalid URL format\n+         #{url => \"\", owner => self()}], % Empty URL\n+\n     lists:foreach(fun(Opts) ->\n-        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(websocket, Opts))\n-    end, InvalidOpts),\n+                     ?assertMatch({error, _},\n+                                  erlmcp_transport:validate_transport_opts(websocket, Opts))\n+                  end,\n+                  InvalidOpts),\n     ok.\n \n %%====================================================================\n %% Test Cases - Message Formats\n %%====================================================================\n \n json_rpc_structure(Config) ->\n     % Test JSON-RPC 2.0 message structure requirements\n-    \n     % Valid request with all fields\n-    FullRequest = #{\n-        <<\"jsonrpc\">> => <<\"2.0\">>,\n-        <<\"method\">> => <<\"test_method\">>,\n-        <<\"params\">> => #{<<\"arg1\">> => <<\"value1\">>},\n-        <<\"id\">> => 1\n-    },\n+    FullRequest =\n+        #{<<\"jsonrpc\">> => <<\"2.0\">>,\n+          <<\"method\">> => <<\"test_method\">>,\n+          <<\"params\">> => #{<<\"arg1\">> => <<\"value1\">>},\n+          <<\"id\">> => 1},\n     ?assertEqual(ok, erlmcp_transport:validate_message(FullRequest)),\n-    \n+\n     % Valid request without params\n-    RequestWithoutParams = #{\n-        <<\"jsonrpc\">> => <<\"2.0\">>,\n-        <<\"method\">> => <<\"test_method\">>,\n-        <<\"id\">> => 1\n-    },\n+    RequestWithoutParams =\n+        #{<<\"jsonrpc\">> => <<\"2.0\">>,\n+          <<\"method\">> => <<\"test_method\">>,\n+          <<\"id\">> => 1},\n     ?assertEqual(ok, erlmcp_transport:validate_message(RequestWithoutParams)),\n-    \n+\n     % Valid notification (no id)\n-    Notification = #{\n-        <<\"jsonrpc\">> => <<\"2.0\">>,\n-        <<\"method\">> => <<\"notify_method\">>,\n-        <<\"params\">> => #{<<\"data\">> => <<\"value\">>}\n-    },\n+    Notification =\n+        #{<<\"jsonrpc\">> => <<\"2.0\">>,\n+          <<\"method\">> => <<\"notify_method\">>,\n+          <<\"params\">> => #{<<\"data\">> => <<\"value\">>}},\n     ?assertEqual(ok, erlmcp_transport:validate_message(Notification)),\n     ok.\n \n notification_format(Config) ->\n     % Test notification format (no id field)\n     Method = <<\"test_notification\">>,\n     Params = #{<<\"data\">> => <<\"test\">>},\n-    \n+\n     Notification = erlmcp_transport:create_notification(Method, Params),\n-    \n+\n     % Should have required fields\n     ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Notification)),\n     ?assertEqual(Method, maps:get(<<\"method\">>, Notification)),\n     ?assertEqual(Params, maps:get(<<\"params\">>, Notification)),\n-    \n+\n     % Should NOT have id field\n     ?assertNot(maps:is_key(<<\"id\">>, Notification)),\n-    \n+\n     % Should validate as a proper message\n     ?assertEqual(ok, erlmcp_transport:validate_message(Notification)),\n     ok.\n \n response_format(Config) ->\n     % Test response format\n     Id = 42,\n     Result = #{<<\"status\">> => <<\"success\">>, <<\"data\">> => <<\"test_result\">>},\n-    \n+\n     Response = erlmcp_transport:create_response(Id, Result),\n-    \n+\n     % Should have required fields\n     ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Response)),\n     ?assertEqual(Id, maps:get(<<\"id\">>, Response)),\n     ?assertEqual(Result, maps:get(<<\"result\">>, Response)),\n-    \n+\n     % Should NOT have method or error fields\n     ?assertNot(maps:is_key(<<\"method\">>, Response)),\n     ?assertNot(maps:is_key(<<\"error\">>, Response)),\n-    \n+\n     % Should validate as a proper message\n     ?assertEqual(ok, erlmcp_transport:validate_message(Response)),\n     ok.\n \n@@ -517,25 +495,25 @@\n     Id = 123,\n     Code = -32602,\n     Message = <<\"Invalid params\">>,\n     Data = #{<<\"param\">> => <<\"invalid_value\">>},\n-    \n+\n     ErrorResponse = erlmcp_transport:create_error_response(Id, Code, Message, Data),\n-    \n+\n     % Should have required top-level fields\n     ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, ErrorResponse)),\n     ?assertEqual(Id, maps:get(<<\"id\">>, ErrorResponse)),\n-    \n+\n     % Should have error object with required fields\n     ErrorObj = maps:get(<<\"error\">>, ErrorResponse),\n     ?assertEqual(Code, maps:get(<<\"code\">>, ErrorObj)),\n     ?assertEqual(Message, maps:get(<<\"message\">>, ErrorObj)),\n     ?assertEqual(Data, maps:get(<<\"data\">>, ErrorObj)),\n-    \n+\n     % Should NOT have method or result fields\n     ?assertNot(maps:is_key(<<\"method\">>, ErrorResponse)),\n     ?assertNot(maps:is_key(<<\"result\">>, ErrorResponse)),\n-    \n+\n     % Should validate as a proper message\n     ?assertEqual(ok, erlmcp_transport:validate_message(ErrorResponse)),\n     ok.\n \n@@ -544,71 +522,81 @@\n %%====================================================================\n \n stdio_behavior_compliance(Config) ->\n     % Test that stdio transport implements the behavior correctly\n-    \n     % Test init callback\n     StdioOpts = #{owner => self(), test_mode => true},\n     case erlmcp_transport_stdio_new:init([transport_id, StdioOpts]) of\n         {ok, State} ->\n             % Test send callback\n             ?assertEqual(ok, erlmcp_transport_stdio_new:send(State, <<\"test\">>)),\n-            \n+\n             % Test close callback\n             ?assertEqual(ok, erlmcp_transport_stdio_new:close(State)),\n-            \n+\n             % Test optional get_info callback if implemented\n             try\n                 Info = erlmcp_transport_stdio_new:get_info(State),\n                 ?assert(is_map(Info)),\n                 ?assert(maps:is_key(type, Info))\n             catch\n-                error:undef -> ok % Optional callback not implemented\n+                error:undef ->\n+                    ok % Optional callback not implemented\n             end;\n         {stop, Reason} ->\n             ct:pal(\"Stdio transport failed to initialize: ~p\", [Reason])\n     end,\n     ok.\n \n tcp_behavior_compliance(Config) ->\n     % Test that TCP transport implements the behavior correctly\n-    \n-    % Test init callback (behavior version)\n-    TcpOpts = #{\n-        transport_id => test_tcp_behavior,\n-        server_id => test_server_behavior,\n-        host => \"localhost\",\n-        port => 8080\n-    },\n-    \n-    {ok, State} = erlmcp_transport_tcp:init(TcpOpts),\n-    \n-    % Test send callback (may fail if not connected, but shouldn't crash)\n-    Result = erlmcp_transport_tcp:send(State, <<\"test\">>),\n-    ?assert(Result =:= ok orelse element(1, Result) =:= error),\n-    \n-    % Test close callback\n-    ?assertEqual(ok, erlmcp_transport_tcp:close(State)),\n+    TcpOpts =\n+        #{transport_id => test_tcp_behavior,\n+          server_id => test_server_behavior,\n+          host => \"localhost\",\n+          port => 8080,\n+          test_mode => true},\n+\n+    case catch erlmcp_transport_tcp:start_link(test_tcp_behavior, TcpOpts) of\n+        {ok, Pid} ->\n+            {ok, State} = gen_server:call(Pid, get_state),\n+            \n+            % Test send callback (may fail if not connected, but shouldn't crash)\n+            Result = erlmcp_transport_tcp:send(State, <<\"test\">>),\n+            ?assert(Result =:= ok orelse element(1, Result) =:= error),\n+            \n+            % Test close callback\n+            ?assertEqual(ok, erlmcp_transport_tcp:close(State)),\n+            \n+            ok = gen_server:stop(Pid);\n+        Error ->\n+            ct:pal(\"TCP transport not available for behavior test: ~p\", [Error])\n+    end,\n     ok.\n \n http_behavior_compliance(Config) ->\n     % Test that HTTP transport implements the behavior correctly\n-    \n-    % Test init callback\n-    HttpOpts = #{\n-        transport_id => test_http_behavior,\n-        server_id => test_server_behavior,\n-        url => \"http://example.com/api\"\n-    },\n-    \n-    {ok, State} = erlmcp_transport_http:init_transport(HttpOpts),\n-    \n-    % Test send callback (may fail due to network, but shouldn't crash)\n-    Result = erlmcp_transport_http:send(State, <<\"test\">>),\n-    ?assert(Result =:= ok orelse element(1, Result) =:= error),\n-    \n-    % Test close callback\n-    ?assertEqual(ok, erlmcp_transport_http:close(State)),\n+    HttpOpts =\n+        #{transport_id => test_http_behavior,\n+          server_id => test_server_behavior,\n+          url => \"http://example.com/api\",\n+          test_mode => true},\n+\n+    case catch erlmcp_transport_http:start_link(test_http_behavior, HttpOpts) of\n+        {ok, Pid} ->\n+            {ok, State} = gen_server:call(Pid, get_state),\n+            \n+            % Test send callback (may fail due to network, but shouldn't crash)\n+            Result = erlmcp_transport_http:send(State, <<\"test\">>),\n+            ?assert(Result =:= ok orelse element(1, Result) =:= error),\n+            \n+            % Test close callback\n+            ?assertEqual(ok, erlmcp_transport_http:close(State)),\n+            \n+            ok = gen_server:stop(Pid);\n+        Error ->\n+            ct:pal(\"HTTP transport not available for behavior test: ~p\", [Error])\n+    end,\n     ok.\n \n %%====================================================================\n %% Test Cases - Type System\n@@ -616,44 +604,45 @@\n \n transport_state_type(Config) ->\n     % Test that transport state is properly typed\n     % This is mainly a compilation/interface test\n-    \n     % Verify different transports return state that works with behavior\n     StdioOpts = #{owner => self(), test_mode => true},\n     case erlmcp_transport_stdio_new:init([transport_id, StdioOpts]) of\n         {ok, StdioState} ->\n             ?assert(erlmcp_transport_stdio_new:send(StdioState, <<\"test\">>) =/= undefined);\n-        _ -> ok\n+        _ ->\n+            ok\n     end,\n-    \n+\n     TcpOpts = #{host => \"localhost\", port => 8080},\n     {ok, TcpState} = erlmcp_transport_tcp:init(TcpOpts),\n     ?assert(erlmcp_transport_tcp:send(TcpState, <<\"test\">>) =/= undefined),\n     ok.\n \n transport_opts_type(Config) ->\n     % Test transport options type compatibility\n-    \n     % These should all be valid transport_opts types\n     StdioOpts = #{owner => self()},\n-    TcpOpts = #{host => \"localhost\", port => 8080, owner => self()},\n+    TcpOpts =\n+        #{host => \"localhost\",\n+          port => 8080,\n+          owner => self()},\n     HttpOpts = #{url => \"http://example.com\", owner => self()},\n-    \n+\n     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(stdio, StdioOpts)),\n     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, TcpOpts)),\n     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, HttpOpts)),\n     ok.\n \n transport_message_type(Config) ->\n     % Test transport message type compliance\n-    \n     % Create various message types\n     Message1 = erlmcp_transport:create_message(<<\"test\">>, #{}, 1),\n     Message2 = erlmcp_transport:create_notification(<<\"notify\">>, #{}),\n     Message3 = erlmcp_transport:create_response(1, #{result => ok}),\n     Message4 = erlmcp_transport:create_error_response(1, -32600, <<\"Error\">>, undefined),\n-    \n+\n     % All should be valid transport messages\n     ?assertEqual(ok, erlmcp_transport:validate_message(Message1)),\n     ?assertEqual(ok, erlmcp_transport:validate_message(Message2)),\n     ?assertEqual(ok, erlmcp_transport:validate_message(Message3)),\n@@ -661,18 +650,16 @@\n     ok.\n \n transport_info_type(Config) ->\n     % Test transport info type structure\n-    \n     % Mock transport info\n-    MockInfo = #{\n-        type => test_transport,\n-        version => <<\"1.0.0\">>,\n-        capabilities => [send, 'receive'],\n-        connection_state => connected,\n-        statistics => #{messages_sent => 10, messages_received => 5}\n-    },\n-    \n+    MockInfo =\n+        #{type => test_transport,\n+          version => <<\"1.0.0\">>,\n+          capabilities => [send, 'receive'],\n+          connection_state => connected,\n+          statistics => #{messages_sent => 10, messages_received => 5}},\n+\n     % Should have expected structure\n     ?assert(maps:is_key(type, MockInfo)),\n     ?assert(maps:is_key(connection_state, MockInfo)),\n     ok.\n@@ -682,195 +669,192 @@\n %%====================================================================\n \n url_validation_functions(Config) ->\n     % Test URL validation helper functions\n-    \n     % Valid HTTP URLs\n-    ValidHttpUrls = [\n-        \"http://example.com\",\n-        \"https://secure.example.com\",\n-        \"http://localhost:8080/path\"\n-    ],\n-    \n+    ValidHttpUrls =\n+        [\"http://example.com\", \"https://secure.example.com\", \"http://localhost:8080/path\"],\n+\n     % Valid WebSocket URLs\n-    ValidWsUrls = [\n-        \"ws://example.com/ws\",\n-        \"wss://secure.example.com/ws\"\n-    ],\n-    \n+    ValidWsUrls = [\"ws://example.com/ws\", \"wss://secure.example.com/ws\"],\n+\n     % Test the validation functions exist and work\n     % Note: These are internal functions, so we test through public interface\n     lists:foreach(fun(Url) ->\n-        HttpOpts = #{url => Url, owner => self()},\n-        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, HttpOpts))\n-    end, ValidHttpUrls),\n-    \n+                     HttpOpts = #{url => Url, owner => self()},\n+                     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, HttpOpts))\n+                  end,\n+                  ValidHttpUrls),\n+\n     lists:foreach(fun(Url) ->\n-        WsOpts = #{url => Url, owner => self()},\n-        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(websocket, WsOpts))\n-    end, ValidWsUrls),\n+                     WsOpts = #{url => Url, owner => self()},\n+                     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(websocket, WsOpts))\n+                  end,\n+                  ValidWsUrls),\n     ok.\n \n host_validation_functions(Config) ->\n     % Test host validation helper functions\n-    \n-    ValidHosts = [\n-        \"localhost\",\n-        \"example.com\",\n-        \"192.168.1.1\",\n-        {127, 0, 0, 1},\n-        {192, 168, 1, 1}\n-    ],\n-    \n+    ValidHosts =\n+        [\"localhost\", \"example.com\", \"192.168.1.1\", {127, 0, 0, 1}, {192, 168, 1, 1}],\n+\n     lists:foreach(fun(Host) ->\n-        TcpOpts = #{host => Host, port => 8080, owner => self()},\n-        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, TcpOpts))\n-    end, ValidHosts),\n-    \n+                     TcpOpts =\n+                         #{host => Host,\n+                           port => 8080,\n+                           owner => self()},\n+                     ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, TcpOpts))\n+                  end,\n+                  ValidHosts),\n+\n     % Test invalid hosts\n-    InvalidHosts = [\n-        {256, 0, 0, 1}, % Invalid IP\n-        {}, % Wrong tuple format\n-        123, % Not a string or IP tuple\n-        \"\"  % Empty string\n-    ],\n-    \n+    InvalidHosts =\n+        [{256, 0, 0, 1}, % Invalid IP\n+         {}, % Wrong tuple format\n+         123, % Not a string or IP tuple\n+         \"\"],  % Empty string\n+\n     lists:foreach(fun(Host) ->\n-        TcpOpts = #{host => Host, port => 8080, owner => self()},\n-        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(tcp, TcpOpts))\n-    end, InvalidHosts),\n+                     TcpOpts =\n+                         #{host => Host,\n+                           port => 8080,\n+                           owner => self()},\n+                     ?assertMatch({error, _},\n+                                  erlmcp_transport:validate_transport_opts(tcp, TcpOpts))\n+                  end,\n+                  InvalidHosts),\n     ok.\n \n message_content_validation(Config) ->\n     % Test message content validation functions\n-    \n     % Valid message contents\n-    ValidMessages = [\n-        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"method\">> => <<\"test\">>, <<\"id\">> => 1},\n-        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"result\">> => <<\"ok\">>, <<\"id\">> => 1},\n-        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"error\">> => \n-            #{<<\"code\">> => -32600, <<\"message\">> => <<\"Error\">>}, <<\"id\">> => 1}\n-    ],\n-    \n-    lists:foreach(fun(Message) ->\n-        ?assertEqual(ok, erlmcp_transport:validate_message(Message))\n-    end, ValidMessages),\n-    \n+    ValidMessages =\n+        [#{<<\"jsonrpc\">> => <<\"2.0\">>,\n+           <<\"method\">> => <<\"test\">>,\n+           <<\"id\">> => 1},\n+         #{<<\"jsonrpc\">> => <<\"2.0\">>,\n+           <<\"result\">> => <<\"ok\">>,\n+           <<\"id\">> => 1},\n+         #{<<\"jsonrpc\">> => <<\"2.0\">>,\n+           <<\"error\">> => #{<<\"code\">> => -32600, <<\"message\">> => <<\"Error\">>},\n+           <<\"id\">> => 1}],\n+\n+    lists:foreach(fun(Message) -> ?assertEqual(ok, erlmcp_transport:validate_message(Message))\n+                  end,\n+                  ValidMessages),\n+\n     % Invalid message contents\n-    InvalidMessages = [\n-        #{<<\"method\">> => <<\"test\">>}, % Missing jsonrpc\n-        #{<<\"jsonrpc\">> => <<\"1.0\">>}, % Wrong version\n-        #{<<\"jsonrpc\">> => <<\"2.0\">>}  % Missing content\n-    ],\n-    \n+    InvalidMessages =\n+        [#{<<\"method\">> => <<\"test\">>}, % Missing jsonrpc\n+         #{<<\"jsonrpc\">> => <<\"1.0\">>}, % Wrong version\n+         #{<<\"jsonrpc\">> => <<\"2.0\">>}],  % Missing content\n+\n     lists:foreach(fun(Message) ->\n-        ?assertMatch({error, _}, erlmcp_transport:validate_message(Message))\n-    end, InvalidMessages),\n+                     ?assertMatch({error, _}, erlmcp_transport:validate_message(Message))\n+                  end,\n+                  InvalidMessages),\n     ok.\n \n error_structure_validation(Config) ->\n     % Test error structure validation\n-    \n     % Valid error structures\n-    ValidErrors = [\n-        #{<<\"code\">> => -32600, <<\"message\">> => <<\"Invalid Request\">>},\n-        #{<<\"code\">> => -32601, <<\"message\">> => <<\"Method not found\">>, \n-          <<\"data\">> => #{<<\"method\">> => <<\"unknown\">>}}\n-    ],\n-    \n+    ValidErrors =\n+        [#{<<\"code\">> => -32600, <<\"message\">> => <<\"Invalid Request\">>},\n+         #{<<\"code\">> => -32601,\n+           <<\"message\">> => <<\"Method not found\">>,\n+           <<\"data\">> => #{<<\"method\">> => <<\"unknown\">>}}],\n+\n     lists:foreach(fun(ErrorObj) ->\n-        ErrorResponse = #{\n-            <<\"jsonrpc\">> => <<\"2.0\">>,\n-            <<\"error\">> => ErrorObj,\n-            <<\"id\">> => 1\n-        },\n-        ?assertEqual(ok, erlmcp_transport:validate_message(ErrorResponse))\n-    end, ValidErrors),\n-    \n+                     ErrorResponse =\n+                         #{<<\"jsonrpc\">> => <<\"2.0\">>,\n+                           <<\"error\">> => ErrorObj,\n+                           <<\"id\">> => 1},\n+                     ?assertEqual(ok, erlmcp_transport:validate_message(ErrorResponse))\n+                  end,\n+                  ValidErrors),\n+\n     % Invalid error structures\n-    InvalidErrors = [\n-        #{<<\"message\">> => <<\"Error\">>}, % Missing code\n-        #{<<\"code\">> => \"invalid\", <<\"message\">> => <<\"Error\">>}, % Wrong code type\n-        #{<<\"code\">> => -32600, <<\"message\">> => 123} % Wrong message type\n-    ],\n-    \n+    InvalidErrors =\n+        [#{<<\"message\">> => <<\"Error\">>}, % Missing code\n+         #{<<\"code\">> => \"invalid\", <<\"message\">> => <<\"Error\">>}, % Wrong code type\n+         #{<<\"code\">> => -32600, <<\"message\">> => 123}], % Wrong message type\n+\n     lists:foreach(fun(ErrorObj) ->\n-        ErrorResponse = #{\n-            <<\"jsonrpc\">> => <<\"2.0\">>,\n-            <<\"error\">> => ErrorObj,\n-            <<\"id\">> => 1\n-        },\n-        ?assertMatch({error, _}, erlmcp_transport:validate_message(ErrorResponse))\n-    end, InvalidErrors),\n+                     ErrorResponse =\n+                         #{<<\"jsonrpc\">> => <<\"2.0\">>,\n+                           <<\"error\">> => ErrorObj,\n+                           <<\"id\">> => 1},\n+                     ?assertMatch({error, _}, erlmcp_transport:validate_message(ErrorResponse))\n+                  end,\n+                  InvalidErrors),\n     ok.\n \n %%====================================================================\n %% Test Cases - Integration\n %%====================================================================\n \n behavior_with_registry(Config) ->\n     % Test behavior integration with registry\n-    \n     TransportId = test_behavior_registry,\n     ServerId = test_server_registry,\n-    \n+\n     % Start a transport that implements the behavior\n     StdioOpts = #{test_mode => true, server_id => ServerId},\n     {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, StdioOpts),\n-    \n+\n     timer:sleep(100), % Allow registration\n-    \n+\n     % Verify it registered properly\n     {ok, {RegPid, RegConfig}} = erlmcp_registry:find_transport(TransportId),\n     ?assertEqual(Pid, RegPid),\n     ?assert(maps:is_key(type, RegConfig)),\n-    \n+\n     ok = gen_server:stop(Pid),\n     ok.\n \n behavior_error_handling(Config) ->\n     % Test behavior error handling patterns\n-    \n     % Test with invalid options\n     InvalidOpts = #{invalid => option},\n-    \n+\n     % Should handle gracefully\n     try\n         erlmcp_transport:validate_transport_opts(stdio, InvalidOpts)\n     catch\n-        _:_ -> ok % Expected to fail\n+        _:_ ->\n+            ok % Expected to fail\n     end,\n-    \n+\n     % Test message validation with invalid input\n     InvalidMessage = <<\"not a map\">>,\n     ?assertMatch({error, _}, erlmcp_transport:validate_message(InvalidMessage)),\n     ok.\n \n behavior_lifecycle(Config) ->\n     % Test complete behavior lifecycle\n-    \n     TransportId = test_behavior_lifecycle,\n-    \n+\n     % 1. Initialize\n     StdioOpts = #{test_mode => true},\n     {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, StdioOpts),\n     ?assert(is_process_alive(Pid)),\n-    \n+\n     % 2. Get state and test send\n     {ok, State} = gen_server:call(Pid, get_state),\n     ?assertEqual(ok, erlmcp_transport_stdio_new:send(State, <<\"test message\">>)),\n-    \n+\n     % 3. Test optional callbacks if available\n     try\n         Info = erlmcp_transport_stdio_new:get_info(State),\n         ?assert(is_map(Info))\n     catch\n-        error:undef -> ok % Optional callback not implemented\n+        error:undef ->\n+            ok % Optional callback not implemented\n     end,\n-    \n+\n     % 4. Close\n     ?assertEqual(ok, erlmcp_transport_stdio_new:close(State)),\n-    \n+\n     % 5. Terminate\n     ok = gen_server:stop(Pid),\n     ?assertNot(is_process_alive(Pid)),\n     ok.\n@@ -878,5 +862,5 @@\n %%====================================================================\n %% Helper Functions\n %%====================================================================\n \n-% No additional helper functions needed for this test suite\n\\ No newline at end of file\n+% No additional helper functions needed for this test suite\n"
                }
            ],
            "date": 1756185314750,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @doc\n%%% Common Test suite for erlmcp_transport_behavior module\n%%%\n%%% This comprehensive test suite validates the transport behavior\n%%% interface and tests behavior compliance across all transport\n%%% implementations.\n%%%-------------------------------------------------------------------\n-module(erlmcp_transport_behavior_SUITE).\n\n-include_lib(\"common_test/include/ct.hrl\").\n-include_lib(\"eunit/include/eunit.hrl\").\n-include(\"erlmcp.hrl\").\n\n%% Suite callbacks\n-export([all/0, groups/0, init_per_suite/1, end_per_suite/1,\n         init_per_group/2, end_per_group/2,\n         init_per_testcase/2, end_per_testcase/2]).\n\n%% Test cases\n-export([\n    % Behavior validation\n    behavior_module_exists/1,\n    behavior_callbacks_defined/1,\n    behavior_types_exported/1,\n    behavior_optional_callbacks/1,\n    \n    % Message validation\n    validate_json_rpc_message/1,\n    validate_transport_opts/1,\n    message_creation_functions/1,\n    error_message_creation/1,\n    \n    % Transport options validation\n    stdio_opts_validation/1,\n    tcp_opts_validation/1,\n    http_opts_validation/1,\n    websocket_opts_validation/1,\n    \n    % Message format compliance\n    json_rpc_structure/1,\n    notification_format/1,\n    response_format/1,\n    error_response_format/1,\n    \n    % Behavior compliance tests\n    stdio_behavior_compliance/1,\n    tcp_behavior_compliance/1,\n    http_behavior_compliance/1,\n    \n    % Type system validation\n    transport_state_type/1,\n    transport_opts_type/1,\n    transport_message_type/1,\n    transport_info_type/1,\n    \n    % Validation functions\n    url_validation_functions/1,\n    host_validation_functions/1,\n    message_content_validation/1,\n    error_structure_validation/1,\n    \n    % Integration testing\n    behavior_with_registry/1,\n    behavior_error_handling/1,\n    behavior_lifecycle/1\n]).\n\n%%====================================================================\n%% Suite Configuration\n%%====================================================================\n\nall() ->\n    [\n        {group, behavior_validation},\n        {group, message_validation},\n        {group, transport_options},\n        {group, message_formats},\n        {group, behavior_compliance},\n        {group, type_system},\n        {group, validation_functions},\n        {group, integration}\n    ].\n\ngroups() ->\n    [\n        {behavior_validation, [parallel], [\n            behavior_module_exists,\n            behavior_callbacks_defined,\n            behavior_types_exported,\n            behavior_optional_callbacks\n        ]},\n        {message_validation, [parallel], [\n            validate_json_rpc_message,\n            validate_transport_opts,\n            message_creation_functions,\n            error_message_creation\n        ]},\n        {transport_options, [parallel], [\n            stdio_opts_validation,\n            tcp_opts_validation,\n            http_opts_validation,\n            websocket_opts_validation\n        ]},\n        {message_formats, [parallel], [\n            json_rpc_structure,\n            notification_format,\n            response_format,\n            error_response_format\n        ]},\n        {behavior_compliance, [sequential], [\n            stdio_behavior_compliance,\n            tcp_behavior_compliance,\n            http_behavior_compliance\n        ]},\n        {type_system, [parallel], [\n            transport_state_type,\n            transport_opts_type,\n            transport_message_type,\n            transport_info_type\n        ]},\n        {validation_functions, [parallel], [\n            url_validation_functions,\n            host_validation_functions,\n            message_content_validation,\n            error_structure_validation\n        ]},\n        {integration, [sequential], [\n            behavior_with_registry,\n            behavior_error_handling,\n            behavior_lifecycle\n        ]}\n    ].\n\n%%====================================================================\n%% Suite Setup/Teardown\n%%====================================================================\n\ninit_per_suite(Config) ->\n    ct:pal(\"Starting transport behavior test suite\"),\n    \n    % Start necessary applications\n    ok = application:ensure_started(crypto),\n    ok = application:ensure_started(sasl),\n    \n    % Start registry for integration tests\n    case erlmcp_registry:start_link() of\n        {ok, _} -> ok;\n        {error, {already_started, _}} -> ok\n    end,\n    \n    Config.\n\nend_per_suite(_Config) ->\n    ct:pal(\"Ending transport behavior test suite\"),\n    ok.\n\ninit_per_group(GroupName, Config) ->\n    ct:pal(\"Starting group: ~p\", [GroupName]),\n    Config.\n\nend_per_group(GroupName, _Config) ->\n    ct:pal(\"Ending group: ~p\", [GroupName]),\n    ok.\n\ninit_per_testcase(TestCase, Config) ->\n    ct:pal(\"Starting test case: ~p\", [TestCase]),\n    Config.\n\nend_per_testcase(TestCase, _Config) ->\n    ct:pal(\"Ending test case: ~p\", [TestCase]),\n    ok.\n\n%%====================================================================\n%% Test Cases - Behavior Validation\n%%====================================================================\n\nbehavior_module_exists(Config) ->\n    % Verify the behavior module exists and can be loaded\n    ?assert(code:is_loaded(erlmcp_transport) =/= false orelse \n            code:load_file(erlmcp_transport) =:= {module, erlmcp_transport}),\n    \n    % Verify it's a behavior module\n    Attributes = erlmcp_transport:module_info(attributes),\n    ?assert(lists:member(behavior, proplists:get_keys(Attributes)) orelse\n            lists:member(behaviour, proplists:get_keys(Attributes))),\n    ok.\n\nbehavior_callbacks_defined(Config) ->\n    % Verify required callbacks are defined\n    RequiredCallbacks = [\n        {init, 1},\n        {send, 2},\n        {close, 1}\n    ],\n    \n    Callbacks = erlmcp_transport:behaviour_info(callbacks),\n    \n    lists:foreach(fun(Callback) ->\n        ?assert(lists:member(Callback, Callbacks))\n    end, RequiredCallbacks),\n    \n    % Verify optional callbacks are marked as optional\n    OptionalCallbacks = erlmcp_transport:behaviour_info(optional_callbacks),\n    ExpectedOptional = [{get_info, 1}, {handle_transport_call, 2}],\n    \n    lists:foreach(fun(OptCallback) ->\n        ?assert(lists:member(OptCallback, OptionalCallbacks))\n    end, ExpectedOptional),\n    \n    ok.\n\nbehavior_types_exported(Config) ->\n    % Verify exported types\n    Exports = erlmcp_transport:module_info(exports),\n    \n    % Check for type information (may vary by Erlang version)\n    % At minimum, verify the module compiles and loads\n    ?assert(is_list(Exports)),\n    ?assert(length(Exports) > 0),\n    ok.\n\nbehavior_optional_callbacks(Config) ->\n    % Test optional callbacks behavior\n    OptionalCallbacks = [get_info, handle_transport_call],\n    \n    % These should be marked as optional\n    lists:foreach(fun(Callback) ->\n        % Verify optional callback is properly defined\n        ?assert(erlang:function_exported(erlmcp_transport, behaviour_info, 1))\n    end, OptionalCallbacks),\n    ok.\n\n%%====================================================================\n%% Test Cases - Message Validation\n%%====================================================================\n\nvalidate_json_rpc_message(Config) ->\n    % Test valid JSON-RPC messages\n    ValidMessages = [\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"method\">> => <<\"test\">>, <<\"id\">> => 1},\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"result\">> => <<\"ok\">>, <<\"id\">> => 1},\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"method\">> => <<\"notify\">>}, % Notification\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"error\">> => \n            #{<<\"code\">> => -32600, <<\"message\">> => <<\"Invalid Request\">>}, <<\"id\">> => null}\n    ],\n    \n    lists:foreach(fun(Message) ->\n        ?assertEqual(ok, erlmcp_transport:validate_message(Message))\n    end, ValidMessages),\n    \n    % Test invalid messages\n    InvalidMessages = [\n        #{}, % Missing jsonrpc field\n        #{<<\"jsonrpc\">> => <<\"1.0\">>}, % Wrong version\n        #{<<\"jsonrpc\">> => <<\"2.0\">>}, % No method, result, or error\n        \"not a map\", % Not a map\n        42 % Not a map\n    ],\n    \n    lists:foreach(fun(Message) ->\n        ?assertMatch({error, _}, erlmcp_transport:validate_message(Message))\n    end, InvalidMessages),\n    ok.\n\nvalidate_transport_opts(Config) ->\n    % Test stdio options validation\n    ValidStdioOpts = #{owner => self()},\n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(stdio, ValidStdioOpts)),\n    \n    % Test TCP options validation\n    ValidTcpOpts = #{host => \"localhost\", port => 8080, owner => self()},\n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, ValidTcpOpts)),\n    \n    % Test HTTP options validation  \n    ValidHttpOpts = #{url => \"http://example.com/api\", owner => self()},\n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, ValidHttpOpts)),\n    \n    % Test WebSocket options validation\n    ValidWsOpts = #{url => \"ws://example.com/ws\", owner => self()},\n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(websocket, ValidWsOpts)),\n    \n    % Test invalid transport type\n    ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(invalid_type, #{})),\n    ok.\n\nmessage_creation_functions(Config) ->\n    % Test message creation functions\n    Method = <<\"test_method\">>,\n    Params = #{param1 => <<\"value1\">>},\n    Id = 123,\n    \n    % Test create_message/3\n    Message = erlmcp_transport:create_message(Method, Params, Id),\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Message)),\n    ?assertEqual(Method, maps:get(<<\"method\">>, Message)),\n    ?assertEqual(Params, maps:get(<<\"params\">>, Message)),\n    ?assertEqual(Id, maps:get(<<\"id\">>, Message)),\n    \n    % Test create_notification/2\n    Notification = erlmcp_transport:create_notification(Method, Params),\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Notification)),\n    ?assertEqual(Method, maps:get(<<\"method\">>, Notification)),\n    ?assertEqual(Params, maps:get(<<\"params\">>, Notification)),\n    ?assertNot(maps:is_key(<<\"id\">>, Notification)),\n    \n    % Test create_response/2\n    Result = #{result => <<\"success\">>},\n    Response = erlmcp_transport:create_response(Id, Result),\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Response)),\n    ?assertEqual(Id, maps:get(<<\"id\">>, Response)),\n    ?assertEqual(Result, maps:get(<<\"result\">>, Response)),\n    ok.\n\nerror_message_creation(Config) ->\n    % Test error response creation\n    Id = 456,\n    Code = -32600,\n    Message = <<\"Invalid Request\">>,\n    Data = #{additional => <<\"info\">>},\n    \n    % Test with data\n    ErrorWithData = erlmcp_transport:create_error_response(Id, Code, Message, Data),\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, ErrorWithData)),\n    ?assertEqual(Id, maps:get(<<\"id\">>, ErrorWithData)),\n    \n    ErrorObj = maps:get(<<\"error\">>, ErrorWithData),\n    ?assertEqual(Code, maps:get(<<\"code\">>, ErrorObj)),\n    ?assertEqual(Message, maps:get(<<\"message\">>, ErrorObj)),\n    ?assertEqual(Data, maps:get(<<\"data\">>, ErrorObj)),\n    \n    % Test without data\n    ErrorWithoutData = erlmcp_transport:create_error_response(Id, Code, Message, undefined),\n    ErrorObj2 = maps:get(<<\"error\">>, ErrorWithoutData),\n    ?assertNot(maps:is_key(<<\"data\">>, ErrorObj2)),\n    ok.\n\n%%====================================================================\n%% Test Cases - Transport Options\n%%====================================================================\n\nstdio_opts_validation(Config) ->\n    % Valid stdio options\n    ValidOpts = [\n        #{owner => self()},\n        #{owner => self(), test_mode => true},\n        #{owner => self(), test_mode => false}\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(stdio, Opts))\n    end, ValidOpts),\n    \n    % Invalid stdio options\n    InvalidOpts = [\n        #{}, % Missing owner\n        #{owner => \"not_a_pid\"}, % Invalid owner type\n        #{owner => self(), invalid_option => true} % Extra invalid option\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(stdio, Opts))\n    end, InvalidOpts),\n    ok.\n\ntcp_opts_validation(Config) ->\n    % Valid TCP options\n    ValidOpts = [\n        #{host => \"localhost\", port => 8080, owner => self()},\n        #{host => {127,0,0,1}, port => 8080, owner => self()},\n        #{host => \"example.com\", port => 443, owner => self(), keepalive => true}\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, Opts))\n    end, ValidOpts),\n    \n    % Invalid TCP options\n    InvalidOpts = [\n        #{}, % Missing required fields\n        #{host => \"localhost\", owner => self()}, % Missing port\n        #{host => \"localhost\", port => 0, owner => self()}, % Invalid port\n        #{host => \"localhost\", port => 70000, owner => self()}, % Port too high\n        #{host => invalid_host, port => 8080, owner => self()} % Invalid host\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(tcp, Opts))\n    end, InvalidOpts),\n    ok.\n\nhttp_opts_validation(Config) ->\n    % Valid HTTP options\n    ValidOpts = [\n        #{url => \"http://example.com/api\", owner => self()},\n        #{url => \"https://secure.example.com/api\", owner => self()},\n        #{url => <<\"http://example.com/api\">>, owner => self()},\n        #{url => \"http://localhost:8080/api\", owner => self()}\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, Opts))\n    end, ValidOpts),\n    \n    % Invalid HTTP options\n    InvalidOpts = [\n        #{}, % Missing required fields\n        #{url => \"ftp://example.com\", owner => self()}, % Invalid protocol\n        #{url => \"not-a-url\", owner => self()}, % Invalid URL format\n        #{url => \"\", owner => self()} % Empty URL\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(http, Opts))\n    end, InvalidOpts),\n    ok.\n\nwebsocket_opts_validation(Config) ->\n    % Valid WebSocket options\n    ValidOpts = [\n        #{url => \"ws://example.com/ws\", owner => self()},\n        #{url => \"wss://secure.example.com/ws\", owner => self()},\n        #{url => <<\"ws://example.com/ws\">>, owner => self()}\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(websocket, Opts))\n    end, ValidOpts),\n    \n    % Invalid WebSocket options\n    InvalidOpts = [\n        #{}, % Missing required fields\n        #{url => \"http://example.com\", owner => self()}, % Wrong protocol\n        #{url => \"not-a-url\", owner => self()}, % Invalid URL format\n        #{url => \"\", owner => self()} % Empty URL\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(websocket, Opts))\n    end, InvalidOpts),\n    ok.\n\n%%====================================================================\n%% Test Cases - Message Formats\n%%====================================================================\n\njson_rpc_structure(Config) ->\n    % Test JSON-RPC 2.0 message structure requirements\n    \n    % Valid request with all fields\n    FullRequest = #{\n        <<\"jsonrpc\">> => <<\"2.0\">>,\n        <<\"method\">> => <<\"test_method\">>,\n        <<\"params\">> => #{<<\"arg1\">> => <<\"value1\">>},\n        <<\"id\">> => 1\n    },\n    ?assertEqual(ok, erlmcp_transport:validate_message(FullRequest)),\n    \n    % Valid request without params\n    RequestWithoutParams = #{\n        <<\"jsonrpc\">> => <<\"2.0\">>,\n        <<\"method\">> => <<\"test_method\">>,\n        <<\"id\">> => 1\n    },\n    ?assertEqual(ok, erlmcp_transport:validate_message(RequestWithoutParams)),\n    \n    % Valid notification (no id)\n    Notification = #{\n        <<\"jsonrpc\">> => <<\"2.0\">>,\n        <<\"method\">> => <<\"notify_method\">>,\n        <<\"params\">> => #{<<\"data\">> => <<\"value\">>}\n    },\n    ?assertEqual(ok, erlmcp_transport:validate_message(Notification)),\n    ok.\n\nnotification_format(Config) ->\n    % Test notification format (no id field)\n    Method = <<\"test_notification\">>,\n    Params = #{<<\"data\">> => <<\"test\">>},\n    \n    Notification = erlmcp_transport:create_notification(Method, Params),\n    \n    % Should have required fields\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Notification)),\n    ?assertEqual(Method, maps:get(<<\"method\">>, Notification)),\n    ?assertEqual(Params, maps:get(<<\"params\">>, Notification)),\n    \n    % Should NOT have id field\n    ?assertNot(maps:is_key(<<\"id\">>, Notification)),\n    \n    % Should validate as a proper message\n    ?assertEqual(ok, erlmcp_transport:validate_message(Notification)),\n    ok.\n\nresponse_format(Config) ->\n    % Test response format\n    Id = 42,\n    Result = #{<<\"status\">> => <<\"success\">>, <<\"data\">> => <<\"test_result\">>},\n    \n    Response = erlmcp_transport:create_response(Id, Result),\n    \n    % Should have required fields\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Response)),\n    ?assertEqual(Id, maps:get(<<\"id\">>, Response)),\n    ?assertEqual(Result, maps:get(<<\"result\">>, Response)),\n    \n    % Should NOT have method or error fields\n    ?assertNot(maps:is_key(<<\"method\">>, Response)),\n    ?assertNot(maps:is_key(<<\"error\">>, Response)),\n    \n    % Should validate as a proper message\n    ?assertEqual(ok, erlmcp_transport:validate_message(Response)),\n    ok.\n\nerror_response_format(Config) ->\n    % Test error response format\n    Id = 123,\n    Code = -32602,\n    Message = <<\"Invalid params\">>,\n    Data = #{<<\"param\">> => <<\"invalid_value\">>},\n    \n    ErrorResponse = erlmcp_transport:create_error_response(Id, Code, Message, Data),\n    \n    % Should have required top-level fields\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, ErrorResponse)),\n    ?assertEqual(Id, maps:get(<<\"id\">>, ErrorResponse)),\n    \n    % Should have error object with required fields\n    ErrorObj = maps:get(<<\"error\">>, ErrorResponse),\n    ?assertEqual(Code, maps:get(<<\"code\">>, ErrorObj)),\n    ?assertEqual(Message, maps:get(<<\"message\">>, ErrorObj)),\n    ?assertEqual(Data, maps:get(<<\"data\">>, ErrorObj)),\n    \n    % Should NOT have method or result fields\n    ?assertNot(maps:is_key(<<\"method\">>, ErrorResponse)),\n    ?assertNot(maps:is_key(<<\"result\">>, ErrorResponse)),\n    \n    % Should validate as a proper message\n    ?assertEqual(ok, erlmcp_transport:validate_message(ErrorResponse)),\n    ok.\n\n%%====================================================================\n%% Test Cases - Behavior Compliance\n%%====================================================================\n\nstdio_behavior_compliance(Config) ->\n    % Test that stdio transport implements the behavior correctly\n    \n    % Test init callback\n    StdioOpts = #{owner => self(), test_mode => true},\n    case erlmcp_transport_stdio_new:init([transport_id, StdioOpts]) of\n        {ok, State} ->\n            % Test send callback\n            ?assertEqual(ok, erlmcp_transport_stdio_new:send(State, <<\"test\">>)),\n            \n            % Test close callback\n            ?assertEqual(ok, erlmcp_transport_stdio_new:close(State)),\n            \n            % Test optional get_info callback if implemented\n            try\n                Info = erlmcp_transport_stdio_new:get_info(State),\n                ?assert(is_map(Info)),\n                ?assert(maps:is_key(type, Info))\n            catch\n                error:undef -> ok % Optional callback not implemented\n            end;\n        {stop, Reason} ->\n            ct:pal(\"Stdio transport failed to initialize: ~p\", [Reason])\n    end,\n    ok.\n\ntcp_behavior_compliance(Config) ->\n    % Test that TCP transport implements the behavior correctly\n    \n    % Test init callback (behavior version)\n    TcpOpts = #{\n        transport_id => test_tcp_behavior,\n        server_id => test_server_behavior,\n        host => \"localhost\",\n        port => 8080\n    },\n    \n    {ok, State} = erlmcp_transport_tcp:init(TcpOpts),\n    \n    % Test send callback (may fail if not connected, but shouldn't crash)\n    Result = erlmcp_transport_tcp:send(State, <<\"test\">>),\n    ?assert(Result =:= ok orelse element(1, Result) =:= error),\n    \n    % Test close callback\n    ?assertEqual(ok, erlmcp_transport_tcp:close(State)),\n    ok.\n\nhttp_behavior_compliance(Config) ->\n    % Test that HTTP transport implements the behavior correctly\n    \n    % Test init callback\n    HttpOpts = #{\n        transport_id => test_http_behavior,\n        server_id => test_server_behavior,\n        url => \"http://example.com/api\"\n    },\n    \n    {ok, State} = erlmcp_transport_http:init_transport(HttpOpts),\n    \n    % Test send callback (may fail due to network, but shouldn't crash)\n    Result = erlmcp_transport_http:send(State, <<\"test\">>),\n    ?assert(Result =:= ok orelse element(1, Result) =:= error),\n    \n    % Test close callback\n    ?assertEqual(ok, erlmcp_transport_http:close(State)),\n    ok.\n\n%%====================================================================\n%% Test Cases - Type System\n%%====================================================================\n\ntransport_state_type(Config) ->\n    % Test that transport state is properly typed\n    % This is mainly a compilation/interface test\n    \n    % Verify different transports return state that works with behavior\n    StdioOpts = #{owner => self(), test_mode => true},\n    case erlmcp_transport_stdio_new:init([transport_id, StdioOpts]) of\n        {ok, StdioState} ->\n            ?assert(erlmcp_transport_stdio_new:send(StdioState, <<\"test\">>) =/= undefined);\n        _ -> ok\n    end,\n    \n    TcpOpts = #{host => \"localhost\", port => 8080},\n    {ok, TcpState} = erlmcp_transport_tcp:init(TcpOpts),\n    ?assert(erlmcp_transport_tcp:send(TcpState, <<\"test\">>) =/= undefined),\n    ok.\n\ntransport_opts_type(Config) ->\n    % Test transport options type compatibility\n    \n    % These should all be valid transport_opts types\n    StdioOpts = #{owner => self()},\n    TcpOpts = #{host => \"localhost\", port => 8080, owner => self()},\n    HttpOpts = #{url => \"http://example.com\", owner => self()},\n    \n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(stdio, StdioOpts)),\n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, TcpOpts)),\n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, HttpOpts)),\n    ok.\n\ntransport_message_type(Config) ->\n    % Test transport message type compliance\n    \n    % Create various message types\n    Message1 = erlmcp_transport:create_message(<<\"test\">>, #{}, 1),\n    Message2 = erlmcp_transport:create_notification(<<\"notify\">>, #{}),\n    Message3 = erlmcp_transport:create_response(1, #{result => ok}),\n    Message4 = erlmcp_transport:create_error_response(1, -32600, <<\"Error\">>, undefined),\n    \n    % All should be valid transport messages\n    ?assertEqual(ok, erlmcp_transport:validate_message(Message1)),\n    ?assertEqual(ok, erlmcp_transport:validate_message(Message2)),\n    ?assertEqual(ok, erlmcp_transport:validate_message(Message3)),\n    ?assertEqual(ok, erlmcp_transport:validate_message(Message4)),\n    ok.\n\ntransport_info_type(Config) ->\n    % Test transport info type structure\n    \n    % Mock transport info\n    MockInfo = #{\n        type => test_transport,\n        version => <<\"1.0.0\">>,\n        capabilities => [send, 'receive'],\n        connection_state => connected,\n        statistics => #{messages_sent => 10, messages_received => 5}\n    },\n    \n    % Should have expected structure\n    ?assert(maps:is_key(type, MockInfo)),\n    ?assert(maps:is_key(connection_state, MockInfo)),\n    ok.\n\n%%====================================================================\n%% Test Cases - Validation Functions\n%%====================================================================\n\nurl_validation_functions(Config) ->\n    % Test URL validation helper functions\n    \n    % Valid HTTP URLs\n    ValidHttpUrls = [\n        \"http://example.com\",\n        \"https://secure.example.com\",\n        \"http://localhost:8080/path\"\n    ],\n    \n    % Valid WebSocket URLs\n    ValidWsUrls = [\n        \"ws://example.com/ws\",\n        \"wss://secure.example.com/ws\"\n    ],\n    \n    % Test the validation functions exist and work\n    % Note: These are internal functions, so we test through public interface\n    lists:foreach(fun(Url) ->\n        HttpOpts = #{url => Url, owner => self()},\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, HttpOpts))\n    end, ValidHttpUrls),\n    \n    lists:foreach(fun(Url) ->\n        WsOpts = #{url => Url, owner => self()},\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(websocket, WsOpts))\n    end, ValidWsUrls),\n    ok.\n\nhost_validation_functions(Config) ->\n    % Test host validation helper functions\n    \n    ValidHosts = [\n        \"localhost\",\n        \"example.com\",\n        \"192.168.1.1\",\n        {127, 0, 0, 1},\n        {192, 168, 1, 1}\n    ],\n    \n    lists:foreach(fun(Host) ->\n        TcpOpts = #{host => Host, port => 8080, owner => self()},\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, TcpOpts))\n    end, ValidHosts),\n    \n    % Test invalid hosts\n    InvalidHosts = [\n        {256, 0, 0, 1}, % Invalid IP\n        {}, % Wrong tuple format\n        123, % Not a string or IP tuple\n        \"\"  % Empty string\n    ],\n    \n    lists:foreach(fun(Host) ->\n        TcpOpts = #{host => Host, port => 8080, owner => self()},\n        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(tcp, TcpOpts))\n    end, InvalidHosts),\n    ok.\n\nmessage_content_validation(Config) ->\n    % Test message content validation functions\n    \n    % Valid message contents\n    ValidMessages = [\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"method\">> => <<\"test\">>, <<\"id\">> => 1},\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"result\">> => <<\"ok\">>, <<\"id\">> => 1},\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"error\">> => \n            #{<<\"code\">> => -32600, <<\"message\">> => <<\"Error\">>}, <<\"id\">> => 1}\n    ],\n    \n    lists:foreach(fun(Message) ->\n        ?assertEqual(ok, erlmcp_transport:validate_message(Message))\n    end, ValidMessages),\n    \n    % Invalid message contents\n    InvalidMessages = [\n        #{<<\"method\">> => <<\"test\">>}, % Missing jsonrpc\n        #{<<\"jsonrpc\">> => <<\"1.0\">>}, % Wrong version\n        #{<<\"jsonrpc\">> => <<\"2.0\">>}  % Missing content\n    ],\n    \n    lists:foreach(fun(Message) ->\n        ?assertMatch({error, _}, erlmcp_transport:validate_message(Message))\n    end, InvalidMessages),\n    ok.\n\nerror_structure_validation(Config) ->\n    % Test error structure validation\n    \n    % Valid error structures\n    ValidErrors = [\n        #{<<\"code\">> => -32600, <<\"message\">> => <<\"Invalid Request\">>},\n        #{<<\"code\">> => -32601, <<\"message\">> => <<\"Method not found\">>, \n          <<\"data\">> => #{<<\"method\">> => <<\"unknown\">>}}\n    ],\n    \n    lists:foreach(fun(ErrorObj) ->\n        ErrorResponse = #{\n            <<\"jsonrpc\">> => <<\"2.0\">>,\n            <<\"error\">> => ErrorObj,\n            <<\"id\">> => 1\n        },\n        ?assertEqual(ok, erlmcp_transport:validate_message(ErrorResponse))\n    end, ValidErrors),\n    \n    % Invalid error structures\n    InvalidErrors = [\n        #{<<\"message\">> => <<\"Error\">>}, % Missing code\n        #{<<\"code\">> => \"invalid\", <<\"message\">> => <<\"Error\">>}, % Wrong code type\n        #{<<\"code\">> => -32600, <<\"message\">> => 123} % Wrong message type\n    ],\n    \n    lists:foreach(fun(ErrorObj) ->\n        ErrorResponse = #{\n            <<\"jsonrpc\">> => <<\"2.0\">>,\n            <<\"error\">> => ErrorObj,\n            <<\"id\">> => 1\n        },\n        ?assertMatch({error, _}, erlmcp_transport:validate_message(ErrorResponse))\n    end, InvalidErrors),\n    ok.\n\n%%====================================================================\n%% Test Cases - Integration\n%%====================================================================\n\nbehavior_with_registry(Config) ->\n    % Test behavior integration with registry\n    \n    TransportId = test_behavior_registry,\n    ServerId = test_server_registry,\n    \n    % Start a transport that implements the behavior\n    StdioOpts = #{test_mode => true, server_id => ServerId},\n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, StdioOpts),\n    \n    timer:sleep(100), % Allow registration\n    \n    % Verify it registered properly\n    {ok, {RegPid, RegConfig}} = erlmcp_registry:find_transport(TransportId),\n    ?assertEqual(Pid, RegPid),\n    ?assert(maps:is_key(type, RegConfig)),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nbehavior_error_handling(Config) ->\n    % Test behavior error handling patterns\n    \n    % Test with invalid options\n    InvalidOpts = #{invalid => option},\n    \n    % Should handle gracefully\n    try\n        erlmcp_transport:validate_transport_opts(stdio, InvalidOpts)\n    catch\n        _:_ -> ok % Expected to fail\n    end,\n    \n    % Test message validation with invalid input\n    InvalidMessage = <<\"not a map\">>,\n    ?assertMatch({error, _}, erlmcp_transport:validate_message(InvalidMessage)),\n    ok.\n\nbehavior_lifecycle(Config) ->\n    % Test complete behavior lifecycle\n    \n    TransportId = test_behavior_lifecycle,\n    \n    % 1. Initialize\n    StdioOpts = #{test_mode => true},\n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, StdioOpts),\n    ?assert(is_process_alive(Pid)),\n    \n    % 2. Get state and test send\n    {ok, State} = gen_server:call(Pid, get_state),\n    ?assertEqual(ok, erlmcp_transport_stdio_new:send(State, <<\"test message\">>)),\n    \n    % 3. Test optional callbacks if available\n    try\n        Info = erlmcp_transport_stdio_new:get_info(State),\n        ?assert(is_map(Info))\n    catch\n        error:undef -> ok % Optional callback not implemented\n    end,\n    \n    % 4. Close\n    ?assertEqual(ok, erlmcp_transport_stdio_new:close(State)),\n    \n    % 5. Terminate\n    ok = gen_server:stop(Pid),\n    ?assertNot(is_process_alive(Pid)),\n    ok.\n\n%%====================================================================\n%% Helper Functions\n%%====================================================================\n\n% No additional helper functions needed for this test suite"
        }
    ]
}