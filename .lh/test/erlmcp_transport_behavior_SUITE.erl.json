{
    "sourceFile": "test/erlmcp_transport_behavior_SUITE.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1756185314750,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1756185314750,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @doc\n%%% Common Test suite for erlmcp_transport_behavior module\n%%%\n%%% This comprehensive test suite validates the transport behavior\n%%% interface and tests behavior compliance across all transport\n%%% implementations.\n%%%-------------------------------------------------------------------\n-module(erlmcp_transport_behavior_SUITE).\n\n-include_lib(\"common_test/include/ct.hrl\").\n-include_lib(\"eunit/include/eunit.hrl\").\n-include(\"erlmcp.hrl\").\n\n%% Suite callbacks\n-export([all/0, groups/0, init_per_suite/1, end_per_suite/1,\n         init_per_group/2, end_per_group/2,\n         init_per_testcase/2, end_per_testcase/2]).\n\n%% Test cases\n-export([\n    % Behavior validation\n    behavior_module_exists/1,\n    behavior_callbacks_defined/1,\n    behavior_types_exported/1,\n    behavior_optional_callbacks/1,\n    \n    % Message validation\n    validate_json_rpc_message/1,\n    validate_transport_opts/1,\n    message_creation_functions/1,\n    error_message_creation/1,\n    \n    % Transport options validation\n    stdio_opts_validation/1,\n    tcp_opts_validation/1,\n    http_opts_validation/1,\n    websocket_opts_validation/1,\n    \n    % Message format compliance\n    json_rpc_structure/1,\n    notification_format/1,\n    response_format/1,\n    error_response_format/1,\n    \n    % Behavior compliance tests\n    stdio_behavior_compliance/1,\n    tcp_behavior_compliance/1,\n    http_behavior_compliance/1,\n    \n    % Type system validation\n    transport_state_type/1,\n    transport_opts_type/1,\n    transport_message_type/1,\n    transport_info_type/1,\n    \n    % Validation functions\n    url_validation_functions/1,\n    host_validation_functions/1,\n    message_content_validation/1,\n    error_structure_validation/1,\n    \n    % Integration testing\n    behavior_with_registry/1,\n    behavior_error_handling/1,\n    behavior_lifecycle/1\n]).\n\n%%====================================================================\n%% Suite Configuration\n%%====================================================================\n\nall() ->\n    [\n        {group, behavior_validation},\n        {group, message_validation},\n        {group, transport_options},\n        {group, message_formats},\n        {group, behavior_compliance},\n        {group, type_system},\n        {group, validation_functions},\n        {group, integration}\n    ].\n\ngroups() ->\n    [\n        {behavior_validation, [parallel], [\n            behavior_module_exists,\n            behavior_callbacks_defined,\n            behavior_types_exported,\n            behavior_optional_callbacks\n        ]},\n        {message_validation, [parallel], [\n            validate_json_rpc_message,\n            validate_transport_opts,\n            message_creation_functions,\n            error_message_creation\n        ]},\n        {transport_options, [parallel], [\n            stdio_opts_validation,\n            tcp_opts_validation,\n            http_opts_validation,\n            websocket_opts_validation\n        ]},\n        {message_formats, [parallel], [\n            json_rpc_structure,\n            notification_format,\n            response_format,\n            error_response_format\n        ]},\n        {behavior_compliance, [sequential], [\n            stdio_behavior_compliance,\n            tcp_behavior_compliance,\n            http_behavior_compliance\n        ]},\n        {type_system, [parallel], [\n            transport_state_type,\n            transport_opts_type,\n            transport_message_type,\n            transport_info_type\n        ]},\n        {validation_functions, [parallel], [\n            url_validation_functions,\n            host_validation_functions,\n            message_content_validation,\n            error_structure_validation\n        ]},\n        {integration, [sequential], [\n            behavior_with_registry,\n            behavior_error_handling,\n            behavior_lifecycle\n        ]}\n    ].\n\n%%====================================================================\n%% Suite Setup/Teardown\n%%====================================================================\n\ninit_per_suite(Config) ->\n    ct:pal(\"Starting transport behavior test suite\"),\n    \n    % Start necessary applications\n    ok = application:ensure_started(crypto),\n    ok = application:ensure_started(sasl),\n    \n    % Start registry for integration tests\n    case erlmcp_registry:start_link() of\n        {ok, _} -> ok;\n        {error, {already_started, _}} -> ok\n    end,\n    \n    Config.\n\nend_per_suite(_Config) ->\n    ct:pal(\"Ending transport behavior test suite\"),\n    ok.\n\ninit_per_group(GroupName, Config) ->\n    ct:pal(\"Starting group: ~p\", [GroupName]),\n    Config.\n\nend_per_group(GroupName, _Config) ->\n    ct:pal(\"Ending group: ~p\", [GroupName]),\n    ok.\n\ninit_per_testcase(TestCase, Config) ->\n    ct:pal(\"Starting test case: ~p\", [TestCase]),\n    Config.\n\nend_per_testcase(TestCase, _Config) ->\n    ct:pal(\"Ending test case: ~p\", [TestCase]),\n    ok.\n\n%%====================================================================\n%% Test Cases - Behavior Validation\n%%====================================================================\n\nbehavior_module_exists(Config) ->\n    % Verify the behavior module exists and can be loaded\n    ?assert(code:is_loaded(erlmcp_transport) =/= false orelse \n            code:load_file(erlmcp_transport) =:= {module, erlmcp_transport}),\n    \n    % Verify it's a behavior module\n    Attributes = erlmcp_transport:module_info(attributes),\n    ?assert(lists:member(behavior, proplists:get_keys(Attributes)) orelse\n            lists:member(behaviour, proplists:get_keys(Attributes))),\n    ok.\n\nbehavior_callbacks_defined(Config) ->\n    % Verify required callbacks are defined\n    RequiredCallbacks = [\n        {init, 1},\n        {send, 2},\n        {close, 1}\n    ],\n    \n    Callbacks = erlmcp_transport:behaviour_info(callbacks),\n    \n    lists:foreach(fun(Callback) ->\n        ?assert(lists:member(Callback, Callbacks))\n    end, RequiredCallbacks),\n    \n    % Verify optional callbacks are marked as optional\n    OptionalCallbacks = erlmcp_transport:behaviour_info(optional_callbacks),\n    ExpectedOptional = [{get_info, 1}, {handle_transport_call, 2}],\n    \n    lists:foreach(fun(OptCallback) ->\n        ?assert(lists:member(OptCallback, OptionalCallbacks))\n    end, ExpectedOptional),\n    \n    ok.\n\nbehavior_types_exported(Config) ->\n    % Verify exported types\n    Exports = erlmcp_transport:module_info(exports),\n    \n    % Check for type information (may vary by Erlang version)\n    % At minimum, verify the module compiles and loads\n    ?assert(is_list(Exports)),\n    ?assert(length(Exports) > 0),\n    ok.\n\nbehavior_optional_callbacks(Config) ->\n    % Test optional callbacks behavior\n    OptionalCallbacks = [get_info, handle_transport_call],\n    \n    % These should be marked as optional\n    lists:foreach(fun(Callback) ->\n        % Verify optional callback is properly defined\n        ?assert(erlang:function_exported(erlmcp_transport, behaviour_info, 1))\n    end, OptionalCallbacks),\n    ok.\n\n%%====================================================================\n%% Test Cases - Message Validation\n%%====================================================================\n\nvalidate_json_rpc_message(Config) ->\n    % Test valid JSON-RPC messages\n    ValidMessages = [\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"method\">> => <<\"test\">>, <<\"id\">> => 1},\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"result\">> => <<\"ok\">>, <<\"id\">> => 1},\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"method\">> => <<\"notify\">>}, % Notification\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"error\">> => \n            #{<<\"code\">> => -32600, <<\"message\">> => <<\"Invalid Request\">>}, <<\"id\">> => null}\n    ],\n    \n    lists:foreach(fun(Message) ->\n        ?assertEqual(ok, erlmcp_transport:validate_message(Message))\n    end, ValidMessages),\n    \n    % Test invalid messages\n    InvalidMessages = [\n        #{}, % Missing jsonrpc field\n        #{<<\"jsonrpc\">> => <<\"1.0\">>}, % Wrong version\n        #{<<\"jsonrpc\">> => <<\"2.0\">>}, % No method, result, or error\n        \"not a map\", % Not a map\n        42 % Not a map\n    ],\n    \n    lists:foreach(fun(Message) ->\n        ?assertMatch({error, _}, erlmcp_transport:validate_message(Message))\n    end, InvalidMessages),\n    ok.\n\nvalidate_transport_opts(Config) ->\n    % Test stdio options validation\n    ValidStdioOpts = #{owner => self()},\n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(stdio, ValidStdioOpts)),\n    \n    % Test TCP options validation\n    ValidTcpOpts = #{host => \"localhost\", port => 8080, owner => self()},\n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, ValidTcpOpts)),\n    \n    % Test HTTP options validation  \n    ValidHttpOpts = #{url => \"http://example.com/api\", owner => self()},\n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, ValidHttpOpts)),\n    \n    % Test WebSocket options validation\n    ValidWsOpts = #{url => \"ws://example.com/ws\", owner => self()},\n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(websocket, ValidWsOpts)),\n    \n    % Test invalid transport type\n    ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(invalid_type, #{})),\n    ok.\n\nmessage_creation_functions(Config) ->\n    % Test message creation functions\n    Method = <<\"test_method\">>,\n    Params = #{param1 => <<\"value1\">>},\n    Id = 123,\n    \n    % Test create_message/3\n    Message = erlmcp_transport:create_message(Method, Params, Id),\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Message)),\n    ?assertEqual(Method, maps:get(<<\"method\">>, Message)),\n    ?assertEqual(Params, maps:get(<<\"params\">>, Message)),\n    ?assertEqual(Id, maps:get(<<\"id\">>, Message)),\n    \n    % Test create_notification/2\n    Notification = erlmcp_transport:create_notification(Method, Params),\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Notification)),\n    ?assertEqual(Method, maps:get(<<\"method\">>, Notification)),\n    ?assertEqual(Params, maps:get(<<\"params\">>, Notification)),\n    ?assertNot(maps:is_key(<<\"id\">>, Notification)),\n    \n    % Test create_response/2\n    Result = #{result => <<\"success\">>},\n    Response = erlmcp_transport:create_response(Id, Result),\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Response)),\n    ?assertEqual(Id, maps:get(<<\"id\">>, Response)),\n    ?assertEqual(Result, maps:get(<<\"result\">>, Response)),\n    ok.\n\nerror_message_creation(Config) ->\n    % Test error response creation\n    Id = 456,\n    Code = -32600,\n    Message = <<\"Invalid Request\">>,\n    Data = #{additional => <<\"info\">>},\n    \n    % Test with data\n    ErrorWithData = erlmcp_transport:create_error_response(Id, Code, Message, Data),\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, ErrorWithData)),\n    ?assertEqual(Id, maps:get(<<\"id\">>, ErrorWithData)),\n    \n    ErrorObj = maps:get(<<\"error\">>, ErrorWithData),\n    ?assertEqual(Code, maps:get(<<\"code\">>, ErrorObj)),\n    ?assertEqual(Message, maps:get(<<\"message\">>, ErrorObj)),\n    ?assertEqual(Data, maps:get(<<\"data\">>, ErrorObj)),\n    \n    % Test without data\n    ErrorWithoutData = erlmcp_transport:create_error_response(Id, Code, Message, undefined),\n    ErrorObj2 = maps:get(<<\"error\">>, ErrorWithoutData),\n    ?assertNot(maps:is_key(<<\"data\">>, ErrorObj2)),\n    ok.\n\n%%====================================================================\n%% Test Cases - Transport Options\n%%====================================================================\n\nstdio_opts_validation(Config) ->\n    % Valid stdio options\n    ValidOpts = [\n        #{owner => self()},\n        #{owner => self(), test_mode => true},\n        #{owner => self(), test_mode => false}\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(stdio, Opts))\n    end, ValidOpts),\n    \n    % Invalid stdio options\n    InvalidOpts = [\n        #{}, % Missing owner\n        #{owner => \"not_a_pid\"}, % Invalid owner type\n        #{owner => self(), invalid_option => true} % Extra invalid option\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(stdio, Opts))\n    end, InvalidOpts),\n    ok.\n\ntcp_opts_validation(Config) ->\n    % Valid TCP options\n    ValidOpts = [\n        #{host => \"localhost\", port => 8080, owner => self()},\n        #{host => {127,0,0,1}, port => 8080, owner => self()},\n        #{host => \"example.com\", port => 443, owner => self(), keepalive => true}\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, Opts))\n    end, ValidOpts),\n    \n    % Invalid TCP options\n    InvalidOpts = [\n        #{}, % Missing required fields\n        #{host => \"localhost\", owner => self()}, % Missing port\n        #{host => \"localhost\", port => 0, owner => self()}, % Invalid port\n        #{host => \"localhost\", port => 70000, owner => self()}, % Port too high\n        #{host => invalid_host, port => 8080, owner => self()} % Invalid host\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(tcp, Opts))\n    end, InvalidOpts),\n    ok.\n\nhttp_opts_validation(Config) ->\n    % Valid HTTP options\n    ValidOpts = [\n        #{url => \"http://example.com/api\", owner => self()},\n        #{url => \"https://secure.example.com/api\", owner => self()},\n        #{url => <<\"http://example.com/api\">>, owner => self()},\n        #{url => \"http://localhost:8080/api\", owner => self()}\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, Opts))\n    end, ValidOpts),\n    \n    % Invalid HTTP options\n    InvalidOpts = [\n        #{}, % Missing required fields\n        #{url => \"ftp://example.com\", owner => self()}, % Invalid protocol\n        #{url => \"not-a-url\", owner => self()}, % Invalid URL format\n        #{url => \"\", owner => self()} % Empty URL\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(http, Opts))\n    end, InvalidOpts),\n    ok.\n\nwebsocket_opts_validation(Config) ->\n    % Valid WebSocket options\n    ValidOpts = [\n        #{url => \"ws://example.com/ws\", owner => self()},\n        #{url => \"wss://secure.example.com/ws\", owner => self()},\n        #{url => <<\"ws://example.com/ws\">>, owner => self()}\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(websocket, Opts))\n    end, ValidOpts),\n    \n    % Invalid WebSocket options\n    InvalidOpts = [\n        #{}, % Missing required fields\n        #{url => \"http://example.com\", owner => self()}, % Wrong protocol\n        #{url => \"not-a-url\", owner => self()}, % Invalid URL format\n        #{url => \"\", owner => self()} % Empty URL\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(websocket, Opts))\n    end, InvalidOpts),\n    ok.\n\n%%====================================================================\n%% Test Cases - Message Formats\n%%====================================================================\n\njson_rpc_structure(Config) ->\n    % Test JSON-RPC 2.0 message structure requirements\n    \n    % Valid request with all fields\n    FullRequest = #{\n        <<\"jsonrpc\">> => <<\"2.0\">>,\n        <<\"method\">> => <<\"test_method\">>,\n        <<\"params\">> => #{<<\"arg1\">> => <<\"value1\">>},\n        <<\"id\">> => 1\n    },\n    ?assertEqual(ok, erlmcp_transport:validate_message(FullRequest)),\n    \n    % Valid request without params\n    RequestWithoutParams = #{\n        <<\"jsonrpc\">> => <<\"2.0\">>,\n        <<\"method\">> => <<\"test_method\">>,\n        <<\"id\">> => 1\n    },\n    ?assertEqual(ok, erlmcp_transport:validate_message(RequestWithoutParams)),\n    \n    % Valid notification (no id)\n    Notification = #{\n        <<\"jsonrpc\">> => <<\"2.0\">>,\n        <<\"method\">> => <<\"notify_method\">>,\n        <<\"params\">> => #{<<\"data\">> => <<\"value\">>}\n    },\n    ?assertEqual(ok, erlmcp_transport:validate_message(Notification)),\n    ok.\n\nnotification_format(Config) ->\n    % Test notification format (no id field)\n    Method = <<\"test_notification\">>,\n    Params = #{<<\"data\">> => <<\"test\">>},\n    \n    Notification = erlmcp_transport:create_notification(Method, Params),\n    \n    % Should have required fields\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Notification)),\n    ?assertEqual(Method, maps:get(<<\"method\">>, Notification)),\n    ?assertEqual(Params, maps:get(<<\"params\">>, Notification)),\n    \n    % Should NOT have id field\n    ?assertNot(maps:is_key(<<\"id\">>, Notification)),\n    \n    % Should validate as a proper message\n    ?assertEqual(ok, erlmcp_transport:validate_message(Notification)),\n    ok.\n\nresponse_format(Config) ->\n    % Test response format\n    Id = 42,\n    Result = #{<<\"status\">> => <<\"success\">>, <<\"data\">> => <<\"test_result\">>},\n    \n    Response = erlmcp_transport:create_response(Id, Result),\n    \n    % Should have required fields\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, Response)),\n    ?assertEqual(Id, maps:get(<<\"id\">>, Response)),\n    ?assertEqual(Result, maps:get(<<\"result\">>, Response)),\n    \n    % Should NOT have method or error fields\n    ?assertNot(maps:is_key(<<\"method\">>, Response)),\n    ?assertNot(maps:is_key(<<\"error\">>, Response)),\n    \n    % Should validate as a proper message\n    ?assertEqual(ok, erlmcp_transport:validate_message(Response)),\n    ok.\n\nerror_response_format(Config) ->\n    % Test error response format\n    Id = 123,\n    Code = -32602,\n    Message = <<\"Invalid params\">>,\n    Data = #{<<\"param\">> => <<\"invalid_value\">>},\n    \n    ErrorResponse = erlmcp_transport:create_error_response(Id, Code, Message, Data),\n    \n    % Should have required top-level fields\n    ?assertEqual(<<\"2.0\">>, maps:get(<<\"jsonrpc\">>, ErrorResponse)),\n    ?assertEqual(Id, maps:get(<<\"id\">>, ErrorResponse)),\n    \n    % Should have error object with required fields\n    ErrorObj = maps:get(<<\"error\">>, ErrorResponse),\n    ?assertEqual(Code, maps:get(<<\"code\">>, ErrorObj)),\n    ?assertEqual(Message, maps:get(<<\"message\">>, ErrorObj)),\n    ?assertEqual(Data, maps:get(<<\"data\">>, ErrorObj)),\n    \n    % Should NOT have method or result fields\n    ?assertNot(maps:is_key(<<\"method\">>, ErrorResponse)),\n    ?assertNot(maps:is_key(<<\"result\">>, ErrorResponse)),\n    \n    % Should validate as a proper message\n    ?assertEqual(ok, erlmcp_transport:validate_message(ErrorResponse)),\n    ok.\n\n%%====================================================================\n%% Test Cases - Behavior Compliance\n%%====================================================================\n\nstdio_behavior_compliance(Config) ->\n    % Test that stdio transport implements the behavior correctly\n    \n    % Test init callback\n    StdioOpts = #{owner => self(), test_mode => true},\n    case erlmcp_transport_stdio_new:init([transport_id, StdioOpts]) of\n        {ok, State} ->\n            % Test send callback\n            ?assertEqual(ok, erlmcp_transport_stdio_new:send(State, <<\"test\">>)),\n            \n            % Test close callback\n            ?assertEqual(ok, erlmcp_transport_stdio_new:close(State)),\n            \n            % Test optional get_info callback if implemented\n            try\n                Info = erlmcp_transport_stdio_new:get_info(State),\n                ?assert(is_map(Info)),\n                ?assert(maps:is_key(type, Info))\n            catch\n                error:undef -> ok % Optional callback not implemented\n            end;\n        {stop, Reason} ->\n            ct:pal(\"Stdio transport failed to initialize: ~p\", [Reason])\n    end,\n    ok.\n\ntcp_behavior_compliance(Config) ->\n    % Test that TCP transport implements the behavior correctly\n    \n    % Test init callback (behavior version)\n    TcpOpts = #{\n        transport_id => test_tcp_behavior,\n        server_id => test_server_behavior,\n        host => \"localhost\",\n        port => 8080\n    },\n    \n    {ok, State} = erlmcp_transport_tcp:init(TcpOpts),\n    \n    % Test send callback (may fail if not connected, but shouldn't crash)\n    Result = erlmcp_transport_tcp:send(State, <<\"test\">>),\n    ?assert(Result =:= ok orelse element(1, Result) =:= error),\n    \n    % Test close callback\n    ?assertEqual(ok, erlmcp_transport_tcp:close(State)),\n    ok.\n\nhttp_behavior_compliance(Config) ->\n    % Test that HTTP transport implements the behavior correctly\n    \n    % Test init callback\n    HttpOpts = #{\n        transport_id => test_http_behavior,\n        server_id => test_server_behavior,\n        url => \"http://example.com/api\"\n    },\n    \n    {ok, State} = erlmcp_transport_http:init_transport(HttpOpts),\n    \n    % Test send callback (may fail due to network, but shouldn't crash)\n    Result = erlmcp_transport_http:send(State, <<\"test\">>),\n    ?assert(Result =:= ok orelse element(1, Result) =:= error),\n    \n    % Test close callback\n    ?assertEqual(ok, erlmcp_transport_http:close(State)),\n    ok.\n\n%%====================================================================\n%% Test Cases - Type System\n%%====================================================================\n\ntransport_state_type(Config) ->\n    % Test that transport state is properly typed\n    % This is mainly a compilation/interface test\n    \n    % Verify different transports return state that works with behavior\n    StdioOpts = #{owner => self(), test_mode => true},\n    case erlmcp_transport_stdio_new:init([transport_id, StdioOpts]) of\n        {ok, StdioState} ->\n            ?assert(erlmcp_transport_stdio_new:send(StdioState, <<\"test\">>) =/= undefined);\n        _ -> ok\n    end,\n    \n    TcpOpts = #{host => \"localhost\", port => 8080},\n    {ok, TcpState} = erlmcp_transport_tcp:init(TcpOpts),\n    ?assert(erlmcp_transport_tcp:send(TcpState, <<\"test\">>) =/= undefined),\n    ok.\n\ntransport_opts_type(Config) ->\n    % Test transport options type compatibility\n    \n    % These should all be valid transport_opts types\n    StdioOpts = #{owner => self()},\n    TcpOpts = #{host => \"localhost\", port => 8080, owner => self()},\n    HttpOpts = #{url => \"http://example.com\", owner => self()},\n    \n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(stdio, StdioOpts)),\n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, TcpOpts)),\n    ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, HttpOpts)),\n    ok.\n\ntransport_message_type(Config) ->\n    % Test transport message type compliance\n    \n    % Create various message types\n    Message1 = erlmcp_transport:create_message(<<\"test\">>, #{}, 1),\n    Message2 = erlmcp_transport:create_notification(<<\"notify\">>, #{}),\n    Message3 = erlmcp_transport:create_response(1, #{result => ok}),\n    Message4 = erlmcp_transport:create_error_response(1, -32600, <<\"Error\">>, undefined),\n    \n    % All should be valid transport messages\n    ?assertEqual(ok, erlmcp_transport:validate_message(Message1)),\n    ?assertEqual(ok, erlmcp_transport:validate_message(Message2)),\n    ?assertEqual(ok, erlmcp_transport:validate_message(Message3)),\n    ?assertEqual(ok, erlmcp_transport:validate_message(Message4)),\n    ok.\n\ntransport_info_type(Config) ->\n    % Test transport info type structure\n    \n    % Mock transport info\n    MockInfo = #{\n        type => test_transport,\n        version => <<\"1.0.0\">>,\n        capabilities => [send, 'receive'],\n        connection_state => connected,\n        statistics => #{messages_sent => 10, messages_received => 5}\n    },\n    \n    % Should have expected structure\n    ?assert(maps:is_key(type, MockInfo)),\n    ?assert(maps:is_key(connection_state, MockInfo)),\n    ok.\n\n%%====================================================================\n%% Test Cases - Validation Functions\n%%====================================================================\n\nurl_validation_functions(Config) ->\n    % Test URL validation helper functions\n    \n    % Valid HTTP URLs\n    ValidHttpUrls = [\n        \"http://example.com\",\n        \"https://secure.example.com\",\n        \"http://localhost:8080/path\"\n    ],\n    \n    % Valid WebSocket URLs\n    ValidWsUrls = [\n        \"ws://example.com/ws\",\n        \"wss://secure.example.com/ws\"\n    ],\n    \n    % Test the validation functions exist and work\n    % Note: These are internal functions, so we test through public interface\n    lists:foreach(fun(Url) ->\n        HttpOpts = #{url => Url, owner => self()},\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(http, HttpOpts))\n    end, ValidHttpUrls),\n    \n    lists:foreach(fun(Url) ->\n        WsOpts = #{url => Url, owner => self()},\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(websocket, WsOpts))\n    end, ValidWsUrls),\n    ok.\n\nhost_validation_functions(Config) ->\n    % Test host validation helper functions\n    \n    ValidHosts = [\n        \"localhost\",\n        \"example.com\",\n        \"192.168.1.1\",\n        {127, 0, 0, 1},\n        {192, 168, 1, 1}\n    ],\n    \n    lists:foreach(fun(Host) ->\n        TcpOpts = #{host => Host, port => 8080, owner => self()},\n        ?assertEqual(ok, erlmcp_transport:validate_transport_opts(tcp, TcpOpts))\n    end, ValidHosts),\n    \n    % Test invalid hosts\n    InvalidHosts = [\n        {256, 0, 0, 1}, % Invalid IP\n        {}, % Wrong tuple format\n        123, % Not a string or IP tuple\n        \"\"  % Empty string\n    ],\n    \n    lists:foreach(fun(Host) ->\n        TcpOpts = #{host => Host, port => 8080, owner => self()},\n        ?assertMatch({error, _}, erlmcp_transport:validate_transport_opts(tcp, TcpOpts))\n    end, InvalidHosts),\n    ok.\n\nmessage_content_validation(Config) ->\n    % Test message content validation functions\n    \n    % Valid message contents\n    ValidMessages = [\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"method\">> => <<\"test\">>, <<\"id\">> => 1},\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"result\">> => <<\"ok\">>, <<\"id\">> => 1},\n        #{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"error\">> => \n            #{<<\"code\">> => -32600, <<\"message\">> => <<\"Error\">>}, <<\"id\">> => 1}\n    ],\n    \n    lists:foreach(fun(Message) ->\n        ?assertEqual(ok, erlmcp_transport:validate_message(Message))\n    end, ValidMessages),\n    \n    % Invalid message contents\n    InvalidMessages = [\n        #{<<\"method\">> => <<\"test\">>}, % Missing jsonrpc\n        #{<<\"jsonrpc\">> => <<\"1.0\">>}, % Wrong version\n        #{<<\"jsonrpc\">> => <<\"2.0\">>}  % Missing content\n    ],\n    \n    lists:foreach(fun(Message) ->\n        ?assertMatch({error, _}, erlmcp_transport:validate_message(Message))\n    end, InvalidMessages),\n    ok.\n\nerror_structure_validation(Config) ->\n    % Test error structure validation\n    \n    % Valid error structures\n    ValidErrors = [\n        #{<<\"code\">> => -32600, <<\"message\">> => <<\"Invalid Request\">>},\n        #{<<\"code\">> => -32601, <<\"message\">> => <<\"Method not found\">>, \n          <<\"data\">> => #{<<\"method\">> => <<\"unknown\">>}}\n    ],\n    \n    lists:foreach(fun(ErrorObj) ->\n        ErrorResponse = #{\n            <<\"jsonrpc\">> => <<\"2.0\">>,\n            <<\"error\">> => ErrorObj,\n            <<\"id\">> => 1\n        },\n        ?assertEqual(ok, erlmcp_transport:validate_message(ErrorResponse))\n    end, ValidErrors),\n    \n    % Invalid error structures\n    InvalidErrors = [\n        #{<<\"message\">> => <<\"Error\">>}, % Missing code\n        #{<<\"code\">> => \"invalid\", <<\"message\">> => <<\"Error\">>}, % Wrong code type\n        #{<<\"code\">> => -32600, <<\"message\">> => 123} % Wrong message type\n    ],\n    \n    lists:foreach(fun(ErrorObj) ->\n        ErrorResponse = #{\n            <<\"jsonrpc\">> => <<\"2.0\">>,\n            <<\"error\">> => ErrorObj,\n            <<\"id\">> => 1\n        },\n        ?assertMatch({error, _}, erlmcp_transport:validate_message(ErrorResponse))\n    end, InvalidErrors),\n    ok.\n\n%%====================================================================\n%% Test Cases - Integration\n%%====================================================================\n\nbehavior_with_registry(Config) ->\n    % Test behavior integration with registry\n    \n    TransportId = test_behavior_registry,\n    ServerId = test_server_registry,\n    \n    % Start a transport that implements the behavior\n    StdioOpts = #{test_mode => true, server_id => ServerId},\n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, StdioOpts),\n    \n    timer:sleep(100), % Allow registration\n    \n    % Verify it registered properly\n    {ok, {RegPid, RegConfig}} = erlmcp_registry:find_transport(TransportId),\n    ?assertEqual(Pid, RegPid),\n    ?assert(maps:is_key(type, RegConfig)),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nbehavior_error_handling(Config) ->\n    % Test behavior error handling patterns\n    \n    % Test with invalid options\n    InvalidOpts = #{invalid => option},\n    \n    % Should handle gracefully\n    try\n        erlmcp_transport:validate_transport_opts(stdio, InvalidOpts)\n    catch\n        _:_ -> ok % Expected to fail\n    end,\n    \n    % Test message validation with invalid input\n    InvalidMessage = <<\"not a map\">>,\n    ?assertMatch({error, _}, erlmcp_transport:validate_message(InvalidMessage)),\n    ok.\n\nbehavior_lifecycle(Config) ->\n    % Test complete behavior lifecycle\n    \n    TransportId = test_behavior_lifecycle,\n    \n    % 1. Initialize\n    StdioOpts = #{test_mode => true},\n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, StdioOpts),\n    ?assert(is_process_alive(Pid)),\n    \n    % 2. Get state and test send\n    {ok, State} = gen_server:call(Pid, get_state),\n    ?assertEqual(ok, erlmcp_transport_stdio_new:send(State, <<\"test message\">>)),\n    \n    % 3. Test optional callbacks if available\n    try\n        Info = erlmcp_transport_stdio_new:get_info(State),\n        ?assert(is_map(Info))\n    catch\n        error:undef -> ok % Optional callback not implemented\n    end,\n    \n    % 4. Close\n    ?assertEqual(ok, erlmcp_transport_stdio_new:close(State)),\n    \n    % 5. Terminate\n    ok = gen_server:stop(Pid),\n    ?assertNot(is_process_alive(Pid)),\n    ok.\n\n%%====================================================================\n%% Helper Functions\n%%====================================================================\n\n% No additional helper functions needed for this test suite"
        }
    ]
}