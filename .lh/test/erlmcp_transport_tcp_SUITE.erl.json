{
    "sourceFile": "test/erlmcp_transport_tcp_SUITE.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1756190592288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1756190592288,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @doc\n%%% Common Test suite for erlmcp_transport_tcp module\n%%%\n%%% This comprehensive test suite covers all aspects of the TCP transport\n%%% including behavior compliance, connection management, error handling,\n%%% and performance characteristics.\n%%%-------------------------------------------------------------------\n-module(erlmcp_transport_tcp_SUITE).\n\n-include_lib(\"common_test/include/ct.hrl\").\n-include_lib(\"eunit/include/eunit.hrl\").\n\n-include(\"erlmcp.hrl\").\n\n%% Suite callbacks\n-export([all/0, groups/0, init_per_suite/1, end_per_suite/1, init_per_group/2,\n         end_per_group/2, init_per_testcase/2, end_per_testcase/2]).\n%% Test cases\n-export([basic_startup_test/1, basic_send_test/1, basic_close_test/1, enhanced_info_test/1,\n         get_info_test/1, transport_behavior_send/1, transport_behavior_close/1, \n         transport_behavior_get_info/1, transport_behavior_handle_transport_call/1,\n         registry_registration/1, registry_unregistration/1, registry_message_routing/1,\n         config_validation/1, config_defaults/1, test_mode_startup/1, connection_parameters/1,\n         error_handling_no_socket/1, error_handling_connection_refused/1,\n         error_handling_socket_error/1, error_handling_invalid_host/1,\n         message_parsing/1, message_buffering/1, line_extraction/1, large_message_handling/1,\n         connection_establishment/1, connection_failure_handling/1, socket_options_validation/1,\n         supervisor_integration/1, graceful_shutdown/1, abnormal_termination/1,\n         high_volume_messages/1, memory_usage/1, latency_measurement/1,\n         concurrent_connections/1, stress_test/1, socket_cleanup/1]).\n\n%%====================================================================\n%% Suite Configuration\n%%====================================================================\n\nall() ->\n    [{group, basic_functionality},\n     {group, transport_behavior},\n     {group, registry_integration},\n     {group, configuration},\n     {group, error_handling},\n     {group, message_processing},\n     {group, connection_management},\n     {group, lifecycle},\n     {group, performance},\n     {group, integration}].\n\ngroups() ->\n    [{basic_functionality,\n      [parallel],\n      [basic_startup_test, basic_send_test, basic_close_test, enhanced_info_test, get_info_test]},\n     {transport_behavior,\n      [sequential],\n      [transport_behavior_send,\n       transport_behavior_close,\n       transport_behavior_get_info,\n       transport_behavior_handle_transport_call]},\n     {registry_integration,\n      [sequential],\n      [registry_registration,\n       registry_unregistration,\n       registry_message_routing]},\n     {configuration,\n      [parallel],\n      [config_validation, config_defaults, test_mode_startup, connection_parameters]},\n     {error_handling,\n      [sequential],\n      [error_handling_no_socket,\n       error_handling_connection_refused,\n       error_handling_socket_error,\n       error_handling_invalid_host]},\n     {message_processing,\n      [parallel],\n      [message_parsing, message_buffering, line_extraction, large_message_handling]},\n     {connection_management,\n      [sequential],\n      [connection_establishment, connection_failure_handling, socket_options_validation]},\n     {lifecycle,\n      [sequential],\n      [supervisor_integration, graceful_shutdown, abnormal_termination]},\n     {performance, \n      [sequential], \n      [high_volume_messages, memory_usage, latency_measurement]},\n     {integration,\n      [sequential],\n      [concurrent_connections, stress_test, socket_cleanup]}].\n\n%%====================================================================\n%% Suite Setup/Teardown\n%%====================================================================\n\ninit_per_suite(Config) ->\n    ct:pal(\"Starting TCP transport test suite\"),\n\n    % Start necessary applications\n    ok = application:ensure_started(crypto),\n    ok = application:ensure_started(sasl),\n\n    % Start registry for integration tests\n    case erlmcp_registry:start_link() of\n        {ok, _} ->\n            ok;\n        {error, {already_started, _}} ->\n            ok\n    end,\n\n    % Start test TCP server for connection tests\n    {ok, TestServer} = start_test_tcp_server(),\n    TestPort = get_test_server_port(TestServer),\n\n    [{test_server, TestServer},\n     {test_port, TestPort},\n     {test_host, \"127.0.0.1\"}\n     | Config].\n\nend_per_suite(Config) ->\n    TestServer = ?config(test_server, Config),\n    stop_test_tcp_server(TestServer),\n    ct:pal(\"Ending TCP transport test suite\"),\n    ok.\n\ninit_per_group(GroupName, Config) ->\n    ct:pal(\"Starting group: ~p\", [GroupName]),\n    Config.\n\nend_per_group(GroupName, _Config) ->\n    ct:pal(\"Ending group: ~p\", [GroupName]),\n    ok.\n\ninit_per_testcase(TestCase, Config) ->\n    ct:pal(\"Starting test case: ~p\", [TestCase]),\n    TransportId = list_to_atom(lists:flatten(\n        io_lib:format(\"~p_~p\", [TestCase, erlang:unique_integer([positive])]))),\n    [{transport_id, TransportId} | Config].\n\nend_per_testcase(TestCase, _Config) ->\n    ct:pal(\"Ending test case: ~p\", [TestCase]),\n    % Cleanup any processes started during test\n    cleanup_processes(),\n    ok.\n\n%%====================================================================\n%% Test Cases - Basic Functionality\n%%====================================================================\n\nbasic_startup_test(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n    ?assert(is_pid(Pid)),\n    ?assert(is_process_alive(Pid)),\n\n    % Verify transport info instead of internal state\n    Info = erlmcp_transport_tcp:get_info(Pid),\n    ?assertMatch(#{transport_id := TransportId}, Info),\n    ?assertMatch(#{type := tcp}, Info),\n    ?assertMatch(#{test_mode := true}, Info),\n    ?assertMatch(#{status := running}, Info),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\nbasic_send_test(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n\n    % Test sending via PID in test mode (should succeed without actual socket)\n    ?assertEqual(ok, erlmcp_transport_tcp:send(Pid, <<\"test message\">>)),\n    ?assertEqual(ok, erlmcp_transport_tcp:send(Pid, \"test string\")),\n    ?assertEqual(ok, erlmcp_transport_tcp:send(Pid, [<<\"iolist\">>, \" data\"])),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\nbasic_close_test(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n\n    % Test close operation via PID\n    ?assertEqual(ok, erlmcp_transport_tcp:close(Pid)),\n\n    % Verify transport still responds\n    Info = erlmcp_transport_tcp:get_info(Pid),\n    ?assertMatch(#{type := tcp}, Info),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\nenhanced_info_test(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n\n    % Test enhanced get_info functionality\n    Info = erlmcp_transport_tcp:get_info(Pid),\n    \n    % Verify required fields\n    ?assertMatch(#{transport_id := TransportId}, Info),\n    ?assertMatch(#{type := tcp}, Info),\n    ?assertMatch(#{test_mode := true}, Info),\n    ?assertMatch(#{status := running}, Info),\n    \n    % Verify connection info structure\n    ?assert(maps:is_key(connection, Info)),\n    Connection = maps:get(connection, Info),\n    ?assertMatch(#{host := \"127.0.0.1\"}, Connection),\n    ?assertMatch(#{port := 8080}, Connection),\n    ?assertMatch(#{connected := false}, Connection),\n    ?assertMatch(#{reconnect_attempts := 0}, Connection),\n    ?assert(maps:is_key(uptime, Connection)),\n    \n    % Verify statistics structure\n    ?assert(maps:is_key(statistics, Info)),\n    Stats = maps:get(statistics, Info),\n    ?assert(maps:is_key(messages_sent, Stats)),\n    ?assert(maps:is_key(messages_received, Stats)),\n    ?assert(maps:is_key(errors, Stats)),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\nget_info_test(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n\n    Info = erlmcp_transport_tcp:get_info(Pid),\n    ?assert(is_map(Info)),\n    ?assertMatch(#{type := tcp}, Info),\n    ?assertMatch(#{transport_id := TransportId}, Info),\n    ?assertMatch(#{connection := #{host := \"127.0.0.1\"}}, Info),\n    ?assertMatch(#{connection := #{port := 8080}}, Info),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Test Cases - Transport Behavior\n%%====================================================================\n\ntransport_behavior_send(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n    {ok, State} = gen_server:call(Pid, get_state),\n\n    % Test different data types\n    TestCases = [\n        <<\"binary data\">>,\n        \"string data\",\n        [<<\"iolist\">>, \" \", <<\"data\">>]\n    ],\n\n    lists:foreach(fun(Data) ->\n        ?assertEqual(ok, erlmcp_transport_tcp:send(State, Data))\n    end, TestCases),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\ntransport_behavior_close(Config) ->\n    TransportId = ?config(transport_id, Config),\n\n    % Test with different configurations\n    TestConfigs = [\n        #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n        #{test_mode => false, host => \"127.0.0.1\", port => 9999}  % Non-existent port\n    ],\n\n    lists:foreach(fun(TestConfig) ->\n        case erlmcp_transport_tcp:start_link(TransportId, TestConfig) of\n            {ok, Pid} ->\n                {ok, State} = gen_server:call(Pid, get_state),\n                ?assertEqual(ok, erlmcp_transport_tcp:close(State)),\n                ok = gen_server:stop(Pid);\n            {error, _} ->\n                % Expected for invalid configurations\n                ok\n        end\n    end, TestConfigs),\n\n    ok.\n\ntransport_behavior_get_info(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n    {ok, State} = gen_server:call(Pid, get_state),\n\n    Info = erlmcp_transport_tcp:get_info(State),\n\n    ?assertMatch(#{type := tcp}, Info),\n    ?assertMatch(#{status := running}, Info),\n    ?assertMatch(#{test_mode := true}, Info),\n    ?assertMatch(#{transport_id := TransportId}, Info),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\ntransport_behavior_handle_transport_call(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n\n    % Test transport call - should handle properly\n    Response = gen_server:call(Pid, {transport_call, get_stats}),\n    ?assertMatch({reply, {reply, {ok, _}, _}}, Response),\n\n    % Test unknown call - should return error\n    UnknownResponse = gen_server:call(Pid, {transport_call, unknown_request}),\n    ?assertMatch({reply, {error, unknown_request}}, UnknownResponse),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Test Cases - Registry Integration\n%%====================================================================\n\nregistry_registration(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n\n    % Wait for registration to complete\n    timer:sleep(100),\n    \n    % Verify registration (registry should exist from init_per_suite)\n    case erlmcp_registry:find_transport(TransportId) of\n        {ok, {RegPid, RegConfig}} ->\n            ?assertEqual(Pid, RegPid),\n            ?assertMatch(#{type := tcp}, RegConfig);\n        {error, not_found} ->\n            ct:pal(\"Warning: Transport not registered (registry might not be available)\")\n    end,\n\n    ok = gen_server:stop(Pid),\n    ok.\n\nregistry_unregistration(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n\n    % Verify registered (if registry is available)\n    case erlmcp_registry:find_transport(TransportId) of\n        {ok, _} ->\n            % Stop and verify unregistered\n            ok = gen_server:stop(Pid),\n            timer:sleep(100),\n            ?assertEqual({error, not_found}, erlmcp_registry:find_transport(TransportId));\n        {error, not_found} ->\n            ct:pal(\"Registry not available, skipping unregistration test\"),\n            ok = gen_server:stop(Pid)\n    end,\n    ok.\n\nregistry_message_routing(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n\n    % Test message sending through registry\n    TestMessage = <<\"test_message\">>,\n    \n    % Send message directly to transport\n    gen_server:cast(Pid, {data, TestMessage}),\n    \n    % Verify transport is still alive (basic message handling)\n    timer:sleep(100),\n    ?assert(is_process_alive(Pid)),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Test Cases - Configuration\n%%====================================================================\n\nconfig_validation(Config) ->\n    % Test valid configurations\n    ValidConfigs = [\n        #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n        #{test_mode => false, host => \"localhost\", port => 9090},\n        #{host => {127, 0, 0, 1}, port => 8080, test_mode => true}\n    ],\n\n    lists:foreach(fun(TestConfig) ->\n        TransportId = list_to_atom(\"test_\" ++ integer_to_list(erlang:unique_integer([positive]))),\n        try\n            {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n            ?assert(is_process_alive(Pid)),\n            ok = gen_server:stop(Pid)\n        catch\n            error:{badmatch, {error, Reason}} ->\n                ct:pal(\"Valid config failed: ~p, Reason: ~p\", [TestConfig, Reason])\n        end\n    end, ValidConfigs),\n    ok.\n\nconfig_defaults(Config) ->\n    TransportId = ?config(transport_id, Config),\n    MinimalConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},  % Valid minimal config\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, MinimalConfig),\n    Info = erlmcp_transport_tcp:get_info(Pid),\n\n    % Verify basic configuration is applied\n    ?assertMatch(#{connection := #{port := 8080}}, Info),\n    ?assertMatch(#{connection := #{host := \"127.0.0.1\"}}, Info),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\ntest_mode_startup(Config) ->\n    TransportId = ?config(transport_id, Config),\n\n    % Test mode enabled\n    TestConfig1 = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n    {ok, Pid1} = erlmcp_transport_tcp:start_link(TransportId, TestConfig1),\n    \n    Info1 = erlmcp_transport_tcp:get_info(Pid1),\n    ?assertMatch(#{test_mode := true}, Info1),\n\n    ok = gen_server:stop(Pid1),\n\n    % Test mode disabled (should attempt real connection and may fail)\n    TestConfig2 = #{test_mode => false, host => \"127.0.0.1\", port => 9999},\n    case erlmcp_transport_tcp:start_link(TransportId, TestConfig2) of\n        {ok, Pid2} ->\n            ok = gen_server:stop(Pid2);\n        {error, _Reason} ->\n            % Expected for non-existent port\n            ok\n    end,\n    ok.\n\nconnection_parameters(Config) ->\n    TransportId = ?config(transport_id, Config),\n\n    % Test various connection parameter combinations\n    TestCases = [\n        #{test_mode => true, host => \"localhost\", port => 8080},\n        #{test_mode => true, host => {127, 0, 0, 1}, port => 8080},\n        #{test_mode => true, host => \"127.0.0.1\", port => 443},\n        #{test_mode => true, host => \"127.0.0.1\", port => 80}\n    ],\n\n    lists:foreach(fun(TestConfig) ->\n        TestId = list_to_atom(\"test_\" ++ integer_to_list(erlang:unique_integer([positive]))),\n        {ok, Pid} = erlmcp_transport_tcp:start_link(TestId, TestConfig),\n        Info = erlmcp_transport_tcp:get_info(Pid),\n        \n        ?assert(maps:is_key(connection, Info)),\n        Connection = maps:get(connection, Info),\n        ?assert(maps:is_key(host, Connection)),\n        ?assert(maps:is_key(port, Connection)),\n        \n        ok = gen_server:stop(Pid)\n    end, TestCases),\n    ok.\n\n%%====================================================================\n%% Test Cases - Error Handling\n%%====================================================================\n\nerror_handling_no_socket(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n    {ok, State} = gen_server:call(Pid, get_state),\n\n    % In test mode, socket operations should succeed\n    ?assertEqual(ok, erlmcp_transport_tcp:send(State, <<\"test\">>)),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\nerror_handling_connection_refused(Config) ->\n    TransportId = ?config(transport_id, Config),\n    % Try to connect to a port that should be closed\n    TestConfig = #{test_mode => false, host => \"127.0.0.1\", port => 9999},\n\n    case erlmcp_transport_tcp:start_link(TransportId, TestConfig) of\n        {ok, Pid} ->\n            ct:pal(\"Unexpected success connecting to closed port\"),\n            ok = gen_server:stop(Pid);\n        {error, Reason} ->\n            ct:pal(\"Expected connection failure: ~p\", [Reason]),\n            ?assert(is_atom(Reason) orelse is_tuple(Reason))\n    end,\n    ok.\n\nerror_handling_socket_error(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n\n    % Simulate socket error\n    Pid ! {tcp_error, fake_socket, connection_lost},\n    \n    % Process should handle the error (may stop or continue)\n    timer:sleep(100),\n    % Note: In test mode, the process might not actually handle tcp_error\n    % since there's no real socket\n    \n    case is_process_alive(Pid) of\n        true ->\n            ok = gen_server:stop(Pid);\n        false ->\n            ct:pal(\"Process stopped due to simulated socket error\")\n    end,\n    ok.\n\nerror_handling_invalid_host(Config) ->\n    TransportId = ?config(transport_id, Config),\n    % Test with invalid host\n    TestConfig = #{test_mode => false, host => \"invalid.host.that.does.not.exist\", port => 8080},\n\n    case erlmcp_transport_tcp:start_link(TransportId, TestConfig) of\n        {ok, Pid} ->\n            ct:pal(\"Unexpected success with invalid host\"),\n            ok = gen_server:stop(Pid);\n        {error, Reason} ->\n            ct:pal(\"Expected failure with invalid host: ~p\", [Reason]),\n            ?assert(is_atom(Reason) orelse is_tuple(Reason))\n    end,\n    ok.\n\n%%====================================================================\n%% Test Cases - Message Processing\n%%====================================================================\n\nmessage_parsing(Config) ->\n    % Test the internal line extraction functionality if accessible\n    % Since extract_lines is private, we test through message handling\n    \n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n\n    % Send various message formats\n    TestMessages = [\n        <<\"single line\">>,\n        <<\"line1\\nline2\\n\">>,\n        <<\"partial\">>\n    ],\n\n    lists:foreach(fun(Message) ->\n        gen_server:cast(Pid, {data, Message}),\n        timer:sleep(10)  % Allow processing\n    end, TestMessages),\n\n    % Transport should still be alive\n    ?assert(is_process_alive(Pid)),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\nmessage_buffering(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n\n    % Send partial messages that need buffering\n    gen_server:cast(Pid, {data, <<\"partial\">>}),\n    gen_server:cast(Pid, {data, <<\" message\\n\">>}),\n    gen_server:cast(Pid, {data, <<\"complete message\\n\">>}),\n\n    timer:sleep(50),  % Allow processing\n    ?assert(is_process_alive(Pid)),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\nline_extraction(Config) ->\n    % Test line extraction logic through cast messages\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n\n    % Test various line formats\n    TestData = [\n        <<\"line1\\nline2\\npartial\">>,\n        <<\" continued\\nline3\\n\">>,\n        <<\"\\n\">>,  % Empty line\n        <<\"final line\\n\">>\n    ],\n\n    lists:foreach(fun(Data) ->\n        gen_server:cast(Pid, {data, Data})\n    end, TestData),\n\n    timer:sleep(100),\n    ?assert(is_process_alive(Pid)),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\nlarge_message_handling(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n\n    % Create large message (1MB)\n    LargeMessage = binary:copy(<<\"X\">>, 1024 * 1024),\n    LargeMessageWithNewline = <<LargeMessage/binary, \"\\n\">>,\n\n    % Send large message\n    gen_server:cast(Pid, {data, LargeMessageWithNewline}),\n\n    timer:sleep(500),  % Allow processing\n    ?assert(is_process_alive(Pid)),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Test Cases - Connection Management\n%%====================================================================\n\nconnection_establishment(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestHost = ?config(test_host, Config),\n    TestPort = ?config(test_port, Config),\n\n    % Test connection to real test server\n    TestConfig = #{test_mode => false, host => TestHost, port => TestPort},\n\n    case erlmcp_transport_tcp:start_link(TransportId, TestConfig) of\n        {ok, Pid} ->\n            Info = erlmcp_transport_tcp:get_info(Pid),\n            ?assertMatch(#{type := tcp}, Info),\n            ?assertMatch(#{connection := #{host := TestHost}}, Info),\n            ?assertMatch(#{connection := #{port := TestPort}}, Info),\n            \n            ok = gen_server:stop(Pid);\n        {error, Reason} ->\n            ct:pal(\"Connection establishment failed: ~p\", [Reason]),\n            % This might be expected if test server isn't available\n            ?assert(true)\n    end,\n    ok.\n\nconnection_failure_handling(Config) ->\n    TransportId = ?config(transport_id, Config),\n    \n    % Test connection to non-existent server\n    TestConfig = #{test_mode => false, host => \"127.0.0.1\", port => 9998},\n\n    case erlmcp_transport_tcp:start_link(TransportId, TestConfig) of\n        {ok, Pid} ->\n            ct:pal(\"Unexpected connection success\"),\n            ok = gen_server:stop(Pid);\n        {error, Reason} ->\n            ct:pal(\"Expected connection failure: ~p\", [Reason])\n    end,\n    ok.\n\nsocket_options_validation(Config) ->\n    % Test that socket options are properly configured\n    % This is mainly tested through successful initialization\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n    Info = erlmcp_transport_tcp:get_info(Pid),\n    \n    % Verify basic configuration is present\n    ?assert(maps:is_key(config, Info)),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Test Cases - Lifecycle\n%%====================================================================\n\nsupervisor_integration(Config) ->\n    % Test that transport can be started/stopped cleanly for supervisor use\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n    ?assert(is_process_alive(Pid)),\n\n    % Verify clean shutdown\n    ok = gen_server:stop(Pid),\n    ?assertNot(is_process_alive(Pid)),\n    ok.\n\ngraceful_shutdown(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => false, host => \"127.0.0.1\", port => 9997},\n\n    case erlmcp_transport_tcp:start_link(TransportId, TestConfig) of\n        {ok, Pid} ->\n            % Test graceful shutdown\n            ok = gen_server:stop(Pid),\n            timer:sleep(100),\n            ?assertNot(is_process_alive(Pid));\n        {error, _} ->\n            % Expected if can't bind to port\n            ok\n    end,\n    ok.\n\nabnormal_termination(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n    \n    % Kill the transport process\n    exit(Pid, kill),\n    timer:sleep(100),\n    \n    ?assertNot(is_process_alive(Pid)),\n    ok.\n\n%%====================================================================\n%% Test Cases - Performance\n%%====================================================================\n\nhigh_volume_messages(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n    \n    % Send many messages quickly\n    MessageCount = 1000,\n    StartTime = erlang:monotonic_time(millisecond),\n\n    lists:foreach(fun(N) ->\n        Message = iolist_to_binary([<<\"message_\">>, integer_to_list(N), <<\"\\n\">>]),\n        gen_server:cast(Pid, {data, Message})\n    end, lists:seq(1, MessageCount)),\n\n    EndTime = erlang:monotonic_time(millisecond),\n    Duration = EndTime - StartTime,\n\n    ct:pal(\"Processed ~p messages in ~p ms (~p msg/sec)\", \n           [MessageCount, Duration, round(MessageCount * 1000 / Duration)]),\n\n    % Should handle high volume without crashing\n    timer:sleep(100),\n    ?assert(is_process_alive(Pid)),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\nmemory_usage(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    % Measure memory before\n    {memory, MemBefore} = erlang:process_info(self(), memory),\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n\n    % Measure transport memory\n    {memory, TransportMem} = erlang:process_info(Pid, memory),\n\n    ct:pal(\"TCP transport memory usage: ~p bytes\", [TransportMem]),\n\n    % Verify reasonable memory usage (< 1MB for basic transport)\n    ?assert(TransportMem < 1024 * 1024),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\nlatency_measurement(Config) ->\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n\n    % Measure latency for get_info calls\n    MessageCount = 100,\n    Latencies = lists:map(fun(_N) ->\n        StartTime = erlang:monotonic_time(microsecond),\n        _Info = erlmcp_transport_tcp:get_info(Pid),\n        EndTime = erlang:monotonic_time(microsecond),\n        EndTime - StartTime\n    end, lists:seq(1, MessageCount)),\n\n    AvgLatency = lists:sum(Latencies) / length(Latencies),\n    MaxLatency = lists:max(Latencies),\n    MinLatency = lists:min(Latencies),\n\n    ct:pal(\"Latency stats - Avg: ~.2f μs, Min: ~p μs, Max: ~p μs\",\n           [AvgLatency, MinLatency, MaxLatency]),\n\n    % Verify reasonable latency (< 1ms average for test mode calls)\n    ?assert(AvgLatency < 1000),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Test Cases - Integration\n%%====================================================================\n\nconcurrent_connections(Config) ->\n    % Test multiple TCP transports running concurrently\n    NumTransports = 5,\n    TestConfigs = [\n        #{test_mode => true, host => \"127.0.0.1\", port => 8080 + N}\n        || N <- lists:seq(1, NumTransports)\n    ],\n\n    Parent = self(),\n    Pids = [\n        begin\n            TransportId = list_to_atom(\"transport_\" ++ integer_to_list(N)),\n            {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, Config),\n            spawn(fun() ->\n                lists:foreach(fun(I) ->\n                    Message = iolist_to_binary([<<\"msg_\">>, integer_to_list(I), <<\"\\n\">>]),\n                    gen_server:cast(Pid, {data, Message})\n                end, lists:seq(1, 100)),\n                Parent ! {done, Pid}\n            end),\n            Pid\n        end\n        || {N, Config} <- lists:zip(lists:seq(1, NumTransports), TestConfigs)\n    ],\n\n    % Wait for all to complete\n    lists:foreach(fun(Pid) ->\n        receive\n            {done, Pid} -> ok\n        after 5000 -> \n            ?assert(false, \"Concurrent test timed out\")\n        end\n    end, Pids),\n\n    % All transports should still be alive\n    lists:foreach(fun(Pid) ->\n        ?assert(is_process_alive(Pid)),\n        ok = gen_server:stop(Pid)\n    end, Pids),\n\n    ok.\n\nstress_test(Config) ->\n    % Combined stress test\n    TransportId = ?config(transport_id, Config),\n    TestConfig = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n\n    {ok, Pid} = erlmcp_transport_tcp:start_link(TransportId, TestConfig),\n\n    % Multiple concurrent operations\n    NumClients = 3,\n    OpsPerClient = 200,\n\n    Parent = self(),\n    Clients = [\n        spawn(fun() ->\n            lists:foreach(fun(N) ->\n                % Mix of different operations\n                case N rem 3 of\n                    0 -> \n                        _Info = erlmcp_transport_tcp:get_info(Pid);\n                    1 -> \n                        Message = iolist_to_binary([<<\"stress_\">>, integer_to_list(N), <<\"\\n\">>]),\n                        gen_server:cast(Pid, {data, Message});\n                    2 -> \n                        {ok, _State} = gen_server:call(Pid, get_state)\n                end\n            end, lists:seq(1, OpsPerClient)),\n            Parent ! {client_done, self()}\n        end)\n        || _ <- lists:seq(1, NumClients)\n    ],\n\n    StartTime = erlang:monotonic_time(millisecond),\n\n    % Wait for all clients\n    lists:foreach(fun(ClientPid) ->\n        receive\n            {client_done, ClientPid} -> ok\n        after 10000 -> \n            ?assert(false, \"Stress test client timed out\")\n        end\n    end, Clients),\n\n    EndTime = erlang:monotonic_time(millisecond),\n    TotalOps = NumClients * OpsPerClient,\n    Duration = EndTime - StartTime,\n\n    ct:pal(\"Stress test: ~p ops in ~p ms (~.2f ops/sec)\",\n           [TotalOps, Duration, TotalOps * 1000 / Duration]),\n\n    % Should survive stress test\n    ?assert(is_process_alive(Pid)),\n\n    ok = gen_server:stop(Pid),\n    ok.\n\nsocket_cleanup(Config) ->\n    % Test that sockets are properly cleaned up\n    TransportId = ?config(transport_id, Config),\n    \n    % Test cleanup in test mode\n    TestConfig1 = #{test_mode => true, host => \"127.0.0.1\", port => 8080},\n    {ok, Pid1} = erlmcp_transport_tcp:start_link(TransportId, TestConfig1),\n    ok = gen_server:stop(Pid1),\n    timer:sleep(100),\n    ?assertNot(is_process_alive(Pid1)),\n\n    % Test cleanup with potential real socket (may fail to create)\n    TestConfig2 = #{test_mode => false, host => \"127.0.0.1\", port => 9996},\n    case erlmcp_transport_tcp:start_link(TransportId, TestConfig2) of\n        {ok, Pid2} ->\n            ok = gen_server:stop(Pid2),\n            timer:sleep(100),\n            ?assertNot(is_process_alive(Pid2));\n        {error, _} ->\n            % Expected if can't create socket\n            ok\n    end,\n\n    ok.\n\n%%====================================================================\n%% Helper Functions\n%%====================================================================\n\ncleanup_processes() ->\n    % Kill any stray processes\n    timer:sleep(50).\n\n%% Test TCP server functions\nstart_test_tcp_server() ->\n    {ok, ListenSocket} = gen_tcp:listen(0, [binary, {active, false}, {reuseaddr, true}]),\n    {ok, Port} = inet:port(ListenSocket),\n    \n    ServerPid = spawn(fun() -> test_tcp_server_loop(ListenSocket) end),\n    \n    {ok, {ServerPid, Port}}.\n\nget_test_server_port({_Pid, Port}) ->\n    Port.\n\nstop_test_tcp_server({ServerPid, _Port}) ->\n    exit(ServerPid, normal).\n\ntest_tcp_server_loop(ListenSocket) ->\n    case gen_tcp:accept(ListenSocket) of\n        {ok, Socket} ->\n            spawn(fun() -> test_tcp_client_handler(Socket) end),\n            test_tcp_server_loop(ListenSocket);\n        {error, closed} ->\n            ok\n    end.\n\ntest_tcp_client_handler(Socket) ->\n    case gen_tcp:recv(Socket, 0) of\n        {ok, Data} ->\n            ct:pal(\"Test TCP server received: ~p\", [Data]),\n            gen_tcp:send(Socket, <<\"OK\">>),\n            test_tcp_client_handler(Socket);\n        {error, closed} ->\n            gen_tcp:close(Socket);\n        {error, Reason} ->\n            ct:pal(\"Test TCP server error: ~p\", [Reason]),\n            gen_tcp:close(Socket)\n    end."
        }
    ]
}