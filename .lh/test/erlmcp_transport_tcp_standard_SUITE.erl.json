{
    "sourceFile": "test/erlmcp_transport_tcp_standard_SUITE.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1756185314750,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756190592316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,200 +17,151 @@\n -module(erlmcp_transport_tcp_standard_SUITE).\n \n -include_lib(\"common_test/include/ct.hrl\").\n -include_lib(\"eunit/include/eunit.hrl\").\n+\n -include(\"erlmcp.hrl\").\n \n %% Suite callbacks\n--export([all/0, groups/0, init_per_suite/1, end_per_suite/1,\n-         init_per_group/2, end_per_group/2,\n-         init_per_testcase/2, end_per_testcase/2]).\n-\n+-export([all/0, groups/0, init_per_suite/1, end_per_suite/1, init_per_group/2,\n+         end_per_group/2, init_per_testcase/2, end_per_testcase/2]).\n %% Behavior compliance tests\n--export([\n-    behavior_init_compliance/1,\n-    behavior_send_compliance/1,\n-    behavior_close_compliance/1,\n-    behavior_get_info_compliance/1,\n-    behavior_handle_transport_call_compliance/1,\n-    behavior_exports_validation/1\n-]).\n-\n+-export([behavior_init_compliance/1, behavior_send_compliance/1,\n+         behavior_close_compliance/1, behavior_get_info_compliance/1,\n+         behavior_handle_transport_call_compliance/1, behavior_exports_validation/1]).\n %% Connection management tests\n--export([\n-    connection_establishment/1,\n-    connection_parameters_validation/1,\n-    connection_timeout_handling/1,\n-    connection_keepalive/1,\n-    connection_nodelay/1,\n-    connection_buffer_sizing/1\n-]).\n-\n+-export([connection_establishment/1, connection_parameters_validation/1,\n+         connection_timeout_handling/1, connection_keepalive/1, connection_nodelay/1,\n+         connection_buffer_sizing/1]).\n %% Network error handling tests\n--export([\n-    network_connection_refused/1,\n-    network_connection_timeout/1,\n-    network_host_unreachable/1,\n-    network_connection_reset/1,\n-    network_partial_write/1,\n-    network_socket_closure/1\n-]).\n-\n+-export([network_connection_refused/1, network_connection_timeout/1,\n+         network_host_unreachable/1, network_connection_reset/1, network_partial_write/1,\n+         network_socket_closure/1]).\n %% Reconnection logic tests\n--export([\n-    reconnection_automatic/1,\n-    reconnection_max_attempts/1,\n-    reconnection_backoff_strategy/1,\n-    reconnection_state_preservation/1,\n-    reconnection_message_queuing/1,\n-    reconnection_failure_handling/1\n-]).\n-\n+-export([reconnection_automatic/1, reconnection_max_attempts/1,\n+         reconnection_backoff_strategy/1, reconnection_state_preservation/1,\n+         reconnection_message_queuing/1, reconnection_failure_handling/1]).\n %% Registry integration tests\n--export([\n-    registry_auto_registration/1,\n-    registry_connection_status/1,\n-    registry_failover_coordination/1,\n-    registry_transport_discovery/1\n-]).\n-\n+-export([registry_auto_registration/1, registry_connection_status/1,\n+         registry_failover_coordination/1, registry_transport_discovery/1]).\n %% Message handling tests\n--export([\n-    message_framing_tcp/1,\n-    message_large_payloads/1,\n-    message_fragmentation/1,\n-    message_ordering/1,\n-    message_concurrent_send/1,\n-    message_backpressure/1\n-]).\n-\n+-export([message_framing_tcp/1, message_large_payloads/1, message_fragmentation/1,\n+         message_ordering/1, message_concurrent_send/1, message_backpressure/1]).\n %% Performance tests\n--export([\n-    performance_throughput/1,\n-    performance_latency/1,\n-    performance_concurrent_connections/1,\n-    performance_memory_usage/1,\n-    performance_cpu_utilization/1,\n-    performance_socket_pooling/1\n-]).\n-\n+-export([performance_throughput/1, performance_latency/1,\n+         performance_concurrent_connections/1, performance_memory_usage/1,\n+         performance_cpu_utilization/1, performance_socket_pooling/1]).\n %% Resource management tests\n--export([\n-    resource_socket_cleanup/1,\n-    resource_process_cleanup/1,\n-    resource_memory_leaks/1,\n-    resource_file_descriptor_limits/1,\n-    resource_port_exhaustion/1,\n-    resource_graceful_shutdown/1\n-]).\n+-export([resource_socket_cleanup/1, resource_process_cleanup/1, resource_memory_leaks/1,\n+         resource_file_descriptor_limits/1, resource_port_exhaustion/1,\n+         resource_graceful_shutdown/1]).\n \n %%====================================================================\n %% Suite Configuration\n %%====================================================================\n \n all() ->\n-    [\n-        {group, behavior_compliance},\n-        {group, connection_management},\n-        {group, network_error_handling},\n-        {group, reconnection_logic},\n-        {group, registry_integration},\n-        {group, message_handling},\n-        {group, performance},\n-        {group, resource_management}\n-    ].\n+    [{group, behavior_compliance},\n+     {group, connection_management},\n+     {group, network_error_handling},\n+     {group, reconnection_logic},\n+     {group, registry_integration},\n+     {group, message_handling},\n+     {group, performance},\n+     {group, resource_management}].\n \n groups() ->\n-    [\n-        {behavior_compliance, [sequential], [\n-            behavior_exports_validation,\n-            behavior_init_compliance,\n-            behavior_send_compliance,\n-            behavior_close_compliance,\n-            behavior_get_info_compliance,\n-            behavior_handle_transport_call_compliance\n-        ]},\n-        {connection_management, [sequential], [\n-            connection_establishment,\n-            connection_parameters_validation,\n-            connection_timeout_handling,\n-            connection_keepalive,\n-            connection_nodelay,\n-            connection_buffer_sizing\n-        ]},\n-        {network_error_handling, [sequential], [\n-            network_connection_refused,\n-            network_connection_timeout,\n-            network_host_unreachable,\n-            network_connection_reset,\n-            network_partial_write,\n-            network_socket_closure\n-        ]},\n-        {reconnection_logic, [sequential], [\n-            reconnection_automatic,\n-            reconnection_max_attempts,\n-            reconnection_backoff_strategy,\n-            reconnection_state_preservation,\n-            reconnection_message_queuing,\n-            reconnection_failure_handling\n-        ]},\n-        {registry_integration, [sequential], [\n-            registry_auto_registration,\n-            registry_connection_status,\n-            registry_failover_coordination,\n-            registry_transport_discovery\n-        ]},\n-        {message_handling, [parallel], [\n-            message_framing_tcp,\n-            message_large_payloads,\n-            message_fragmentation,\n-            message_ordering,\n-            message_concurrent_send,\n-            message_backpressure\n-        ]},\n-        {performance, [sequential], [\n-            performance_throughput,\n-            performance_latency,\n-            performance_concurrent_connections,\n-            performance_memory_usage,\n-            performance_cpu_utilization,\n-            performance_socket_pooling\n-        ]},\n-        {resource_management, [sequential], [\n-            resource_socket_cleanup,\n-            resource_process_cleanup,\n-            resource_memory_leaks,\n-            resource_file_descriptor_limits,\n-            resource_port_exhaustion,\n-            resource_graceful_shutdown\n-        ]}\n-    ].\n+    [{behavior_compliance,\n+      [sequential],\n+      [behavior_exports_validation,\n+       behavior_init_compliance,\n+       behavior_send_compliance,\n+       behavior_close_compliance,\n+       behavior_get_info_compliance,\n+       behavior_handle_transport_call_compliance]},\n+     {connection_management,\n+      [sequential],\n+      [connection_establishment,\n+       connection_parameters_validation,\n+       connection_timeout_handling,\n+       connection_keepalive,\n+       connection_nodelay,\n+       connection_buffer_sizing]},\n+     {network_error_handling,\n+      [sequential],\n+      [network_connection_refused,\n+       network_connection_timeout,\n+       network_host_unreachable,\n+       network_connection_reset,\n+       network_partial_write,\n+       network_socket_closure]},\n+     {reconnection_logic,\n+      [sequential],\n+      [reconnection_automatic,\n+       reconnection_max_attempts,\n+       reconnection_backoff_strategy,\n+       reconnection_state_preservation,\n+       reconnection_message_queuing,\n+       reconnection_failure_handling]},\n+     {registry_integration,\n+      [sequential],\n+      [registry_auto_registration,\n+       registry_connection_status,\n+       registry_failover_coordination,\n+       registry_transport_discovery]},\n+     {message_handling,\n+      [parallel],\n+      [message_framing_tcp,\n+       message_large_payloads,\n+       message_fragmentation,\n+       message_ordering,\n+       message_concurrent_send,\n+       message_backpressure]},\n+     {performance,\n+      [sequential],\n+      [performance_throughput,\n+       performance_latency,\n+       performance_concurrent_connections,\n+       performance_memory_usage,\n+       performance_cpu_utilization,\n+       performance_socket_pooling]},\n+     {resource_management,\n+      [sequential],\n+      [resource_socket_cleanup,\n+       resource_process_cleanup,\n+       resource_memory_leaks,\n+       resource_file_descriptor_limits,\n+       resource_port_exhaustion,\n+       resource_graceful_shutdown]}].\n \n %%====================================================================\n %% Suite Setup/Teardown\n %%====================================================================\n \n init_per_suite(Config) ->\n     ct:pal(\"Starting TCP transport standard test suite\"),\n-    \n+\n     %% Start required applications\n     ok = application:ensure_started(crypto),\n     ok = application:ensure_started(sasl),\n-    \n+\n     %% Initialize registry\n     case erlmcp_registry:start_link() of\n-        {ok, _} -> ok;\n-        {error, {already_started, _}} -> ok\n+        {ok, _} ->\n+            ok;\n+        {error, {already_started, _}} ->\n+            ok\n     end,\n-    \n+\n     %% Start test TCP server for connection tests\n     {ok, TestServer} = start_test_tcp_server(),\n     TestPort = get_test_server_port(TestServer),\n-    \n-    [{test_module, erlmcp_transport_tcp}, \n+\n+    [{test_module, erlmcp_transport_tcp},\n      {test_server, TestServer},\n      {test_port, TestPort},\n-     {test_host, \"127.0.0.1\"} | Config].\n+     {test_host, \"127.0.0.1\"}\n+     | Config].\n \n end_per_suite(Config) ->\n     TestServer = ?config(test_server, Config),\n     stop_test_tcp_server(TestServer),\n@@ -226,9 +177,11 @@\n     ok.\n \n init_per_testcase(TestCase, Config) ->\n     ct:pal(\"Starting test case: ~p\", [TestCase]),\n-    TransportId = list_to_atom(lists:flatten(io_lib:format(\"~p_~p\", [TestCase, erlang:unique_integer([positive])]))),\n+    TransportId =\n+        list_to_atom(lists:flatten(\n+                         io_lib:format(\"~p_~p\", [TestCase, erlang:unique_integer([positive])]))),\n     [{transport_id, TransportId} | Config].\n \n end_per_testcase(TestCase, Config) ->\n     ct:pal(\"Ending test case: ~p\", [TestCase]),\n@@ -240,196 +193,180 @@\n %%====================================================================\n \n behavior_exports_validation(Config) ->\n     Module = ?config(test_module, Config),\n-    \n-    RequiredExports = [\n-        {init, 1},\n-        {send, 2},\n-        {close, 1}\n-    ],\n-    \n-    OptionalExports = [\n-        {get_info, 1},\n-        {handle_transport_call, 2}\n-    ],\n-    \n+\n+    RequiredExports = [{init, 1}, {send, 2}, {close, 1}],\n+\n+    OptionalExports = [{get_info, 1}, {handle_transport_call, 2}],\n+\n     ModuleExports = Module:module_info(exports),\n-    \n+\n     lists:foreach(fun(Export) ->\n-        ?assert(lists:member(Export, ModuleExports)),\n-        ct:pal(\"Required export ~p found\", [Export])\n-    end, RequiredExports),\n-    \n+                     ?assert(lists:member(Export, ModuleExports)),\n+                     ct:pal(\"Required export ~p found\", [Export])\n+                  end,\n+                  RequiredExports),\n+\n     lists:foreach(fun(Export) ->\n-        case lists:member(Export, ModuleExports) of\n-            true -> ct:pal(\"Optional export ~p implemented\", [Export]);\n-            false -> ct:pal(\"Optional export ~p not implemented\", [Export])\n-        end\n-    end, OptionalExports),\n-    \n+                     case lists:member(Export, ModuleExports) of\n+                         true -> ct:pal(\"Optional export ~p implemented\", [Export]);\n+                         false -> ct:pal(\"Optional export ~p not implemented\", [Export])\n+                     end\n+                  end,\n+                  OptionalExports),\n+\n     ok.\n \n behavior_init_compliance(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = ?config(test_module, Config),\n     TestHost = ?config(test_host, Config),\n     TestPort = ?config(test_port, Config),\n-    \n+\n     %% Test successful initialization\n-    ValidOpts = #{\n-        host => TestHost,\n-        port => TestPort,\n-        owner => self(),\n-        transport_id => TransportId\n-    },\n-    \n+    ValidOpts =\n+        #{host => TestHost,\n+          port => TestPort,\n+          owner => self(),\n+          transport_id => TransportId},\n+\n     {ok, State} = Module:init(ValidOpts),\n     ?assert(State =/= undefined),\n     ct:pal(\"TCP init successful with valid options\"),\n-    \n+\n     %% Test initialization with optional parameters\n-    ExtendedOpts = ValidOpts#{\n-        connect_timeout => 5000,\n-        keepalive => true,\n-        nodelay => true,\n-        buffer_size => 8192\n-    },\n-    \n+    ExtendedOpts =\n+        ValidOpts#{connect_timeout => 5000,\n+                   keepalive => true,\n+                   nodelay => true,\n+                   buffer_size => 8192},\n+\n     {ok, _ExtendedState} = Module:init(ExtendedOpts),\n     ct:pal(\"TCP init successful with extended options\"),\n-    \n+\n     %% Test initialization with invalid options\n-    InvalidOpts = #{\n-        host => \"invalid.host.that.does.not.exist\",\n-        port => 99999,  % Invalid port\n-        owner => self()\n-    },\n-    \n+    InvalidOpts =\n+        #{host => \"invalid.host.that.does.not.exist\",\n+          port => 99999,  % Invalid port\n+          owner => self()},\n+\n     case Module:init(InvalidOpts) of\n         {ok, _} ->\n             ct:pal(\"Warning: TCP init accepted invalid options\");\n         {error, Reason} ->\n             ct:pal(\"TCP init properly rejected invalid options: ~p\", [Reason])\n     end,\n-    \n+\n     ok.\n \n behavior_send_compliance(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = ?config(test_module, Config),\n     TestHost = ?config(test_host, Config),\n     TestPort = ?config(test_port, Config),\n-    \n-    ValidOpts = #{\n-        host => TestHost,\n-        port => TestPort,\n-        owner => self(),\n-        transport_id => TransportId\n-    },\n-    \n+\n+    ValidOpts =\n+        #{host => TestHost,\n+          port => TestPort,\n+          owner => self(),\n+          transport_id => TransportId},\n+\n     {ok, State} = Module:init(ValidOpts),\n-    \n+\n     %% Test various data types\n-    TestData = [\n-        <<\"binary message\">>,\n-        \"string message\",\n-        [<<\"iodata \">>, <<\"message\">>],\n-        jsx:encode(#{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"method\">> => <<\"test\">>})\n-    ],\n-    \n+    TestData =\n+        [<<\"binary message\">>,\n+         \"string message\",\n+         [<<\"iodata \">>, <<\"message\">>],\n+         jsx:encode(#{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"method\">> => <<\"test\">>})],\n+\n     lists:foreach(fun(Data) ->\n-        case Module:send(State, Data) of\n-            ok ->\n-                ct:pal(\"TCP send successful for data type: ~p\", [typeof(Data)]);\n-            {error, Reason} ->\n-                ct:pal(\"TCP send failed for data type ~p: ~p\", [typeof(Data), Reason])\n-        end\n-    end, TestData),\n-    \n+                     case Module:send(State, Data) of\n+                         ok -> ct:pal(\"TCP send successful for data type: ~p\", [typeof(Data)]);\n+                         {error, Reason} ->\n+                             ct:pal(\"TCP send failed for data type ~p: ~p\", [typeof(Data), Reason])\n+                     end\n+                  end,\n+                  TestData),\n+\n     ok.\n \n behavior_close_compliance(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = ?config(test_module, Config),\n     TestHost = ?config(test_host, Config),\n     TestPort = ?config(test_port, Config),\n-    \n-    ValidOpts = #{\n-        host => TestHost,\n-        port => TestPort,\n-        owner => self(),\n-        transport_id => TransportId\n-    },\n-    \n+\n+    ValidOpts =\n+        #{host => TestHost,\n+          port => TestPort,\n+          owner => self(),\n+          transport_id => TransportId},\n+\n     {ok, State} = Module:init(ValidOpts),\n-    \n+\n     %% Test close\n     Result = Module:close(State),\n     ?assertEqual(ok, Result),\n     ct:pal(\"TCP close successful\"),\n-    \n+\n     %% Test idempotent close\n     Result2 = Module:close(State),\n     ?assertEqual(ok, Result2),\n     ct:pal(\"TCP close is idempotent\"),\n-    \n+\n     ok.\n \n behavior_get_info_compliance(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = ?config(test_module, Config),\n     TestHost = ?config(test_host, Config),\n     TestPort = ?config(test_port, Config),\n-    \n-    ValidOpts = #{\n-        host => TestHost,\n-        port => TestPort,\n-        owner => self(),\n-        transport_id => TransportId\n-    },\n-    \n+\n+    ValidOpts =\n+        #{host => TestHost,\n+          port => TestPort,\n+          owner => self(),\n+          transport_id => TransportId},\n+\n     {ok, State} = Module:init(ValidOpts),\n-    \n+\n     Info = Module:get_info(State),\n     ?assert(is_map(Info)),\n     ?assertMatch(#{type := tcp}, Info),\n     ?assert(maps:is_key(connection_state, Info)),\n-    \n+\n     ct:pal(\"TCP transport info: ~p\", [Info]),\n     ok.\n \n behavior_handle_transport_call_compliance(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = ?config(test_module, Config),\n     TestHost = ?config(test_host, Config),\n     TestPort = ?config(test_port, Config),\n-    \n-    ValidOpts = #{\n-        host => TestHost,\n-        port => TestPort,\n-        owner => self(),\n-        transport_id => TransportId\n-    },\n-    \n+\n+    ValidOpts =\n+        #{host => TestHost,\n+          port => TestPort,\n+          owner => self(),\n+          transport_id => TransportId},\n+\n     {ok, State} = Module:init(ValidOpts),\n-    \n+\n     %% Test valid transport calls\n-    ValidCalls = [\n-        get_connection_state,\n-        get_socket_info,\n-        reconnect\n-    ],\n-    \n+    ValidCalls = [get_connection_state, get_socket_info, reconnect],\n+\n     lists:foreach(fun(Call) ->\n-        case Module:handle_transport_call(Call, State) of\n-            {reply, Reply, NewState} ->\n-                ct:pal(\"TCP transport call ~p replied: ~p\", [Call, Reply]);\n-            {error, Reason} ->\n-                ct:pal(\"TCP transport call ~p failed: ~p\", [Call, Reason])\n-        end\n-    end, ValidCalls),\n-    \n+                     case Module:handle_transport_call(Call, State) of\n+                         {reply, Reply, NewState} ->\n+                             ct:pal(\"TCP transport call ~p replied: ~p\", [Call, Reply]);\n+                         {error, Reason} ->\n+                             ct:pal(\"TCP transport call ~p failed: ~p\", [Call, Reason])\n+                     end\n+                  end,\n+                  ValidCalls),\n+\n     ok.\n \n %%====================================================================\n %% Connection Management Tests\n@@ -439,22 +376,21 @@\n     TransportId = ?config(transport_id, Config),\n     Module = ?config(test_module, Config),\n     TestHost = ?config(test_host, Config),\n     TestPort = ?config(test_port, Config),\n-    \n-    ValidOpts = #{\n-        host => TestHost,\n-        port => TestPort,\n-        owner => self(),\n-        transport_id => TransportId\n-    },\n-    \n+\n+    ValidOpts =\n+        #{host => TestHost,\n+          port => TestPort,\n+          owner => self(),\n+          transport_id => TransportId},\n+\n     {ok, State} = Module:init(ValidOpts),\n-    \n+\n     %% Verify connection is established\n     Info = Module:get_info(State),\n     ConnectionState = maps:get(connection_state, Info, disconnected),\n-    \n+\n     case ConnectionState of\n         connected ->\n             ct:pal(\"TCP connection established successfully\");\n         connecting ->\n@@ -463,50 +399,64 @@\n             ct:pal(\"TCP connection not established\");\n         error ->\n             ct:pal(\"TCP connection error\")\n     end,\n-    \n+\n     ok.\n \n connection_parameters_validation(Config) ->\n     Module = ?config(test_module, Config),\n-    \n+\n     %% Test various parameter combinations\n-    TestCases = [\n-        #{host => \"127.0.0.1\", port => 8080, owner => self()},\n-        #{host => {127,0,0,1}, port => 8080, owner => self()},\n-        #{host => \"localhost\", port => 8080, owner => self()},\n-        #{host => \"127.0.0.1\", port => 8080, owner => self(), keepalive => true},\n-        #{host => \"127.0.0.1\", port => 8080, owner => self(), nodelay => true},\n-        #{host => \"127.0.0.1\", port => 8080, owner => self(), buffer_size => 4096}\n-    ],\n-    \n+    TestCases =\n+        [#{host => \"127.0.0.1\",\n+           port => 8080,\n+           owner => self()},\n+         #{host => {127, 0, 0, 1},\n+           port => 8080,\n+           owner => self()},\n+         #{host => \"localhost\",\n+           port => 8080,\n+           owner => self()},\n+         #{host => \"127.0.0.1\",\n+           port => 8080,\n+           owner => self(),\n+           keepalive => true},\n+         #{host => \"127.0.0.1\",\n+           port => 8080,\n+           owner => self(),\n+           nodelay => true},\n+         #{host => \"127.0.0.1\",\n+           port => 8080,\n+           owner => self(),\n+           buffer_size => 4096}],\n+\n     lists:foreach(fun(Opts) ->\n-        case Module:init(Opts) of\n-            {ok, _State} ->\n-                ct:pal(\"Valid TCP options accepted: ~p\", [maps:keys(Opts)]);\n-            {error, Reason} ->\n-                ct:pal(\"TCP options rejected: ~p (~p)\", [maps:keys(Opts), Reason])\n-        end\n-    end, TestCases),\n-    \n+                     case Module:init(Opts) of\n+                         {ok, _State} ->\n+                             ct:pal(\"Valid TCP options accepted: ~p\", [maps:keys(Opts)]);\n+                         {error, Reason} ->\n+                             ct:pal(\"TCP options rejected: ~p (~p)\", [maps:keys(Opts), Reason])\n+                     end\n+                  end,\n+                  TestCases),\n+\n     ok.\n \n connection_timeout_handling(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = ?config(test_module, Config),\n-    \n+\n     %% Test connection timeout to non-existent server\n-    TimeoutOpts = #{\n-        host => \"127.0.0.1\",\n-        port => 9999,  % Assume this port is closed\n-        owner => self(),\n-        transport_id => TransportId,\n-        connect_timeout => 1000  % Short timeout\n-    },\n-    \n+    TimeoutOpts =\n+        #{host => \"127.0.0.1\",\n+          port => 9999,  % Assume this port is closed\n+          owner => self(),\n+          transport_id => TransportId,\n+          connect_timeout => 1000},  % Short timeout\n+\n     StartTime = erlang:monotonic_time(millisecond),\n-    \n+\n     case Module:init(TimeoutOpts) of\n         {ok, State} ->\n             ct:pal(\"Connection succeeded unexpectedly\"),\n             Module:close(State);\n@@ -518,9 +468,9 @@\n             ?assert(Duration < 2000);  % Should not take much longer\n         {error, Reason} ->\n             ct:pal(\"Connection failed with reason: ~p\", [Reason])\n     end,\n-    \n+\n     ok.\n \n connection_keepalive(Config) ->\n     ct:pal(\"TCP keepalive test - implementation depends on OS socket options\"),\n@@ -530,9 +480,10 @@\n     ct:pal(\"TCP nodelay test - implementation depends on OS socket options\"),\n     ok.\n \n connection_buffer_sizing(Config) ->\n-    ct:pal(\"TCP buffer sizing test - implementation depends on OS socket options\"),\n+    ct:pal(\"TCP buffer sizing test - implementation depends on OS socket \"\n+           \"options\"),\n     ok.\n \n %%====================================================================\n %% Network Error Handling Tests\n@@ -540,17 +491,16 @@\n \n network_connection_refused(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = ?config(test_module, Config),\n-    \n+\n     %% Try to connect to a port that should be closed\n-    RefusedOpts = #{\n-        host => \"127.0.0.1\",\n-        port => 9998,  % Assume this port is closed\n-        owner => self(),\n-        transport_id => TransportId\n-    },\n-    \n+    RefusedOpts =\n+        #{host => \"127.0.0.1\",\n+          port => 9998,  % Assume this port is closed\n+          owner => self(),\n+          transport_id => TransportId},\n+\n     case Module:init(RefusedOpts) of\n         {ok, State} ->\n             ct:pal(\"Connection succeeded unexpectedly\"),\n             Module:close(State);\n@@ -558,9 +508,9 @@\n             ct:pal(\"Connection properly refused\");\n         {error, Reason} ->\n             ct:pal(\"Connection failed with reason: ~p\", [Reason])\n     end,\n-    \n+\n     ok.\n \n network_connection_timeout(Config) ->\n     ct:pal(\"Network connection timeout test\"),\n@@ -618,27 +568,27 @@\n     TransportId = ?config(transport_id, Config),\n     Module = ?config(test_module, Config),\n     TestHost = ?config(test_host, Config),\n     TestPort = ?config(test_port, Config),\n-    \n+\n     %% Start transport and verify auto-registration\n-    {ok, Pid} = Module:start_link(TransportId, #{\n-        host => TestHost,\n-        port => TestPort,\n-        owner => self()\n-    }),\n-    \n+    {ok, Pid} =\n+        Module:start_link(TransportId,\n+                          #{host => TestHost,\n+                            port => TestPort,\n+                            owner => self()}),\n+\n     timer:sleep(100), % Allow registration to complete\n-    \n+\n     case erlmcp_registry:find_transport(TransportId) of\n         {ok, {RegPid, RegConfig}} ->\n             ?assertEqual(Pid, RegPid),\n             ?assert(is_map(RegConfig)),\n             ct:pal(\"TCP transport auto-registered successfully\");\n         {error, not_found} ->\n             ct:pal(\"Warning: TCP transport not auto-registered\")\n     end,\n-    \n+\n     ok = gen_server:stop(Pid),\n     ok.\n \n registry_connection_status(Config) ->\n@@ -744,20 +694,24 @@\n cleanup_test_resources(_Config) ->\n     %% Cleanup any test resources\n     timer:sleep(50).\n \n-typeof(Term) when is_binary(Term) -> binary;\n-typeof(Term) when is_list(Term) -> list;\n-typeof(Term) when is_atom(Term) -> atom;\n-typeof(_) -> unknown.\n+typeof(Term) when is_binary(Term) ->\n+    binary;\n+typeof(Term) when is_list(Term) ->\n+    list;\n+typeof(Term) when is_atom(Term) ->\n+    atom;\n+typeof(_) ->\n+    unknown.\n \n %% Test TCP server functions\n start_test_tcp_server() ->\n     {ok, ListenSocket} = gen_tcp:listen(0, [binary, {active, false}, {reuseaddr, true}]),\n     {ok, Port} = inet:port(ListenSocket),\n-    \n+\n     ServerPid = spawn(fun() -> test_tcp_server_loop(ListenSocket) end),\n-    \n+\n     {ok, {ServerPid, Port}}.\n \n get_test_server_port({_Pid, Port}) ->\n     Port.\n@@ -784,5 +738,5 @@\n             gen_tcp:close(Socket);\n         {error, Reason} ->\n             ct:pal(\"Test TCP server error: ~p\", [Reason]),\n             gen_tcp:close(Socket)\n-    end.\n\\ No newline at end of file\n+    end.\n"
                }
            ],
            "date": 1756185314750,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @doc\n%%% Standard Test Suite for TCP Transport Implementation\n%%%\n%%% This comprehensive test suite validates the TCP transport against\n%%% standardized behavior requirements, connection management, and\n%%% network resilience specifications.\n%%%\n%%% Test Categories:\n%%% - Behavior compliance\n%%% - Connection management\n%%% - Network error handling\n%%% - Reconnection logic\n%%% - Performance requirements\n%%% - Resource management\n%%%-------------------------------------------------------------------\n-module(erlmcp_transport_tcp_standard_SUITE).\n\n-include_lib(\"common_test/include/ct.hrl\").\n-include_lib(\"eunit/include/eunit.hrl\").\n-include(\"erlmcp.hrl\").\n\n%% Suite callbacks\n-export([all/0, groups/0, init_per_suite/1, end_per_suite/1,\n         init_per_group/2, end_per_group/2,\n         init_per_testcase/2, end_per_testcase/2]).\n\n%% Behavior compliance tests\n-export([\n    behavior_init_compliance/1,\n    behavior_send_compliance/1,\n    behavior_close_compliance/1,\n    behavior_get_info_compliance/1,\n    behavior_handle_transport_call_compliance/1,\n    behavior_exports_validation/1\n]).\n\n%% Connection management tests\n-export([\n    connection_establishment/1,\n    connection_parameters_validation/1,\n    connection_timeout_handling/1,\n    connection_keepalive/1,\n    connection_nodelay/1,\n    connection_buffer_sizing/1\n]).\n\n%% Network error handling tests\n-export([\n    network_connection_refused/1,\n    network_connection_timeout/1,\n    network_host_unreachable/1,\n    network_connection_reset/1,\n    network_partial_write/1,\n    network_socket_closure/1\n]).\n\n%% Reconnection logic tests\n-export([\n    reconnection_automatic/1,\n    reconnection_max_attempts/1,\n    reconnection_backoff_strategy/1,\n    reconnection_state_preservation/1,\n    reconnection_message_queuing/1,\n    reconnection_failure_handling/1\n]).\n\n%% Registry integration tests\n-export([\n    registry_auto_registration/1,\n    registry_connection_status/1,\n    registry_failover_coordination/1,\n    registry_transport_discovery/1\n]).\n\n%% Message handling tests\n-export([\n    message_framing_tcp/1,\n    message_large_payloads/1,\n    message_fragmentation/1,\n    message_ordering/1,\n    message_concurrent_send/1,\n    message_backpressure/1\n]).\n\n%% Performance tests\n-export([\n    performance_throughput/1,\n    performance_latency/1,\n    performance_concurrent_connections/1,\n    performance_memory_usage/1,\n    performance_cpu_utilization/1,\n    performance_socket_pooling/1\n]).\n\n%% Resource management tests\n-export([\n    resource_socket_cleanup/1,\n    resource_process_cleanup/1,\n    resource_memory_leaks/1,\n    resource_file_descriptor_limits/1,\n    resource_port_exhaustion/1,\n    resource_graceful_shutdown/1\n]).\n\n%%====================================================================\n%% Suite Configuration\n%%====================================================================\n\nall() ->\n    [\n        {group, behavior_compliance},\n        {group, connection_management},\n        {group, network_error_handling},\n        {group, reconnection_logic},\n        {group, registry_integration},\n        {group, message_handling},\n        {group, performance},\n        {group, resource_management}\n    ].\n\ngroups() ->\n    [\n        {behavior_compliance, [sequential], [\n            behavior_exports_validation,\n            behavior_init_compliance,\n            behavior_send_compliance,\n            behavior_close_compliance,\n            behavior_get_info_compliance,\n            behavior_handle_transport_call_compliance\n        ]},\n        {connection_management, [sequential], [\n            connection_establishment,\n            connection_parameters_validation,\n            connection_timeout_handling,\n            connection_keepalive,\n            connection_nodelay,\n            connection_buffer_sizing\n        ]},\n        {network_error_handling, [sequential], [\n            network_connection_refused,\n            network_connection_timeout,\n            network_host_unreachable,\n            network_connection_reset,\n            network_partial_write,\n            network_socket_closure\n        ]},\n        {reconnection_logic, [sequential], [\n            reconnection_automatic,\n            reconnection_max_attempts,\n            reconnection_backoff_strategy,\n            reconnection_state_preservation,\n            reconnection_message_queuing,\n            reconnection_failure_handling\n        ]},\n        {registry_integration, [sequential], [\n            registry_auto_registration,\n            registry_connection_status,\n            registry_failover_coordination,\n            registry_transport_discovery\n        ]},\n        {message_handling, [parallel], [\n            message_framing_tcp,\n            message_large_payloads,\n            message_fragmentation,\n            message_ordering,\n            message_concurrent_send,\n            message_backpressure\n        ]},\n        {performance, [sequential], [\n            performance_throughput,\n            performance_latency,\n            performance_concurrent_connections,\n            performance_memory_usage,\n            performance_cpu_utilization,\n            performance_socket_pooling\n        ]},\n        {resource_management, [sequential], [\n            resource_socket_cleanup,\n            resource_process_cleanup,\n            resource_memory_leaks,\n            resource_file_descriptor_limits,\n            resource_port_exhaustion,\n            resource_graceful_shutdown\n        ]}\n    ].\n\n%%====================================================================\n%% Suite Setup/Teardown\n%%====================================================================\n\ninit_per_suite(Config) ->\n    ct:pal(\"Starting TCP transport standard test suite\"),\n    \n    %% Start required applications\n    ok = application:ensure_started(crypto),\n    ok = application:ensure_started(sasl),\n    \n    %% Initialize registry\n    case erlmcp_registry:start_link() of\n        {ok, _} -> ok;\n        {error, {already_started, _}} -> ok\n    end,\n    \n    %% Start test TCP server for connection tests\n    {ok, TestServer} = start_test_tcp_server(),\n    TestPort = get_test_server_port(TestServer),\n    \n    [{test_module, erlmcp_transport_tcp}, \n     {test_server, TestServer},\n     {test_port, TestPort},\n     {test_host, \"127.0.0.1\"} | Config].\n\nend_per_suite(Config) ->\n    TestServer = ?config(test_server, Config),\n    stop_test_tcp_server(TestServer),\n    ct:pal(\"Ending TCP transport standard test suite\"),\n    ok.\n\ninit_per_group(GroupName, Config) ->\n    ct:pal(\"Starting group: ~p\", [GroupName]),\n    Config.\n\nend_per_group(GroupName, _Config) ->\n    ct:pal(\"Ending group: ~p\", [GroupName]),\n    ok.\n\ninit_per_testcase(TestCase, Config) ->\n    ct:pal(\"Starting test case: ~p\", [TestCase]),\n    TransportId = list_to_atom(lists:flatten(io_lib:format(\"~p_~p\", [TestCase, erlang:unique_integer([positive])]))),\n    [{transport_id, TransportId} | Config].\n\nend_per_testcase(TestCase, Config) ->\n    ct:pal(\"Ending test case: ~p\", [TestCase]),\n    cleanup_test_resources(Config),\n    ok.\n\n%%====================================================================\n%% Behavior Compliance Tests\n%%====================================================================\n\nbehavior_exports_validation(Config) ->\n    Module = ?config(test_module, Config),\n    \n    RequiredExports = [\n        {init, 1},\n        {send, 2},\n        {close, 1}\n    ],\n    \n    OptionalExports = [\n        {get_info, 1},\n        {handle_transport_call, 2}\n    ],\n    \n    ModuleExports = Module:module_info(exports),\n    \n    lists:foreach(fun(Export) ->\n        ?assert(lists:member(Export, ModuleExports)),\n        ct:pal(\"Required export ~p found\", [Export])\n    end, RequiredExports),\n    \n    lists:foreach(fun(Export) ->\n        case lists:member(Export, ModuleExports) of\n            true -> ct:pal(\"Optional export ~p implemented\", [Export]);\n            false -> ct:pal(\"Optional export ~p not implemented\", [Export])\n        end\n    end, OptionalExports),\n    \n    ok.\n\nbehavior_init_compliance(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = ?config(test_module, Config),\n    TestHost = ?config(test_host, Config),\n    TestPort = ?config(test_port, Config),\n    \n    %% Test successful initialization\n    ValidOpts = #{\n        host => TestHost,\n        port => TestPort,\n        owner => self(),\n        transport_id => TransportId\n    },\n    \n    {ok, State} = Module:init(ValidOpts),\n    ?assert(State =/= undefined),\n    ct:pal(\"TCP init successful with valid options\"),\n    \n    %% Test initialization with optional parameters\n    ExtendedOpts = ValidOpts#{\n        connect_timeout => 5000,\n        keepalive => true,\n        nodelay => true,\n        buffer_size => 8192\n    },\n    \n    {ok, _ExtendedState} = Module:init(ExtendedOpts),\n    ct:pal(\"TCP init successful with extended options\"),\n    \n    %% Test initialization with invalid options\n    InvalidOpts = #{\n        host => \"invalid.host.that.does.not.exist\",\n        port => 99999,  % Invalid port\n        owner => self()\n    },\n    \n    case Module:init(InvalidOpts) of\n        {ok, _} ->\n            ct:pal(\"Warning: TCP init accepted invalid options\");\n        {error, Reason} ->\n            ct:pal(\"TCP init properly rejected invalid options: ~p\", [Reason])\n    end,\n    \n    ok.\n\nbehavior_send_compliance(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = ?config(test_module, Config),\n    TestHost = ?config(test_host, Config),\n    TestPort = ?config(test_port, Config),\n    \n    ValidOpts = #{\n        host => TestHost,\n        port => TestPort,\n        owner => self(),\n        transport_id => TransportId\n    },\n    \n    {ok, State} = Module:init(ValidOpts),\n    \n    %% Test various data types\n    TestData = [\n        <<\"binary message\">>,\n        \"string message\",\n        [<<\"iodata \">>, <<\"message\">>],\n        jsx:encode(#{<<\"jsonrpc\">> => <<\"2.0\">>, <<\"method\">> => <<\"test\">>})\n    ],\n    \n    lists:foreach(fun(Data) ->\n        case Module:send(State, Data) of\n            ok ->\n                ct:pal(\"TCP send successful for data type: ~p\", [typeof(Data)]);\n            {error, Reason} ->\n                ct:pal(\"TCP send failed for data type ~p: ~p\", [typeof(Data), Reason])\n        end\n    end, TestData),\n    \n    ok.\n\nbehavior_close_compliance(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = ?config(test_module, Config),\n    TestHost = ?config(test_host, Config),\n    TestPort = ?config(test_port, Config),\n    \n    ValidOpts = #{\n        host => TestHost,\n        port => TestPort,\n        owner => self(),\n        transport_id => TransportId\n    },\n    \n    {ok, State} = Module:init(ValidOpts),\n    \n    %% Test close\n    Result = Module:close(State),\n    ?assertEqual(ok, Result),\n    ct:pal(\"TCP close successful\"),\n    \n    %% Test idempotent close\n    Result2 = Module:close(State),\n    ?assertEqual(ok, Result2),\n    ct:pal(\"TCP close is idempotent\"),\n    \n    ok.\n\nbehavior_get_info_compliance(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = ?config(test_module, Config),\n    TestHost = ?config(test_host, Config),\n    TestPort = ?config(test_port, Config),\n    \n    ValidOpts = #{\n        host => TestHost,\n        port => TestPort,\n        owner => self(),\n        transport_id => TransportId\n    },\n    \n    {ok, State} = Module:init(ValidOpts),\n    \n    Info = Module:get_info(State),\n    ?assert(is_map(Info)),\n    ?assertMatch(#{type := tcp}, Info),\n    ?assert(maps:is_key(connection_state, Info)),\n    \n    ct:pal(\"TCP transport info: ~p\", [Info]),\n    ok.\n\nbehavior_handle_transport_call_compliance(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = ?config(test_module, Config),\n    TestHost = ?config(test_host, Config),\n    TestPort = ?config(test_port, Config),\n    \n    ValidOpts = #{\n        host => TestHost,\n        port => TestPort,\n        owner => self(),\n        transport_id => TransportId\n    },\n    \n    {ok, State} = Module:init(ValidOpts),\n    \n    %% Test valid transport calls\n    ValidCalls = [\n        get_connection_state,\n        get_socket_info,\n        reconnect\n    ],\n    \n    lists:foreach(fun(Call) ->\n        case Module:handle_transport_call(Call, State) of\n            {reply, Reply, NewState} ->\n                ct:pal(\"TCP transport call ~p replied: ~p\", [Call, Reply]);\n            {error, Reason} ->\n                ct:pal(\"TCP transport call ~p failed: ~p\", [Call, Reason])\n        end\n    end, ValidCalls),\n    \n    ok.\n\n%%====================================================================\n%% Connection Management Tests\n%%====================================================================\n\nconnection_establishment(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = ?config(test_module, Config),\n    TestHost = ?config(test_host, Config),\n    TestPort = ?config(test_port, Config),\n    \n    ValidOpts = #{\n        host => TestHost,\n        port => TestPort,\n        owner => self(),\n        transport_id => TransportId\n    },\n    \n    {ok, State} = Module:init(ValidOpts),\n    \n    %% Verify connection is established\n    Info = Module:get_info(State),\n    ConnectionState = maps:get(connection_state, Info, disconnected),\n    \n    case ConnectionState of\n        connected ->\n            ct:pal(\"TCP connection established successfully\");\n        connecting ->\n            ct:pal(\"TCP connection in progress\");\n        disconnected ->\n            ct:pal(\"TCP connection not established\");\n        error ->\n            ct:pal(\"TCP connection error\")\n    end,\n    \n    ok.\n\nconnection_parameters_validation(Config) ->\n    Module = ?config(test_module, Config),\n    \n    %% Test various parameter combinations\n    TestCases = [\n        #{host => \"127.0.0.1\", port => 8080, owner => self()},\n        #{host => {127,0,0,1}, port => 8080, owner => self()},\n        #{host => \"localhost\", port => 8080, owner => self()},\n        #{host => \"127.0.0.1\", port => 8080, owner => self(), keepalive => true},\n        #{host => \"127.0.0.1\", port => 8080, owner => self(), nodelay => true},\n        #{host => \"127.0.0.1\", port => 8080, owner => self(), buffer_size => 4096}\n    ],\n    \n    lists:foreach(fun(Opts) ->\n        case Module:init(Opts) of\n            {ok, _State} ->\n                ct:pal(\"Valid TCP options accepted: ~p\", [maps:keys(Opts)]);\n            {error, Reason} ->\n                ct:pal(\"TCP options rejected: ~p (~p)\", [maps:keys(Opts), Reason])\n        end\n    end, TestCases),\n    \n    ok.\n\nconnection_timeout_handling(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = ?config(test_module, Config),\n    \n    %% Test connection timeout to non-existent server\n    TimeoutOpts = #{\n        host => \"127.0.0.1\",\n        port => 9999,  % Assume this port is closed\n        owner => self(),\n        transport_id => TransportId,\n        connect_timeout => 1000  % Short timeout\n    },\n    \n    StartTime = erlang:monotonic_time(millisecond),\n    \n    case Module:init(TimeoutOpts) of\n        {ok, State} ->\n            ct:pal(\"Connection succeeded unexpectedly\"),\n            Module:close(State);\n        {error, timeout} ->\n            EndTime = erlang:monotonic_time(millisecond),\n            Duration = EndTime - StartTime,\n            ct:pal(\"Connection timeout after ~p ms\", [Duration]),\n            ?assert(Duration >= 1000), % Should respect timeout\n            ?assert(Duration < 2000);  % Should not take much longer\n        {error, Reason} ->\n            ct:pal(\"Connection failed with reason: ~p\", [Reason])\n    end,\n    \n    ok.\n\nconnection_keepalive(Config) ->\n    ct:pal(\"TCP keepalive test - implementation depends on OS socket options\"),\n    ok.\n\nconnection_nodelay(Config) ->\n    ct:pal(\"TCP nodelay test - implementation depends on OS socket options\"),\n    ok.\n\nconnection_buffer_sizing(Config) ->\n    ct:pal(\"TCP buffer sizing test - implementation depends on OS socket options\"),\n    ok.\n\n%%====================================================================\n%% Network Error Handling Tests\n%%====================================================================\n\nnetwork_connection_refused(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = ?config(test_module, Config),\n    \n    %% Try to connect to a port that should be closed\n    RefusedOpts = #{\n        host => \"127.0.0.1\",\n        port => 9998,  % Assume this port is closed\n        owner => self(),\n        transport_id => TransportId\n    },\n    \n    case Module:init(RefusedOpts) of\n        {ok, State} ->\n            ct:pal(\"Connection succeeded unexpectedly\"),\n            Module:close(State);\n        {error, econnrefused} ->\n            ct:pal(\"Connection properly refused\");\n        {error, Reason} ->\n            ct:pal(\"Connection failed with reason: ~p\", [Reason])\n    end,\n    \n    ok.\n\nnetwork_connection_timeout(Config) ->\n    ct:pal(\"Network connection timeout test\"),\n    ok.\n\nnetwork_host_unreachable(Config) ->\n    ct:pal(\"Network host unreachable test\"),\n    ok.\n\nnetwork_connection_reset(Config) ->\n    ct:pal(\"Network connection reset test\"),\n    ok.\n\nnetwork_partial_write(Config) ->\n    ct:pal(\"Network partial write test\"),\n    ok.\n\nnetwork_socket_closure(Config) ->\n    ct:pal(\"Network socket closure test\"),\n    ok.\n\n%%====================================================================\n%% Reconnection Logic Tests\n%%====================================================================\n\nreconnection_automatic(Config) ->\n    ct:pal(\"Automatic reconnection test\"),\n    ok.\n\nreconnection_max_attempts(Config) ->\n    ct:pal(\"Max reconnection attempts test\"),\n    ok.\n\nreconnection_backoff_strategy(Config) ->\n    ct:pal(\"Reconnection backoff strategy test\"),\n    ok.\n\nreconnection_state_preservation(Config) ->\n    ct:pal(\"Reconnection state preservation test\"),\n    ok.\n\nreconnection_message_queuing(Config) ->\n    ct:pal(\"Reconnection message queuing test\"),\n    ok.\n\nreconnection_failure_handling(Config) ->\n    ct:pal(\"Reconnection failure handling test\"),\n    ok.\n\n%%====================================================================\n%% Registry Integration Tests\n%%====================================================================\n\nregistry_auto_registration(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = ?config(test_module, Config),\n    TestHost = ?config(test_host, Config),\n    TestPort = ?config(test_port, Config),\n    \n    %% Start transport and verify auto-registration\n    {ok, Pid} = Module:start_link(TransportId, #{\n        host => TestHost,\n        port => TestPort,\n        owner => self()\n    }),\n    \n    timer:sleep(100), % Allow registration to complete\n    \n    case erlmcp_registry:find_transport(TransportId) of\n        {ok, {RegPid, RegConfig}} ->\n            ?assertEqual(Pid, RegPid),\n            ?assert(is_map(RegConfig)),\n            ct:pal(\"TCP transport auto-registered successfully\");\n        {error, not_found} ->\n            ct:pal(\"Warning: TCP transport not auto-registered\")\n    end,\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nregistry_connection_status(Config) ->\n    ct:pal(\"Registry connection status test\"),\n    ok.\n\nregistry_failover_coordination(Config) ->\n    ct:pal(\"Registry failover coordination test\"),\n    ok.\n\nregistry_transport_discovery(Config) ->\n    ct:pal(\"Registry transport discovery test\"),\n    ok.\n\n%%====================================================================\n%% Message Handling Tests\n%%====================================================================\n\nmessage_framing_tcp(Config) ->\n    ct:pal(\"TCP message framing test\"),\n    ok.\n\nmessage_large_payloads(Config) ->\n    ct:pal(\"Large payload handling test\"),\n    ok.\n\nmessage_fragmentation(Config) ->\n    ct:pal(\"Message fragmentation test\"),\n    ok.\n\nmessage_ordering(Config) ->\n    ct:pal(\"Message ordering test\"),\n    ok.\n\nmessage_concurrent_send(Config) ->\n    ct:pal(\"Concurrent message send test\"),\n    ok.\n\nmessage_backpressure(Config) ->\n    ct:pal(\"Message backpressure test\"),\n    ok.\n\n%%====================================================================\n%% Performance Tests\n%%====================================================================\n\nperformance_throughput(Config) ->\n    ct:pal(\"TCP throughput performance test\"),\n    ok.\n\nperformance_latency(Config) ->\n    ct:pal(\"TCP latency performance test\"),\n    ok.\n\nperformance_concurrent_connections(Config) ->\n    ct:pal(\"Concurrent connections performance test\"),\n    ok.\n\nperformance_memory_usage(Config) ->\n    ct:pal(\"Memory usage performance test\"),\n    ok.\n\nperformance_cpu_utilization(Config) ->\n    ct:pal(\"CPU utilization performance test\"),\n    ok.\n\nperformance_socket_pooling(Config) ->\n    ct:pal(\"Socket pooling performance test\"),\n    ok.\n\n%%====================================================================\n%% Resource Management Tests\n%%====================================================================\n\nresource_socket_cleanup(Config) ->\n    ct:pal(\"Socket cleanup test\"),\n    ok.\n\nresource_process_cleanup(Config) ->\n    ct:pal(\"Process cleanup test\"),\n    ok.\n\nresource_memory_leaks(Config) ->\n    ct:pal(\"Memory leak detection test\"),\n    ok.\n\nresource_file_descriptor_limits(Config) ->\n    ct:pal(\"File descriptor limits test\"),\n    ok.\n\nresource_port_exhaustion(Config) ->\n    ct:pal(\"Port exhaustion test\"),\n    ok.\n\nresource_graceful_shutdown(Config) ->\n    ct:pal(\"Graceful shutdown test\"),\n    ok.\n\n%%====================================================================\n%% Helper Functions\n%%====================================================================\n\ncleanup_test_resources(_Config) ->\n    %% Cleanup any test resources\n    timer:sleep(50).\n\ntypeof(Term) when is_binary(Term) -> binary;\ntypeof(Term) when is_list(Term) -> list;\ntypeof(Term) when is_atom(Term) -> atom;\ntypeof(_) -> unknown.\n\n%% Test TCP server functions\nstart_test_tcp_server() ->\n    {ok, ListenSocket} = gen_tcp:listen(0, [binary, {active, false}, {reuseaddr, true}]),\n    {ok, Port} = inet:port(ListenSocket),\n    \n    ServerPid = spawn(fun() -> test_tcp_server_loop(ListenSocket) end),\n    \n    {ok, {ServerPid, Port}}.\n\nget_test_server_port({_Pid, Port}) ->\n    Port.\n\nstop_test_tcp_server({ServerPid, _Port}) ->\n    exit(ServerPid, normal).\n\ntest_tcp_server_loop(ListenSocket) ->\n    case gen_tcp:accept(ListenSocket) of\n        {ok, Socket} ->\n            spawn(fun() -> test_tcp_client_handler(Socket) end),\n            test_tcp_server_loop(ListenSocket);\n        {error, closed} ->\n            ok\n    end.\n\ntest_tcp_client_handler(Socket) ->\n    case gen_tcp:recv(Socket, 0) of\n        {ok, Data} ->\n            ct:pal(\"Test TCP server received: ~p\", [Data]),\n            gen_tcp:send(Socket, <<\"OK\">>),\n            test_tcp_client_handler(Socket);\n        {error, closed} ->\n            gen_tcp:close(Socket);\n        {error, Reason} ->\n            ct:pal(\"Test TCP server error: ~p\", [Reason]),\n            gen_tcp:close(Socket)\n    end."
        }
    ]
}