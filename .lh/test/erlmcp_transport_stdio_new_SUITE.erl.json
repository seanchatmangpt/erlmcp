{
    "sourceFile": "test/erlmcp_transport_stdio_new_SUITE.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1756185314751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1756185314751,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @doc\n%%% Common Test suite for erlmcp_transport_stdio_new module\n%%%\n%%% This comprehensive test suite covers all aspects of the stdio transport\n%%% including behavior compliance, registry integration, error handling,\n%%% and performance characteristics.\n%%%-------------------------------------------------------------------\n-module(erlmcp_transport_stdio_new_SUITE).\n\n-include_lib(\"common_test/include/ct.hrl\").\n-include_lib(\"eunit/include/eunit.hrl\").\n-include(\"erlmcp.hrl\").\n\n%% Suite callbacks\n-export([all/0, groups/0, init_per_suite/1, end_per_suite/1,\n         init_per_group/2, end_per_group/2,\n         init_per_testcase/2, end_per_testcase/2]).\n\n%% Test cases\n-export([\n    % Basic functionality\n    basic_startup_test/1,\n    basic_send_test/1,\n    basic_close_test/1,\n    get_state_test/1,\n    \n    % Transport behavior tests\n    transport_behavior_send/1,\n    transport_behavior_close/1,\n    transport_behavior_get_info/1,\n    transport_behavior_handle_transport_call/1,\n    \n    % Registry integration\n    registry_registration/1,\n    registry_unregistration/1,\n    registry_message_routing/1,\n    registry_response_handling/1,\n    \n    % Configuration and startup\n    config_validation/1,\n    config_defaults/1,\n    test_mode_startup/1,\n    server_binding/1,\n    \n    % Error handling\n    error_handling_no_server/1,\n    error_handling_routing_failure/1,\n    error_handling_reader_crash/1,\n    error_handling_invalid_messages/1,\n    \n    % Message processing\n    message_parsing/1,\n    message_buffering/1,\n    line_trimming/1,\n    empty_line_handling/1,\n    \n    % Process lifecycle\n    supervisor_integration/1,\n    graceful_shutdown/1,\n    abnormal_termination/1,\n    \n    % Performance tests\n    high_volume_messages/1,\n    memory_usage/1,\n    latency_measurement/1,\n    \n    % Integration tests\n    end_to_end_communication/1,\n    concurrent_operations/1,\n    stress_test/1\n]).\n\n%%====================================================================\n%% Suite Configuration\n%%====================================================================\n\nall() ->\n    [\n        {group, basic_functionality},\n        {group, transport_behavior},\n        {group, registry_integration},\n        {group, configuration},\n        {group, error_handling},\n        {group, message_processing},\n        {group, lifecycle},\n        {group, performance},\n        {group, integration}\n    ].\n\ngroups() ->\n    [\n        {basic_functionality, [parallel], [\n            basic_startup_test,\n            basic_send_test,\n            basic_close_test,\n            get_state_test\n        ]},\n        {transport_behavior, [sequential], [\n            transport_behavior_send,\n            transport_behavior_close,\n            transport_behavior_get_info,\n            transport_behavior_handle_transport_call\n        ]},\n        {registry_integration, [sequential], [\n            registry_registration,\n            registry_unregistration,\n            registry_message_routing,\n            registry_response_handling\n        ]},\n        {configuration, [parallel], [\n            config_validation,\n            config_defaults,\n            test_mode_startup,\n            server_binding\n        ]},\n        {error_handling, [sequential], [\n            error_handling_no_server,\n            error_handling_routing_failure,\n            error_handling_reader_crash,\n            error_handling_invalid_messages\n        ]},\n        {message_processing, [parallel], [\n            message_parsing,\n            message_buffering,\n            line_trimming,\n            empty_line_handling\n        ]},\n        {lifecycle, [sequential], [\n            supervisor_integration,\n            graceful_shutdown,\n            abnormal_termination\n        ]},\n        {performance, [sequential], [\n            high_volume_messages,\n            memory_usage,\n            latency_measurement\n        ]},\n        {integration, [sequential], [\n            end_to_end_communication,\n            concurrent_operations,\n            stress_test\n        ]}\n    ].\n\n%%====================================================================\n%% Suite Setup/Teardown\n%%====================================================================\n\ninit_per_suite(Config) ->\n    ct:pal(\"Starting stdio transport test suite\"),\n    \n    % Start necessary applications\n    ok = application:ensure_started(crypto),\n    ok = application:ensure_started(sasl),\n    \n    % Start registry for integration tests\n    case erlmcp_registry:start_link() of\n        {ok, _} -> ok;\n        {error, {already_started, _}} -> ok\n    end,\n    \n    % Enable test mode\n    put(test_mode, true),\n    \n    [{test_mode, true} | Config].\n\nend_per_suite(_Config) ->\n    ct:pal(\"Ending stdio transport test suite\"),\n    ok.\n\ninit_per_group(GroupName, Config) ->\n    ct:pal(\"Starting group: ~p\", [GroupName]),\n    Config.\n\nend_per_group(GroupName, _Config) ->\n    ct:pal(\"Ending group: ~p\", [GroupName]),\n    ok.\n\ninit_per_testcase(TestCase, Config) ->\n    ct:pal(\"Starting test case: ~p\", [TestCase]),\n    Config.\n\nend_per_testcase(TestCase, _Config) ->\n    ct:pal(\"Ending test case: ~p\", [TestCase]),\n    % Cleanup any processes started during test\n    cleanup_processes(),\n    ok.\n\n%%====================================================================\n%% Test Cases - Basic Functionality\n%%====================================================================\n\nbasic_startup_test(Config) ->\n    TransportId = test_transport_basic,\n    TestConfig = #{test_mode => true},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    ?assert(is_pid(Pid)),\n    ?assert(is_process_alive(Pid)),\n    \n    % Verify state\n    {ok, State} = gen_server:call(Pid, get_state),\n    ?assertEqual(TransportId, maps:get(transport_id, State)),\n    ?assertEqual(true, maps:get(test_mode, State)),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nbasic_send_test(Config) ->\n    TransportId = test_transport_send,\n    TestConfig = #{test_mode => true},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    {ok, State} = gen_server:call(Pid, get_state),\n    \n    % Test sending in test mode (should succeed without actual I/O)\n    ?assertEqual(ok, erlmcp_transport_stdio_new:send(State, <<\"test message\">>)),\n    ?assertEqual(ok, erlmcp_transport_stdio_new:send(State, \"test string\")),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nbasic_close_test(Config) ->\n    TransportId = test_transport_close,\n    TestConfig = #{test_mode => true},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    {ok, State} = gen_server:call(Pid, get_state),\n    \n    % Test close operation\n    ?assertEqual(ok, erlmcp_transport_stdio_new:close(State)),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nget_state_test(Config) ->\n    TransportId = test_transport_state,\n    TestConfig = #{test_mode => true, server_id => test_server},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    {ok, State} = gen_server:call(Pid, get_state),\n    \n    ?assertMatch(#{transport_id := TransportId}, State),\n    ?assertMatch(#{test_mode := true}, State),\n    ?assertMatch(#{server_id := test_server}, State),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Test Cases - Transport Behavior\n%%====================================================================\n\ntransport_behavior_send(Config) ->\n    TransportId = test_transport_behavior_send,\n    TestConfig = #{test_mode => true},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    {ok, State} = gen_server:call(Pid, get_state),\n    \n    % Test different data types\n    TestCases = [\n        <<\"binary data\">>,\n        \"string data\",\n        [<<\"list\">>, \" \", <<\"of\">>, \" \", <<\"iodata\">>]\n    ],\n    \n    lists:foreach(fun(Data) ->\n        ?assertEqual(ok, erlmcp_transport_stdio_new:send(State, Data))\n    end, TestCases),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\ntransport_behavior_close(Config) ->\n    TransportId = test_transport_behavior_close,\n    \n    % Test with reader\n    TestConfig1 = #{test_mode => false},\n    {ok, Pid1} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig1),\n    {ok, State1} = gen_server:call(Pid1, get_state),\n    \n    ?assertEqual(ok, erlmcp_transport_stdio_new:close(State1)),\n    ok = gen_server:stop(Pid1),\n    \n    % Test without reader (test mode)\n    TestConfig2 = #{test_mode => true},\n    {ok, Pid2} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig2),\n    {ok, State2} = gen_server:call(Pid2, get_state),\n    \n    ?assertEqual(ok, erlmcp_transport_stdio_new:close(State2)),\n    ok = gen_server:stop(Pid2),\n    ok.\n\ntransport_behavior_get_info(Config) ->\n    TransportId = test_transport_behavior_info,\n    TestConfig = #{test_mode => true},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    {ok, State} = gen_server:call(Pid, get_state),\n    \n    Info = erlmcp_transport_stdio_new:get_info(State),\n    \n    ?assertMatch(#{type := stdio}, Info),\n    ?assertMatch(#{status := connected}, Info),\n    ?assertMatch(#{peer := test_environment}, Info),\n    ?assertMatch(#{test_mode := true}, Info),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\ntransport_behavior_handle_transport_call(Config) ->\n    TransportId = test_transport_behavior_call,\n    TestConfig = #{test_mode => true},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    \n    % Test valid calls\n    {reply, {ok, _}, _} = gen_server:call(Pid, {transport_call, get_buffer}),\n    {reply, {ok, true}, _} = gen_server:call(Pid, {transport_call, get_test_mode}),\n    {reply, {ok, _}, _} = gen_server:call(Pid, {transport_call, get_reader_pid}),\n    \n    % Test invalid call\n    {reply, {error, unknown_transport_request}, _} = \n        gen_server:call(Pid, {transport_call, invalid_request}),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Test Cases - Registry Integration\n%%====================================================================\n\nregistry_registration(Config) ->\n    TransportId = test_transport_registry_reg,\n    ServerId = test_server_reg,\n    TestConfig = #{test_mode => true, server_id => ServerId},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    \n    % Verify registration\n    timer:sleep(100), % Allow registration to complete\n    {ok, {RegPid, RegConfig}} = erlmcp_registry:find_transport(TransportId),\n    ?assertEqual(Pid, RegPid),\n    ?assertMatch(#{type := stdio}, RegConfig),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nregistry_unregistration(Config) ->\n    TransportId = test_transport_registry_unreg,\n    ServerId = test_server_unreg,\n    TestConfig = #{test_mode => true, server_id => ServerId},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n    \n    % Verify registered\n    {ok, _} = erlmcp_registry:find_transport(TransportId),\n    \n    % Stop and verify unregistered\n    ok = gen_server:stop(Pid),\n    timer:sleep(100),\n    \n    ?assertEqual({error, not_found}, erlmcp_registry:find_transport(TransportId)),\n    ok.\n\nregistry_message_routing(Config) ->\n    TransportId = test_transport_registry_routing,\n    ServerId = test_server_routing,\n    TestConfig = #{test_mode => true, server_id => ServerId},\n    \n    % Start mock server\n    MockServer = spawn_mock_server(ServerId),\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n    \n    % Simulate message input\n    gen_server:call(Pid, {simulate_input, <<\"test message\">>}),\n    \n    % Verify server received message\n    receive\n        {mock_server, ServerId, Message} ->\n            ?assertEqual(<<\"test message\">>, Message)\n    after 1000 ->\n        ?assert(false, \"Message not received by server\")\n    end,\n    \n    cleanup_mock_server(MockServer),\n    ok = gen_server:stop(Pid),\n    ok.\n\nregistry_response_handling(Config) ->\n    TransportId = test_transport_registry_response,\n    ServerId = test_server_response,\n    TestConfig = #{test_mode => true, server_id => ServerId},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n    \n    % Send response via registry mechanism\n    Pid ! {mcp_response, ServerId, <<\"response data\">>},\n    timer:sleep(100),\n    \n    % Verify transport handled response (would normally send to stdout)\n    % In test mode, this just verifies no crash occurred\n    ?assert(is_process_alive(Pid)),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Test Cases - Configuration\n%%====================================================================\n\nconfig_validation(Config) ->\n    % Test valid configurations\n    ValidConfigs = [\n        #{test_mode => true},\n        #{test_mode => false},\n        #{server_id => test_server},\n        #{test_mode => true, server_id => test_server}\n    ],\n    \n    lists:foreach(fun(TestConfig) ->\n        {ok, Pid} = erlmcp_transport_stdio_new:start_link(test_transport_config, TestConfig),\n        ?assert(is_process_alive(Pid)),\n        ok = gen_server:stop(Pid)\n    end, ValidConfigs),\n    ok.\n\nconfig_defaults(Config) ->\n    TransportId = test_transport_defaults,\n    TestConfig = #{}, % Empty config\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    {ok, State} = gen_server:call(Pid, get_state),\n    \n    % Verify defaults\n    ?assertEqual(undefined, maps:get(server_id, State)),\n    ?assertEqual(connected, maps:get(status, State)),\n    ?assertEqual(<<>>, maps:get(buffer, State)),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\ntest_mode_startup(Config) ->\n    TransportId = test_transport_test_mode,\n    \n    % Test mode enabled\n    TestConfig1 = #{test_mode => true},\n    {ok, Pid1} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig1),\n    {ok, State1} = gen_server:call(Pid1, get_state),\n    \n    ?assertEqual(true, maps:get(test_mode, State1)),\n    ?assertEqual(undefined, maps:get(reader, State1)),\n    \n    ok = gen_server:stop(Pid1),\n    \n    % Test mode auto-detection\n    put(test_mode, true),\n    TestConfig2 = #{},\n    {ok, Pid2} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig2),\n    {ok, State2} = gen_server:call(Pid2, get_state),\n    \n    ?assertEqual(true, maps:get(test_mode, State2)),\n    \n    ok = gen_server:stop(Pid2),\n    ok.\n\nserver_binding(Config) ->\n    TransportId = test_transport_binding,\n    ServerId = test_server_binding,\n    \n    % Test with server binding\n    TestConfig1 = #{test_mode => true, server_id => ServerId},\n    {ok, Pid1} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig1),\n    {ok, State1} = gen_server:call(Pid1, get_state),\n    \n    ?assertEqual(ServerId, maps:get(server_id, State1)),\n    \n    ok = gen_server:stop(Pid1),\n    \n    % Test without server binding\n    TestConfig2 = #{test_mode => true},\n    {ok, Pid2} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig2),\n    {ok, State2} = gen_server:call(Pid2, get_state),\n    \n    ?assertEqual(undefined, maps:get(server_id, State2)),\n    \n    ok = gen_server:stop(Pid2),\n    ok.\n\n%%====================================================================\n%% Test Cases - Error Handling\n%%====================================================================\n\nerror_handling_no_server(Config) ->\n    TransportId = test_transport_no_server,\n    TestConfig = #{test_mode => true}, % No server_id\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    \n    % Simulate message without server binding\n    gen_server:call(Pid, {simulate_input, <<\"test message\">>}),\n    \n    % Should not crash\n    timer:sleep(100),\n    ?assert(is_process_alive(Pid)),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nerror_handling_routing_failure(Config) ->\n    TransportId = test_transport_routing_failure,\n    ServerId = non_existent_server,\n    TestConfig = #{test_mode => true, server_id => ServerId},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n    \n    % Simulate message to non-existent server\n    gen_server:call(Pid, {simulate_input, <<\"test message\">>}),\n    \n    % Should not crash\n    timer:sleep(100),\n    ?assert(is_process_alive(Pid)),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nerror_handling_reader_crash(Config) ->\n    TransportId = test_transport_reader_crash,\n    TestConfig = #{test_mode => false}, % Real reader\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    {ok, State} = gen_server:call(Pid, get_state),\n    \n    ReaderPid = maps:get(reader, State),\n    ?assert(is_pid(ReaderPid)),\n    \n    % Kill reader and verify handling\n    exit(ReaderPid, kill),\n    timer:sleep(100),\n    \n    % Check if transport handled reader death\n    {ok, NewState} = gen_server:call(Pid, get_state),\n    ?assertEqual(error, maps:get(status, NewState)),\n    \n    ok.\n\nerror_handling_invalid_messages(Config) ->\n    TransportId = test_transport_invalid_msg,\n    ServerId = test_server_invalid,\n    TestConfig = #{test_mode => true, server_id => ServerId},\n    \n    MockServer = spawn_mock_server(ServerId),\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n    \n    % Send various invalid/edge case messages\n    InvalidMessages = [\n        <<>>,\n        <<\"\">>,\n        <<\"\\n\">>,\n        <<\"\\r\\n\">>,\n        <<\"single line\">>,\n        <<\"multi\\nline\\nmessage\">>\n    ],\n    \n    lists:foreach(fun(Msg) ->\n        gen_server:call(Pid, {simulate_input, Msg})\n    end, InvalidMessages),\n    \n    % Should not crash\n    timer:sleep(100),\n    ?assert(is_process_alive(Pid)),\n    \n    cleanup_mock_server(MockServer),\n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Test Cases - Message Processing\n%%====================================================================\n\nmessage_parsing(Config) ->\n    % Test line trimming functions directly\n    ?assertEqual(<<\"hello\">>, erlmcp_transport_stdio_new:trim_line(<<\"hello\\n\">>)),\n    ?assertEqual(<<\"hello\">>, erlmcp_transport_stdio_new:trim_line(<<\"hello\\r\\n\">>)),\n    ?assertEqual(<<\"hello\">>, erlmcp_transport_stdio_new:trim_line(<<\"hello\\r\">>)),\n    ?assertEqual(<<\"hello\">>, erlmcp_transport_stdio_new:trim_line(<<\"hello\">>)),\n    ?assertEqual(<<>>, erlmcp_transport_stdio_new:trim_line(<<\"\\n\">>)),\n    ?assertEqual(<<>>, erlmcp_transport_stdio_new:trim_line(<<>>)),\n    ok.\n\nmessage_buffering(Config) ->\n    TransportId = test_transport_buffering,\n    TestConfig = #{test_mode => true},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    {ok, InitialState} = gen_server:call(Pid, get_state),\n    \n    % Verify initial buffer is empty\n    ?assertEqual(<<>>, maps:get(buffer, InitialState)),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nline_trimming(Config) ->\n    TestCases = [\n        {<<\"hello world\">>, <<\"hello world\">>},\n        {<<\"hello world\\n\">>, <<\"hello world\">>},\n        {<<\"hello world\\r\\n\">>, <<\"hello world\">>},\n        {<<\"hello world\\r\">>, <<\"hello world\">>},\n        {<<\"\\n\">>, <<>>},\n        {<<\"\\r\\n\">>, <<>>},\n        {<<\"\\r\">>, <<>>},\n        {<<>>, <<>>}\n    ],\n    \n    lists:foreach(fun({Input, Expected}) ->\n        Result = erlmcp_transport_stdio_new:trim_line(Input),\n        ?assertEqual(Expected, Result)\n    end, TestCases),\n    ok.\n\nempty_line_handling(Config) ->\n    TransportId = test_transport_empty_lines,\n    ServerId = test_server_empty,\n    TestConfig = #{test_mode => true, server_id => ServerId},\n    \n    MockServer = spawn_mock_server(ServerId),\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n    \n    % Send empty lines (should be ignored)\n    EmptyLines = [<<>>, <<\"\\n\">>, <<\"\\r\\n\">>, <<\"\\r\">>, <<\"  \">>],\n    \n    lists:foreach(fun(Line) ->\n        gen_server:call(Pid, {simulate_input, Line})\n    end, EmptyLines),\n    \n    % Should not receive any messages at server\n    receive\n        {mock_server, ServerId, _} ->\n            ?assert(false, \"Empty line was processed\")\n    after 200 ->\n        ok % Expected - no messages\n    end,\n    \n    cleanup_mock_server(MockServer),\n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Test Cases - Lifecycle\n%%====================================================================\n\nsupervisor_integration(Config) ->\n    % This test would typically verify supervisor behavior\n    % For now, just verify the transport can be started/stopped cleanly\n    TransportId = test_transport_supervisor,\n    TestConfig = #{test_mode => true},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    ?assert(is_process_alive(Pid)),\n    \n    % Verify clean shutdown\n    ok = gen_server:stop(Pid),\n    ?assertNot(is_process_alive(Pid)),\n    ok.\n\ngraceful_shutdown(Config) ->\n    TransportId = test_transport_graceful,\n    TestConfig = #{test_mode => false}, % With reader\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    {ok, State} = gen_server:call(Pid, get_state),\n    \n    ReaderPid = maps:get(reader, State),\n    ?assert(is_pid(ReaderPid)),\n    ?assert(is_process_alive(ReaderPid)),\n    \n    % Graceful stop should clean up reader\n    ok = gen_server:stop(Pid),\n    timer:sleep(100),\n    \n    ?assertNot(is_process_alive(ReaderPid)),\n    ok.\n\nabnormal_termination(Config) ->\n    TransportId = test_transport_abnormal,\n    TestConfig = #{test_mode => false}, % With reader\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    {ok, State} = gen_server:call(Pid, get_state),\n    \n    ReaderPid = maps:get(reader, State),\n    ?assert(is_pid(ReaderPid)),\n    \n    % Kill the transport process\n    exit(Pid, kill),\n    timer:sleep(100),\n    \n    ?assertNot(is_process_alive(Pid)),\n    % Reader should also be cleaned up\n    ?assertNot(is_process_alive(ReaderPid)),\n    ok.\n\n%%====================================================================\n%% Test Cases - Performance\n%%====================================================================\n\nhigh_volume_messages(Config) ->\n    TransportId = test_transport_volume,\n    ServerId = test_server_volume,\n    TestConfig = #{test_mode => true, server_id => ServerId},\n    \n    MockServer = spawn_mock_server(ServerId),\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n    \n    % Send many messages quickly\n    MessageCount = 1000,\n    StartTime = erlang:monotonic_time(millisecond),\n    \n    lists:foreach(fun(N) ->\n        Message = iolist_to_binary([<<\"message_\">>, integer_to_list(N)]),\n        gen_server:call(Pid, {simulate_input, Message})\n    end, lists:seq(1, MessageCount)),\n    \n    EndTime = erlang:monotonic_time(millisecond),\n    Duration = EndTime - StartTime,\n    \n    ct:pal(\"Processed ~p messages in ~p ms (~p msg/sec)\", \n           [MessageCount, Duration, round(MessageCount * 1000 / Duration)]),\n    \n    % Should handle high volume without crashing\n    ?assert(is_process_alive(Pid)),\n    \n    cleanup_mock_server(MockServer),\n    ok = gen_server:stop(Pid),\n    ok.\n\nmemory_usage(Config) ->\n    TransportId = test_transport_memory,\n    TestConfig = #{test_mode => true},\n    \n    % Measure memory before\n    {memory, MemBefore} = erlang:process_info(self(), memory),\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n    \n    % Measure transport memory\n    {memory, TransportMem} = erlang:process_info(Pid, memory),\n    \n    ct:pal(\"Transport memory usage: ~p bytes\", [TransportMem]),\n    \n    % Verify reasonable memory usage (< 1MB for basic transport)\n    ?assert(TransportMem < 1024 * 1024),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nlatency_measurement(Config) ->\n    TransportId = test_transport_latency,\n    ServerId = test_server_latency,\n    TestConfig = #{test_mode => true, server_id => ServerId},\n    \n    % Create latency-measuring mock server\n    LatencyServer = spawn(fun() -> latency_server_loop([]) end),\n    register(test_server_latency, LatencyServer),\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n    \n    % Measure latency for message processing\n    MessageCount = 100,\n    Latencies = lists:map(fun(N) ->\n        Message = iolist_to_binary([<<\"latency_test_\">>, integer_to_list(N)]),\n        StartTime = erlang:monotonic_time(microsecond),\n        gen_server:call(Pid, {simulate_input, Message}),\n        EndTime = erlang:monotonic_time(microsecond),\n        EndTime - StartTime\n    end, lists:seq(1, MessageCount)),\n    \n    AvgLatency = lists:sum(Latencies) / length(Latencies),\n    MaxLatency = lists:max(Latencies),\n    MinLatency = lists:min(Latencies),\n    \n    ct:pal(\"Latency stats - Avg: ~.2f μs, Min: ~p μs, Max: ~p μs\", \n           [AvgLatency, MinLatency, MaxLatency]),\n    \n    % Verify reasonable latency (< 1ms average for test mode)\n    ?assert(AvgLatency < 1000),\n    \n    LatencyServer ! stop,\n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Test Cases - Integration\n%%====================================================================\n\nend_to_end_communication(Config) ->\n    TransportId = test_transport_e2e,\n    ServerId = test_server_e2e,\n    TestConfig = #{test_mode => true, server_id => ServerId},\n    \n    % Start mock server that echoes messages\n    EchoServer = spawn(fun() -> echo_server_loop() end),\n    register(test_server_e2e, EchoServer),\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n    \n    % Send message and verify echo\n    TestMessage = <<\"end_to_end_test\">>,\n    gen_server:call(Pid, {simulate_input, TestMessage}),\n    \n    % Should receive echoed message\n    receive\n        {mcp_response, ServerId, EchoedMessage} ->\n            ?assertEqual(TestMessage, EchoedMessage)\n    after 1000 ->\n        ?assert(false, \"Echo not received\")\n    end,\n    \n    EchoServer ! stop,\n    ok = gen_server:stop(Pid),\n    ok.\n\nconcurrent_operations(Config) ->\n    TransportId = test_transport_concurrent,\n    TestConfig = #{test_mode => true},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    \n    % Spawn multiple processes doing operations concurrently\n    NumProcesses = 10,\n    OperationsPerProcess = 100,\n    \n    Parent = self(),\n    Processes = [spawn(fun() ->\n        lists:foreach(fun(N) ->\n            {ok, _} = gen_server:call(Pid, get_state),\n            {reply, {ok, _}, _} = gen_server:call(Pid, {transport_call, get_buffer})\n        end, lists:seq(1, OperationsPerProcess)),\n        Parent ! {done, self()}\n    end) || _ <- lists:seq(1, NumProcesses)],\n    \n    % Wait for all to complete\n    lists:foreach(fun(ProcessPid) ->\n        receive\n            {done, ProcessPid} -> ok\n        after 5000 ->\n            ?assert(false, \"Concurrent operation timed out\")\n        end\n    end, Processes),\n    \n    % Transport should still be alive\n    ?assert(is_process_alive(Pid)),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nstress_test(Config) ->\n    % Combined stress test\n    TransportId = test_transport_stress,\n    TestConfig = #{test_mode => true},\n    \n    {ok, Pid} = erlmcp_transport_stdio_new:start_link(TransportId, TestConfig),\n    \n    % Multiple concurrent clients\n    NumClients = 5,\n    MessagesPerClient = 200,\n    \n    Parent = self(),\n    Clients = [spawn(fun() ->\n        lists:foreach(fun(N) ->\n            % Mix of different operations\n            case N rem 3 of\n                0 ->\n                    {ok, _} = gen_server:call(Pid, get_state);\n                1 ->\n                    gen_server:call(Pid, {simulate_input, \n                                        iolist_to_binary([<<\"stress_\">>, integer_to_list(N)])});\n                2 ->\n                    {reply, {ok, _}, _} = gen_server:call(Pid, {transport_call, get_test_mode})\n            end\n        end, lists:seq(1, MessagesPerClient)),\n        Parent ! {client_done, self()}\n    end) || _ <- lists:seq(1, NumClients)],\n    \n    StartTime = erlang:monotonic_time(millisecond),\n    \n    % Wait for all clients\n    lists:foreach(fun(ClientPid) ->\n        receive\n            {client_done, ClientPid} -> ok\n        after 10000 ->\n            ?assert(false, \"Stress test client timed out\")\n        end\n    end, Clients),\n    \n    EndTime = erlang:monotonic_time(millisecond),\n    TotalOps = NumClients * MessagesPerClient,\n    Duration = EndTime - StartTime,\n    \n    ct:pal(\"Stress test: ~p ops in ~p ms (~.2f ops/sec)\", \n           [TotalOps, Duration, TotalOps * 1000 / Duration]),\n    \n    % Should survive stress test\n    ?assert(is_process_alive(Pid)),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Helper Functions\n%%====================================================================\n\ncleanup_processes() ->\n    % Kill any stray registered processes\n    lists:foreach(fun(Name) ->\n        case whereis(Name) of\n            undefined -> ok;\n            Pid -> exit(Pid, kill)\n        end\n    end, [test_server_latency, test_server_e2e]).\n\nspawn_mock_server(ServerId) ->\n    Parent = self(),\n    Pid = spawn(fun() ->\n        register(ServerId, self()),\n        mock_server_loop(Parent, ServerId)\n    end),\n    % Register with registry\n    Config = #{capabilities => #{}, options => #{}},\n    erlmcp_registry:register_server(ServerId, Pid, Config),\n    Pid.\n\nmock_server_loop(Parent, ServerId) ->\n    receive\n        {route_message, _TransportId, Message} ->\n            Parent ! {mock_server, ServerId, Message},\n            mock_server_loop(Parent, ServerId);\n        stop ->\n            erlmcp_registry:unregister_server(ServerId),\n            ok\n    end.\n\ncleanup_mock_server(Pid) ->\n    Pid ! stop,\n    timer:sleep(50).\n\nlatency_server_loop(Messages) ->\n    receive\n        {route_message, _TransportId, Message} ->\n            latency_server_loop([Message | Messages]);\n        stop ->\n            ok\n    end.\n\necho_server_loop() ->\n    receive\n        {route_message, TransportId, Message} ->\n            % Echo back to transport\n            TransportId ! {mcp_response, test_server_e2e, Message},\n            echo_server_loop();\n        stop ->\n            ok\n    end."
        }
    ]
}