{
    "sourceFile": "test/erlmcp_transport_stdio_standard_SUITE.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1756185314751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756190592430,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,201 +17,151 @@\n -module(erlmcp_transport_stdio_standard_SUITE).\n \n -include_lib(\"common_test/include/ct.hrl\").\n -include_lib(\"eunit/include/eunit.hrl\").\n+\n -include(\"erlmcp.hrl\").\n \n %% Suite callbacks\n--export([all/0, groups/0, init_per_suite/1, end_per_suite/1,\n-         init_per_group/2, end_per_group/2,\n-         init_per_testcase/2, end_per_testcase/2]).\n-\n+-export([all/0, groups/0, init_per_suite/1, end_per_suite/1, init_per_group/2,\n+         end_per_group/2, init_per_testcase/2, end_per_testcase/2]).\n %% Behavior compliance tests\n--export([\n-    behavior_init_compliance/1,\n-    behavior_send_compliance/1,\n-    behavior_close_compliance/1,\n-    behavior_get_info_compliance/1,\n-    behavior_handle_transport_call_compliance/1,\n-    behavior_exports_validation/1,\n-    behavior_return_types/1\n-]).\n-\n-%% Registry integration tests  \n--export([\n-    registry_auto_registration/1,\n-    registry_auto_unregistration/1,\n-    registry_message_routing/1,\n-    registry_transport_discovery/1,\n-    registry_configuration_propagation/1,\n-    registry_failover_handling/1\n-]).\n-\n+-export([behavior_init_compliance/1, behavior_send_compliance/1,\n+         behavior_close_compliance/1, behavior_get_info_compliance/1,\n+         behavior_handle_transport_call_compliance/1, behavior_exports_validation/1,\n+         behavior_return_types/1]).\n+%% Registry integration tests\n+-export([registry_auto_registration/1, registry_auto_unregistration/1,\n+         registry_message_routing/1, registry_transport_discovery/1,\n+         registry_configuration_propagation/1, registry_failover_handling/1]).\n %% Message routing tests\n--export([\n-    message_routing_basic/1,\n-    message_routing_json_rpc/1,\n-    message_routing_large_messages/1,\n-    message_routing_malformed_input/1,\n-    message_routing_buffer_management/1,\n-    message_routing_line_processing/1\n-]).\n-\n+-export([message_routing_basic/1, message_routing_json_rpc/1,\n+         message_routing_large_messages/1, message_routing_malformed_input/1,\n+         message_routing_buffer_management/1, message_routing_line_processing/1]).\n %% Connection handling tests\n--export([\n-    connection_stdio_mode/1,\n-    connection_test_mode/1,\n-    connection_reader_lifecycle/1,\n-    connection_process_supervision/1,\n-    connection_graceful_shutdown/1,\n-    connection_abnormal_termination/1\n-]).\n-\n+-export([connection_stdio_mode/1, connection_test_mode/1, connection_reader_lifecycle/1,\n+         connection_process_supervision/1, connection_graceful_shutdown/1,\n+         connection_abnormal_termination/1]).\n %% Error recovery tests\n--export([\n-    error_recovery_reader_crash/1,\n-    error_recovery_invalid_messages/1,\n-    error_recovery_routing_failures/1,\n-    error_recovery_registry_unavailable/1,\n-    error_recovery_resource_exhaustion/1,\n-    error_recovery_state_corruption/1\n-]).\n-\n+-export([error_recovery_reader_crash/1, error_recovery_invalid_messages/1,\n+         error_recovery_routing_failures/1, error_recovery_registry_unavailable/1,\n+         error_recovery_resource_exhaustion/1, error_recovery_state_corruption/1]).\n %% Resource cleanup tests\n--export([\n-    resource_cleanup_normal_shutdown/1,\n-    resource_cleanup_forced_termination/1,\n-    resource_cleanup_reader_cleanup/1,\n-    resource_cleanup_memory_leaks/1,\n-    resource_cleanup_process_monitoring/1,\n-    resource_cleanup_port_management/1\n-]).\n-\n+-export([resource_cleanup_normal_shutdown/1, resource_cleanup_forced_termination/1,\n+         resource_cleanup_reader_cleanup/1, resource_cleanup_memory_leaks/1,\n+         resource_cleanup_process_monitoring/1, resource_cleanup_port_management/1]).\n %% Performance tests\n--export([\n-    performance_throughput_measurement/1,\n-    performance_latency_measurement/1,\n-    performance_memory_efficiency/1,\n-    performance_concurrent_access/1,\n-    performance_high_volume_messages/1,\n-    performance_resource_scaling/1\n-]).\n-\n+-export([performance_throughput_measurement/1, performance_latency_measurement/1,\n+         performance_memory_efficiency/1, performance_concurrent_access/1,\n+         performance_high_volume_messages/1, performance_resource_scaling/1]).\n %% Buffer management tests\n--export([\n-    buffer_partial_messages/1,\n-    buffer_overflow_handling/1,\n-    buffer_line_boundary_detection/1,\n-    buffer_unicode_handling/1,\n-    buffer_memory_efficiency/1,\n-    buffer_concurrent_access/1\n-]).\n+-export([buffer_partial_messages/1, buffer_overflow_handling/1,\n+         buffer_line_boundary_detection/1, buffer_unicode_handling/1, buffer_memory_efficiency/1,\n+         buffer_concurrent_access/1]).\n \n %%====================================================================\n %% Suite Configuration\n %%====================================================================\n \n all() ->\n-    [\n-        {group, behavior_compliance},\n-        {group, registry_integration},\n-        {group, message_routing},\n-        {group, connection_handling},\n-        {group, error_recovery},\n-        {group, resource_cleanup},\n-        {group, performance},\n-        {group, buffer_management}\n-    ].\n+    [{group, behavior_compliance},\n+     {group, registry_integration},\n+     {group, message_routing},\n+     {group, connection_handling},\n+     {group, error_recovery},\n+     {group, resource_cleanup},\n+     {group, performance},\n+     {group, buffer_management}].\n \n groups() ->\n-    [\n-        {behavior_compliance, [sequential], [\n-            behavior_exports_validation,\n-            behavior_init_compliance,\n-            behavior_send_compliance,\n-            behavior_close_compliance,\n-            behavior_get_info_compliance,\n-            behavior_handle_transport_call_compliance,\n-            behavior_return_types\n-        ]},\n-        {registry_integration, [sequential], [\n-            registry_auto_registration,\n-            registry_auto_unregistration,\n-            registry_message_routing,\n-            registry_transport_discovery,\n-            registry_configuration_propagation,\n-            registry_failover_handling\n-        ]},\n-        {message_routing, [parallel], [\n-            message_routing_basic,\n-            message_routing_json_rpc,\n-            message_routing_large_messages,\n-            message_routing_malformed_input,\n-            message_routing_buffer_management,\n-            message_routing_line_processing\n-        ]},\n-        {connection_handling, [sequential], [\n-            connection_stdio_mode,\n-            connection_test_mode,\n-            connection_reader_lifecycle,\n-            connection_process_supervision,\n-            connection_graceful_shutdown,\n-            connection_abnormal_termination\n-        ]},\n-        {error_recovery, [sequential], [\n-            error_recovery_reader_crash,\n-            error_recovery_invalid_messages,\n-            error_recovery_routing_failures,\n-            error_recovery_registry_unavailable,\n-            error_recovery_resource_exhaustion,\n-            error_recovery_state_corruption\n-        ]},\n-        {resource_cleanup, [sequential], [\n-            resource_cleanup_normal_shutdown,\n-            resource_cleanup_forced_termination,\n-            resource_cleanup_reader_cleanup,\n-            resource_cleanup_memory_leaks,\n-            resource_cleanup_process_monitoring,\n-            resource_cleanup_port_management\n-        ]},\n-        {performance, [sequential], [\n-            performance_throughput_measurement,\n-            performance_latency_measurement,\n-            performance_memory_efficiency,\n-            performance_concurrent_access,\n-            performance_high_volume_messages,\n-            performance_resource_scaling\n-        ]},\n-        {buffer_management, [parallel], [\n-            buffer_partial_messages,\n-            buffer_overflow_handling,\n-            buffer_line_boundary_detection,\n-            buffer_unicode_handling,\n-            buffer_memory_efficiency,\n-            buffer_concurrent_access\n-        ]}\n-    ].\n+    [{behavior_compliance,\n+      [sequential],\n+      [behavior_exports_validation,\n+       behavior_init_compliance,\n+       behavior_send_compliance,\n+       behavior_close_compliance,\n+       behavior_get_info_compliance,\n+       behavior_handle_transport_call_compliance,\n+       behavior_return_types]},\n+     {registry_integration,\n+      [sequential],\n+      [registry_auto_registration,\n+       registry_auto_unregistration,\n+       registry_message_routing,\n+       registry_transport_discovery,\n+       registry_configuration_propagation,\n+       registry_failover_handling]},\n+     {message_routing,\n+      [parallel],\n+      [message_routing_basic,\n+       message_routing_json_rpc,\n+       message_routing_large_messages,\n+       message_routing_malformed_input,\n+       message_routing_buffer_management,\n+       message_routing_line_processing]},\n+     {connection_handling,\n+      [sequential],\n+      [connection_stdio_mode,\n+       connection_test_mode,\n+       connection_reader_lifecycle,\n+       connection_process_supervision,\n+       connection_graceful_shutdown,\n+       connection_abnormal_termination]},\n+     {error_recovery,\n+      [sequential],\n+      [error_recovery_reader_crash,\n+       error_recovery_invalid_messages,\n+       error_recovery_routing_failures,\n+       error_recovery_registry_unavailable,\n+       error_recovery_resource_exhaustion,\n+       error_recovery_state_corruption]},\n+     {resource_cleanup,\n+      [sequential],\n+      [resource_cleanup_normal_shutdown,\n+       resource_cleanup_forced_termination,\n+       resource_cleanup_reader_cleanup,\n+       resource_cleanup_memory_leaks,\n+       resource_cleanup_process_monitoring,\n+       resource_cleanup_port_management]},\n+     {performance,\n+      [sequential],\n+      [performance_throughput_measurement,\n+       performance_latency_measurement,\n+       performance_memory_efficiency,\n+       performance_concurrent_access,\n+       performance_high_volume_messages,\n+       performance_resource_scaling]},\n+     {buffer_management,\n+      [parallel],\n+      [buffer_partial_messages,\n+       buffer_overflow_handling,\n+       buffer_line_boundary_detection,\n+       buffer_unicode_handling,\n+       buffer_memory_efficiency,\n+       buffer_concurrent_access]}].\n \n %%====================================================================\n %% Suite Setup/Teardown\n %%====================================================================\n \n init_per_suite(Config) ->\n     ct:pal(\"Starting STDIO transport standard test suite\"),\n-    \n+\n     %% Start required applications\n     ok = application:ensure_started(crypto),\n     ok = application:ensure_started(sasl),\n-    \n+\n     %% Initialize registry\n     case erlmcp_registry:start_link() of\n-        {ok, _} -> ok;\n-        {error, {already_started, _}} -> ok\n+        {ok, _} ->\n+            ok;\n+        {error, {already_started, _}} ->\n+            ok\n     end,\n-    \n+\n     %% Enable test environment\n     put(test_mode, true),\n-    \n+\n     [{test_module, erlmcp_transport_stdio_new}, {test_mode, true} | Config].\n \n end_per_suite(_Config) ->\n     ct:pal(\"Ending STDIO transport standard test suite\"),\n@@ -227,9 +177,11 @@\n \n init_per_testcase(TestCase, Config) ->\n     ct:pal(\"Starting test case: ~p\", [TestCase]),\n     %% Generate unique transport ID for this test\n-    TransportId = list_to_atom(lists:flatten(io_lib:format(\"~p_~p\", [TestCase, erlang:unique_integer([positive])]))),\n+    TransportId =\n+        list_to_atom(lists:flatten(\n+                         io_lib:format(\"~p_~p\", [TestCase, erlang:unique_integer([positive])]))),\n     [{transport_id, TransportId} | Config].\n \n end_per_testcase(TestCase, Config) ->\n     ct:pal(\"Ending test case: ~p\", [TestCase]),\n@@ -242,191 +194,185 @@\n %%====================================================================\n \n behavior_exports_validation(Config) ->\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     %% Required exports\n-    RequiredExports = [\n-        {init, 1},\n-        {send, 2},\n-        {close, 1}\n-    ],\n-    \n+    RequiredExports = [{init, 1}, {send, 2}, {close, 1}],\n+\n     %% Optional exports\n-    OptionalExports = [\n-        {get_info, 1},\n-        {handle_transport_call, 2}\n-    ],\n-    \n+    OptionalExports = [{get_info, 1}, {handle_transport_call, 2}],\n+\n     ModuleExports = Module:module_info(exports),\n-    \n+\n     %% Verify required exports\n     lists:foreach(fun(Export) ->\n-        ?assert(lists:member(Export, ModuleExports)),\n-        ct:pal(\"Required export ~p found\", [Export])\n-    end, RequiredExports),\n-    \n+                     ?assert(lists:member(Export, ModuleExports)),\n+                     ct:pal(\"Required export ~p found\", [Export])\n+                  end,\n+                  RequiredExports),\n+\n     %% Check optional exports\n     lists:foreach(fun(Export) ->\n-        case lists:member(Export, ModuleExports) of\n-            true -> ct:pal(\"Optional export ~p implemented\", [Export]);\n-            false -> ct:pal(\"Optional export ~p not implemented\", [Export])\n-        end\n-    end, OptionalExports),\n-    \n+                     case lists:member(Export, ModuleExports) of\n+                         true -> ct:pal(\"Optional export ~p implemented\", [Export]);\n+                         false -> ct:pal(\"Optional export ~p not implemented\", [Export])\n+                     end\n+                  end,\n+                  OptionalExports),\n+\n     ok.\n \n behavior_init_compliance(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     %% Test valid initialization\n     ValidOpts = #{test_mode => true, transport_id => TransportId},\n     {ok, State} = Module:init(ValidOpts),\n     ?assert(State =/= undefined),\n     ct:pal(\"Init successful with state type: ~p\", [element(1, State)]),\n-    \n+\n     %% Test initialization with minimal options\n     MinimalOpts = #{},\n     {ok, _MinimalState} = Module:init(MinimalOpts),\n     ct:pal(\"Init successful with minimal options\"),\n-    \n+\n     %% Test initialization with server binding\n     ServerOpts = #{test_mode => true, server_id => test_server},\n     {ok, _ServerState} = Module:init(ServerOpts),\n     ct:pal(\"Init successful with server binding\"),\n-    \n+\n     ok.\n \n behavior_send_compliance(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     {ok, State} = Module:init(#{test_mode => true, transport_id => TransportId}),\n-    \n+\n     %% Test various data types\n-    TestData = [\n-        <<\"binary message\">>,\n-        \"string message\",\n-        [<<\"iodata \">>, <<\"message\">>],\n-        []\n-    ],\n-    \n+    TestData = [<<\"binary message\">>, \"string message\", [<<\"iodata \">>, <<\"message\">>], []],\n+\n     lists:foreach(fun(Data) ->\n-        Result = Module:send(State, Data),\n-        ?assertEqual(ok, Result),\n-        ct:pal(\"Send successful for data type: ~p\", [typeof(Data)])\n-    end, TestData),\n-    \n+                     Result = Module:send(State, Data),\n+                     ?assertEqual(ok, Result),\n+                     ct:pal(\"Send successful for data type: ~p\", [typeof(Data)])\n+                  end,\n+                  TestData),\n+\n     %% Test JSON-RPC message\n-    JsonMessage = jsx:encode(#{\n-        <<\"jsonrpc\">> => <<\"2.0\">>,\n-        <<\"method\">> => <<\"test.method\">>,\n-        <<\"params\">> => #{},\n-        <<\"id\">> => <<\"test-1\">>\n-    }),\n+    JsonMessage =\n+        jsx:encode(#{<<\"jsonrpc\">> => <<\"2.0\">>,\n+                     <<\"method\">> => <<\"test.method\">>,\n+                     <<\"params\">> => #{},\n+                     <<\"id\">> => <<\"test-1\">>}),\n     ?assertEqual(ok, Module:send(State, JsonMessage)),\n     ct:pal(\"Send successful for JSON-RPC message\"),\n-    \n+\n     ok.\n \n behavior_close_compliance(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     %% Test close with reader process\n     {ok, State1} = Module:init(#{test_mode => false, transport_id => TransportId}),\n     Result1 = Module:close(State1),\n     ?assertEqual(ok, Result1),\n     ct:pal(\"Close successful with reader process\"),\n-    \n+\n     %% Test close without reader process (test mode)\n     {ok, State2} = Module:init(#{test_mode => true, transport_id => TransportId}),\n     Result2 = Module:close(State2),\n     ?assertEqual(ok, Result2),\n     ct:pal(\"Close successful in test mode\"),\n-    \n+\n     %% Test idempotent close\n     Result3 = Module:close(State2),\n     ?assertEqual(ok, Result3),\n     ct:pal(\"Close is idempotent\"),\n-    \n+\n     ok.\n \n behavior_get_info_compliance(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     {ok, State} = Module:init(#{test_mode => true, transport_id => TransportId}),\n-    \n+\n     Info = Module:get_info(State),\n     ?assert(is_map(Info)),\n-    \n+\n     %% Required fields\n     ?assertMatch(#{type := stdio}, Info),\n     ?assert(maps:is_key(status, Info)),\n-    \n+\n     ct:pal(\"Transport info: ~p\", [Info]),\n     ok.\n \n behavior_handle_transport_call_compliance(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     {ok, State} = Module:init(#{test_mode => true, transport_id => TransportId}),\n-    \n+\n     %% Test valid transport calls\n-    ValidCalls = [\n-        get_buffer,\n-        get_test_mode,\n-        get_reader_pid\n-    ],\n-    \n+    ValidCalls = [get_buffer, get_test_mode, get_reader_pid],\n+\n     lists:foreach(fun(Call) ->\n-        case Module:handle_transport_call(Call, State) of\n-            {reply, Reply, NewState} ->\n-                ct:pal(\"Transport call ~p replied: ~p\", [Call, Reply]);\n-            {error, Reason} ->\n-                ct:pal(\"Transport call ~p failed: ~p\", [Call, Reason])\n-        end\n-    end, ValidCalls),\n-    \n+                     case Module:handle_transport_call(Call, State) of\n+                         {reply, Reply, NewState} ->\n+                             ct:pal(\"Transport call ~p replied: ~p\", [Call, Reply]);\n+                         {error, Reason} -> ct:pal(\"Transport call ~p failed: ~p\", [Call, Reason])\n+                     end\n+                  end,\n+                  ValidCalls),\n+\n     %% Test invalid call\n     case Module:handle_transport_call(invalid_call, State) of\n         {reply, _, _} ->\n             ct:pal(\"Warning: Invalid call was accepted\");\n         {error, unknown_transport_request} ->\n             ct:pal(\"Invalid call properly rejected\")\n     end,\n-    \n+\n     ok.\n \n behavior_return_types(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     %% Test init return types (avoid binding variables used later)\n     case Module:init(#{test_mode => true, transport_id => TransportId}) of\n-        {ok, S1} when S1 =/= undefined -> ok;\n-        {error, _} -> ok;\n-        Other -> throw({invalid_init_return, Other})\n+        {ok, S1} when S1 =/= undefined ->\n+            ok;\n+        {error, _} ->\n+            ok;\n+        Other ->\n+            throw({invalid_init_return, Other})\n     end,\n-    \n+\n     {ok, State} = Module:init(#{test_mode => true, transport_id => TransportId}),\n-    \n+\n     %% Test send return types\n     case Module:send(State, <<\"test\">>) of\n-        ok -> ok;\n-        {error, _} -> ok;\n-        Other2 -> throw({invalid_send_return, Other2})\n+        ok ->\n+            ok;\n+        {error, _} ->\n+            ok;\n+        Other2 ->\n+            throw({invalid_send_return, Other2})\n     end,\n-    \n+\n     %% Test close return types\n     case Module:close(State) of\n-        ok -> ok;\n-        Other3 -> throw({invalid_close_return, Other3})\n+        ok ->\n+            ok;\n+        Other3 ->\n+            throw({invalid_close_return, Other3})\n     end,\n-    \n+\n     ct:pal(\"All return types conform to behavior specification\"),\n     ok.\n \n %%====================================================================\n@@ -435,217 +381,207 @@\n \n registry_auto_registration(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     %% Start transport and verify auto-registration\n     {ok, Pid} = Module:start_link(TransportId, #{test_mode => true}),\n     timer:sleep(100), % Allow registration to complete\n-    \n+\n     case erlmcp_registry:find_transport(TransportId) of\n         {ok, {RegPid, RegConfig}} ->\n             ?assertEqual(Pid, RegPid),\n             ?assert(is_map(RegConfig)),\n             ct:pal(\"Transport auto-registered successfully\");\n         {error, not_found} ->\n             throw({registration_failed, TransportId})\n     end,\n-    \n+\n     ok = gen_server:stop(Pid),\n     ok.\n \n registry_auto_unregistration(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     {ok, Pid} = Module:start_link(TransportId, #{test_mode => true}),\n     timer:sleep(100),\n-    \n+\n     %% Verify registered\n     {ok, _} = erlmcp_registry:find_transport(TransportId),\n-    \n+\n     %% Stop and verify unregistration\n     ok = gen_server:stop(Pid),\n     timer:sleep(100),\n-    \n+\n     case erlmcp_registry:find_transport(TransportId) of\n         {error, not_found} ->\n             ct:pal(\"Transport auto-unregistered successfully\");\n         {ok, _} ->\n             throw({unregistration_failed, TransportId})\n     end,\n-    \n+\n     ok.\n \n registry_message_routing(Config) ->\n     TransportId = ?config(transport_id, Config),\n     ServerId = test_server_routing,\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     %% Start mock server\n     MockServer = spawn_mock_server(ServerId),\n-    \n+\n     %% Start transport with server binding\n-    {ok, Pid} = Module:start_link(TransportId, #{\n-        test_mode => true,\n-        server_id => ServerId\n-    }),\n+    {ok, Pid} = Module:start_link(TransportId, #{test_mode => true, server_id => ServerId}),\n     timer:sleep(100),\n-    \n+\n     %% Simulate input message\n     TestMessage = <<\"registry routing test\">>,\n     gen_server:call(Pid, {simulate_input, TestMessage}),\n-    \n+\n     %% Verify server received message\n     receive\n         {mock_server_message, ServerId, ReceivedMessage} ->\n             ?assertEqual(TestMessage, ReceivedMessage),\n             ct:pal(\"Message routed successfully through registry\")\n     after 1000 ->\n         throw({message_routing_timeout, ServerId})\n     end,\n-    \n+\n     cleanup_mock_server(MockServer),\n     ok = gen_server:stop(Pid),\n     ok.\n \n registry_transport_discovery(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     %% Start multiple transports\n-    TransportIds = [\n-        list_to_atom(atom_to_list(TransportId) ++ \"_1\"),\n-        list_to_atom(atom_to_list(TransportId) ++ \"_2\"),\n-        list_to_atom(atom_to_list(TransportId) ++ \"_3\")\n-    ],\n-    \n-    Pids = [begin\n-        {ok, Pid} = Module:start_link(Id, #{test_mode => true}),\n-        Pid\n-    end || Id <- TransportIds],\n-    \n+    TransportIds =\n+        [list_to_atom(atom_to_list(TransportId) ++ \"_1\"),\n+         list_to_atom(atom_to_list(TransportId) ++ \"_2\"),\n+         list_to_atom(atom_to_list(TransportId) ++ \"_3\")],\n+\n+    Pids =\n+        [begin\n+             {ok, Pid} = Module:start_link(Id, #{test_mode => true}),\n+             Pid\n+         end\n+         || Id <- TransportIds],\n+\n     timer:sleep(100),\n-    \n+\n     %% Verify all transports can be discovered\n     lists:foreach(fun(Id) ->\n-        case erlmcp_registry:find_transport(Id) of\n-            {ok, {Pid, _Config}} ->\n-                ?assert(is_pid(Pid)),\n-                ct:pal(\"Transport ~p discoverable\", [Id]);\n-            {error, not_found} ->\n-                throw({discovery_failed, Id})\n-        end\n-    end, TransportIds),\n-    \n+                     case erlmcp_registry:find_transport(Id) of\n+                         {ok, {Pid, _Config}} ->\n+                             ?assert(is_pid(Pid)),\n+                             ct:pal(\"Transport ~p discoverable\", [Id]);\n+                         {error, not_found} -> throw({discovery_failed, Id})\n+                     end\n+                  end,\n+                  TransportIds),\n+\n     %% Cleanup\n     lists:foreach(fun(Pid) -> ok = gen_server:stop(Pid) end, Pids),\n     ok.\n \n registry_configuration_propagation(Config) ->\n     TransportId = ?config(transport_id, Config),\n     ServerId = test_server_config,\n     Module = erlmcp_transport_stdio_new,\n-    \n-    TestConfig = #{\n-        test_mode => true,\n-        server_id => ServerId,\n-        custom_option => custom_value\n-    },\n-    \n+\n+    TestConfig =\n+        #{test_mode => true,\n+          server_id => ServerId,\n+          custom_option => custom_value},\n+\n     {ok, Pid} = Module:start_link(TransportId, TestConfig),\n     timer:sleep(100),\n-    \n+\n     %% Verify configuration is accessible through registry\n     {ok, {_RegPid, RegConfig}} = erlmcp_registry:find_transport(TransportId),\n     ?assertMatch(#{type := stdio}, RegConfig),\n-    \n+\n     ct:pal(\"Configuration propagated: ~p\", [RegConfig]),\n-    \n+\n     ok = gen_server:stop(Pid),\n     ok.\n \n registry_failover_handling(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     %% Start transport\n     {ok, Pid} = Module:start_link(TransportId, #{test_mode => true}),\n     timer:sleep(100),\n-    \n+\n     %% Simulate registry failure/restart\n     erlmcp_registry:stop(),\n     timer:sleep(100),\n-    \n+\n     %% Restart registry\n     {ok, _} = erlmcp_registry:start_link(),\n     timer:sleep(100),\n-    \n+\n     %% Transport should still be functional\n     ?assert(is_process_alive(Pid)),\n     {ok, State} = gen_server:call(Pid, get_state),\n     ?assertEqual(ok, Module:send(State, <<\"failover test\">>)),\n-    \n+\n     ct:pal(\"Transport survived registry failover\"),\n-    \n+\n     ok = gen_server:stop(Pid),\n     ok.\n \n %%====================================================================\n-%% Message Routing Tests  \n+%% Message Routing Tests\n %%====================================================================\n \n message_routing_basic(Config) ->\n     TransportId = ?config(transport_id, Config),\n     ServerId = test_server_basic,\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     MockServer = spawn_mock_server(ServerId),\n-    \n-    {ok, Pid} = Module:start_link(TransportId, #{\n-        test_mode => true,\n-        server_id => ServerId\n-    }),\n+\n+    {ok, Pid} = Module:start_link(TransportId, #{test_mode => true, server_id => ServerId}),\n     timer:sleep(100),\n-    \n+\n     %% Test basic message routing\n     TestMessage = <<\"basic routing test\">>,\n     gen_server:call(Pid, {simulate_input, TestMessage}),\n-    \n+\n     receive\n         {mock_server_message, ServerId, ReceivedMessage} ->\n             ?assertEqual(TestMessage, ReceivedMessage)\n     after 1000 ->\n         throw({basic_routing_timeout, ServerId})\n     end,\n-    \n+\n     cleanup_mock_server(MockServer),\n     ok = gen_server:stop(Pid),\n     ok.\n \n message_routing_json_rpc(Config) ->\n     TransportId = ?config(transport_id, Config),\n     ServerId = test_server_jsonrpc,\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     MockServer = spawn_mock_server(ServerId),\n-    \n-    {ok, Pid} = Module:start_link(TransportId, #{\n-        test_mode => true,\n-        server_id => ServerId\n-    }),\n+\n+    {ok, Pid} = Module:start_link(TransportId, #{test_mode => true, server_id => ServerId}),\n     timer:sleep(100),\n-    \n+\n     %% Test JSON-RPC message routing\n-    JsonRpcMessage = jsx:encode(#{\n-        <<\"jsonrpc\">> => <<\"2.0\">>,\n-        <<\"method\">> => <<\"test.method\">>,\n-        <<\"params\">> => #{<<\"key\">> => <<\"value\">>},\n-        <<\"id\">> => <<\"test-123\">>\n-    }),\n-    \n+    JsonRpcMessage =\n+        jsx:encode(#{<<\"jsonrpc\">> => <<\"2.0\">>,\n+                     <<\"method\">> => <<\"test.method\">>,\n+                     <<\"params\">> => #{<<\"key\">> => <<\"value\">>},\n+                     <<\"id\">> => <<\"test-123\">>}),\n+\n     gen_server:call(Pid, {simulate_input, JsonRpcMessage}),\n-    \n+\n     receive\n         {mock_server_message, ServerId, ReceivedMessage} ->\n             ?assertEqual(JsonRpcMessage, ReceivedMessage),\n             %% Verify it's valid JSON-RPC\n@@ -653,151 +589,150 @@\n             ?assertMatch(#{<<\"jsonrpc\">> := <<\"2.0\">>}, Decoded)\n     after 1000 ->\n         throw({jsonrpc_routing_timeout, ServerId})\n     end,\n-    \n+\n     cleanup_mock_server(MockServer),\n     ok = gen_server:stop(Pid),\n     ok.\n \n message_routing_large_messages(Config) ->\n     TransportId = ?config(transport_id, Config),\n     ServerId = test_server_large,\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     MockServer = spawn_mock_server(ServerId),\n-    \n-    {ok, Pid} = Module:start_link(TransportId, #{\n-        test_mode => true,\n-        server_id => ServerId\n-    }),\n+\n+    {ok, Pid} = Module:start_link(TransportId, #{test_mode => true, server_id => ServerId}),\n     timer:sleep(100),\n-    \n+\n     %% Create large message (1MB)\n     LargeMessage = binary:copy(<<\"X\">>, 1024 * 1024),\n     gen_server:call(Pid, {simulate_input, LargeMessage}),\n-    \n+\n     receive\n         {mock_server_message, ServerId, ReceivedMessage} ->\n             ?assertEqual(byte_size(LargeMessage), byte_size(ReceivedMessage)),\n             ct:pal(\"Large message (~p bytes) routed successfully\", [byte_size(ReceivedMessage)])\n     after 5000 ->\n         throw({large_message_routing_timeout, ServerId})\n     end,\n-    \n+\n     cleanup_mock_server(MockServer),\n     ok = gen_server:stop(Pid),\n     ok.\n \n message_routing_malformed_input(Config) ->\n     TransportId = ?config(transport_id, Config),\n     ServerId = test_server_malformed,\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     MockServer = spawn_mock_server(ServerId),\n-    \n-    {ok, Pid} = Module:start_link(TransportId, #{\n-        test_mode => true,\n-        server_id => ServerId\n-    }),\n+\n+    {ok, Pid} = Module:start_link(TransportId, #{test_mode => true, server_id => ServerId}),\n     timer:sleep(100),\n-    \n+\n     %% Test various malformed inputs\n-    MalformedInputs = [\n-        <<>>,                           % Empty\n-        <<\"\\n\">>,                       % Just newline\n-        <<\"\\r\\n\">>,                     % Just CRLF\n-        <<\"   \\n\">>,                    % Just whitespace\n-        <<\"incomplete line without\">>, % No newline\n-        <<\"multi\\nline\\ninput\">>       % Multiple lines\n-    ],\n-    \n-    lists:foreach(fun(Input) ->\n-        gen_server:call(Pid, {simulate_input, Input})\n-    end, MalformedInputs),\n-    \n+    MalformedInputs =\n+        [<<>>,                           % Empty\n+         <<\"\\n\">>,                       % Just newline\n+         <<\"\\r\\n\">>,                     % Just CRLF\n+         <<\"   \\n\">>,                    % Just whitespace\n+         <<\"incomplete line without\">>, % No newline\n+         <<\"multi\\nline\\ninput\">>],       % Multiple lines\n+\n+    lists:foreach(fun(Input) -> gen_server:call(Pid, {simulate_input, Input}) end,\n+                  MalformedInputs),\n+\n     %% Should not crash and should handle gracefully\n     timer:sleep(200),\n     ?assert(is_process_alive(Pid)),\n-    \n+\n     ct:pal(\"Malformed input handled gracefully\"),\n-    \n+\n     cleanup_mock_server(MockServer),\n     ok = gen_server:stop(Pid),\n     ok.\n \n message_routing_buffer_management(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     {ok, Pid} = Module:start_link(TransportId, #{test_mode => true}),\n-    \n+\n     %% Test buffer state management\n     {ok, InitialState} = gen_server:call(Pid, get_state),\n     InitialBuffer = maps:get(buffer, InitialState, <<>>),\n     ?assertEqual(<<>>, InitialBuffer),\n-    \n+\n     ct:pal(\"Buffer properly initialized as empty\"),\n-    \n+\n     ok = gen_server:stop(Pid),\n     ok.\n \n message_routing_line_processing(Config) ->\n     TransportId = ?config(transport_id, Config),\n     Module = erlmcp_transport_stdio_new,\n-    \n+\n     %% Test line trimming directly\n-    TestCases = [\n-        {<<\"hello world\">>, <<\"hello world\">>},\n-        {<<\"hello world\\n\">>, <<\"hello world\">>},\n-        {<<\"hello world\\r\\n\">>, <<\"hello world\">>},\n-        {<<\"hello world\\r\">>, <<\"hello world\">>},\n-        {<<\"\\n\">>, <<>>},\n-        {<<\"\\r\\n\">>, <<>>},\n-        {<<>>, <<>>}\n-    ],\n-    \n+    TestCases =\n+        [{<<\"hello world\">>, <<\"hello world\">>},\n+         {<<\"hello world\\n\">>, <<\"hello world\">>},\n+         {<<\"hello world\\r\\n\">>, <<\"hello world\">>},\n+         {<<\"hello world\\r\">>, <<\"hello world\">>},\n+         {<<\"\\n\">>, <<>>},\n+         {<<\"\\r\\n\">>, <<>>},\n+         {<<>>, <<>>}],\n+\n     lists:foreach(fun({Input, Expected}) ->\n-        Result = Module:trim_line(Input),\n-        ?assertEqual(Expected, Result),\n-        ct:pal(\"Line trimming: ~p -> ~p\", [Input, Result])\n-    end, TestCases),\n-    \n+                     Result = Module:trim_line(Input),\n+                     ?assertEqual(Expected, Result),\n+                     ct:pal(\"Line trimming: ~p -> ~p\", [Input, Result])\n+                  end,\n+                  TestCases),\n+\n     ok.\n \n %%====================================================================\n %% Helper Functions\n %%====================================================================\n \n cleanup_test_resources(_Config) ->\n     %% Kill any registered test processes\n-    TestProcesses = [test_server_routing, test_server_basic, test_server_jsonrpc,\n-                    test_server_large, test_server_malformed, test_server_config],\n-    \n+    TestProcesses =\n+        [test_server_routing,\n+         test_server_basic,\n+         test_server_jsonrpc,\n+         test_server_large,\n+         test_server_malformed,\n+         test_server_config],\n+\n     lists:foreach(fun(Name) ->\n-        case whereis(Name) of\n-            undefined -> ok;\n-            Pid -> exit(Pid, kill)\n-        end\n-    end, TestProcesses),\n-    \n+                     case whereis(Name) of\n+                         undefined -> ok;\n+                         Pid -> exit(Pid, kill)\n+                     end\n+                  end,\n+                  TestProcesses),\n+\n     timer:sleep(50).\n \n spawn_mock_server(ServerId) ->\n     Parent = self(),\n     Pid = spawn(fun() ->\n-        register(ServerId, self()),\n-        mock_server_loop(Parent, ServerId)\n-    end),\n-    \n+                   register(ServerId, self()),\n+                   mock_server_loop(Parent, ServerId)\n+                end),\n+\n     %% Register with registry if available\n     case whereis(erlmcp_registry) of\n-        undefined -> ok;\n+        undefined ->\n+            ok;\n         _ ->\n             Config = #{capabilities => #{}, options => #{}},\n             erlmcp_registry:register_server(ServerId, Pid, Config)\n     end,\n-    \n+\n     Pid.\n \n mock_server_loop(Parent, ServerId) ->\n     receive\n@@ -805,63 +740,154 @@\n             Parent ! {mock_server_message, ServerId, Message},\n             mock_server_loop(Parent, ServerId);\n         stop ->\n             case whereis(erlmcp_registry) of\n-                undefined -> ok;\n-                _ -> erlmcp_registry:unregister_server(ServerId)\n+                undefined ->\n+                    ok;\n+                _ ->\n+                    erlmcp_registry:unregister_server(ServerId)\n             end,\n             ok\n     end.\n \n cleanup_mock_server(Pid) ->\n     Pid ! stop,\n     timer:sleep(50).\n \n-typeof(Term) when is_binary(Term) -> binary;\n-typeof(Term) when is_list(Term) -> list;\n-typeof(Term) when is_atom(Term) -> atom;\n-typeof(_) -> unknown.\n+typeof(Term) when is_binary(Term) ->\n+    binary;\n+typeof(Term) when is_list(Term) ->\n+    list;\n+typeof(Term) when is_atom(Term) ->\n+    atom;\n+typeof(_) ->\n+    unknown.\n \n %%====================================================================\n %% Remaining Test Placeholders (Connection, Error Recovery, etc.)\n %% These would be implemented similarly to the above patterns\n %%====================================================================\n \n %% Connection handling tests\n-connection_stdio_mode(_Config) -> ct:pal(\"Connection stdio mode test\"), ok.\n-connection_test_mode(_Config) -> ct:pal(\"Connection test mode test\"), ok.\n-connection_reader_lifecycle(_Config) -> ct:pal(\"Reader lifecycle test\"), ok.\n-connection_process_supervision(_Config) -> ct:pal(\"Process supervision test\"), ok.\n-connection_graceful_shutdown(_Config) -> ct:pal(\"Graceful shutdown test\"), ok.\n-connection_abnormal_termination(_Config) -> ct:pal(\"Abnormal termination test\"), ok.\n+connection_stdio_mode(_Config) ->\n+    ct:pal(\"Connection stdio mode test\"),\n+    ok.\n \n-%% Error recovery tests  \n-error_recovery_reader_crash(_Config) -> ct:pal(\"Reader crash recovery test\"), ok.\n-error_recovery_invalid_messages(_Config) -> ct:pal(\"Invalid message recovery test\"), ok.\n-error_recovery_routing_failures(_Config) -> ct:pal(\"Routing failure recovery test\"), ok.\n-error_recovery_registry_unavailable(_Config) -> ct:pal(\"Registry unavailable recovery test\"), ok.\n-error_recovery_resource_exhaustion(_Config) -> ct:pal(\"Resource exhaustion recovery test\"), ok.\n-error_recovery_state_corruption(_Config) -> ct:pal(\"State corruption recovery test\"), ok.\n+connection_test_mode(_Config) ->\n+    ct:pal(\"Connection test mode test\"),\n+    ok.\n \n+connection_reader_lifecycle(_Config) ->\n+    ct:pal(\"Reader lifecycle test\"),\n+    ok.\n+\n+connection_process_supervision(_Config) ->\n\\ No newline at end of file\n+    ct:pal(\"Process supervision test\"),\n+    ok.\n+\n+connection_graceful_shutdown(_Config) ->\n+    ct:pal(\"Graceful shutdown test\"),\n+    ok.\n+\n+connection_abnormal_termination(_Config) ->\n+    ct:pal(\"Abnormal termination test\"),\n+    ok.\n+\n+%% Error recovery tests\n+error_recovery_reader_crash(_Config) ->\n+    ct:pal(\"Reader crash recovery test\"),\n+    ok.\n+\n+error_recovery_invalid_messages(_Config) ->\n+    ct:pal(\"Invalid message recovery test\"),\n+    ok.\n+\n+error_recovery_routing_failures(_Config) ->\n+    ct:pal(\"Routing failure recovery test\"),\n+    ok.\n+\n+error_recovery_registry_unavailable(_Config) ->\n+    ct:pal(\"Registry unavailable recovery test\"),\n+    ok.\n+\n+error_recovery_resource_exhaustion(_Config) ->\n+    ct:pal(\"Resource exhaustion recovery test\"),\n+    ok.\n+\n+error_recovery_state_corruption(_Config) ->\n+    ct:pal(\"State corruption recovery test\"),\n+    ok.\n+\n %% Resource cleanup tests\n-resource_cleanup_normal_shutdown(_Config) -> ct:pal(\"Normal shutdown cleanup test\"), ok.\n-resource_cleanup_forced_termination(_Config) -> ct:pal(\"Forced termination cleanup test\"), ok.\n-resource_cleanup_reader_cleanup(_Config) -> ct:pal(\"Reader cleanup test\"), ok.\n-resource_cleanup_memory_leaks(_Config) -> ct:pal(\"Memory leak detection test\"), ok.\n-resource_cleanup_process_monitoring(_Config) -> ct:pal(\"Process monitoring test\"), ok.\n-resource_cleanup_port_management(_Config) -> ct:pal(\"Port management test\"), ok.\n+resource_cleanup_normal_shutdown(_Config) ->\n+    ct:pal(\"Normal shutdown cleanup test\"),\n+    ok.\n \n+resource_cleanup_forced_termination(_Config) ->\n+    ct:pal(\"Forced termination cleanup test\"),\n+    ok.\n+\n+resource_cleanup_reader_cleanup(_Config) ->\n+    ct:pal(\"Reader cleanup test\"),\n+    ok.\n+\n+resource_cleanup_memory_leaks(_Config) ->\n+    ct:pal(\"Memory leak detection test\"),\n+    ok.\n+\n+resource_cleanup_process_monitoring(_Config) ->\n+    ct:pal(\"Process monitoring test\"),\n+    ok.\n+\n+resource_cleanup_port_management(_Config) ->\n+    ct:pal(\"Port management test\"),\n+    ok.\n+\n %% Performance tests\n-performance_throughput_measurement(_Config) -> ct:pal(\"Throughput measurement test\"), ok.\n-performance_latency_measurement(_Config) -> ct:pal(\"Latency measurement test\"), ok.\n-performance_memory_efficiency(_Config) -> ct:pal(\"Memory efficiency test\"), ok.\n-performance_concurrent_access(_Config) -> ct:pal(\"Concurrent access test\"), ok.\n-performance_high_volume_messages(_Config) -> ct:pal(\"High volume message test\"), ok.\n-performance_resource_scaling(_Config) -> ct:pal(\"Resource scaling test\"), ok.\n+performance_throughput_measurement(_Config) ->\n+    ct:pal(\"Throughput measurement test\"),\n+    ok.\n \n+performance_latency_measurement(_Config) ->\n+    ct:pal(\"Latency measurement test\"),\n+    ok.\n+\n+performance_memory_efficiency(_Config) ->\n+    ct:pal(\"Memory efficiency test\"),\n+    ok.\n+\n+performance_concurrent_access(_Config) ->\n+    ct:pal(\"Concurrent access test\"),\n+    ok.\n+\n+performance_high_volume_messages(_Config) ->\n+    ct:pal(\"High volume message test\"),\n+    ok.\n+\n+performance_resource_scaling(_Config) ->\n+    ct:pal(\"Resource scaling test\"),\n+    ok.\n+\n %% Buffer management tests\n-buffer_partial_messages(_Config) -> ct:pal(\"Partial message buffer test\"), ok.\n-buffer_overflow_handling(_Config) -> ct:pal(\"Buffer overflow test\"), ok.\n-buffer_line_boundary_detection(_Config) -> ct:pal(\"Line boundary detection test\"), ok.\n-buffer_unicode_handling(_Config) -> ct:pal(\"Unicode handling test\"), ok.\n-buffer_memory_efficiency(_Config) -> ct:pal(\"Buffer memory efficiency test\"), ok.\n-buffer_concurrent_access(_Config) -> ct:pal(\"Buffer concurrent access test\"), ok.\n+buffer_partial_messages(_Config) ->\n+    ct:pal(\"Partial message buffer test\"),\n+    ok.\n+\n+buffer_overflow_handling(_Config) ->\n+    ct:pal(\"Buffer overflow test\"),\n+    ok.\n+\n+buffer_line_boundary_detection(_Config) ->\n+    ct:pal(\"Line boundary detection test\"),\n+    ok.\n+\n+buffer_unicode_handling(_Config) ->\n+    ct:pal(\"Unicode handling test\"),\n+    ok.\n+\n+buffer_memory_efficiency(_Config) ->\n+    ct:pal(\"Buffer memory efficiency test\"),\n+    ok.\n+\n+buffer_concurrent_access(_Config) ->\n+    ct:pal(\"Buffer concurrent access test\"),\n+    ok.\n"
                }
            ],
            "date": 1756185314751,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @doc\n%%% Standard Test Suite for STDIO Transport Implementation\n%%%\n%%% This comprehensive test suite validates the STDIO transport against\n%%% standardized behavior requirements, registry integration, and\n%%% performance specifications.\n%%%\n%%% Test Categories:\n%%% - Behavior compliance\n%%% - Registry integration\n%%% - Message routing\n%%% - Error recovery\n%%% - Performance requirements\n%%% - Resource management\n%%%-------------------------------------------------------------------\n-module(erlmcp_transport_stdio_standard_SUITE).\n\n-include_lib(\"common_test/include/ct.hrl\").\n-include_lib(\"eunit/include/eunit.hrl\").\n-include(\"erlmcp.hrl\").\n\n%% Suite callbacks\n-export([all/0, groups/0, init_per_suite/1, end_per_suite/1,\n         init_per_group/2, end_per_group/2,\n         init_per_testcase/2, end_per_testcase/2]).\n\n%% Behavior compliance tests\n-export([\n    behavior_init_compliance/1,\n    behavior_send_compliance/1,\n    behavior_close_compliance/1,\n    behavior_get_info_compliance/1,\n    behavior_handle_transport_call_compliance/1,\n    behavior_exports_validation/1,\n    behavior_return_types/1\n]).\n\n%% Registry integration tests  \n-export([\n    registry_auto_registration/1,\n    registry_auto_unregistration/1,\n    registry_message_routing/1,\n    registry_transport_discovery/1,\n    registry_configuration_propagation/1,\n    registry_failover_handling/1\n]).\n\n%% Message routing tests\n-export([\n    message_routing_basic/1,\n    message_routing_json_rpc/1,\n    message_routing_large_messages/1,\n    message_routing_malformed_input/1,\n    message_routing_buffer_management/1,\n    message_routing_line_processing/1\n]).\n\n%% Connection handling tests\n-export([\n    connection_stdio_mode/1,\n    connection_test_mode/1,\n    connection_reader_lifecycle/1,\n    connection_process_supervision/1,\n    connection_graceful_shutdown/1,\n    connection_abnormal_termination/1\n]).\n\n%% Error recovery tests\n-export([\n    error_recovery_reader_crash/1,\n    error_recovery_invalid_messages/1,\n    error_recovery_routing_failures/1,\n    error_recovery_registry_unavailable/1,\n    error_recovery_resource_exhaustion/1,\n    error_recovery_state_corruption/1\n]).\n\n%% Resource cleanup tests\n-export([\n    resource_cleanup_normal_shutdown/1,\n    resource_cleanup_forced_termination/1,\n    resource_cleanup_reader_cleanup/1,\n    resource_cleanup_memory_leaks/1,\n    resource_cleanup_process_monitoring/1,\n    resource_cleanup_port_management/1\n]).\n\n%% Performance tests\n-export([\n    performance_throughput_measurement/1,\n    performance_latency_measurement/1,\n    performance_memory_efficiency/1,\n    performance_concurrent_access/1,\n    performance_high_volume_messages/1,\n    performance_resource_scaling/1\n]).\n\n%% Buffer management tests\n-export([\n    buffer_partial_messages/1,\n    buffer_overflow_handling/1,\n    buffer_line_boundary_detection/1,\n    buffer_unicode_handling/1,\n    buffer_memory_efficiency/1,\n    buffer_concurrent_access/1\n]).\n\n%%====================================================================\n%% Suite Configuration\n%%====================================================================\n\nall() ->\n    [\n        {group, behavior_compliance},\n        {group, registry_integration},\n        {group, message_routing},\n        {group, connection_handling},\n        {group, error_recovery},\n        {group, resource_cleanup},\n        {group, performance},\n        {group, buffer_management}\n    ].\n\ngroups() ->\n    [\n        {behavior_compliance, [sequential], [\n            behavior_exports_validation,\n            behavior_init_compliance,\n            behavior_send_compliance,\n            behavior_close_compliance,\n            behavior_get_info_compliance,\n            behavior_handle_transport_call_compliance,\n            behavior_return_types\n        ]},\n        {registry_integration, [sequential], [\n            registry_auto_registration,\n            registry_auto_unregistration,\n            registry_message_routing,\n            registry_transport_discovery,\n            registry_configuration_propagation,\n            registry_failover_handling\n        ]},\n        {message_routing, [parallel], [\n            message_routing_basic,\n            message_routing_json_rpc,\n            message_routing_large_messages,\n            message_routing_malformed_input,\n            message_routing_buffer_management,\n            message_routing_line_processing\n        ]},\n        {connection_handling, [sequential], [\n            connection_stdio_mode,\n            connection_test_mode,\n            connection_reader_lifecycle,\n            connection_process_supervision,\n            connection_graceful_shutdown,\n            connection_abnormal_termination\n        ]},\n        {error_recovery, [sequential], [\n            error_recovery_reader_crash,\n            error_recovery_invalid_messages,\n            error_recovery_routing_failures,\n            error_recovery_registry_unavailable,\n            error_recovery_resource_exhaustion,\n            error_recovery_state_corruption\n        ]},\n        {resource_cleanup, [sequential], [\n            resource_cleanup_normal_shutdown,\n            resource_cleanup_forced_termination,\n            resource_cleanup_reader_cleanup,\n            resource_cleanup_memory_leaks,\n            resource_cleanup_process_monitoring,\n            resource_cleanup_port_management\n        ]},\n        {performance, [sequential], [\n            performance_throughput_measurement,\n            performance_latency_measurement,\n            performance_memory_efficiency,\n            performance_concurrent_access,\n            performance_high_volume_messages,\n            performance_resource_scaling\n        ]},\n        {buffer_management, [parallel], [\n            buffer_partial_messages,\n            buffer_overflow_handling,\n            buffer_line_boundary_detection,\n            buffer_unicode_handling,\n            buffer_memory_efficiency,\n            buffer_concurrent_access\n        ]}\n    ].\n\n%%====================================================================\n%% Suite Setup/Teardown\n%%====================================================================\n\ninit_per_suite(Config) ->\n    ct:pal(\"Starting STDIO transport standard test suite\"),\n    \n    %% Start required applications\n    ok = application:ensure_started(crypto),\n    ok = application:ensure_started(sasl),\n    \n    %% Initialize registry\n    case erlmcp_registry:start_link() of\n        {ok, _} -> ok;\n        {error, {already_started, _}} -> ok\n    end,\n    \n    %% Enable test environment\n    put(test_mode, true),\n    \n    [{test_module, erlmcp_transport_stdio_new}, {test_mode, true} | Config].\n\nend_per_suite(_Config) ->\n    ct:pal(\"Ending STDIO transport standard test suite\"),\n    ok.\n\ninit_per_group(GroupName, Config) ->\n    ct:pal(\"Starting group: ~p\", [GroupName]),\n    Config.\n\nend_per_group(GroupName, _Config) ->\n    ct:pal(\"Ending group: ~p\", [GroupName]),\n    ok.\n\ninit_per_testcase(TestCase, Config) ->\n    ct:pal(\"Starting test case: ~p\", [TestCase]),\n    %% Generate unique transport ID for this test\n    TransportId = list_to_atom(lists:flatten(io_lib:format(\"~p_~p\", [TestCase, erlang:unique_integer([positive])]))),\n    [{transport_id, TransportId} | Config].\n\nend_per_testcase(TestCase, Config) ->\n    ct:pal(\"Ending test case: ~p\", [TestCase]),\n    %% Cleanup any processes or resources\n    cleanup_test_resources(Config),\n    ok.\n\n%%====================================================================\n%% Behavior Compliance Tests\n%%====================================================================\n\nbehavior_exports_validation(Config) ->\n    Module = erlmcp_transport_stdio_new,\n    \n    %% Required exports\n    RequiredExports = [\n        {init, 1},\n        {send, 2},\n        {close, 1}\n    ],\n    \n    %% Optional exports\n    OptionalExports = [\n        {get_info, 1},\n        {handle_transport_call, 2}\n    ],\n    \n    ModuleExports = Module:module_info(exports),\n    \n    %% Verify required exports\n    lists:foreach(fun(Export) ->\n        ?assert(lists:member(Export, ModuleExports)),\n        ct:pal(\"Required export ~p found\", [Export])\n    end, RequiredExports),\n    \n    %% Check optional exports\n    lists:foreach(fun(Export) ->\n        case lists:member(Export, ModuleExports) of\n            true -> ct:pal(\"Optional export ~p implemented\", [Export]);\n            false -> ct:pal(\"Optional export ~p not implemented\", [Export])\n        end\n    end, OptionalExports),\n    \n    ok.\n\nbehavior_init_compliance(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = erlmcp_transport_stdio_new,\n    \n    %% Test valid initialization\n    ValidOpts = #{test_mode => true, transport_id => TransportId},\n    {ok, State} = Module:init(ValidOpts),\n    ?assert(State =/= undefined),\n    ct:pal(\"Init successful with state type: ~p\", [element(1, State)]),\n    \n    %% Test initialization with minimal options\n    MinimalOpts = #{},\n    {ok, _MinimalState} = Module:init(MinimalOpts),\n    ct:pal(\"Init successful with minimal options\"),\n    \n    %% Test initialization with server binding\n    ServerOpts = #{test_mode => true, server_id => test_server},\n    {ok, _ServerState} = Module:init(ServerOpts),\n    ct:pal(\"Init successful with server binding\"),\n    \n    ok.\n\nbehavior_send_compliance(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = erlmcp_transport_stdio_new,\n    \n    {ok, State} = Module:init(#{test_mode => true, transport_id => TransportId}),\n    \n    %% Test various data types\n    TestData = [\n        <<\"binary message\">>,\n        \"string message\",\n        [<<\"iodata \">>, <<\"message\">>],\n        []\n    ],\n    \n    lists:foreach(fun(Data) ->\n        Result = Module:send(State, Data),\n        ?assertEqual(ok, Result),\n        ct:pal(\"Send successful for data type: ~p\", [typeof(Data)])\n    end, TestData),\n    \n    %% Test JSON-RPC message\n    JsonMessage = jsx:encode(#{\n        <<\"jsonrpc\">> => <<\"2.0\">>,\n        <<\"method\">> => <<\"test.method\">>,\n        <<\"params\">> => #{},\n        <<\"id\">> => <<\"test-1\">>\n    }),\n    ?assertEqual(ok, Module:send(State, JsonMessage)),\n    ct:pal(\"Send successful for JSON-RPC message\"),\n    \n    ok.\n\nbehavior_close_compliance(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = erlmcp_transport_stdio_new,\n    \n    %% Test close with reader process\n    {ok, State1} = Module:init(#{test_mode => false, transport_id => TransportId}),\n    Result1 = Module:close(State1),\n    ?assertEqual(ok, Result1),\n    ct:pal(\"Close successful with reader process\"),\n    \n    %% Test close without reader process (test mode)\n    {ok, State2} = Module:init(#{test_mode => true, transport_id => TransportId}),\n    Result2 = Module:close(State2),\n    ?assertEqual(ok, Result2),\n    ct:pal(\"Close successful in test mode\"),\n    \n    %% Test idempotent close\n    Result3 = Module:close(State2),\n    ?assertEqual(ok, Result3),\n    ct:pal(\"Close is idempotent\"),\n    \n    ok.\n\nbehavior_get_info_compliance(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = erlmcp_transport_stdio_new,\n    \n    {ok, State} = Module:init(#{test_mode => true, transport_id => TransportId}),\n    \n    Info = Module:get_info(State),\n    ?assert(is_map(Info)),\n    \n    %% Required fields\n    ?assertMatch(#{type := stdio}, Info),\n    ?assert(maps:is_key(status, Info)),\n    \n    ct:pal(\"Transport info: ~p\", [Info]),\n    ok.\n\nbehavior_handle_transport_call_compliance(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = erlmcp_transport_stdio_new,\n    \n    {ok, State} = Module:init(#{test_mode => true, transport_id => TransportId}),\n    \n    %% Test valid transport calls\n    ValidCalls = [\n        get_buffer,\n        get_test_mode,\n        get_reader_pid\n    ],\n    \n    lists:foreach(fun(Call) ->\n        case Module:handle_transport_call(Call, State) of\n            {reply, Reply, NewState} ->\n                ct:pal(\"Transport call ~p replied: ~p\", [Call, Reply]);\n            {error, Reason} ->\n                ct:pal(\"Transport call ~p failed: ~p\", [Call, Reason])\n        end\n    end, ValidCalls),\n    \n    %% Test invalid call\n    case Module:handle_transport_call(invalid_call, State) of\n        {reply, _, _} ->\n            ct:pal(\"Warning: Invalid call was accepted\");\n        {error, unknown_transport_request} ->\n            ct:pal(\"Invalid call properly rejected\")\n    end,\n    \n    ok.\n\nbehavior_return_types(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = erlmcp_transport_stdio_new,\n    \n    %% Test init return types (avoid binding variables used later)\n    case Module:init(#{test_mode => true, transport_id => TransportId}) of\n        {ok, S1} when S1 =/= undefined -> ok;\n        {error, _} -> ok;\n        Other -> throw({invalid_init_return, Other})\n    end,\n    \n    {ok, State} = Module:init(#{test_mode => true, transport_id => TransportId}),\n    \n    %% Test send return types\n    case Module:send(State, <<\"test\">>) of\n        ok -> ok;\n        {error, _} -> ok;\n        Other2 -> throw({invalid_send_return, Other2})\n    end,\n    \n    %% Test close return types\n    case Module:close(State) of\n        ok -> ok;\n        Other3 -> throw({invalid_close_return, Other3})\n    end,\n    \n    ct:pal(\"All return types conform to behavior specification\"),\n    ok.\n\n%%====================================================================\n%% Registry Integration Tests\n%%====================================================================\n\nregistry_auto_registration(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = erlmcp_transport_stdio_new,\n    \n    %% Start transport and verify auto-registration\n    {ok, Pid} = Module:start_link(TransportId, #{test_mode => true}),\n    timer:sleep(100), % Allow registration to complete\n    \n    case erlmcp_registry:find_transport(TransportId) of\n        {ok, {RegPid, RegConfig}} ->\n            ?assertEqual(Pid, RegPid),\n            ?assert(is_map(RegConfig)),\n            ct:pal(\"Transport auto-registered successfully\");\n        {error, not_found} ->\n            throw({registration_failed, TransportId})\n    end,\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nregistry_auto_unregistration(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = erlmcp_transport_stdio_new,\n    \n    {ok, Pid} = Module:start_link(TransportId, #{test_mode => true}),\n    timer:sleep(100),\n    \n    %% Verify registered\n    {ok, _} = erlmcp_registry:find_transport(TransportId),\n    \n    %% Stop and verify unregistration\n    ok = gen_server:stop(Pid),\n    timer:sleep(100),\n    \n    case erlmcp_registry:find_transport(TransportId) of\n        {error, not_found} ->\n            ct:pal(\"Transport auto-unregistered successfully\");\n        {ok, _} ->\n            throw({unregistration_failed, TransportId})\n    end,\n    \n    ok.\n\nregistry_message_routing(Config) ->\n    TransportId = ?config(transport_id, Config),\n    ServerId = test_server_routing,\n    Module = erlmcp_transport_stdio_new,\n    \n    %% Start mock server\n    MockServer = spawn_mock_server(ServerId),\n    \n    %% Start transport with server binding\n    {ok, Pid} = Module:start_link(TransportId, #{\n        test_mode => true,\n        server_id => ServerId\n    }),\n    timer:sleep(100),\n    \n    %% Simulate input message\n    TestMessage = <<\"registry routing test\">>,\n    gen_server:call(Pid, {simulate_input, TestMessage}),\n    \n    %% Verify server received message\n    receive\n        {mock_server_message, ServerId, ReceivedMessage} ->\n            ?assertEqual(TestMessage, ReceivedMessage),\n            ct:pal(\"Message routed successfully through registry\")\n    after 1000 ->\n        throw({message_routing_timeout, ServerId})\n    end,\n    \n    cleanup_mock_server(MockServer),\n    ok = gen_server:stop(Pid),\n    ok.\n\nregistry_transport_discovery(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = erlmcp_transport_stdio_new,\n    \n    %% Start multiple transports\n    TransportIds = [\n        list_to_atom(atom_to_list(TransportId) ++ \"_1\"),\n        list_to_atom(atom_to_list(TransportId) ++ \"_2\"),\n        list_to_atom(atom_to_list(TransportId) ++ \"_3\")\n    ],\n    \n    Pids = [begin\n        {ok, Pid} = Module:start_link(Id, #{test_mode => true}),\n        Pid\n    end || Id <- TransportIds],\n    \n    timer:sleep(100),\n    \n    %% Verify all transports can be discovered\n    lists:foreach(fun(Id) ->\n        case erlmcp_registry:find_transport(Id) of\n            {ok, {Pid, _Config}} ->\n                ?assert(is_pid(Pid)),\n                ct:pal(\"Transport ~p discoverable\", [Id]);\n            {error, not_found} ->\n                throw({discovery_failed, Id})\n        end\n    end, TransportIds),\n    \n    %% Cleanup\n    lists:foreach(fun(Pid) -> ok = gen_server:stop(Pid) end, Pids),\n    ok.\n\nregistry_configuration_propagation(Config) ->\n    TransportId = ?config(transport_id, Config),\n    ServerId = test_server_config,\n    Module = erlmcp_transport_stdio_new,\n    \n    TestConfig = #{\n        test_mode => true,\n        server_id => ServerId,\n        custom_option => custom_value\n    },\n    \n    {ok, Pid} = Module:start_link(TransportId, TestConfig),\n    timer:sleep(100),\n    \n    %% Verify configuration is accessible through registry\n    {ok, {_RegPid, RegConfig}} = erlmcp_registry:find_transport(TransportId),\n    ?assertMatch(#{type := stdio}, RegConfig),\n    \n    ct:pal(\"Configuration propagated: ~p\", [RegConfig]),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nregistry_failover_handling(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = erlmcp_transport_stdio_new,\n    \n    %% Start transport\n    {ok, Pid} = Module:start_link(TransportId, #{test_mode => true}),\n    timer:sleep(100),\n    \n    %% Simulate registry failure/restart\n    erlmcp_registry:stop(),\n    timer:sleep(100),\n    \n    %% Restart registry\n    {ok, _} = erlmcp_registry:start_link(),\n    timer:sleep(100),\n    \n    %% Transport should still be functional\n    ?assert(is_process_alive(Pid)),\n    {ok, State} = gen_server:call(Pid, get_state),\n    ?assertEqual(ok, Module:send(State, <<\"failover test\">>)),\n    \n    ct:pal(\"Transport survived registry failover\"),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\n%%====================================================================\n%% Message Routing Tests  \n%%====================================================================\n\nmessage_routing_basic(Config) ->\n    TransportId = ?config(transport_id, Config),\n    ServerId = test_server_basic,\n    Module = erlmcp_transport_stdio_new,\n    \n    MockServer = spawn_mock_server(ServerId),\n    \n    {ok, Pid} = Module:start_link(TransportId, #{\n        test_mode => true,\n        server_id => ServerId\n    }),\n    timer:sleep(100),\n    \n    %% Test basic message routing\n    TestMessage = <<\"basic routing test\">>,\n    gen_server:call(Pid, {simulate_input, TestMessage}),\n    \n    receive\n        {mock_server_message, ServerId, ReceivedMessage} ->\n            ?assertEqual(TestMessage, ReceivedMessage)\n    after 1000 ->\n        throw({basic_routing_timeout, ServerId})\n    end,\n    \n    cleanup_mock_server(MockServer),\n    ok = gen_server:stop(Pid),\n    ok.\n\nmessage_routing_json_rpc(Config) ->\n    TransportId = ?config(transport_id, Config),\n    ServerId = test_server_jsonrpc,\n    Module = erlmcp_transport_stdio_new,\n    \n    MockServer = spawn_mock_server(ServerId),\n    \n    {ok, Pid} = Module:start_link(TransportId, #{\n        test_mode => true,\n        server_id => ServerId\n    }),\n    timer:sleep(100),\n    \n    %% Test JSON-RPC message routing\n    JsonRpcMessage = jsx:encode(#{\n        <<\"jsonrpc\">> => <<\"2.0\">>,\n        <<\"method\">> => <<\"test.method\">>,\n        <<\"params\">> => #{<<\"key\">> => <<\"value\">>},\n        <<\"id\">> => <<\"test-123\">>\n    }),\n    \n    gen_server:call(Pid, {simulate_input, JsonRpcMessage}),\n    \n    receive\n        {mock_server_message, ServerId, ReceivedMessage} ->\n            ?assertEqual(JsonRpcMessage, ReceivedMessage),\n            %% Verify it's valid JSON-RPC\n            Decoded = jsx:decode(ReceivedMessage, [return_maps]),\n            ?assertMatch(#{<<\"jsonrpc\">> := <<\"2.0\">>}, Decoded)\n    after 1000 ->\n        throw({jsonrpc_routing_timeout, ServerId})\n    end,\n    \n    cleanup_mock_server(MockServer),\n    ok = gen_server:stop(Pid),\n    ok.\n\nmessage_routing_large_messages(Config) ->\n    TransportId = ?config(transport_id, Config),\n    ServerId = test_server_large,\n    Module = erlmcp_transport_stdio_new,\n    \n    MockServer = spawn_mock_server(ServerId),\n    \n    {ok, Pid} = Module:start_link(TransportId, #{\n        test_mode => true,\n        server_id => ServerId\n    }),\n    timer:sleep(100),\n    \n    %% Create large message (1MB)\n    LargeMessage = binary:copy(<<\"X\">>, 1024 * 1024),\n    gen_server:call(Pid, {simulate_input, LargeMessage}),\n    \n    receive\n        {mock_server_message, ServerId, ReceivedMessage} ->\n            ?assertEqual(byte_size(LargeMessage), byte_size(ReceivedMessage)),\n            ct:pal(\"Large message (~p bytes) routed successfully\", [byte_size(ReceivedMessage)])\n    after 5000 ->\n        throw({large_message_routing_timeout, ServerId})\n    end,\n    \n    cleanup_mock_server(MockServer),\n    ok = gen_server:stop(Pid),\n    ok.\n\nmessage_routing_malformed_input(Config) ->\n    TransportId = ?config(transport_id, Config),\n    ServerId = test_server_malformed,\n    Module = erlmcp_transport_stdio_new,\n    \n    MockServer = spawn_mock_server(ServerId),\n    \n    {ok, Pid} = Module:start_link(TransportId, #{\n        test_mode => true,\n        server_id => ServerId\n    }),\n    timer:sleep(100),\n    \n    %% Test various malformed inputs\n    MalformedInputs = [\n        <<>>,                           % Empty\n        <<\"\\n\">>,                       % Just newline\n        <<\"\\r\\n\">>,                     % Just CRLF\n        <<\"   \\n\">>,                    % Just whitespace\n        <<\"incomplete line without\">>, % No newline\n        <<\"multi\\nline\\ninput\">>       % Multiple lines\n    ],\n    \n    lists:foreach(fun(Input) ->\n        gen_server:call(Pid, {simulate_input, Input})\n    end, MalformedInputs),\n    \n    %% Should not crash and should handle gracefully\n    timer:sleep(200),\n    ?assert(is_process_alive(Pid)),\n    \n    ct:pal(\"Malformed input handled gracefully\"),\n    \n    cleanup_mock_server(MockServer),\n    ok = gen_server:stop(Pid),\n    ok.\n\nmessage_routing_buffer_management(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = erlmcp_transport_stdio_new,\n    \n    {ok, Pid} = Module:start_link(TransportId, #{test_mode => true}),\n    \n    %% Test buffer state management\n    {ok, InitialState} = gen_server:call(Pid, get_state),\n    InitialBuffer = maps:get(buffer, InitialState, <<>>),\n    ?assertEqual(<<>>, InitialBuffer),\n    \n    ct:pal(\"Buffer properly initialized as empty\"),\n    \n    ok = gen_server:stop(Pid),\n    ok.\n\nmessage_routing_line_processing(Config) ->\n    TransportId = ?config(transport_id, Config),\n    Module = erlmcp_transport_stdio_new,\n    \n    %% Test line trimming directly\n    TestCases = [\n        {<<\"hello world\">>, <<\"hello world\">>},\n        {<<\"hello world\\n\">>, <<\"hello world\">>},\n        {<<\"hello world\\r\\n\">>, <<\"hello world\">>},\n        {<<\"hello world\\r\">>, <<\"hello world\">>},\n        {<<\"\\n\">>, <<>>},\n        {<<\"\\r\\n\">>, <<>>},\n        {<<>>, <<>>}\n    ],\n    \n    lists:foreach(fun({Input, Expected}) ->\n        Result = Module:trim_line(Input),\n        ?assertEqual(Expected, Result),\n        ct:pal(\"Line trimming: ~p -> ~p\", [Input, Result])\n    end, TestCases),\n    \n    ok.\n\n%%====================================================================\n%% Helper Functions\n%%====================================================================\n\ncleanup_test_resources(_Config) ->\n    %% Kill any registered test processes\n    TestProcesses = [test_server_routing, test_server_basic, test_server_jsonrpc,\n                    test_server_large, test_server_malformed, test_server_config],\n    \n    lists:foreach(fun(Name) ->\n        case whereis(Name) of\n            undefined -> ok;\n            Pid -> exit(Pid, kill)\n        end\n    end, TestProcesses),\n    \n    timer:sleep(50).\n\nspawn_mock_server(ServerId) ->\n    Parent = self(),\n    Pid = spawn(fun() ->\n        register(ServerId, self()),\n        mock_server_loop(Parent, ServerId)\n    end),\n    \n    %% Register with registry if available\n    case whereis(erlmcp_registry) of\n        undefined -> ok;\n        _ ->\n            Config = #{capabilities => #{}, options => #{}},\n            erlmcp_registry:register_server(ServerId, Pid, Config)\n    end,\n    \n    Pid.\n\nmock_server_loop(Parent, ServerId) ->\n    receive\n        {route_message, _TransportId, Message} ->\n            Parent ! {mock_server_message, ServerId, Message},\n            mock_server_loop(Parent, ServerId);\n        stop ->\n            case whereis(erlmcp_registry) of\n                undefined -> ok;\n                _ -> erlmcp_registry:unregister_server(ServerId)\n            end,\n            ok\n    end.\n\ncleanup_mock_server(Pid) ->\n    Pid ! stop,\n    timer:sleep(50).\n\ntypeof(Term) when is_binary(Term) -> binary;\ntypeof(Term) when is_list(Term) -> list;\ntypeof(Term) when is_atom(Term) -> atom;\ntypeof(_) -> unknown.\n\n%%====================================================================\n%% Remaining Test Placeholders (Connection, Error Recovery, etc.)\n%% These would be implemented similarly to the above patterns\n%%====================================================================\n\n%% Connection handling tests\nconnection_stdio_mode(_Config) -> ct:pal(\"Connection stdio mode test\"), ok.\nconnection_test_mode(_Config) -> ct:pal(\"Connection test mode test\"), ok.\nconnection_reader_lifecycle(_Config) -> ct:pal(\"Reader lifecycle test\"), ok.\nconnection_process_supervision(_Config) -> ct:pal(\"Process supervision test\"), ok.\nconnection_graceful_shutdown(_Config) -> ct:pal(\"Graceful shutdown test\"), ok.\nconnection_abnormal_termination(_Config) -> ct:pal(\"Abnormal termination test\"), ok.\n\n%% Error recovery tests  \nerror_recovery_reader_crash(_Config) -> ct:pal(\"Reader crash recovery test\"), ok.\nerror_recovery_invalid_messages(_Config) -> ct:pal(\"Invalid message recovery test\"), ok.\nerror_recovery_routing_failures(_Config) -> ct:pal(\"Routing failure recovery test\"), ok.\nerror_recovery_registry_unavailable(_Config) -> ct:pal(\"Registry unavailable recovery test\"), ok.\nerror_recovery_resource_exhaustion(_Config) -> ct:pal(\"Resource exhaustion recovery test\"), ok.\nerror_recovery_state_corruption(_Config) -> ct:pal(\"State corruption recovery test\"), ok.\n\n%% Resource cleanup tests\nresource_cleanup_normal_shutdown(_Config) -> ct:pal(\"Normal shutdown cleanup test\"), ok.\nresource_cleanup_forced_termination(_Config) -> ct:pal(\"Forced termination cleanup test\"), ok.\nresource_cleanup_reader_cleanup(_Config) -> ct:pal(\"Reader cleanup test\"), ok.\nresource_cleanup_memory_leaks(_Config) -> ct:pal(\"Memory leak detection test\"), ok.\nresource_cleanup_process_monitoring(_Config) -> ct:pal(\"Process monitoring test\"), ok.\nresource_cleanup_port_management(_Config) -> ct:pal(\"Port management test\"), ok.\n\n%% Performance tests\nperformance_throughput_measurement(_Config) -> ct:pal(\"Throughput measurement test\"), ok.\nperformance_latency_measurement(_Config) -> ct:pal(\"Latency measurement test\"), ok.\nperformance_memory_efficiency(_Config) -> ct:pal(\"Memory efficiency test\"), ok.\nperformance_concurrent_access(_Config) -> ct:pal(\"Concurrent access test\"), ok.\nperformance_high_volume_messages(_Config) -> ct:pal(\"High volume message test\"), ok.\nperformance_resource_scaling(_Config) -> ct:pal(\"Resource scaling test\"), ok.\n\n%% Buffer management tests\nbuffer_partial_messages(_Config) -> ct:pal(\"Partial message buffer test\"), ok.\nbuffer_overflow_handling(_Config) -> ct:pal(\"Buffer overflow test\"), ok.\nbuffer_line_boundary_detection(_Config) -> ct:pal(\"Line boundary detection test\"), ok.\nbuffer_unicode_handling(_Config) -> ct:pal(\"Unicode handling test\"), ok.\nbuffer_memory_efficiency(_Config) -> ct:pal(\"Buffer memory efficiency test\"), ok.\nbuffer_concurrent_access(_Config) -> ct:pal(\"Buffer concurrent access test\"), ok."
        }
    ]
}