{
    "sourceFile": "test/erlmcp_adversarial_SUITE.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1756184977914,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756185314916,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,47 +1,28 @@\n -module(erlmcp_adversarial_SUITE).\n+\n -compile(export_all).\n \n -include_lib(\"common_test/include/ct.hrl\").\n -include_lib(\"eunit/include/eunit.hrl\").\n \n %% Common Test callbacks\n--export([suite/0, init_per_suite/1, end_per_suite/1,\n-         init_per_testcase/2, end_per_testcase/2,\n-         all/0, groups/0]).\n-\n+-export([suite/0, init_per_suite/1, end_per_suite/1, init_per_testcase/2,\n+         end_per_testcase/2, all/0, groups/0]).\n %% Chaos Engineering Tests\n--export([chaos_process_killer/1,\n-         chaos_network_partition/1,\n-         chaos_latency_injection/1,\n-         chaos_packet_loss/1,\n-         chaos_byzantine_failure/1,\n-         chaos_memory_corruption/1,\n-         chaos_disk_failure/1,\n-         chaos_clock_skew/1]).\n-\n+-export([chaos_process_killer/1, chaos_network_partition/1, chaos_latency_injection/1,\n+         chaos_packet_loss/1, chaos_byzantine_failure/1, chaos_memory_corruption/1,\n+         chaos_disk_failure/1, chaos_clock_skew/1]).\n %% Security Fuzzing Tests\n--export([fuzz_json_rpc_protocol/1,\n-         fuzz_buffer_overflow/1,\n-         fuzz_resource_exhaustion/1,\n-         fuzz_timing_attacks/1,\n-         fuzz_input_validation/1,\n-         fuzz_authentication_bypass/1,\n+-export([fuzz_json_rpc_protocol/1, fuzz_buffer_overflow/1, fuzz_resource_exhaustion/1,\n+         fuzz_timing_attacks/1, fuzz_input_validation/1, fuzz_authentication_bypass/1,\n          fuzz_malformed_messages/1]).\n-\n %% Race Condition Tests\n--export([race_concurrent_mutations/1,\n-         race_registration_conflicts/1,\n-         race_message_ordering/1,\n-         race_deadlock_scenarios/1,\n-         race_state_corruption/1]).\n-\n+-export([race_concurrent_mutations/1, race_registration_conflicts/1,\n+         race_message_ordering/1, race_deadlock_scenarios/1, race_state_corruption/1]).\n %% Fault Injection Tests\n--export([fault_memory_corruption/1,\n-         fault_disk_corruption/1,\n-         fault_certificate_expiration/1,\n-         fault_dns_poisoning/1,\n-         fault_system_overload/1]).\n+-export([fault_memory_corruption/1, fault_disk_corruption/1,\n+         fault_certificate_expiration/1, fault_dns_poisoning/1, fault_system_overload/1]).\n \n -define(CHAOS_PROBABILITY, 0.3).\n -define(MAX_LATENCY_MS, 10000).\n -define(PACKET_LOSS_MAX, 50).\n@@ -74,876 +55,898 @@\n     cleanup_chaos_state(),\n     Config.\n \n all() ->\n-    [\n-     {group, chaos_engineering},\n+    [{group, chaos_engineering},\n      {group, security_fuzzing},\n      {group, race_conditions},\n-     {group, fault_injection}\n-    ].\n+     {group, fault_injection}].\n \n groups() ->\n-    [\n-     {chaos_engineering, [parallel], [\n-        chaos_process_killer,\n-        chaos_network_partition,\n-        chaos_latency_injection,\n-        chaos_packet_loss,\n-        chaos_byzantine_failure,\n-        chaos_memory_corruption,\n-        chaos_disk_failure,\n-        chaos_clock_skew\n-     ]},\n-     {security_fuzzing, [parallel], [\n-        fuzz_json_rpc_protocol,\n-        fuzz_buffer_overflow,\n-        fuzz_resource_exhaustion,\n-        fuzz_timing_attacks,\n-        fuzz_input_validation,\n-        fuzz_authentication_bypass,\n-        fuzz_malformed_messages\n-     ]},\n-     {race_conditions, [sequence], [\n-        race_concurrent_mutations,\n-        race_registration_conflicts,\n-        race_message_ordering,\n-        race_deadlock_scenarios,\n-        race_state_corruption\n-     ]},\n-     {fault_injection, [parallel], [\n-        fault_memory_corruption,\n-        fault_disk_corruption,\n-        fault_certificate_expiration,\n-        fault_dns_poisoning,\n-        fault_system_overload\n-     ]}\n-    ].\n+    [{chaos_engineering,\n+      [parallel],\n+      [chaos_process_killer,\n+       chaos_network_partition,\n+       chaos_latency_injection,\n+       chaos_packet_loss,\n+       chaos_byzantine_failure,\n+       chaos_memory_corruption,\n+       chaos_disk_failure,\n+       chaos_clock_skew]},\n+     {security_fuzzing,\n+      [parallel],\n+      [fuzz_json_rpc_protocol,\n+       fuzz_buffer_overflow,\n+       fuzz_resource_exhaustion,\n+       fuzz_timing_attacks,\n+       fuzz_input_validation,\n+       fuzz_authentication_bypass,\n+       fuzz_malformed_messages]},\n+     {race_conditions,\n+      [sequence],\n+      [race_concurrent_mutations,\n+       race_registration_conflicts,\n+       race_message_ordering,\n+       race_deadlock_scenarios,\n+       race_state_corruption]},\n+     {fault_injection,\n+      [parallel],\n+      [fault_memory_corruption,\n+       fault_disk_corruption,\n+       fault_certificate_expiration,\n+       fault_dns_poisoning,\n+       fault_system_overload]}].\n \n %% ============================================================================\n %% Chaos Engineering Tests\n %% ============================================================================\n \n chaos_process_killer(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"chaos_process_killer_start\">>, #{}),\n-    \n+\n     % Start target processes\n     Processes = start_target_processes(10),\n     otel_span:set_attribute(SpanCtx, <<\"target_processes\">>, length(Processes)),\n-    \n+\n     % Inject random process kills\n     KillCount = inject_process_kills(Processes, ?CHAOS_PROBABILITY),\n     otel_span:set_attribute(SpanCtx, <<\"processes_killed\">>, KillCount),\n-    \n+\n     % Verify system recovery\n     RecoveryTime = measure_recovery_time(),\n     otel_span:set_attribute(SpanCtx, <<\"recovery_time_ms\">>, RecoveryTime),\n-    \n+\n     % Assert system survived\n     ?assert(system_is_healthy()),\n-    otel_span:add_event(SpanCtx, <<\"chaos_process_killer_complete\">>, #{\n-        <<\"processes_killed\">> => KillCount,\n-        <<\"recovery_time\">> => RecoveryTime\n-    }).\n+    otel_span:add_event(SpanCtx,\n+                        <<\"chaos_process_killer_complete\">>,\n+                        #{<<\"processes_killed\">> => KillCount,\n+                          <<\"recovery_time\">> => RecoveryTime}).\n \n chaos_network_partition(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"chaos_network_partition_start\">>, #{}),\n-    \n+\n     % Create network partitions\n     Partitions = create_network_partitions(3),\n     otel_span:set_attribute(SpanCtx, <<\"partition_count\">>, length(Partitions)),\n-    \n+\n     timer:sleep(5000), % Let chaos ensue\n-    \n+\n     % Heal partitions\n     heal_network_partitions(Partitions),\n-    \n+\n     % Measure convergence time\n     ConvergenceTime = measure_convergence_time(),\n     otel_span:set_attribute(SpanCtx, <<\"convergence_time_ms\">>, ConvergenceTime),\n-    \n+\n     ?assert(system_converged()),\n-    otel_span:add_event(SpanCtx, <<\"chaos_network_partition_complete\">>, #{\n-        <<\"convergence_time\">> => ConvergenceTime\n-    }).\n+    otel_span:add_event(SpanCtx,\n+                        <<\"chaos_network_partition_complete\">>,\n+                        #{<<\"convergence_time\">> => ConvergenceTime}).\n \n chaos_latency_injection(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"chaos_latency_injection_start\">>, #{}),\n-    \n+\n     LatencyMs = rand:uniform(?MAX_LATENCY_MS),\n     otel_span:set_attribute(SpanCtx, <<\"injected_latency_ms\">>, LatencyMs),\n-    \n+\n     % Inject latency into message passing\n     LatencyInjector = start_latency_injector(LatencyMs),\n-    \n+\n     % Perform operations under latency\n     Operations = perform_latency_sensitive_operations(100),\n     SuccessRate = calculate_success_rate(Operations),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"success_rate\">>, SuccessRate),\n-    \n+\n     stop_latency_injector(LatencyInjector),\n-    \n+\n     % System should degrade gracefully\n     ?assert(SuccessRate > 0.7), % At least 70% should succeed\n-    otel_span:add_event(SpanCtx, <<\"chaos_latency_injection_complete\">>, #{\n-        <<\"success_rate\">> => SuccessRate\n-    }).\n+    otel_span:add_event(SpanCtx,\n+                        <<\"chaos_latency_injection_complete\">>,\n+                        #{<<\"success_rate\">> => SuccessRate}).\n \n chaos_packet_loss(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"chaos_packet_loss_start\">>, #{}),\n-    \n+\n     LossPercent = rand:uniform(?PACKET_LOSS_MAX),\n     otel_span:set_attribute(SpanCtx, <<\"packet_loss_percent\">>, LossPercent),\n-    \n+\n     % Inject packet loss\n     PacketLossInjector = start_packet_loss_injector(LossPercent),\n-    \n+\n     % Measure message delivery rates\n     {Sent, Received} = measure_message_delivery(1000),\n     ActualLossRate = (Sent - Received) / Sent * 100,\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"actual_loss_rate\">>, ActualLossRate),\n-    \n+\n     stop_packet_loss_injector(PacketLossInjector),\n-    \n+\n     % Verify retransmission works\n     ?assert(ActualLossRate =< LossPercent * 1.1), % Allow 10% variance\n-    otel_span:add_event(SpanCtx, <<\"chaos_packet_loss_complete\">>, #{\n-        <<\"actual_loss_rate\">> => ActualLossRate\n-    }).\n+    otel_span:add_event(SpanCtx,\n+                        <<\"chaos_packet_loss_complete\">>,\n+                        #{<<\"actual_loss_rate\">> => ActualLossRate}).\n \n chaos_byzantine_failure(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"chaos_byzantine_failure_start\">>, #{}),\n-    \n+\n     % Create Byzantine nodes that send conflicting messages\n     ByzantineNodes = start_byzantine_nodes(3),\n     otel_span:set_attribute(SpanCtx, <<\"byzantine_node_count\">>, length(ByzantineNodes)),\n-    \n+\n     % Let them cause havoc\n     timer:sleep(10000),\n-    \n+\n     % Measure system consensus despite Byzantine failures\n     ConsensusReached = check_consensus_reached(),\n     ConsensusTime = measure_consensus_time(),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"consensus_reached\">>, ConsensusReached),\n     otel_span:set_attribute(SpanCtx, <<\"consensus_time_ms\">>, ConsensusTime),\n-    \n+\n     stop_byzantine_nodes(ByzantineNodes),\n-    \n+\n     ?assert(ConsensusReached),\n-    otel_span:add_event(SpanCtx, <<\"chaos_byzantine_failure_complete\">>, #{\n-        <<\"consensus_time\">> => ConsensusTime\n-    }).\n+    otel_span:add_event(SpanCtx,\n+                        <<\"chaos_byzantine_failure_complete\">>,\n+                        #{<<\"consensus_time\">> => ConsensusTime}).\n \n chaos_memory_corruption(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"chaos_memory_corruption_start\">>, #{}),\n-    \n+\n     % Corrupt ETS tables randomly\n     CorruptionCount = inject_memory_corruption(?CHAOS_PROBABILITY),\n     otel_span:set_attribute(SpanCtx, <<\"corrupted_tables\">>, CorruptionCount),\n-    \n+\n     % Verify error handling\n     ErrorsDetected = count_corruption_errors(),\n     RecoveryTime = measure_memory_recovery_time(),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"errors_detected\">>, ErrorsDetected),\n     otel_span:set_attribute(SpanCtx, <<\"recovery_time_ms\">>, RecoveryTime),\n-    \n+\n     ?assert(ErrorsDetected > 0), % Should detect corruption\n     ?assert(system_recovered_from_corruption()),\n-    \n-    otel_span:add_event(SpanCtx, <<\"chaos_memory_corruption_complete\">>, #{\n-        <<\"errors_detected\">> => ErrorsDetected,\n-        <<\"recovery_time\">> => RecoveryTime\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"chaos_memory_corruption_complete\">>,\n+                        #{<<\"errors_detected\">> => ErrorsDetected,\n+                          <<\"recovery_time\">> => RecoveryTime}).\n+\n chaos_disk_failure(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"chaos_disk_failure_start\">>, #{}),\n-    \n+\n     % Simulate disk failures\n     FailedDisks = simulate_disk_failures(2),\n     otel_span:set_attribute(SpanCtx, <<\"failed_disk_count\">>, length(FailedDisks)),\n-    \n+\n     % Test persistence operations\n     PersistenceOperations = test_persistence_under_failure(100),\n     SuccessRate = calculate_success_rate(PersistenceOperations),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"persistence_success_rate\">>, SuccessRate),\n-    \n+\n     restore_disk_failures(FailedDisks),\n-    \n+\n     ?assert(SuccessRate > 0.5), % Should handle some failures\n-    otel_span:add_event(SpanCtx, <<\"chaos_disk_failure_complete\">>, #{\n-        <<\"success_rate\">> => SuccessRate\n-    }).\n+    otel_span:add_event(SpanCtx,\n+                        <<\"chaos_disk_failure_complete\">>,\n+                        #{<<\"success_rate\">> => SuccessRate}).\n \n chaos_clock_skew(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"chaos_clock_skew_start\">>, #{}),\n-    \n+\n     % Inject clock skew\n     SkewSeconds = rand:uniform(3600), % Up to 1 hour\n     otel_span:set_attribute(SpanCtx, <<\"clock_skew_seconds\">>, SkewSeconds),\n-    \n+\n     ClockSkewer = inject_clock_skew(SkewSeconds),\n-    \n+\n     % Test time-sensitive operations\n     TimeOperations = test_time_sensitive_operations(50),\n     SuccessRate = calculate_success_rate(TimeOperations),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"time_ops_success_rate\">>, SuccessRate),\n-    \n+\n     stop_clock_skew(ClockSkewer),\n-    \n+\n     ?assert(SuccessRate > 0.6), % Should handle moderate clock skew\n-    otel_span:add_event(SpanCtx, <<\"chaos_clock_skew_complete\">>, #{\n-        <<\"success_rate\">> => SuccessRate\n-    }).\n+    otel_span:add_event(SpanCtx,\n+                        <<\"chaos_clock_skew_complete\">>,\n+                        #{<<\"success_rate\">> => SuccessRate}).\n \n %% ============================================================================\n %% Security Fuzzing Tests\n %% ============================================================================\n \n fuzz_json_rpc_protocol(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"fuzz_json_rpc_start\">>, #{}),\n-    \n+\n     Crashes = 0,\n     SecurityViolations = 0,\n-    \n+\n     % Generate malicious JSON-RPC messages\n     lists:foreach(fun(I) ->\n-        MaliciousMsg = generate_malicious_json_rpc(I),\n-        otel_span:add_event(SpanCtx, <<\"sending_malicious_message\">>, #{\n-            <<\"iteration\">> => I,\n-            <<\"message_type\">> => maps:get(type, MaliciousMsg, unknown)\n-        }),\n-        \n-        Result = send_malicious_message(MaliciousMsg),\n-        case Result of\n-            crash -> Crashes + 1;\n-            security_violation -> SecurityViolations + 1;\n-            _ -> ok\n-        end\n-    end, lists:seq(1, ?FUZZ_ITERATIONS)),\n-    \n+                     MaliciousMsg = generate_malicious_json_rpc(I),\n+                     otel_span:add_event(SpanCtx,\n+                                         <<\"sending_malicious_message\">>,\n+                                         #{<<\"iteration\">> => I,\n+                                           <<\"message_type\">> =>\n+                                               maps:get(type, MaliciousMsg, unknown)}),\n+\n+                     Result = send_malicious_message(MaliciousMsg),\n+                     case Result of\n+                         crash -> Crashes + 1;\n+                         security_violation -> SecurityViolations + 1;\n+                         _ -> ok\n+                     end\n+                  end,\n+                  lists:seq(1, ?FUZZ_ITERATIONS)),\n+\n     otel_span:set_attribute(SpanCtx, <<\"crashes_detected\">>, Crashes),\n     otel_span:set_attribute(SpanCtx, <<\"security_violations\">>, SecurityViolations),\n-    \n+\n     ?assert(Crashes =:= 0), % No crashes allowed\n     ?assert(SecurityViolations =:= 0), % No security violations\n-    \n-    otel_span:add_event(SpanCtx, <<\"fuzz_json_rpc_complete\">>, #{\n-        <<\"iterations\">> => ?FUZZ_ITERATIONS,\n-        <<\"crashes\">> => Crashes,\n-        <<\"violations\">> => SecurityViolations\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"fuzz_json_rpc_complete\">>,\n+                        #{<<\"iterations\">> => ?FUZZ_ITERATIONS,\n+                          <<\"crashes\">> => Crashes,\n+                          <<\"violations\">> => SecurityViolations}).\n+\n fuzz_buffer_overflow(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"fuzz_buffer_overflow_start\">>, #{}),\n-    \n-    OverflowAttempts = lists:map(fun(Size) ->\n-        LargePayload = binary:copy(<<$A>>, Size),\n-        otel_span:add_event(SpanCtx, <<\"buffer_overflow_attempt\">>, #{\n-            <<\"payload_size\">> => Size\n-        }),\n-        \n-        Result = attempt_buffer_overflow(LargePayload),\n-        {Size, Result}\n-    end, [1024, 10240, 102400, 1048576, 10485760]), % 1KB to 10MB\n-    \n+\n+    OverflowAttempts =\n+        lists:map(fun(Size) ->\n+                     LargePayload = binary:copy(<<$A>>, Size),\n+                     otel_span:add_event(SpanCtx,\n+                                         <<\"buffer_overflow_attempt\">>,\n+                                         #{<<\"payload_size\">> => Size}),\n+\n+                     Result = attempt_buffer_overflow(LargePayload),\n+                     {Size, Result}\n+                  end,\n+                  [1024, 10240, 102400, 1048576, 10485760]), % 1KB to 10MB\n+\n     Failures = [R || {_, R} <- OverflowAttempts, R =:= failure],\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"overflow_attempts\">>, length(OverflowAttempts)),\n     otel_span:set_attribute(SpanCtx, <<\"failures\">>, length(Failures)),\n-    \n+\n     ?assert(length(Failures) =:= 0), % All should be handled gracefully\n-    \n-    otel_span:add_event(SpanCtx, <<\"fuzz_buffer_overflow_complete\">>, #{\n-        <<\"attempts\">> => length(OverflowAttempts),\n-        <<\"failures\">> => length(Failures)\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"fuzz_buffer_overflow_complete\">>,\n+                        #{<<\"attempts\">> => length(OverflowAttempts),\n+                          <<\"failures\">> => length(Failures)}).\n+\n fuzz_resource_exhaustion(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"fuzz_resource_exhaustion_start\">>, #{}),\n-    \n+\n     % Attack vectors\n-    AttackVectors = [\n-        {memory_bomb, fun() -> create_memory_bomb(1000000) end},\n-        {process_bomb, fun() -> create_process_bomb(10000) end},\n-        {file_descriptor_bomb, fun() -> create_fd_bomb(1000) end},\n-        {cpu_bomb, fun() -> create_cpu_bomb(100) end}\n-    ],\n-    \n-    Results = lists:map(fun({AttackType, AttackFun}) ->\n-        otel_span:add_event(SpanCtx, <<\"resource_exhaustion_attack\">>, #{\n-            <<\"attack_type\">> => AttackType\n-        }),\n-        \n-        StartTime = erlang:monotonic_time(millisecond),\n-        Result = execute_resource_attack(AttackFun),\n-        EndTime = erlang:monotonic_time(millisecond),\n-        \n-        {AttackType, Result, EndTime - StartTime}\n-    end, AttackVectors),\n-    \n+    AttackVectors =\n+        [{memory_bomb, fun() -> create_memory_bomb(1000000) end},\n+         {process_bomb, fun() -> create_process_bomb(10000) end},\n+         {file_descriptor_bomb, fun() -> create_fd_bomb(1000) end},\n+         {cpu_bomb, fun() -> create_cpu_bomb(100) end}],\n+\n+    Results =\n+        lists:map(fun({AttackType, AttackFun}) ->\n+                     otel_span:add_event(SpanCtx,\n+                                         <<\"resource_exhaustion_attack\">>,\n+                                         #{<<\"attack_type\">> => AttackType}),\n+\n+                     StartTime = erlang:monotonic_time(millisecond),\n+                     Result = execute_resource_attack(AttackFun),\n+                     EndTime = erlang:monotonic_time(millisecond),\n+\n+                     {AttackType, Result, EndTime - StartTime}\n+                  end,\n+                  AttackVectors),\n+\n     SystemSurvived = system_is_healthy(),\n     otel_span:set_attribute(SpanCtx, <<\"system_survived\">>, SystemSurvived),\n-    \n+\n     ?assert(SystemSurvived), % System should survive all attacks\n-    \n-    otel_span:add_event(SpanCtx, <<\"fuzz_resource_exhaustion_complete\">>, #{\n-        <<\"attack_count\">> => length(AttackVectors),\n-        <<\"system_survived\">> => SystemSurvived\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"fuzz_resource_exhaustion_complete\">>,\n+                        #{<<\"attack_count\">> => length(AttackVectors),\n+                          <<\"system_survived\">> => SystemSurvived}).\n+\n fuzz_timing_attacks(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"fuzz_timing_attacks_start\">>, #{}),\n-    \n+\n     % Measure timing differences in authentication\n-    TimingResults = lists:map(fun(_) ->\n-        ValidUser = generate_valid_credentials(),\n-        InvalidUser = generate_invalid_credentials(),\n-        \n-        ValidTime = measure_auth_time(ValidUser),\n-        InvalidTime = measure_auth_time(InvalidUser),\n-        \n-        otel_span:add_event(SpanCtx, <<\"timing_measurement\">>, #{\n-            <<\"valid_time_us\">> => ValidTime,\n-            <<\"invalid_time_us\">> => InvalidTime,\n-            <<\"time_diff_us\">> => abs(ValidTime - InvalidTime)\n-        }),\n-        \n-        abs(ValidTime - InvalidTime)\n-    end, lists:seq(1, 100)),\n-    \n+    TimingResults =\n+        lists:map(fun(_) ->\n+                     ValidUser = generate_valid_credentials(),\n+                     InvalidUser = generate_invalid_credentials(),\n+\n+                     ValidTime = measure_auth_time(ValidUser),\n+                     InvalidTime = measure_auth_time(InvalidUser),\n+\n+                     otel_span:add_event(SpanCtx,\n+                                         <<\"timing_measurement\">>,\n+                                         #{<<\"valid_time_us\">> => ValidTime,\n+                                           <<\"invalid_time_us\">> => InvalidTime,\n+                                           <<\"time_diff_us\">> => abs(ValidTime - InvalidTime)}),\n+\n+                     abs(ValidTime - InvalidTime)\n+                  end,\n+                  lists:seq(1, 100)),\n+\n     AvgTimingDiff = lists:sum(TimingResults) / length(TimingResults),\n     MaxTimingDiff = lists:max(TimingResults),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"avg_timing_diff_us\">>, AvgTimingDiff),\n     otel_span:set_attribute(SpanCtx, <<\"max_timing_diff_us\">>, MaxTimingDiff),\n-    \n+\n     % Timing differences should be minimal\n     ?assert(AvgTimingDiff < 1000), % Less than 1ms average difference\n     ?assert(MaxTimingDiff < 5000), % Less than 5ms max difference\n-    \n-    otel_span:add_event(SpanCtx, <<\"fuzz_timing_attacks_complete\">>, #{\n-        <<\"avg_timing_diff\">> => AvgTimingDiff,\n-        <<\"max_timing_diff\">> => MaxTimingDiff\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"fuzz_timing_attacks_complete\">>,\n+                        #{<<\"avg_timing_diff\">> => AvgTimingDiff,\n+                          <<\"max_timing_diff\">> => MaxTimingDiff}).\n+\n fuzz_input_validation(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"fuzz_input_validation_start\">>, #{}),\n-    \n+\n     % Generate malicious inputs\n     MaliciousInputs = generate_malicious_inputs(1000),\n-    \n-    ValidationResults = lists:map(fun(Input) ->\n-        otel_span:add_event(SpanCtx, <<\"testing_malicious_input\">>, #{\n-            <<\"input_type\">> => maps:get(type, Input, unknown),\n-            <<\"input_size\">> => byte_size(maps:get(payload, Input, <<>>))\n-        }),\n-        \n-        test_input_validation(Input)\n-    end, MaliciousInputs),\n-    \n+\n+    ValidationResults =\n+        lists:map(fun(Input) ->\n+                     otel_span:add_event(SpanCtx,\n+                                         <<\"testing_malicious_input\">>,\n+                                         #{<<\"input_type\">> => maps:get(type, Input, unknown),\n+                                           <<\"input_size\">> =>\n+                                               byte_size(maps:get(payload, Input, <<>>))}),\n+\n+                     test_input_validation(Input)\n+                  end,\n+                  MaliciousInputs),\n+\n     Bypasses = [R || R <- ValidationResults, R =:= bypass],\n     Crashes = [R || R <- ValidationResults, R =:= crash],\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"validation_bypasses\">>, length(Bypasses)),\n     otel_span:set_attribute(SpanCtx, <<\"validation_crashes\">>, length(Crashes)),\n-    \n+\n     ?assert(length(Bypasses) =:= 0), % No validation bypasses\n     ?assert(length(Crashes) =:= 0), % No crashes from bad input\n-    \n-    otel_span:add_event(SpanCtx, <<\"fuzz_input_validation_complete\">>, #{\n-        <<\"inputs_tested\">> => length(MaliciousInputs),\n-        <<\"bypasses\">> => length(Bypasses),\n-        <<\"crashes\">> => length(Crashes)\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"fuzz_input_validation_complete\">>,\n+                        #{<<\"inputs_tested\">> => length(MaliciousInputs),\n+                          <<\"bypasses\">> => length(Bypasses),\n+                          <<\"crashes\">> => length(Crashes)}).\n+\n fuzz_authentication_bypass(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"fuzz_auth_bypass_start\">>, #{}),\n-    \n+\n     % Generate authentication bypass attempts\n     BypassAttempts = generate_auth_bypass_attempts(500),\n-    \n-    BypassResults = lists:map(fun(Attempt) ->\n-        otel_span:add_event(SpanCtx, <<\"auth_bypass_attempt\">>, #{\n-            <<\"attempt_type\">> => maps:get(type, Attempt, unknown)\n-        }),\n-        \n-        test_auth_bypass(Attempt)\n-    end, BypassAttempts),\n-    \n+\n+    BypassResults =\n+        lists:map(fun(Attempt) ->\n+                     otel_span:add_event(SpanCtx,\n+                                         <<\"auth_bypass_attempt\">>,\n+                                         #{<<\"attempt_type\">> => maps:get(type, Attempt, unknown)}),\n+\n+                     test_auth_bypass(Attempt)\n+                  end,\n+                  BypassAttempts),\n+\n     SuccessfulBypasses = [R || R <- BypassResults, R =:= success],\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"bypass_attempts\">>, length(BypassAttempts)),\n     otel_span:set_attribute(SpanCtx, <<\"successful_bypasses\">>, length(SuccessfulBypasses)),\n-    \n+\n     ?assert(length(SuccessfulBypasses) =:= 0), % No bypasses should succeed\n-    \n-    otel_span:add_event(SpanCtx, <<\"fuzz_auth_bypass_complete\">>, #{\n-        <<\"attempts\">> => length(BypassAttempts),\n-        <<\"bypasses\">> => length(SuccessfulBypasses)\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"fuzz_auth_bypass_complete\">>,\n+                        #{<<\"attempts\">> => length(BypassAttempts),\n+                          <<\"bypasses\">> => length(SuccessfulBypasses)}).\n+\n fuzz_malformed_messages(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"fuzz_malformed_messages_start\">>, #{}),\n-    \n+\n     % Generate various malformed messages\n     MalformedMessages = generate_malformed_messages(2000),\n-    \n-    ProcessingResults = lists:map(fun(Message) ->\n-        otel_span:add_event(SpanCtx, <<\"processing_malformed_message\">>, #{\n-            <<\"message_type\">> => maps:get(type, Message, unknown),\n-            <<\"corruption_type\">> => maps:get(corruption, Message, unknown)\n-        }),\n-        \n-        process_malformed_message(Message)\n-    end, MalformedMessages),\n-    \n+\n+    ProcessingResults =\n+        lists:map(fun(Message) ->\n+                     otel_span:add_event(SpanCtx,\n+                                         <<\"processing_malformed_message\">>,\n+                                         #{<<\"message_type\">> => maps:get(type, Message, unknown),\n+                                           <<\"corruption_type\">> =>\n+                                               maps:get(corruption, Message, unknown)}),\n+\n+                     process_malformed_message(Message)\n+                  end,\n+                  MalformedMessages),\n+\n     Crashes = [R || R <- ProcessingResults, R =:= crash],\n     Hangs = [R || R <- ProcessingResults, R =:= hang],\n     MemoryLeaks = [R || R <- ProcessingResults, R =:= memory_leak],\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"message_crashes\">>, length(Crashes)),\n     otel_span:set_attribute(SpanCtx, <<\"message_hangs\">>, length(Hangs)),\n     otel_span:set_attribute(SpanCtx, <<\"memory_leaks\">>, length(MemoryLeaks)),\n-    \n+\n     ?assert(length(Crashes) =:= 0),\n     ?assert(length(Hangs) =:= 0),\n     ?assert(length(MemoryLeaks) =:= 0),\n-    \n-    otel_span:add_event(SpanCtx, <<\"fuzz_malformed_messages_complete\">>, #{\n-        <<\"messages_processed\">> => length(MalformedMessages),\n-        <<\"crashes\">> => length(Crashes),\n-        <<\"hangs\">> => length(Hangs),\n-        <<\"memory_leaks\">> => length(MemoryLeaks)\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"fuzz_malformed_messages_complete\">>,\n+                        #{<<\"messages_processed\">> => length(MalformedMessages),\n+                          <<\"crashes\">> => length(Crashes),\n+                          <<\"hangs\">> => length(Hangs),\n+                          <<\"memory_leaks\">> => length(MemoryLeaks)}).\n+\n %% ============================================================================\n %% Race Condition Tests\n %% ============================================================================\n \n race_concurrent_mutations(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"race_concurrent_mutations_start\">>, #{}),\n-    \n+\n     % Create shared state\n     StateRef = create_shared_state(),\n-    \n+\n     % Spawn concurrent workers\n     Workers = spawn_mutation_workers(?RACE_WORKERS, StateRef),\n     otel_span:set_attribute(SpanCtx, <<\"worker_count\">>, length(Workers)),\n-    \n+\n     % Let them race\n     timer:sleep(5000),\n-    \n+\n     % Stop workers and check consistency\n     stop_workers(Workers),\n     FinalState = get_final_state(StateRef),\n     ConsistencyCheck = check_state_consistency(FinalState),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"state_consistent\">>, ConsistencyCheck),\n-    \n+\n     ?assert(ConsistencyCheck), % State should be consistent despite races\n-    \n-    otel_span:add_event(SpanCtx, <<\"race_concurrent_mutations_complete\">>, #{\n-        <<\"workers\">> => length(Workers),\n-        <<\"consistent\">> => ConsistencyCheck\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"race_concurrent_mutations_complete\">>,\n+                        #{<<\"workers\">> => length(Workers), <<\"consistent\">> => ConsistencyCheck}).\n+\n race_registration_conflicts(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"race_registration_conflicts_start\">>, #{}),\n-    \n+\n     % Try to register the same service from multiple processes\n     ServiceName = \"test_service_\" ++ integer_to_list(rand:uniform(1000000)),\n-    \n-    RegistrationWorkers = lists:map(fun(I) ->\n-        spawn_link(fun() ->\n-            otel_span:add_event(SpanCtx, <<\"attempting_registration\">>, #{\n-                <<\"worker_id\">> => I,\n-                <<\"service_name\">> => ServiceName\n-            }),\n-            Result = attempt_service_registration(ServiceName, I),\n-            {I, Result}\n-        end)\n-    end, lists:seq(1, 50)),\n-    \n+\n+    RegistrationWorkers =\n+        lists:map(fun(I) ->\n+                     spawn_link(fun() ->\n+                                   otel_span:add_event(SpanCtx,\n+                                                       <<\"attempting_registration\">>,\n+                                                       #{<<\"worker_id\">> => I,\n+                                                         <<\"service_name\">> => ServiceName}),\n+                                   Result = attempt_service_registration(ServiceName, I),\n+                                   {I, Result}\n+                                end)\n+                  end,\n+                  lists:seq(1, 50)),\n+\n     % Collect results\n     Results = collect_worker_results(RegistrationWorkers),\n     Successful = [R || {_, R} <- Results, R =:= success],\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"registration_attempts\">>, length(Results)),\n     otel_span:set_attribute(SpanCtx, <<\"successful_registrations\">>, length(Successful)),\n-    \n+\n     % Only one should succeed\n     ?assert(length(Successful) =:= 1),\n-    \n-    otel_span:add_event(SpanCtx, <<\"race_registration_conflicts_complete\">>, #{\n-        <<\"attempts\">> => length(Results),\n-        <<\"successful\">> => length(Successful)\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"race_registration_conflicts_complete\">>,\n+                        #{<<\"attempts\">> => length(Results),\n+                          <<\"successful\">> => length(Successful)}).\n+\n race_message_ordering(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"race_message_ordering_start\">>, #{}),\n-    \n+\n     % Create message ordering test\n     MessageSequencer = start_message_sequencer(),\n-    \n+\n     % Send messages concurrently with expected order\n-    MessageWorkers = lists:map(fun(I) ->\n-        spawn_link(fun() ->\n-            otel_span:add_event(SpanCtx, <<\"sending_ordered_message\">>, #{\n-                <<\"message_id\">> => I\n-            }),\n-            send_ordered_message(MessageSequencer, I)\n-        end)\n-    end, lists:seq(1, 100)),\n-    \n+    MessageWorkers =\n+        lists:map(fun(I) ->\n+                     spawn_link(fun() ->\n+                                   otel_span:add_event(SpanCtx,\n+                                                       <<\"sending_ordered_message\">>,\n+                                                       #{<<\"message_id\">> => I}),\n+                                   send_ordered_message(MessageSequencer, I)\n+                                end)\n+                  end,\n+                  lists:seq(1, 100)),\n+\n     % Wait for all messages\n     wait_for_workers(MessageWorkers),\n-    \n+\n     % Check message ordering\n     ReceivedOrder = get_received_order(MessageSequencer),\n     OrderingViolations = count_ordering_violations(ReceivedOrder),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"ordering_violations\">>, OrderingViolations),\n-    \n+\n     stop_message_sequencer(MessageSequencer),\n-    \n+\n     ?assert(OrderingViolations =< 5), % Allow some reordering\n-    \n-    otel_span:add_event(SpanCtx, <<\"race_message_ordering_complete\">>, #{\n-        <<\"messages_sent\">> => 100,\n-        <<\"ordering_violations\">> => OrderingViolations\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"race_message_ordering_complete\">>,\n+                        #{<<\"messages_sent\">> => 100,\n+                          <<\"ordering_violations\">> => OrderingViolations}).\n+\n race_deadlock_scenarios(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"race_deadlock_scenarios_start\">>, #{}),\n-    \n+\n     % Create deadlock-prone scenario\n     {ResourceA, ResourceB} = create_deadlock_resources(),\n-    \n+\n     % Spawn processes that acquire resources in different orders\n-    DeadlockWorkers = lists:map(fun(I) ->\n-        spawn_link(fun() ->\n-            case I rem 2 of\n-                0 -> % Even: A then B\n-                    otel_span:add_event(SpanCtx, <<\"acquiring_resources_AB\">>, #{\n-                        <<\"worker_id\">> => I\n-                    }),\n-                    acquire_resources_order_AB(ResourceA, ResourceB);\n-                1 -> % Odd: B then A\n-                    otel_span:add_event(SpanCtx, <<\"acquiring_resources_BA\">>, #{\n-                        <<\"worker_id\">> => I\n-                    }),\n-                    acquire_resources_order_BA(ResourceA, ResourceB)\n-            end\n-        end)\n-    end, lists:seq(1, 20)),\n-    \n+    DeadlockWorkers =\n+        lists:map(fun(I) ->\n+                     spawn_link(fun() ->\n+                                   case I rem 2 of\n+                                       0 -> % Even: A then B\n+                                           otel_span:add_event(SpanCtx,\n+                                                               <<\"acquiring_resources_AB\">>,\n+                                                               #{<<\"worker_id\">> => I}),\n+                                           acquire_resources_order_AB(ResourceA, ResourceB);\n+                                       1 -> % Odd: B then A\n+                                           otel_span:add_event(SpanCtx,\n+                                                               <<\"acquiring_resources_BA\">>,\n+                                                               #{<<\"worker_id\">> => I}),\n+                                           acquire_resources_order_BA(ResourceA, ResourceB)\n+                                   end\n+                                end)\n+                  end,\n+                  lists:seq(1, 20)),\n+\n     % Monitor for deadlocks\n     DeadlockDetector = start_deadlock_detector(),\n     timer:sleep(10000), % Let potential deadlock develop\n-    \n+\n     DeadlocksDetected = get_deadlock_count(DeadlockDetector),\n     stop_deadlock_detector(DeadlockDetector),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"deadlocks_detected\">>, DeadlocksDetected),\n-    \n+\n     % Clean up any stuck processes\n     cleanup_deadlock_workers(DeadlockWorkers),\n-    \n+\n     ?assert(DeadlocksDetected =:= 0), % No deadlocks should occur\n-    \n-    otel_span:add_event(SpanCtx, <<\"race_deadlock_scenarios_complete\">>, #{\n-        <<\"workers\">> => length(DeadlockWorkers),\n-        <<\"deadlocks\">> => DeadlocksDetected\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"race_deadlock_scenarios_complete\">>,\n+                        #{<<\"workers\">> => length(DeadlockWorkers),\n+                          <<\"deadlocks\">> => DeadlocksDetected}).\n+\n race_state_corruption(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"race_state_corruption_start\">>, #{}),\n-    \n+\n     % Create complex state that can be corrupted\n     ComplexState = create_complex_state(),\n-    \n+\n     % Spawn many processes doing state operations\n-    StateWorkers = lists:map(fun(I) ->\n-        spawn_link(fun() ->\n-            Operations = [read, write, delete, update],\n-            Operation = lists:nth(rand:uniform(length(Operations)), Operations),\n-            \n-            otel_span:add_event(SpanCtx, <<\"state_operation\">>, #{\n-                <<\"worker_id\">> => I,\n-                <<\"operation\">> => Operation\n-            }),\n-            \n-            perform_state_operation(ComplexState, Operation, I)\n-        end)\n-    end, lists:seq(1, 200)),\n-    \n+    StateWorkers =\n+        lists:map(fun(I) ->\n+                     spawn_link(fun() ->\n+                                   Operations = [read, write, delete, update],\n+                                   Operation =\n+                                       lists:nth(\n+                                           rand:uniform(length(Operations)), Operations),\n+\n+                                   otel_span:add_event(SpanCtx,\n+                                                       <<\"state_operation\">>,\n+                                                       #{<<\"worker_id\">> => I,\n+                                                         <<\"operation\">> => Operation}),\n+\n+                                   perform_state_operation(ComplexState, Operation, I)\n+                                end)\n+                  end,\n+                  lists:seq(1, 200)),\n+\n     % Wait for all operations\n     wait_for_workers(StateWorkers),\n-    \n+\n     % Check for state corruption\n     CorruptionDetected = detect_state_corruption(ComplexState),\n     StateIntegrity = check_state_integrity(ComplexState),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"corruption_detected\">>, CorruptionDetected),\n     otel_span:set_attribute(SpanCtx, <<\"state_integrity\">>, StateIntegrity),\n-    \n+\n     ?assert(not CorruptionDetected),\n     ?assert(StateIntegrity),\n-    \n-    otel_span:add_event(SpanCtx, <<\"race_state_corruption_complete\">>, #{\n-        <<\"operations\">> => length(StateWorkers),\n-        <<\"corruption_detected\">> => CorruptionDetected,\n-        <<\"state_integrity\">> => StateIntegrity\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"race_state_corruption_complete\">>,\n+                        #{<<\"operations\">> => length(StateWorkers),\n+                          <<\"corruption_detected\">> => CorruptionDetected,\n+                          <<\"state_integrity\">> => StateIntegrity}).\n+\n %% ============================================================================\n %% Fault Injection Tests\n %% ============================================================================\n \n fault_memory_corruption(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"fault_memory_corruption_start\">>, #{}),\n-    \n-    MemoryFaults = inject_memory_faults([\n-        {heap_corruption, 0.1},\n-        {stack_overflow, 0.05},\n-        {buffer_overrun, 0.1},\n-        {use_after_free, 0.05}\n-    ]),\n-    \n+\n+    MemoryFaults =\n+        inject_memory_faults([{heap_corruption, 0.1},\n+                              {stack_overflow, 0.05},\n+                              {buffer_overrun, 0.1},\n+                              {use_after_free, 0.05}]),\n+\n     otel_span:set_attribute(SpanCtx, <<\"memory_faults_injected\">>, MemoryFaults),\n-    \n+\n     % Test system under memory corruption\n     OperationResults = perform_memory_intensive_operations(100),\n     SuccessRate = calculate_success_rate(OperationResults),\n     ErrorsHandled = count_memory_errors_handled(),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"success_rate\">>, SuccessRate),\n     otel_span:set_attribute(SpanCtx, <<\"errors_handled\">>, ErrorsHandled),\n-    \n+\n     ?assert(SuccessRate > 0.8), % Should handle most memory faults\n     ?assert(ErrorsHandled > 0), % Should detect and handle errors\n-    \n-    otel_span:add_event(SpanCtx, <<\"fault_memory_corruption_complete\">>, #{\n-        <<\"faults_injected\">> => MemoryFaults,\n-        <<\"success_rate\">> => SuccessRate,\n-        <<\"errors_handled\">> => ErrorsHandled\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"fault_memory_corruption_complete\">>,\n+                        #{<<\"faults_injected\">> => MemoryFaults,\n+                          <<\"success_rate\">> => SuccessRate,\n+                          <<\"errors_handled\">> => ErrorsHandled}).\n+\n fault_disk_corruption(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"fault_disk_corruption_start\">>, #{}),\n-    \n+\n     % Inject disk corruption faults\n-    DiskFaults = inject_disk_faults([\n-        {sector_corruption, 0.1},\n-        {file_system_corruption, 0.05},\n-        {metadata_corruption, 0.1}\n-    ]),\n-    \n+    DiskFaults =\n+        inject_disk_faults([{sector_corruption, 0.1},\n+                            {file_system_corruption, 0.05},\n+                            {metadata_corruption, 0.1}]),\n+\n     otel_span:set_attribute(SpanCtx, <<\"disk_faults_injected\">>, DiskFaults),\n-    \n+\n     % Test file operations under corruption\n     FileOperations = perform_file_operations_under_corruption(50),\n     ChecksumsValid = verify_file_checksums(FileOperations),\n     DataIntegrity = check_data_integrity(FileOperations),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"checksums_valid\">>, ChecksumsValid),\n     otel_span:set_attribute(SpanCtx, <<\"data_integrity\">>, DataIntegrity),\n-    \n+\n     ?assert(ChecksumsValid > 0.9), % Most checksums should be valid\n     ?assert(DataIntegrity), % Data integrity should be maintained\n-    \n-    otel_span:add_event(SpanCtx, <<\"fault_disk_corruption_complete\">>, #{\n-        <<\"faults_injected\">> => DiskFaults,\n-        <<\"checksums_valid\">> => ChecksumsValid,\n-        <<\"data_integrity\">> => DataIntegrity\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"fault_disk_corruption_complete\">>,\n+                        #{<<\"faults_injected\">> => DiskFaults,\n+                          <<\"checksums_valid\">> => ChecksumsValid,\n+                          <<\"data_integrity\">> => DataIntegrity}).\n+\n fault_certificate_expiration(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"fault_certificate_expiration_start\">>, #{}),\n-    \n+\n     % Create certificates with various expiration times\n-    Certificates = create_test_certificates([\n-        {expired, -86400},    % Expired yesterday\n-        {expiring_soon, 3600}, % Expires in 1 hour\n-        {valid, 86400 * 30}   % Expires in 30 days\n-    ]),\n-    \n+    Certificates =\n+        create_test_certificates([{expired, -86400},    % Expired yesterday\n+                                  {expiring_soon, 3600}, % Expires in 1 hour\n+                                  {valid, 86400 * 30}]),   % Expires in 30 days\n+\n     otel_span:set_attribute(SpanCtx, <<\"certificates_created\">>, length(Certificates)),\n-    \n+\n     % Test TLS connections with each certificate\n-    ConnectionResults = lists:map(fun({CertType, Cert}) ->\n-        otel_span:add_event(SpanCtx, <<\"testing_certificate\">>, #{\n-            <<\"cert_type\">> => CertType\n-        }),\n-        \n-        Result = test_tls_connection_with_cert(Cert),\n-        {CertType, Result}\n-    end, Certificates),\n-    \n+    ConnectionResults =\n+        lists:map(fun({CertType, Cert}) ->\n+                     otel_span:add_event(SpanCtx,\n+                                         <<\"testing_certificate\">>,\n+                                         #{<<\"cert_type\">> => CertType}),\n+\n+                     Result = test_tls_connection_with_cert(Cert),\n+                     {CertType, Result}\n+                  end,\n+                  Certificates),\n+\n     ExpiredRejected = length([R || {expired, R} <- ConnectionResults, R =:= rejected]),\n     ValidAccepted = length([R || {valid, R} <- ConnectionResults, R =:= accepted]),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"expired_rejected\">>, ExpiredRejected),\n     otel_span:set_attribute(SpanCtx, <<\"valid_accepted\">>, ValidAccepted),\n-    \n+\n     ?assert(ExpiredRejected > 0), % Expired certs should be rejected\n     ?assert(ValidAccepted > 0), % Valid certs should be accepted\n-    \n-    otel_span:add_event(SpanCtx, <<\"fault_certificate_expiration_complete\">>, #{\n-        <<\"expired_rejected\">> => ExpiredRejected,\n-        <<\"valid_accepted\">> => ValidAccepted\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"fault_certificate_expiration_complete\">>,\n+                        #{<<\"expired_rejected\">> => ExpiredRejected,\n+                          <<\"valid_accepted\">> => ValidAccepted}).\n+\n fault_dns_poisoning(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"fault_dns_poisoning_start\">>, #{}),\n-    \n+\n     % Inject DNS poisoning\n-    PoisonedDomains = inject_dns_poisoning([\n-        {\"legitimate-service.com\", \"192.168.1.100\"}, % Point to malicious IP\n-        {\"api.service.com\", \"10.0.0.100\"}\n-    ]),\n-    \n+    PoisonedDomains =\n+        inject_dns_poisoning([{\"legitimate-service.com\", \"192.168.1.100\"}, % Point to malicious IP\n+                              {\"api.service.com\", \"10.0.0.100\"}]),\n+\n     otel_span:set_attribute(SpanCtx, <<\"poisoned_domains\">>, length(PoisonedDomains)),\n-    \n+\n     % Test DNS resolution and connection behavior\n-    DNSResults = lists:map(fun({Domain, _}) ->\n-        otel_span:add_event(SpanCtx, <<\"testing_poisoned_dns\">>, #{\n-            <<\"domain\">> => Domain\n-        }),\n-        \n-        test_dns_resolution_safety(Domain)\n-    end, PoisonedDomains),\n-    \n+    DNSResults =\n+        lists:map(fun({Domain, _}) ->\n+                     otel_span:add_event(SpanCtx,\n+                                         <<\"testing_poisoned_dns\">>,\n+                                         #{<<\"domain\">> => Domain}),\n+\n+                     test_dns_resolution_safety(Domain)\n+                  end,\n+                  PoisonedDomains),\n+\n     SafeResolutions = [R || R <- DNSResults, R =:= safe],\n     UnsafeResolutions = [R || R <- DNSResults, R =:= unsafe],\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"safe_resolutions\">>, length(SafeResolutions)),\n     otel_span:set_attribute(SpanCtx, <<\"unsafe_resolutions\">>, length(UnsafeResolutions)),\n-    \n+\n     % Clean up DNS poisoning\n     cleanup_dns_poisoning(PoisonedDomains),\n-    \n+\n     ?assert(length(UnsafeResolutions) =:= 0), % No unsafe resolutions\n-    \n-    otel_span:add_event(SpanCtx, <<\"fault_dns_poisoning_complete\">>, #{\n-        <<\"safe_resolutions\">> => length(SafeResolutions),\n-        <<\"unsafe_resolutions\">> => length(UnsafeResolutions)\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"fault_dns_poisoning_complete\">>,\n+                        #{<<\"safe_resolutions\">> => length(SafeResolutions),\n+                          <<\"unsafe_resolutions\">> => length(UnsafeResolutions)}).\n+\n fault_system_overload(Config) ->\n     SpanCtx = ?config(span_ctx, Config),\n     otel_span:add_event(SpanCtx, <<\"fault_system_overload_start\">>, #{}),\n-    \n+\n     % Create system overload conditions\n-    OverloadConditions = [\n-        {cpu_overload, fun() -> create_cpu_intensive_load() end},\n-        {memory_pressure, fun() -> create_memory_pressure() end},\n-        {io_saturation, fun() -> create_io_saturation() end},\n-        {network_congestion, fun() -> create_network_congestion() end}\n-    ],\n-    \n+    OverloadConditions =\n+        [{cpu_overload, fun() -> create_cpu_intensive_load() end},\n+         {memory_pressure, fun() -> create_memory_pressure() end},\n+         {io_saturation, fun() -> create_io_saturation() end},\n+         {network_congestion, fun() -> create_network_congestion() end}],\n+\n     % Apply each overload condition and test system behavior\n-    OverloadResults = lists:map(fun({OverloadType, OverloadFun}) ->\n-        otel_span:add_event(SpanCtx, <<\"applying_system_overload\">>, #{\n-            <<\"overload_type\">> => OverloadType\n-        }),\n-        \n-        OverloadProcess = spawn_link(OverloadFun),\n-        timer:sleep(5000), % Let overload take effect\n-        \n-        % Test system responsiveness\n-        ResponseTime = measure_system_responsiveness(),\n-        Throughput = measure_system_throughput(),\n-        \n-        exit(OverloadProcess, kill), % Stop overload\n-        timer:sleep(1000), % Let system recover\n-        \n-        {OverloadType, ResponseTime, Throughput}\n-    end, OverloadConditions),\n-    \n-    AvgResponseTime = lists:sum([RT || {_, RT, _} <- OverloadResults]) / length(OverloadResults),\n+    OverloadResults =\n+        lists:map(fun({OverloadType, OverloadFun}) ->\n+                     otel_span:add_event(SpanCtx,\n+                                         <<\"applying_system_overload\">>,\n+                                         #{<<\"overload_type\">> => OverloadType}),\n+\n+                     OverloadProcess = spawn_link(OverloadFun),\n+                     timer:sleep(5000), % Let overload take effect\n+\n+                     % Test system responsiveness\n+                     ResponseTime = measure_system_responsiveness(),\n+                     Throughput = measure_system_throughput(),\n+\n+                     exit(OverloadProcess, kill), % Stop overload\n+                     timer:sleep(1000), % Let system recover\n+\n+                     {OverloadType, ResponseTime, Throughput}\n+                  end,\n+                  OverloadConditions),\n+\n+    AvgResponseTime =\n+        lists:sum([RT || {_, RT, _} <- OverloadResults]) / length(OverloadResults),\n     MinThroughput = lists:min([TP || {_, _, TP} <- OverloadResults]),\n-    \n+\n     otel_span:set_attribute(SpanCtx, <<\"avg_response_time_ms\">>, AvgResponseTime),\n     otel_span:set_attribute(SpanCtx, <<\"min_throughput_ops\">>, MinThroughput),\n-    \n+\n     % System should degrade gracefully\n     ?assert(AvgResponseTime < 10000), % Less than 10 seconds\n     ?assert(MinThroughput > 0), % Should maintain some throughput\n-    \n-    otel_span:add_event(SpanCtx, <<\"fault_system_overload_complete\">>, #{\n-        <<\"overload_conditions\">> => length(OverloadConditions),\n-        <<\"avg_response_time\">> => AvgResponseTime,\n-        <<\"min_throughput\">> => MinThroughput\n-    }).\n \n+    otel_span:add_event(SpanCtx,\n+                        <<\"fault_system_overload_complete\">>,\n+                        #{<<\"overload_conditions\">> => length(OverloadConditions),\n+                          <<\"avg_response_time\">> => AvgResponseTime,\n+                          <<\"min_throughput\">> => MinThroughput}).\n+\n %% ============================================================================\n %% Fault Injection Infrastructure\n %% ============================================================================\n \n inject_fault(Type, Probability) ->\n     case rand:uniform() < Probability of\n-        true -> execute_fault(Type);\n-        false -> ok\n+        true ->\n+            execute_fault(Type);\n+        false ->\n+            ok\n     end.\n \n execute_fault(network_partition) ->\n     ct:pal(\"INJECTING NETWORK PARTITION\"),\n     % Simulate by blocking messages between nodes\n     block_inter_node_communication();\n-\n execute_fault(process_kill) ->\n     Processes = erlang:processes(),\n     case Processes of\n-        [] -> ok;\n+        [] ->\n+            ok;\n         _ ->\n-            Target = lists:nth(rand:uniform(length(Processes)), Processes),\n+            Target =\n+                lists:nth(\n+                    rand:uniform(length(Processes)), Processes),\n             ct:pal(\"KILLING PROCESS: ~p\", [Target]),\n             exit(Target, kill)\n     end;\n-\n execute_fault(memory_corruption) ->\n     ct:pal(\"CORRUPTING MEMORY\"),\n     corrupt_random_ets_table();\n-\n execute_fault(disk_failure) ->\n     ct:pal(\"SIMULATING DISK FAILURE\"),\n     simulate_disk_write_failure();\n-\n execute_fault(clock_skew) ->\n     ct:pal(\"INJECTING CLOCK SKEW\"),\n     inject_time_skew(rand:uniform(3600));\n-\n execute_fault(packet_loss) ->\n     ct:pal(\"INJECTING PACKET LOSS\"),\n     enable_packet_loss_simulation(rand:uniform(?PACKET_LOSS_MAX)).\n \n@@ -955,21 +958,28 @@\n     spawn_link(fun() -> chaos_monkey_loop() end).\n \n stop_chaos_monkey() ->\n     case whereis(chaos_monkey) of\n-        undefined -> ok;\n-        Pid -> exit(Pid, shutdown)\n+        undefined ->\n+            ok;\n+        Pid ->\n+            exit(Pid, shutdown)\n     end.\n \n chaos_monkey_loop() ->\n     register(chaos_monkey, self()),\n     timer:sleep(rand:uniform(5000) + 1000), % 1-6 seconds\n-    \n-    FaultType = lists:nth(rand:uniform(6), [\n-        network_partition, process_kill, memory_corruption,\n-        disk_failure, clock_skew, packet_loss\n-    ]),\n-    \n+\n+    FaultType =\n+        lists:nth(\n+            rand:uniform(6),\n+            [network_partition,\n+             process_kill,\n+             memory_corruption,\n+             disk_failure,\n+             clock_skew,\n+             packet_loss]),\n+\n     inject_fault(FaultType, ?CHAOS_PROBABILITY),\n     chaos_monkey_loop().\n \n generate_trace_id() ->\n@@ -977,15 +987,14 @@\n     io_lib:format(\"~16.16.0b~16.16.0b\", [A, B]).\n \n start_adversarial_span(TestCase, TraceId) ->\n     SpanName = iolist_to_binary([\"adversarial_test_\", atom_to_list(TestCase)]),\n-    otel_tracer:start_span(SpanName, #{\n-        <<\"test.name\">> => TestCase,\n-        <<\"test.type\">> => <<\"adversarial\">>,\n-        <<\"trace.id\">> => TraceId,\n-        <<\"chaos.enabled\">> => true,\n-        <<\"attack.simulation\">> => true\n-    }).\n+    otel_tracer:start_span(SpanName,\n+                           #{<<\"test.name\">> => TestCase,\n+                             <<\"test.type\">> => <<\"adversarial\">>,\n+                             <<\"trace.id\">> => TraceId,\n+                             <<\"chaos.enabled\">> => true,\n+                             <<\"attack.simulation\">> => true}).\n \n end_adversarial_span(SpanCtx, TestCase) ->\n     otel_span:set_attribute(SpanCtx, <<\"test.completed\">>, true),\n     otel_span:set_attribute(SpanCtx, <<\"test.result\">>, <<\"passed\">>),\n@@ -1003,13 +1012,16 @@\n     [spawn(fun() -> timer:sleep(60000) end) || _ <- lists:seq(1, N)].\n \n inject_process_kills(Processes, Probability) ->\n     lists:sum([begin\n-        case inject_fault(process_kill, Probability) of\n-            ok -> 1;\n-            _ -> 0\n-        end\n-    end || _ <- Processes]).\n+                   case inject_fault(process_kill, Probability) of\n+                       ok ->\n+                           1;\n+                       _ ->\n+                           0\n+                   end\n+               end\n+               || _ <- Processes]).\n \n measure_recovery_time() ->\n     rand:uniform(5000).\n \n@@ -1028,15 +1040,9 @@\n system_converged() ->\n     true.\n \n start_latency_injector(LatencyMs) ->\n-    spawn(fun() ->\n-        receive\n-            stop -> ok\n-        after LatencyMs ->\n-            timer:sleep(LatencyMs)\n-        end\n-    end).\n+    spawn(fun() -> receive stop -> ok after LatencyMs -> timer:sleep(LatencyMs) end end).\n \n stop_latency_injector(Pid) ->\n     Pid ! stop.\n \n@@ -1047,13 +1053,9 @@\n     Successful = length([Op || Op <- Operations, maps:get(result, Op) =:= success]),\n     Successful / length(Operations).\n \n start_packet_loss_injector(Percent) ->\n-    spawn(fun() ->\n-        receive stop -> ok\n-        after 1000 -> ok\n-        end\n-    end).\n+    spawn(fun() -> receive stop -> ok after 1000 -> ok end end).\n \n stop_packet_loss_injector(Pid) ->\n     Pid ! stop.\n \n@@ -1080,10 +1082,12 @@\n     rand:uniform(15000).\n \n inject_memory_corruption(Probability) ->\n     case inject_fault(memory_corruption, Probability) of\n-        ok -> 1;\n-        _ -> 0\n+        ok ->\n+            1;\n+        _ ->\n+            0\n     end.\n \n count_corruption_errors() ->\n     rand:uniform(5).\n@@ -1103,13 +1107,9 @@\n restore_disk_failures(_Failures) ->\n     ok.\n \n inject_clock_skew(Seconds) ->\n-    spawn(fun() ->\n-        receive stop -> ok\n-        after 10000 -> ok\n-        end\n-    end).\n+    spawn(fun() -> receive stop -> ok after 10000 -> ok end end).\n \n test_time_sensitive_operations(N) ->\n     [#{operation => I, result => success} || I <- lists:seq(1, N)].\n \n@@ -1127,11 +1127,13 @@\n     handled_gracefully.\n \n execute_resource_attack(AttackFun) ->\n     try AttackFun() of\n-        _ -> handled_gracefully\n+        _ ->\n+            handled_gracefully\n     catch\n-        _:_ -> handled_gracefully\n+        _:_ ->\n+            handled_gracefully\n     end.\n \n create_memory_bomb(_Size) ->\n     ok.\n@@ -1194,14 +1196,22 @@\n     true.\n \n attempt_service_registration(ServiceName, WorkerId) ->\n     case rand:uniform(50) of\n-        1 -> success; % Only one should succeed\n-        _ -> conflict\n+        1 ->\n+            success; % Only one should succeed\n+        _ ->\n+            conflict\n     end.\n \n collect_worker_results(Workers) ->\n-    [receive {W, Result} -> {W, Result} after 1000 -> {W, timeout} end || W <- Workers].\n+    [receive\n+         {W, Result} ->\n+             {W, Result}\n+     after 1000 ->\n+         {W, timeout}\n+     end\n+     || W <- Workers].\n \n start_message_sequencer() ->\n     spawn(fun() -> message_sequencer([]) end).\n \n@@ -1220,15 +1230,24 @@\n     Sequencer ! {message, Id}.\n \n wait_for_workers(Workers) ->\n     [begin\n-        monitor(process, W),\n-        receive {'DOWN', _, process, W, _} -> ok end\n-     end || W <- Workers].\n+         monitor(process, W),\n+         receive\n+             {'DOWN', _, process, W, _} ->\n+                 ok\n+         end\n+     end\n+     || W <- Workers].\n \n get_received_order(Sequencer) ->\n     Sequencer ! {get_order, self()},\n-    receive {order, Order} -> Order after 1000 -> [] end.\n+    receive\n+        {order, Order} ->\n+            Order\n+    after 1000 ->\n+        []\n+    end.\n \n count_ordering_violations(Order) ->\n     length([1 || {A, B} <- lists:zip(Order, tl(Order)), A > B]).\n \n@@ -1238,14 +1257,16 @@\n create_deadlock_resources() ->\n     {make_ref(), make_ref()}.\n \n acquire_resources_order_AB(A, B) ->\n-    timer:sleep(rand:uniform(100)),\n+    timer:sleep(\n+        rand:uniform(100)),\n     % Mock resource acquisition\n     ok.\n \n acquire_resources_order_BA(B, A) ->\n-    timer:sleep(rand:uniform(100)),\n+    timer:sleep(\n+        rand:uniform(100)),\n     % Mock resource acquisition\n     ok.\n \n start_deadlock_detector() ->\n@@ -1265,9 +1286,14 @@\n     end.\n \n get_deadlock_count(Detector) ->\n     Detector ! {get_count, self()},\n-    receive {count, Count} -> Count after 1000 -> 0 end.\n+    receive\n+        {count, Count} ->\n+            Count\n+    after 1000 ->\n+        0\n+    end.\n \n stop_deadlock_detector(Detector) ->\n     Detector ! stop.\n \n@@ -1278,12 +1304,16 @@\n     ets:new(complex_state, [public, set]).\n \n perform_state_operation(State, Operation, WorkerId) ->\n     case Operation of\n-        read -> ets:lookup(State, WorkerId);\n-        write -> ets:insert(State, {WorkerId, rand:uniform(1000)});\n-        delete -> ets:delete(State, WorkerId);\n-        update -> ets:update_element(State, WorkerId, {2, rand:uniform(1000)})\n+        read ->\n+            ets:lookup(State, WorkerId);\n+        write ->\n+            ets:insert(State, {WorkerId, rand:uniform(1000)});\n+        delete ->\n+            ets:delete(State, WorkerId);\n+        update ->\n+            ets:update_element(State, WorkerId, {2, rand:uniform(1000)})\n     end.\n \n detect_state_corruption(_State) ->\n     false.\n@@ -1316,10 +1346,12 @@\n     [{Type, #{cert => fake_cert, expires_in => ExpiresIn}} || {Type, ExpiresIn} <- CertSpecs].\n \n test_tls_connection_with_cert(Cert) ->\n     case maps:get(expires_in, Cert) of\n-        ExpiresIn when ExpiresIn < 0 -> rejected;\n-        _ -> accepted\n+        ExpiresIn when ExpiresIn < 0 ->\n+            rejected;\n+        _ ->\n+            accepted\n     end.\n \n inject_dns_poisoning(DomainSpecs) ->\n     DomainSpecs.\n@@ -1331,24 +1363,23 @@\n     ok.\n \n create_cpu_intensive_load() ->\n     fun() ->\n-        lists:sum(lists:seq(1, 1000000))\n+       lists:sum(\n+           lists:seq(1, 1000000))\n     end.\n \n create_memory_pressure() ->\n     fun() ->\n-        binary:copy(<<0>>, 1048576) % 1MB\n+       binary:copy(<<0>>, 1048576) % 1MB\n     end.\n \n create_io_saturation() ->\n-    fun() ->\n-        file:write_file(\"/tmp/test_io\", binary:copy(<<0>>, 1048576))\n-    end.\n+    fun() -> file:write_file(\"/tmp/test_io\", binary:copy(<<0>>, 1048576)) end.\n \n create_network_congestion() ->\n     fun() ->\n-        ok % Mock network congestion\n+       ok % Mock network congestion\n     end.\n \n measure_system_responsiveness() ->\n     rand:uniform(1000).\n@@ -1356,12 +1387,27 @@\n measure_system_throughput() ->\n     rand:uniform(1000).\n \n % Additional utility functions for cleanup...\n-block_inter_node_communication() -> ok.\n-corrupt_random_ets_table() -> ok.\n-simulate_disk_write_failure() -> ok.\n-inject_time_skew(_Seconds) -> ok.\n-enable_packet_loss_simulation(_Percent) -> ok.\n-restore_normal_networking() -> ok.\n-cleanup_corrupted_memory() -> ok.\n-restore_system_clocks() -> ok.\n\\ No newline at end of file\n+block_inter_node_communication() ->\n+    ok.\n+\n+corrupt_random_ets_table() ->\n+    ok.\n+\n+simulate_disk_write_failure() ->\n+    ok.\n+\n+inject_time_skew(_Seconds) ->\n+    ok.\n+\n+enable_packet_loss_simulation(_Percent) ->\n+    ok.\n+\n+restore_normal_networking() ->\n+    ok.\n+\n+cleanup_corrupted_memory() ->\n+    ok.\n+\n+restore_system_clocks() ->\n+    ok.\n"
                }
            ],
            "date": 1756184977914,
            "name": "Commit-0",
            "content": "-module(erlmcp_adversarial_SUITE).\n-compile(export_all).\n\n-include_lib(\"common_test/include/ct.hrl\").\n-include_lib(\"eunit/include/eunit.hrl\").\n\n%% Common Test callbacks\n-export([suite/0, init_per_suite/1, end_per_suite/1,\n         init_per_testcase/2, end_per_testcase/2,\n         all/0, groups/0]).\n\n%% Chaos Engineering Tests\n-export([chaos_process_killer/1,\n         chaos_network_partition/1,\n         chaos_latency_injection/1,\n         chaos_packet_loss/1,\n         chaos_byzantine_failure/1,\n         chaos_memory_corruption/1,\n         chaos_disk_failure/1,\n         chaos_clock_skew/1]).\n\n%% Security Fuzzing Tests\n-export([fuzz_json_rpc_protocol/1,\n         fuzz_buffer_overflow/1,\n         fuzz_resource_exhaustion/1,\n         fuzz_timing_attacks/1,\n         fuzz_input_validation/1,\n         fuzz_authentication_bypass/1,\n         fuzz_malformed_messages/1]).\n\n%% Race Condition Tests\n-export([race_concurrent_mutations/1,\n         race_registration_conflicts/1,\n         race_message_ordering/1,\n         race_deadlock_scenarios/1,\n         race_state_corruption/1]).\n\n%% Fault Injection Tests\n-export([fault_memory_corruption/1,\n         fault_disk_corruption/1,\n         fault_certificate_expiration/1,\n         fault_dns_poisoning/1,\n         fault_system_overload/1]).\n\n-define(CHAOS_PROBABILITY, 0.3).\n-define(MAX_LATENCY_MS, 10000).\n-define(PACKET_LOSS_MAX, 50).\n-define(FUZZ_ITERATIONS, 1000).\n-define(RACE_WORKERS, 100).\n\nsuite() ->\n    [{timetrap, {minutes, 30}}].\n\ninit_per_suite(Config) ->\n    application:ensure_all_started(opentelemetry),\n    application:ensure_all_started(erlmcp),\n    start_chaos_monkey(),\n    [{adversarial_mode, true} | Config].\n\nend_per_suite(_Config) ->\n    stop_chaos_monkey(),\n    application:stop(erlmcp),\n    application:stop(opentelemetry),\n    ok.\n\ninit_per_testcase(TestCase, Config) ->\n    TraceId = generate_trace_id(),\n    SpanCtx = start_adversarial_span(TestCase, TraceId),\n    [{trace_id, TraceId}, {span_ctx, SpanCtx} | Config].\n\nend_per_testcase(TestCase, Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    end_adversarial_span(SpanCtx, TestCase),\n    cleanup_chaos_state(),\n    Config.\n\nall() ->\n    [\n     {group, chaos_engineering},\n     {group, security_fuzzing},\n     {group, race_conditions},\n     {group, fault_injection}\n    ].\n\ngroups() ->\n    [\n     {chaos_engineering, [parallel], [\n        chaos_process_killer,\n        chaos_network_partition,\n        chaos_latency_injection,\n        chaos_packet_loss,\n        chaos_byzantine_failure,\n        chaos_memory_corruption,\n        chaos_disk_failure,\n        chaos_clock_skew\n     ]},\n     {security_fuzzing, [parallel], [\n        fuzz_json_rpc_protocol,\n        fuzz_buffer_overflow,\n        fuzz_resource_exhaustion,\n        fuzz_timing_attacks,\n        fuzz_input_validation,\n        fuzz_authentication_bypass,\n        fuzz_malformed_messages\n     ]},\n     {race_conditions, [sequence], [\n        race_concurrent_mutations,\n        race_registration_conflicts,\n        race_message_ordering,\n        race_deadlock_scenarios,\n        race_state_corruption\n     ]},\n     {fault_injection, [parallel], [\n        fault_memory_corruption,\n        fault_disk_corruption,\n        fault_certificate_expiration,\n        fault_dns_poisoning,\n        fault_system_overload\n     ]}\n    ].\n\n%% ============================================================================\n%% Chaos Engineering Tests\n%% ============================================================================\n\nchaos_process_killer(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"chaos_process_killer_start\">>, #{}),\n    \n    % Start target processes\n    Processes = start_target_processes(10),\n    otel_span:set_attribute(SpanCtx, <<\"target_processes\">>, length(Processes)),\n    \n    % Inject random process kills\n    KillCount = inject_process_kills(Processes, ?CHAOS_PROBABILITY),\n    otel_span:set_attribute(SpanCtx, <<\"processes_killed\">>, KillCount),\n    \n    % Verify system recovery\n    RecoveryTime = measure_recovery_time(),\n    otel_span:set_attribute(SpanCtx, <<\"recovery_time_ms\">>, RecoveryTime),\n    \n    % Assert system survived\n    ?assert(system_is_healthy()),\n    otel_span:add_event(SpanCtx, <<\"chaos_process_killer_complete\">>, #{\n        <<\"processes_killed\">> => KillCount,\n        <<\"recovery_time\">> => RecoveryTime\n    }).\n\nchaos_network_partition(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"chaos_network_partition_start\">>, #{}),\n    \n    % Create network partitions\n    Partitions = create_network_partitions(3),\n    otel_span:set_attribute(SpanCtx, <<\"partition_count\">>, length(Partitions)),\n    \n    timer:sleep(5000), % Let chaos ensue\n    \n    % Heal partitions\n    heal_network_partitions(Partitions),\n    \n    % Measure convergence time\n    ConvergenceTime = measure_convergence_time(),\n    otel_span:set_attribute(SpanCtx, <<\"convergence_time_ms\">>, ConvergenceTime),\n    \n    ?assert(system_converged()),\n    otel_span:add_event(SpanCtx, <<\"chaos_network_partition_complete\">>, #{\n        <<\"convergence_time\">> => ConvergenceTime\n    }).\n\nchaos_latency_injection(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"chaos_latency_injection_start\">>, #{}),\n    \n    LatencyMs = rand:uniform(?MAX_LATENCY_MS),\n    otel_span:set_attribute(SpanCtx, <<\"injected_latency_ms\">>, LatencyMs),\n    \n    % Inject latency into message passing\n    LatencyInjector = start_latency_injector(LatencyMs),\n    \n    % Perform operations under latency\n    Operations = perform_latency_sensitive_operations(100),\n    SuccessRate = calculate_success_rate(Operations),\n    \n    otel_span:set_attribute(SpanCtx, <<\"success_rate\">>, SuccessRate),\n    \n    stop_latency_injector(LatencyInjector),\n    \n    % System should degrade gracefully\n    ?assert(SuccessRate > 0.7), % At least 70% should succeed\n    otel_span:add_event(SpanCtx, <<\"chaos_latency_injection_complete\">>, #{\n        <<\"success_rate\">> => SuccessRate\n    }).\n\nchaos_packet_loss(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"chaos_packet_loss_start\">>, #{}),\n    \n    LossPercent = rand:uniform(?PACKET_LOSS_MAX),\n    otel_span:set_attribute(SpanCtx, <<\"packet_loss_percent\">>, LossPercent),\n    \n    % Inject packet loss\n    PacketLossInjector = start_packet_loss_injector(LossPercent),\n    \n    % Measure message delivery rates\n    {Sent, Received} = measure_message_delivery(1000),\n    ActualLossRate = (Sent - Received) / Sent * 100,\n    \n    otel_span:set_attribute(SpanCtx, <<\"actual_loss_rate\">>, ActualLossRate),\n    \n    stop_packet_loss_injector(PacketLossInjector),\n    \n    % Verify retransmission works\n    ?assert(ActualLossRate =< LossPercent * 1.1), % Allow 10% variance\n    otel_span:add_event(SpanCtx, <<\"chaos_packet_loss_complete\">>, #{\n        <<\"actual_loss_rate\">> => ActualLossRate\n    }).\n\nchaos_byzantine_failure(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"chaos_byzantine_failure_start\">>, #{}),\n    \n    % Create Byzantine nodes that send conflicting messages\n    ByzantineNodes = start_byzantine_nodes(3),\n    otel_span:set_attribute(SpanCtx, <<\"byzantine_node_count\">>, length(ByzantineNodes)),\n    \n    % Let them cause havoc\n    timer:sleep(10000),\n    \n    % Measure system consensus despite Byzantine failures\n    ConsensusReached = check_consensus_reached(),\n    ConsensusTime = measure_consensus_time(),\n    \n    otel_span:set_attribute(SpanCtx, <<\"consensus_reached\">>, ConsensusReached),\n    otel_span:set_attribute(SpanCtx, <<\"consensus_time_ms\">>, ConsensusTime),\n    \n    stop_byzantine_nodes(ByzantineNodes),\n    \n    ?assert(ConsensusReached),\n    otel_span:add_event(SpanCtx, <<\"chaos_byzantine_failure_complete\">>, #{\n        <<\"consensus_time\">> => ConsensusTime\n    }).\n\nchaos_memory_corruption(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"chaos_memory_corruption_start\">>, #{}),\n    \n    % Corrupt ETS tables randomly\n    CorruptionCount = inject_memory_corruption(?CHAOS_PROBABILITY),\n    otel_span:set_attribute(SpanCtx, <<\"corrupted_tables\">>, CorruptionCount),\n    \n    % Verify error handling\n    ErrorsDetected = count_corruption_errors(),\n    RecoveryTime = measure_memory_recovery_time(),\n    \n    otel_span:set_attribute(SpanCtx, <<\"errors_detected\">>, ErrorsDetected),\n    otel_span:set_attribute(SpanCtx, <<\"recovery_time_ms\">>, RecoveryTime),\n    \n    ?assert(ErrorsDetected > 0), % Should detect corruption\n    ?assert(system_recovered_from_corruption()),\n    \n    otel_span:add_event(SpanCtx, <<\"chaos_memory_corruption_complete\">>, #{\n        <<\"errors_detected\">> => ErrorsDetected,\n        <<\"recovery_time\">> => RecoveryTime\n    }).\n\nchaos_disk_failure(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"chaos_disk_failure_start\">>, #{}),\n    \n    % Simulate disk failures\n    FailedDisks = simulate_disk_failures(2),\n    otel_span:set_attribute(SpanCtx, <<\"failed_disk_count\">>, length(FailedDisks)),\n    \n    % Test persistence operations\n    PersistenceOperations = test_persistence_under_failure(100),\n    SuccessRate = calculate_success_rate(PersistenceOperations),\n    \n    otel_span:set_attribute(SpanCtx, <<\"persistence_success_rate\">>, SuccessRate),\n    \n    restore_disk_failures(FailedDisks),\n    \n    ?assert(SuccessRate > 0.5), % Should handle some failures\n    otel_span:add_event(SpanCtx, <<\"chaos_disk_failure_complete\">>, #{\n        <<\"success_rate\">> => SuccessRate\n    }).\n\nchaos_clock_skew(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"chaos_clock_skew_start\">>, #{}),\n    \n    % Inject clock skew\n    SkewSeconds = rand:uniform(3600), % Up to 1 hour\n    otel_span:set_attribute(SpanCtx, <<\"clock_skew_seconds\">>, SkewSeconds),\n    \n    ClockSkewer = inject_clock_skew(SkewSeconds),\n    \n    % Test time-sensitive operations\n    TimeOperations = test_time_sensitive_operations(50),\n    SuccessRate = calculate_success_rate(TimeOperations),\n    \n    otel_span:set_attribute(SpanCtx, <<\"time_ops_success_rate\">>, SuccessRate),\n    \n    stop_clock_skew(ClockSkewer),\n    \n    ?assert(SuccessRate > 0.6), % Should handle moderate clock skew\n    otel_span:add_event(SpanCtx, <<\"chaos_clock_skew_complete\">>, #{\n        <<\"success_rate\">> => SuccessRate\n    }).\n\n%% ============================================================================\n%% Security Fuzzing Tests\n%% ============================================================================\n\nfuzz_json_rpc_protocol(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"fuzz_json_rpc_start\">>, #{}),\n    \n    Crashes = 0,\n    SecurityViolations = 0,\n    \n    % Generate malicious JSON-RPC messages\n    lists:foreach(fun(I) ->\n        MaliciousMsg = generate_malicious_json_rpc(I),\n        otel_span:add_event(SpanCtx, <<\"sending_malicious_message\">>, #{\n            <<\"iteration\">> => I,\n            <<\"message_type\">> => maps:get(type, MaliciousMsg, unknown)\n        }),\n        \n        Result = send_malicious_message(MaliciousMsg),\n        case Result of\n            crash -> Crashes + 1;\n            security_violation -> SecurityViolations + 1;\n            _ -> ok\n        end\n    end, lists:seq(1, ?FUZZ_ITERATIONS)),\n    \n    otel_span:set_attribute(SpanCtx, <<\"crashes_detected\">>, Crashes),\n    otel_span:set_attribute(SpanCtx, <<\"security_violations\">>, SecurityViolations),\n    \n    ?assert(Crashes =:= 0), % No crashes allowed\n    ?assert(SecurityViolations =:= 0), % No security violations\n    \n    otel_span:add_event(SpanCtx, <<\"fuzz_json_rpc_complete\">>, #{\n        <<\"iterations\">> => ?FUZZ_ITERATIONS,\n        <<\"crashes\">> => Crashes,\n        <<\"violations\">> => SecurityViolations\n    }).\n\nfuzz_buffer_overflow(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"fuzz_buffer_overflow_start\">>, #{}),\n    \n    OverflowAttempts = lists:map(fun(Size) ->\n        LargePayload = binary:copy(<<$A>>, Size),\n        otel_span:add_event(SpanCtx, <<\"buffer_overflow_attempt\">>, #{\n            <<\"payload_size\">> => Size\n        }),\n        \n        Result = attempt_buffer_overflow(LargePayload),\n        {Size, Result}\n    end, [1024, 10240, 102400, 1048576, 10485760]), % 1KB to 10MB\n    \n    Failures = [R || {_, R} <- OverflowAttempts, R =:= failure],\n    \n    otel_span:set_attribute(SpanCtx, <<\"overflow_attempts\">>, length(OverflowAttempts)),\n    otel_span:set_attribute(SpanCtx, <<\"failures\">>, length(Failures)),\n    \n    ?assert(length(Failures) =:= 0), % All should be handled gracefully\n    \n    otel_span:add_event(SpanCtx, <<\"fuzz_buffer_overflow_complete\">>, #{\n        <<\"attempts\">> => length(OverflowAttempts),\n        <<\"failures\">> => length(Failures)\n    }).\n\nfuzz_resource_exhaustion(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"fuzz_resource_exhaustion_start\">>, #{}),\n    \n    % Attack vectors\n    AttackVectors = [\n        {memory_bomb, fun() -> create_memory_bomb(1000000) end},\n        {process_bomb, fun() -> create_process_bomb(10000) end},\n        {file_descriptor_bomb, fun() -> create_fd_bomb(1000) end},\n        {cpu_bomb, fun() -> create_cpu_bomb(100) end}\n    ],\n    \n    Results = lists:map(fun({AttackType, AttackFun}) ->\n        otel_span:add_event(SpanCtx, <<\"resource_exhaustion_attack\">>, #{\n            <<\"attack_type\">> => AttackType\n        }),\n        \n        StartTime = erlang:monotonic_time(millisecond),\n        Result = execute_resource_attack(AttackFun),\n        EndTime = erlang:monotonic_time(millisecond),\n        \n        {AttackType, Result, EndTime - StartTime}\n    end, AttackVectors),\n    \n    SystemSurvived = system_is_healthy(),\n    otel_span:set_attribute(SpanCtx, <<\"system_survived\">>, SystemSurvived),\n    \n    ?assert(SystemSurvived), % System should survive all attacks\n    \n    otel_span:add_event(SpanCtx, <<\"fuzz_resource_exhaustion_complete\">>, #{\n        <<\"attack_count\">> => length(AttackVectors),\n        <<\"system_survived\">> => SystemSurvived\n    }).\n\nfuzz_timing_attacks(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"fuzz_timing_attacks_start\">>, #{}),\n    \n    % Measure timing differences in authentication\n    TimingResults = lists:map(fun(_) ->\n        ValidUser = generate_valid_credentials(),\n        InvalidUser = generate_invalid_credentials(),\n        \n        ValidTime = measure_auth_time(ValidUser),\n        InvalidTime = measure_auth_time(InvalidUser),\n        \n        otel_span:add_event(SpanCtx, <<\"timing_measurement\">>, #{\n            <<\"valid_time_us\">> => ValidTime,\n            <<\"invalid_time_us\">> => InvalidTime,\n            <<\"time_diff_us\">> => abs(ValidTime - InvalidTime)\n        }),\n        \n        abs(ValidTime - InvalidTime)\n    end, lists:seq(1, 100)),\n    \n    AvgTimingDiff = lists:sum(TimingResults) / length(TimingResults),\n    MaxTimingDiff = lists:max(TimingResults),\n    \n    otel_span:set_attribute(SpanCtx, <<\"avg_timing_diff_us\">>, AvgTimingDiff),\n    otel_span:set_attribute(SpanCtx, <<\"max_timing_diff_us\">>, MaxTimingDiff),\n    \n    % Timing differences should be minimal\n    ?assert(AvgTimingDiff < 1000), % Less than 1ms average difference\n    ?assert(MaxTimingDiff < 5000), % Less than 5ms max difference\n    \n    otel_span:add_event(SpanCtx, <<\"fuzz_timing_attacks_complete\">>, #{\n        <<\"avg_timing_diff\">> => AvgTimingDiff,\n        <<\"max_timing_diff\">> => MaxTimingDiff\n    }).\n\nfuzz_input_validation(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"fuzz_input_validation_start\">>, #{}),\n    \n    % Generate malicious inputs\n    MaliciousInputs = generate_malicious_inputs(1000),\n    \n    ValidationResults = lists:map(fun(Input) ->\n        otel_span:add_event(SpanCtx, <<\"testing_malicious_input\">>, #{\n            <<\"input_type\">> => maps:get(type, Input, unknown),\n            <<\"input_size\">> => byte_size(maps:get(payload, Input, <<>>))\n        }),\n        \n        test_input_validation(Input)\n    end, MaliciousInputs),\n    \n    Bypasses = [R || R <- ValidationResults, R =:= bypass],\n    Crashes = [R || R <- ValidationResults, R =:= crash],\n    \n    otel_span:set_attribute(SpanCtx, <<\"validation_bypasses\">>, length(Bypasses)),\n    otel_span:set_attribute(SpanCtx, <<\"validation_crashes\">>, length(Crashes)),\n    \n    ?assert(length(Bypasses) =:= 0), % No validation bypasses\n    ?assert(length(Crashes) =:= 0), % No crashes from bad input\n    \n    otel_span:add_event(SpanCtx, <<\"fuzz_input_validation_complete\">>, #{\n        <<\"inputs_tested\">> => length(MaliciousInputs),\n        <<\"bypasses\">> => length(Bypasses),\n        <<\"crashes\">> => length(Crashes)\n    }).\n\nfuzz_authentication_bypass(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"fuzz_auth_bypass_start\">>, #{}),\n    \n    % Generate authentication bypass attempts\n    BypassAttempts = generate_auth_bypass_attempts(500),\n    \n    BypassResults = lists:map(fun(Attempt) ->\n        otel_span:add_event(SpanCtx, <<\"auth_bypass_attempt\">>, #{\n            <<\"attempt_type\">> => maps:get(type, Attempt, unknown)\n        }),\n        \n        test_auth_bypass(Attempt)\n    end, BypassAttempts),\n    \n    SuccessfulBypasses = [R || R <- BypassResults, R =:= success],\n    \n    otel_span:set_attribute(SpanCtx, <<\"bypass_attempts\">>, length(BypassAttempts)),\n    otel_span:set_attribute(SpanCtx, <<\"successful_bypasses\">>, length(SuccessfulBypasses)),\n    \n    ?assert(length(SuccessfulBypasses) =:= 0), % No bypasses should succeed\n    \n    otel_span:add_event(SpanCtx, <<\"fuzz_auth_bypass_complete\">>, #{\n        <<\"attempts\">> => length(BypassAttempts),\n        <<\"bypasses\">> => length(SuccessfulBypasses)\n    }).\n\nfuzz_malformed_messages(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"fuzz_malformed_messages_start\">>, #{}),\n    \n    % Generate various malformed messages\n    MalformedMessages = generate_malformed_messages(2000),\n    \n    ProcessingResults = lists:map(fun(Message) ->\n        otel_span:add_event(SpanCtx, <<\"processing_malformed_message\">>, #{\n            <<\"message_type\">> => maps:get(type, Message, unknown),\n            <<\"corruption_type\">> => maps:get(corruption, Message, unknown)\n        }),\n        \n        process_malformed_message(Message)\n    end, MalformedMessages),\n    \n    Crashes = [R || R <- ProcessingResults, R =:= crash],\n    Hangs = [R || R <- ProcessingResults, R =:= hang],\n    MemoryLeaks = [R || R <- ProcessingResults, R =:= memory_leak],\n    \n    otel_span:set_attribute(SpanCtx, <<\"message_crashes\">>, length(Crashes)),\n    otel_span:set_attribute(SpanCtx, <<\"message_hangs\">>, length(Hangs)),\n    otel_span:set_attribute(SpanCtx, <<\"memory_leaks\">>, length(MemoryLeaks)),\n    \n    ?assert(length(Crashes) =:= 0),\n    ?assert(length(Hangs) =:= 0),\n    ?assert(length(MemoryLeaks) =:= 0),\n    \n    otel_span:add_event(SpanCtx, <<\"fuzz_malformed_messages_complete\">>, #{\n        <<\"messages_processed\">> => length(MalformedMessages),\n        <<\"crashes\">> => length(Crashes),\n        <<\"hangs\">> => length(Hangs),\n        <<\"memory_leaks\">> => length(MemoryLeaks)\n    }).\n\n%% ============================================================================\n%% Race Condition Tests\n%% ============================================================================\n\nrace_concurrent_mutations(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"race_concurrent_mutations_start\">>, #{}),\n    \n    % Create shared state\n    StateRef = create_shared_state(),\n    \n    % Spawn concurrent workers\n    Workers = spawn_mutation_workers(?RACE_WORKERS, StateRef),\n    otel_span:set_attribute(SpanCtx, <<\"worker_count\">>, length(Workers)),\n    \n    % Let them race\n    timer:sleep(5000),\n    \n    % Stop workers and check consistency\n    stop_workers(Workers),\n    FinalState = get_final_state(StateRef),\n    ConsistencyCheck = check_state_consistency(FinalState),\n    \n    otel_span:set_attribute(SpanCtx, <<\"state_consistent\">>, ConsistencyCheck),\n    \n    ?assert(ConsistencyCheck), % State should be consistent despite races\n    \n    otel_span:add_event(SpanCtx, <<\"race_concurrent_mutations_complete\">>, #{\n        <<\"workers\">> => length(Workers),\n        <<\"consistent\">> => ConsistencyCheck\n    }).\n\nrace_registration_conflicts(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"race_registration_conflicts_start\">>, #{}),\n    \n    % Try to register the same service from multiple processes\n    ServiceName = \"test_service_\" ++ integer_to_list(rand:uniform(1000000)),\n    \n    RegistrationWorkers = lists:map(fun(I) ->\n        spawn_link(fun() ->\n            otel_span:add_event(SpanCtx, <<\"attempting_registration\">>, #{\n                <<\"worker_id\">> => I,\n                <<\"service_name\">> => ServiceName\n            }),\n            Result = attempt_service_registration(ServiceName, I),\n            {I, Result}\n        end)\n    end, lists:seq(1, 50)),\n    \n    % Collect results\n    Results = collect_worker_results(RegistrationWorkers),\n    Successful = [R || {_, R} <- Results, R =:= success],\n    \n    otel_span:set_attribute(SpanCtx, <<\"registration_attempts\">>, length(Results)),\n    otel_span:set_attribute(SpanCtx, <<\"successful_registrations\">>, length(Successful)),\n    \n    % Only one should succeed\n    ?assert(length(Successful) =:= 1),\n    \n    otel_span:add_event(SpanCtx, <<\"race_registration_conflicts_complete\">>, #{\n        <<\"attempts\">> => length(Results),\n        <<\"successful\">> => length(Successful)\n    }).\n\nrace_message_ordering(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"race_message_ordering_start\">>, #{}),\n    \n    % Create message ordering test\n    MessageSequencer = start_message_sequencer(),\n    \n    % Send messages concurrently with expected order\n    MessageWorkers = lists:map(fun(I) ->\n        spawn_link(fun() ->\n            otel_span:add_event(SpanCtx, <<\"sending_ordered_message\">>, #{\n                <<\"message_id\">> => I\n            }),\n            send_ordered_message(MessageSequencer, I)\n        end)\n    end, lists:seq(1, 100)),\n    \n    % Wait for all messages\n    wait_for_workers(MessageWorkers),\n    \n    % Check message ordering\n    ReceivedOrder = get_received_order(MessageSequencer),\n    OrderingViolations = count_ordering_violations(ReceivedOrder),\n    \n    otel_span:set_attribute(SpanCtx, <<\"ordering_violations\">>, OrderingViolations),\n    \n    stop_message_sequencer(MessageSequencer),\n    \n    ?assert(OrderingViolations =< 5), % Allow some reordering\n    \n    otel_span:add_event(SpanCtx, <<\"race_message_ordering_complete\">>, #{\n        <<\"messages_sent\">> => 100,\n        <<\"ordering_violations\">> => OrderingViolations\n    }).\n\nrace_deadlock_scenarios(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"race_deadlock_scenarios_start\">>, #{}),\n    \n    % Create deadlock-prone scenario\n    {ResourceA, ResourceB} = create_deadlock_resources(),\n    \n    % Spawn processes that acquire resources in different orders\n    DeadlockWorkers = lists:map(fun(I) ->\n        spawn_link(fun() ->\n            case I rem 2 of\n                0 -> % Even: A then B\n                    otel_span:add_event(SpanCtx, <<\"acquiring_resources_AB\">>, #{\n                        <<\"worker_id\">> => I\n                    }),\n                    acquire_resources_order_AB(ResourceA, ResourceB);\n                1 -> % Odd: B then A\n                    otel_span:add_event(SpanCtx, <<\"acquiring_resources_BA\">>, #{\n                        <<\"worker_id\">> => I\n                    }),\n                    acquire_resources_order_BA(ResourceA, ResourceB)\n            end\n        end)\n    end, lists:seq(1, 20)),\n    \n    % Monitor for deadlocks\n    DeadlockDetector = start_deadlock_detector(),\n    timer:sleep(10000), % Let potential deadlock develop\n    \n    DeadlocksDetected = get_deadlock_count(DeadlockDetector),\n    stop_deadlock_detector(DeadlockDetector),\n    \n    otel_span:set_attribute(SpanCtx, <<\"deadlocks_detected\">>, DeadlocksDetected),\n    \n    % Clean up any stuck processes\n    cleanup_deadlock_workers(DeadlockWorkers),\n    \n    ?assert(DeadlocksDetected =:= 0), % No deadlocks should occur\n    \n    otel_span:add_event(SpanCtx, <<\"race_deadlock_scenarios_complete\">>, #{\n        <<\"workers\">> => length(DeadlockWorkers),\n        <<\"deadlocks\">> => DeadlocksDetected\n    }).\n\nrace_state_corruption(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"race_state_corruption_start\">>, #{}),\n    \n    % Create complex state that can be corrupted\n    ComplexState = create_complex_state(),\n    \n    % Spawn many processes doing state operations\n    StateWorkers = lists:map(fun(I) ->\n        spawn_link(fun() ->\n            Operations = [read, write, delete, update],\n            Operation = lists:nth(rand:uniform(length(Operations)), Operations),\n            \n            otel_span:add_event(SpanCtx, <<\"state_operation\">>, #{\n                <<\"worker_id\">> => I,\n                <<\"operation\">> => Operation\n            }),\n            \n            perform_state_operation(ComplexState, Operation, I)\n        end)\n    end, lists:seq(1, 200)),\n    \n    % Wait for all operations\n    wait_for_workers(StateWorkers),\n    \n    % Check for state corruption\n    CorruptionDetected = detect_state_corruption(ComplexState),\n    StateIntegrity = check_state_integrity(ComplexState),\n    \n    otel_span:set_attribute(SpanCtx, <<\"corruption_detected\">>, CorruptionDetected),\n    otel_span:set_attribute(SpanCtx, <<\"state_integrity\">>, StateIntegrity),\n    \n    ?assert(not CorruptionDetected),\n    ?assert(StateIntegrity),\n    \n    otel_span:add_event(SpanCtx, <<\"race_state_corruption_complete\">>, #{\n        <<\"operations\">> => length(StateWorkers),\n        <<\"corruption_detected\">> => CorruptionDetected,\n        <<\"state_integrity\">> => StateIntegrity\n    }).\n\n%% ============================================================================\n%% Fault Injection Tests\n%% ============================================================================\n\nfault_memory_corruption(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"fault_memory_corruption_start\">>, #{}),\n    \n    MemoryFaults = inject_memory_faults([\n        {heap_corruption, 0.1},\n        {stack_overflow, 0.05},\n        {buffer_overrun, 0.1},\n        {use_after_free, 0.05}\n    ]),\n    \n    otel_span:set_attribute(SpanCtx, <<\"memory_faults_injected\">>, MemoryFaults),\n    \n    % Test system under memory corruption\n    OperationResults = perform_memory_intensive_operations(100),\n    SuccessRate = calculate_success_rate(OperationResults),\n    ErrorsHandled = count_memory_errors_handled(),\n    \n    otel_span:set_attribute(SpanCtx, <<\"success_rate\">>, SuccessRate),\n    otel_span:set_attribute(SpanCtx, <<\"errors_handled\">>, ErrorsHandled),\n    \n    ?assert(SuccessRate > 0.8), % Should handle most memory faults\n    ?assert(ErrorsHandled > 0), % Should detect and handle errors\n    \n    otel_span:add_event(SpanCtx, <<\"fault_memory_corruption_complete\">>, #{\n        <<\"faults_injected\">> => MemoryFaults,\n        <<\"success_rate\">> => SuccessRate,\n        <<\"errors_handled\">> => ErrorsHandled\n    }).\n\nfault_disk_corruption(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"fault_disk_corruption_start\">>, #{}),\n    \n    % Inject disk corruption faults\n    DiskFaults = inject_disk_faults([\n        {sector_corruption, 0.1},\n        {file_system_corruption, 0.05},\n        {metadata_corruption, 0.1}\n    ]),\n    \n    otel_span:set_attribute(SpanCtx, <<\"disk_faults_injected\">>, DiskFaults),\n    \n    % Test file operations under corruption\n    FileOperations = perform_file_operations_under_corruption(50),\n    ChecksumsValid = verify_file_checksums(FileOperations),\n    DataIntegrity = check_data_integrity(FileOperations),\n    \n    otel_span:set_attribute(SpanCtx, <<\"checksums_valid\">>, ChecksumsValid),\n    otel_span:set_attribute(SpanCtx, <<\"data_integrity\">>, DataIntegrity),\n    \n    ?assert(ChecksumsValid > 0.9), % Most checksums should be valid\n    ?assert(DataIntegrity), % Data integrity should be maintained\n    \n    otel_span:add_event(SpanCtx, <<\"fault_disk_corruption_complete\">>, #{\n        <<\"faults_injected\">> => DiskFaults,\n        <<\"checksums_valid\">> => ChecksumsValid,\n        <<\"data_integrity\">> => DataIntegrity\n    }).\n\nfault_certificate_expiration(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"fault_certificate_expiration_start\">>, #{}),\n    \n    % Create certificates with various expiration times\n    Certificates = create_test_certificates([\n        {expired, -86400},    % Expired yesterday\n        {expiring_soon, 3600}, % Expires in 1 hour\n        {valid, 86400 * 30}   % Expires in 30 days\n    ]),\n    \n    otel_span:set_attribute(SpanCtx, <<\"certificates_created\">>, length(Certificates)),\n    \n    % Test TLS connections with each certificate\n    ConnectionResults = lists:map(fun({CertType, Cert}) ->\n        otel_span:add_event(SpanCtx, <<\"testing_certificate\">>, #{\n            <<\"cert_type\">> => CertType\n        }),\n        \n        Result = test_tls_connection_with_cert(Cert),\n        {CertType, Result}\n    end, Certificates),\n    \n    ExpiredRejected = length([R || {expired, R} <- ConnectionResults, R =:= rejected]),\n    ValidAccepted = length([R || {valid, R} <- ConnectionResults, R =:= accepted]),\n    \n    otel_span:set_attribute(SpanCtx, <<\"expired_rejected\">>, ExpiredRejected),\n    otel_span:set_attribute(SpanCtx, <<\"valid_accepted\">>, ValidAccepted),\n    \n    ?assert(ExpiredRejected > 0), % Expired certs should be rejected\n    ?assert(ValidAccepted > 0), % Valid certs should be accepted\n    \n    otel_span:add_event(SpanCtx, <<\"fault_certificate_expiration_complete\">>, #{\n        <<\"expired_rejected\">> => ExpiredRejected,\n        <<\"valid_accepted\">> => ValidAccepted\n    }).\n\nfault_dns_poisoning(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"fault_dns_poisoning_start\">>, #{}),\n    \n    % Inject DNS poisoning\n    PoisonedDomains = inject_dns_poisoning([\n        {\"legitimate-service.com\", \"192.168.1.100\"}, % Point to malicious IP\n        {\"api.service.com\", \"10.0.0.100\"}\n    ]),\n    \n    otel_span:set_attribute(SpanCtx, <<\"poisoned_domains\">>, length(PoisonedDomains)),\n    \n    % Test DNS resolution and connection behavior\n    DNSResults = lists:map(fun({Domain, _}) ->\n        otel_span:add_event(SpanCtx, <<\"testing_poisoned_dns\">>, #{\n            <<\"domain\">> => Domain\n        }),\n        \n        test_dns_resolution_safety(Domain)\n    end, PoisonedDomains),\n    \n    SafeResolutions = [R || R <- DNSResults, R =:= safe],\n    UnsafeResolutions = [R || R <- DNSResults, R =:= unsafe],\n    \n    otel_span:set_attribute(SpanCtx, <<\"safe_resolutions\">>, length(SafeResolutions)),\n    otel_span:set_attribute(SpanCtx, <<\"unsafe_resolutions\">>, length(UnsafeResolutions)),\n    \n    % Clean up DNS poisoning\n    cleanup_dns_poisoning(PoisonedDomains),\n    \n    ?assert(length(UnsafeResolutions) =:= 0), % No unsafe resolutions\n    \n    otel_span:add_event(SpanCtx, <<\"fault_dns_poisoning_complete\">>, #{\n        <<\"safe_resolutions\">> => length(SafeResolutions),\n        <<\"unsafe_resolutions\">> => length(UnsafeResolutions)\n    }).\n\nfault_system_overload(Config) ->\n    SpanCtx = ?config(span_ctx, Config),\n    otel_span:add_event(SpanCtx, <<\"fault_system_overload_start\">>, #{}),\n    \n    % Create system overload conditions\n    OverloadConditions = [\n        {cpu_overload, fun() -> create_cpu_intensive_load() end},\n        {memory_pressure, fun() -> create_memory_pressure() end},\n        {io_saturation, fun() -> create_io_saturation() end},\n        {network_congestion, fun() -> create_network_congestion() end}\n    ],\n    \n    % Apply each overload condition and test system behavior\n    OverloadResults = lists:map(fun({OverloadType, OverloadFun}) ->\n        otel_span:add_event(SpanCtx, <<\"applying_system_overload\">>, #{\n            <<\"overload_type\">> => OverloadType\n        }),\n        \n        OverloadProcess = spawn_link(OverloadFun),\n        timer:sleep(5000), % Let overload take effect\n        \n        % Test system responsiveness\n        ResponseTime = measure_system_responsiveness(),\n        Throughput = measure_system_throughput(),\n        \n        exit(OverloadProcess, kill), % Stop overload\n        timer:sleep(1000), % Let system recover\n        \n        {OverloadType, ResponseTime, Throughput}\n    end, OverloadConditions),\n    \n    AvgResponseTime = lists:sum([RT || {_, RT, _} <- OverloadResults]) / length(OverloadResults),\n    MinThroughput = lists:min([TP || {_, _, TP} <- OverloadResults]),\n    \n    otel_span:set_attribute(SpanCtx, <<\"avg_response_time_ms\">>, AvgResponseTime),\n    otel_span:set_attribute(SpanCtx, <<\"min_throughput_ops\">>, MinThroughput),\n    \n    % System should degrade gracefully\n    ?assert(AvgResponseTime < 10000), % Less than 10 seconds\n    ?assert(MinThroughput > 0), % Should maintain some throughput\n    \n    otel_span:add_event(SpanCtx, <<\"fault_system_overload_complete\">>, #{\n        <<\"overload_conditions\">> => length(OverloadConditions),\n        <<\"avg_response_time\">> => AvgResponseTime,\n        <<\"min_throughput\">> => MinThroughput\n    }).\n\n%% ============================================================================\n%% Fault Injection Infrastructure\n%% ============================================================================\n\ninject_fault(Type, Probability) ->\n    case rand:uniform() < Probability of\n        true -> execute_fault(Type);\n        false -> ok\n    end.\n\nexecute_fault(network_partition) ->\n    ct:pal(\"INJECTING NETWORK PARTITION\"),\n    % Simulate by blocking messages between nodes\n    block_inter_node_communication();\n\nexecute_fault(process_kill) ->\n    Processes = erlang:processes(),\n    case Processes of\n        [] -> ok;\n        _ ->\n            Target = lists:nth(rand:uniform(length(Processes)), Processes),\n            ct:pal(\"KILLING PROCESS: ~p\", [Target]),\n            exit(Target, kill)\n    end;\n\nexecute_fault(memory_corruption) ->\n    ct:pal(\"CORRUPTING MEMORY\"),\n    corrupt_random_ets_table();\n\nexecute_fault(disk_failure) ->\n    ct:pal(\"SIMULATING DISK FAILURE\"),\n    simulate_disk_write_failure();\n\nexecute_fault(clock_skew) ->\n    ct:pal(\"INJECTING CLOCK SKEW\"),\n    inject_time_skew(rand:uniform(3600));\n\nexecute_fault(packet_loss) ->\n    ct:pal(\"INJECTING PACKET LOSS\"),\n    enable_packet_loss_simulation(rand:uniform(?PACKET_LOSS_MAX)).\n\n%% ============================================================================\n%% Test Utility Functions\n%% ============================================================================\n\nstart_chaos_monkey() ->\n    spawn_link(fun() -> chaos_monkey_loop() end).\n\nstop_chaos_monkey() ->\n    case whereis(chaos_monkey) of\n        undefined -> ok;\n        Pid -> exit(Pid, shutdown)\n    end.\n\nchaos_monkey_loop() ->\n    register(chaos_monkey, self()),\n    timer:sleep(rand:uniform(5000) + 1000), % 1-6 seconds\n    \n    FaultType = lists:nth(rand:uniform(6), [\n        network_partition, process_kill, memory_corruption,\n        disk_failure, clock_skew, packet_loss\n    ]),\n    \n    inject_fault(FaultType, ?CHAOS_PROBABILITY),\n    chaos_monkey_loop().\n\ngenerate_trace_id() ->\n    <<A:64, B:64>> = crypto:strong_rand_bytes(16),\n    io_lib:format(\"~16.16.0b~16.16.0b\", [A, B]).\n\nstart_adversarial_span(TestCase, TraceId) ->\n    SpanName = iolist_to_binary([\"adversarial_test_\", atom_to_list(TestCase)]),\n    otel_tracer:start_span(SpanName, #{\n        <<\"test.name\">> => TestCase,\n        <<\"test.type\">> => <<\"adversarial\">>,\n        <<\"trace.id\">> => TraceId,\n        <<\"chaos.enabled\">> => true,\n        <<\"attack.simulation\">> => true\n    }).\n\nend_adversarial_span(SpanCtx, TestCase) ->\n    otel_span:set_attribute(SpanCtx, <<\"test.completed\">>, true),\n    otel_span:set_attribute(SpanCtx, <<\"test.result\">>, <<\"passed\">>),\n    otel_span:end_span(SpanCtx).\n\ncleanup_chaos_state() ->\n    % Clean up any lingering chaos effects\n    restore_normal_networking(),\n    cleanup_corrupted_memory(),\n    restore_system_clocks(),\n    ok.\n\n%% Mock implementations for demonstration\nstart_target_processes(N) ->\n    [spawn(fun() -> timer:sleep(60000) end) || _ <- lists:seq(1, N)].\n\ninject_process_kills(Processes, Probability) ->\n    lists:sum([begin\n        case inject_fault(process_kill, Probability) of\n            ok -> 1;\n            _ -> 0\n        end\n    end || _ <- Processes]).\n\nmeasure_recovery_time() ->\n    rand:uniform(5000).\n\nsystem_is_healthy() ->\n    true. % Mock implementation\n\ncreate_network_partitions(N) ->\n    [#{partition_id => I, nodes => []} || I <- lists:seq(1, N)].\n\nheal_network_partitions(_Partitions) ->\n    ok.\n\nmeasure_convergence_time() ->\n    rand:uniform(10000).\n\nsystem_converged() ->\n    true.\n\nstart_latency_injector(LatencyMs) ->\n    spawn(fun() ->\n        receive\n            stop -> ok\n        after LatencyMs ->\n            timer:sleep(LatencyMs)\n        end\n    end).\n\nstop_latency_injector(Pid) ->\n    Pid ! stop.\n\nperform_latency_sensitive_operations(N) ->\n    [#{operation => I, result => success} || I <- lists:seq(1, N)].\n\ncalculate_success_rate(Operations) ->\n    Successful = length([Op || Op <- Operations, maps:get(result, Op) =:= success]),\n    Successful / length(Operations).\n\nstart_packet_loss_injector(Percent) ->\n    spawn(fun() ->\n        receive stop -> ok\n        after 1000 -> ok\n        end\n    end).\n\nstop_packet_loss_injector(Pid) ->\n    Pid ! stop.\n\nmeasure_message_delivery(N) ->\n    Sent = N,\n    Lost = rand:uniform(N div 10),\n    {Sent, Sent - Lost}.\n\nstart_byzantine_nodes(N) ->\n    [spawn(fun() -> byzantine_behavior() end) || _ <- lists:seq(1, N)].\n\nbyzantine_behavior() ->\n    % Send conflicting messages\n    timer:sleep(1000),\n    byzantine_behavior().\n\nstop_byzantine_nodes(Nodes) ->\n    [exit(Node, kill) || Node <- Nodes].\n\ncheck_consensus_reached() ->\n    true.\n\nmeasure_consensus_time() ->\n    rand:uniform(15000).\n\ninject_memory_corruption(Probability) ->\n    case inject_fault(memory_corruption, Probability) of\n        ok -> 1;\n        _ -> 0\n    end.\n\ncount_corruption_errors() ->\n    rand:uniform(5).\n\nmeasure_memory_recovery_time() ->\n    rand:uniform(3000).\n\nsystem_recovered_from_corruption() ->\n    true.\n\nsimulate_disk_failures(N) ->\n    [#{disk => I, failure_type => random} || I <- lists:seq(1, N)].\n\ntest_persistence_under_failure(N) ->\n    [#{operation => I, result => success} || I <- lists:seq(1, N)].\n\nrestore_disk_failures(_Failures) ->\n    ok.\n\ninject_clock_skew(Seconds) ->\n    spawn(fun() ->\n        receive stop -> ok\n        after 10000 -> ok\n        end\n    end).\n\ntest_time_sensitive_operations(N) ->\n    [#{operation => I, result => success} || I <- lists:seq(1, N)].\n\nstop_clock_skew(Pid) ->\n    Pid ! stop.\n\n% Additional mock implementations...\ngenerate_malicious_json_rpc(_I) ->\n    #{type => malicious, payload => <<\"malicious_data\">>}.\n\nsend_malicious_message(_Msg) ->\n    handled_gracefully.\n\nattempt_buffer_overflow(_Payload) ->\n    handled_gracefully.\n\nexecute_resource_attack(AttackFun) ->\n    try AttackFun() of\n        _ -> handled_gracefully\n    catch\n        _:_ -> handled_gracefully\n    end.\n\ncreate_memory_bomb(_Size) ->\n    ok.\n\ncreate_process_bomb(_Count) ->\n    ok.\n\ncreate_fd_bomb(_Count) ->\n    ok.\n\ncreate_cpu_bomb(_Intensity) ->\n    ok.\n\ngenerate_valid_credentials() ->\n    #{username => <<\"valid_user\">>, password => <<\"valid_pass\">>}.\n\ngenerate_invalid_credentials() ->\n    #{username => <<\"invalid_user\">>, password => <<\"invalid_pass\">>}.\n\nmeasure_auth_time(_Credentials) ->\n    rand:uniform(1000).\n\ngenerate_malicious_inputs(N) ->\n    [#{type => malicious, payload => <<\"\">>} || _ <- lists:seq(1, N)].\n\ntest_input_validation(_Input) ->\n    rejected.\n\ngenerate_auth_bypass_attempts(N) ->\n    [#{type => bypass_attempt} || _ <- lists:seq(1, N)].\n\ntest_auth_bypass(_Attempt) ->\n    failed.\n\ngenerate_malformed_messages(N) ->\n    [#{type => malformed, corruption => random} || _ <- lists:seq(1, N)].\n\nprocess_malformed_message(_Message) ->\n    handled_gracefully.\n\n% More mock implementations for race conditions and fault injection...\ncreate_shared_state() ->\n    ets:new(shared_state, [public, set]).\n\nspawn_mutation_workers(Count, StateRef) ->\n    [spawn(fun() -> mutation_worker(StateRef) end) || _ <- lists:seq(1, Count)].\n\nmutation_worker(StateRef) ->\n    ets:insert(StateRef, {rand:uniform(100), rand:uniform(1000)}),\n    timer:sleep(10),\n    mutation_worker(StateRef).\n\nstop_workers(Workers) ->\n    [exit(W, kill) || W <- Workers].\n\nget_final_state(StateRef) ->\n    ets:tab2list(StateRef).\n\ncheck_state_consistency(_State) ->\n    true.\n\nattempt_service_registration(ServiceName, WorkerId) ->\n    case rand:uniform(50) of\n        1 -> success; % Only one should succeed\n        _ -> conflict\n    end.\n\ncollect_worker_results(Workers) ->\n    [receive {W, Result} -> {W, Result} after 1000 -> {W, timeout} end || W <- Workers].\n\nstart_message_sequencer() ->\n    spawn(fun() -> message_sequencer([]) end).\n\nmessage_sequencer(Messages) ->\n    receive\n        {message, Id} ->\n            message_sequencer([Id | Messages]);\n        {get_order, From} ->\n            From ! {order, lists:reverse(Messages)},\n            message_sequencer(Messages);\n        stop ->\n            ok\n    end.\n\nsend_ordered_message(Sequencer, Id) ->\n    Sequencer ! {message, Id}.\n\nwait_for_workers(Workers) ->\n    [begin\n        monitor(process, W),\n        receive {'DOWN', _, process, W, _} -> ok end\n     end || W <- Workers].\n\nget_received_order(Sequencer) ->\n    Sequencer ! {get_order, self()},\n    receive {order, Order} -> Order after 1000 -> [] end.\n\ncount_ordering_violations(Order) ->\n    length([1 || {A, B} <- lists:zip(Order, tl(Order)), A > B]).\n\nstop_message_sequencer(Sequencer) ->\n    Sequencer ! stop.\n\ncreate_deadlock_resources() ->\n    {make_ref(), make_ref()}.\n\nacquire_resources_order_AB(A, B) ->\n    timer:sleep(rand:uniform(100)),\n    % Mock resource acquisition\n    ok.\n\nacquire_resources_order_BA(B, A) ->\n    timer:sleep(rand:uniform(100)),\n    % Mock resource acquisition\n    ok.\n\nstart_deadlock_detector() ->\n    spawn(fun() -> deadlock_detector(0) end).\n\ndeadlock_detector(Count) ->\n    receive\n        deadlock_detected ->\n            deadlock_detector(Count + 1);\n        {get_count, From} ->\n            From ! {count, Count},\n            deadlock_detector(Count);\n        stop ->\n            ok\n    after 1000 ->\n        deadlock_detector(Count)\n    end.\n\nget_deadlock_count(Detector) ->\n    Detector ! {get_count, self()},\n    receive {count, Count} -> Count after 1000 -> 0 end.\n\nstop_deadlock_detector(Detector) ->\n    Detector ! stop.\n\ncleanup_deadlock_workers(Workers) ->\n    [exit(W, kill) || W <- Workers].\n\ncreate_complex_state() ->\n    ets:new(complex_state, [public, set]).\n\nperform_state_operation(State, Operation, WorkerId) ->\n    case Operation of\n        read -> ets:lookup(State, WorkerId);\n        write -> ets:insert(State, {WorkerId, rand:uniform(1000)});\n        delete -> ets:delete(State, WorkerId);\n        update -> ets:update_element(State, WorkerId, {2, rand:uniform(1000)})\n    end.\n\ndetect_state_corruption(_State) ->\n    false.\n\ncheck_state_integrity(_State) ->\n    true.\n\ninject_memory_faults(FaultSpecs) ->\n    length(FaultSpecs).\n\nperform_memory_intensive_operations(N) ->\n    [#{operation => I, result => success} || I <- lists:seq(1, N)].\n\ncount_memory_errors_handled() ->\n    rand:uniform(5).\n\ninject_disk_faults(FaultSpecs) ->\n    length(FaultSpecs).\n\nperform_file_operations_under_corruption(N) ->\n    [#{file => I, checksum => crypto:hash(md5, <<I:32>>)} || I <- lists:seq(1, N)].\n\nverify_file_checksums(Operations) ->\n    length(Operations) / length(Operations). % All valid for mock\n\ncheck_data_integrity(_Operations) ->\n    true.\n\ncreate_test_certificates(CertSpecs) ->\n    [{Type, #{cert => fake_cert, expires_in => ExpiresIn}} || {Type, ExpiresIn} <- CertSpecs].\n\ntest_tls_connection_with_cert(Cert) ->\n    case maps:get(expires_in, Cert) of\n        ExpiresIn when ExpiresIn < 0 -> rejected;\n        _ -> accepted\n    end.\n\ninject_dns_poisoning(DomainSpecs) ->\n    DomainSpecs.\n\ntest_dns_resolution_safety(_Domain) ->\n    safe. % Mock safe resolution\n\ncleanup_dns_poisoning(_Domains) ->\n    ok.\n\ncreate_cpu_intensive_load() ->\n    fun() ->\n        lists:sum(lists:seq(1, 1000000))\n    end.\n\ncreate_memory_pressure() ->\n    fun() ->\n        binary:copy(<<0>>, 1048576) % 1MB\n    end.\n\ncreate_io_saturation() ->\n    fun() ->\n        file:write_file(\"/tmp/test_io\", binary:copy(<<0>>, 1048576))\n    end.\n\ncreate_network_congestion() ->\n    fun() ->\n        ok % Mock network congestion\n    end.\n\nmeasure_system_responsiveness() ->\n    rand:uniform(1000).\n\nmeasure_system_throughput() ->\n    rand:uniform(1000).\n\n% Additional utility functions for cleanup...\nblock_inter_node_communication() -> ok.\ncorrupt_random_ets_table() -> ok.\nsimulate_disk_write_failure() -> ok.\ninject_time_skew(_Seconds) -> ok.\nenable_packet_loss_simulation(_Percent) -> ok.\nrestore_normal_networking() -> ok.\ncleanup_corrupted_memory() -> ok.\nrestore_system_clocks() -> ok."
        }
    ]
}