{
    "sourceFile": "src/erlmcp_config.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1756185314751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1756185314751,
            "name": "Commit-0",
            "content": "%% @doc Configuration Management Module\n%% Provides centralized configuration management with dynamic updates,\n%% environment variable support, validation, and hot reload capabilities.\n%% \n%% Features:\n%% - Load configuration from sys.config files\n%% - Environment variable overrides\n%% - Dynamic runtime reconfiguration\n%% - Configuration validation\n%% - Hot reload without restart\n%% - Configuration backup/restore\n%% - Schema-based validation\n%% - Migration from old config formats\n-module(erlmcp_config).\n-behaviour(gen_server).\n\n%% API\n-export([\n    start_link/0,\n    stop/0,\n    get/1,\n    get/2,\n    set_config/1,\n    update_config/1,\n    load_config/1,\n    load_and_watch/1,\n    stop_watching/0,\n    reload_config/0,\n    validate_config/1,\n    reset_to_defaults/0,\n    apply_env_overrides/0,\n    get_server_config/1,\n    set_server_config/1,\n    validate_server_config/1,\n    get_transport_config/1,\n    set_transport_configs/1,\n    validate_transport_config/1,\n    get_enabled_transports/0,\n    merge_configs/2,\n    persist_config/1,\n    backup_config/1,\n    restore_config/1,\n    migrate_config/1,\n    get_all_config/0,\n    subscribe_changes/0,\n    unsubscribe_changes/0\n]).\n\n%% gen_server callbacks\n-export([\n    init/1,\n    handle_call/3,\n    handle_cast/2,\n    handle_info/2,\n    terminate/2,\n    code_change/3\n]).\n\n-include(\"erlmcp.hrl\").\n\n%% Configuration record\n-record(config_state, {\n    config = #{} :: map(),\n    config_file :: string() | undefined,\n    file_watcher :: pid() | undefined,\n    subscribers = [] :: [pid()],\n    schema :: map() | undefined\n}).\n\n%% Default configuration values\n-define(DEFAULT_CONFIG, #{\n    server_name => erlmcp_server,\n    port => 8080,\n    max_connections => 100,\n    timeout => 5000,\n    acceptors => 10,\n    socket_opts => [{reuseaddr, true}],\n    protocol_opts => [],\n    transports => [\n        {stdio, #{enabled => true, buffer_size => 1024, timeout => 5000}},\n        {tcp, #{enabled => false, port => 8080, acceptors => 10}},\n        {http, #{enabled => false, port => 8081, path => \"/mcp\"}}\n    ],\n    log_level => info,\n    log_file => undefined,\n    metrics_enabled => true,\n    tracing_enabled => false\n}).\n\n%% Environment variable mappings\n-define(ENV_MAPPINGS, #{\n    \"ERLMCP_SERVER_NAME\" => server_name,\n    \"ERLMCP_PORT\" => {port, fun erlang:list_to_integer/1},\n    \"ERLMCP_MAX_CONNECTIONS\" => {max_connections, fun erlang:list_to_integer/1},\n    \"ERLMCP_TIMEOUT\" => {timeout, fun erlang:list_to_integer/1},\n    \"ERLMCP_LOG_LEVEL\" => {log_level, fun erlang:list_to_atom/1},\n    \"ERLMCP_LOG_FILE\" => log_file,\n    \"ERLMCP_METRICS_ENABLED\" => {metrics_enabled, fun string_to_boolean/1},\n    \"ERLMCP_TRACING_ENABLED\" => {tracing_enabled, fun string_to_boolean/1}\n}).\n\n%%--------------------------------------------------------------------\n%% API Functions\n%%--------------------------------------------------------------------\n\n%% @doc Start the configuration server\n-spec start_link() -> {ok, pid()} | {error, term()}.\nstart_link() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n\n%% @doc Stop the configuration server\n-spec stop() -> ok.\nstop() ->\n    gen_server:stop(?MODULE).\n\n%% @doc Get a configuration value\n-spec get(atom()) -> term().\nget(Key) ->\n    get(Key, undefined).\n\n%% @doc Get a configuration value with default\n-spec get(atom(), term()) -> term().\nget(Key, Default) ->\n    try\n        gen_server:call(?MODULE, {get, Key, Default})\n    catch\n        exit:{noproc, _} ->\n            %% Server not started, return from default config\n            maps:get(Key, ?DEFAULT_CONFIG, Default)\n    end.\n\n%% @doc Set entire configuration\n-spec set_config(list() | map()) -> ok | {error, term()}.\nset_config(Config) when is_list(Config) ->\n    set_config(maps:from_list(Config));\nset_config(Config) when is_map(Config) ->\n    case validate_config(Config) of\n        ok ->\n            gen_server:call(?MODULE, {set_config, Config});\n        Error ->\n            Error\n    end.\n\n%% @doc Update configuration with new values\n-spec update_config(list() | map()) -> ok | {error, term()}.\nupdate_config(Updates) when is_list(Updates) ->\n    update_config(maps:from_list(Updates));\nupdate_config(Updates) when is_map(Updates) ->\n    gen_server:call(?MODULE, {update_config, Updates}).\n\n%% @doc Load configuration from file\n-spec load_config(string()) -> {ok, map()} | {error, term()}.\nload_config(ConfigFile) ->\n    try\n        case file:consult(ConfigFile) of\n            {ok, [Config]} when is_list(Config) ->\n                %% Extract erlmcp configuration\n                ErlmcpConfig = case lists:keyfind(erlmcp, 1, Config) of\n                    {erlmcp, AppConfig} -> AppConfig;\n                    false -> Config\n                end,\n                ConfigMap = maps:from_list(ErlmcpConfig),\n                case validate_config(ConfigMap) of\n                    ok ->\n                        gen_server:call(?MODULE, {set_config, ConfigMap}),\n                        {ok, ConfigMap};\n                    Error ->\n                        Error\n                end;\n            {ok, Config} when is_list(Config) ->\n                {error, {invalid_config_format, \"Expected single term\"}};\n            {error, Reason} ->\n                {error, {file_error, Reason}}\n        end\n    catch\n        Class:CReason:CStacktrace ->\n            {error, {exception, Class, CReason, CStacktrace}}\n    end.\n\n%% @doc Load configuration and watch for changes\n-spec load_and_watch(string()) -> ok | {error, term()}.\nload_and_watch(ConfigFile) ->\n    case load_config(ConfigFile) of\n        {ok, _} ->\n            gen_server:call(?MODULE, {watch_file, ConfigFile});\n        Error ->\n            Error\n    end.\n\n%% @doc Stop watching configuration file\n-spec stop_watching() -> ok.\nstop_watching() ->\n    gen_server:call(?MODULE, stop_watching).\n\n%% @doc Reload configuration from watched file\n-spec reload_config() -> ok | {error, term()}.\nreload_config() ->\n    gen_server:call(?MODULE, reload_config).\n\n%% @doc Validate configuration\n-spec validate_config(term()) -> ok | {error, term()}.\nvalidate_config(Config) when is_map(Config) ->\n    try\n        erlmcp_config_schema:validate(Config)\n    catch\n        error:undef ->\n            %% Schema module not available, do basic validation\n            basic_validate_config(Config);\n        Class:CReason:CStacktrace ->\n            {error, {validation_exception, Class, CReason, CStacktrace}}\n    end;\nvalidate_config(Config) when is_list(Config) ->\n    validate_config(maps:from_list(Config));\nvalidate_config(_Config) ->\n    {error, {validation_failed, \"Configuration must be a map or property list\"}}.\n\n%% @doc Reset configuration to defaults\n-spec reset_to_defaults() -> ok.\nreset_to_defaults() ->\n    gen_server:call(?MODULE, reset_to_defaults).\n\n%% @doc Apply environment variable overrides\n-spec apply_env_overrides() -> ok.\napply_env_overrides() ->\n    gen_server:call(?MODULE, apply_env_overrides).\n\n%% @doc Get server configuration value\n-spec get_server_config(atom()) -> term().\nget_server_config(Key) ->\n    ?MODULE:get(Key).\n\n%% @doc Set server configuration\n-spec set_server_config(list() | map()) -> ok | {error, term()}.\nset_server_config(Config) ->\n    case validate_server_config(Config) of\n        ok -> update_config(Config);\n        Error -> Error\n    end.\n\n%% @doc Validate server configuration\n-spec validate_server_config(term()) -> ok | {error, term()}.\nvalidate_server_config(Config) when is_list(Config) ->\n    validate_server_config(maps:from_list(Config));\nvalidate_server_config(Config) when is_map(Config) ->\n    %% Basic server config validation\n    try\n        maps:fold(fun validate_server_key/3, ok, Config)\n    catch\n        throw:Error -> Error\n    end;\nvalidate_server_config(_) ->\n    {error, {validation_failed, \"Server config must be a map or property list\"}}.\n\n%% @doc Get transport configuration\n-spec get_transport_config(atom()) -> map() | undefined.\nget_transport_config(Transport) ->\n    Transports = get(transports, []),\n    case lists:keyfind(Transport, 1, Transports) of\n        {Transport, Config} -> Config;\n        false -> undefined\n    end.\n\n%% @doc Set transport configurations\n-spec set_transport_configs(list()) -> ok | {error, term()}.\nset_transport_configs(Configs) when is_list(Configs) ->\n    %% Validate all transport configs\n    case validate_all_transports(Configs) of\n        ok ->\n            update_config([{transports, Configs}]);\n        Error ->\n            Error\n    end.\n\n%% @doc Validate transport configuration\n-spec validate_transport_config({atom(), map()}) -> ok | {error, term()}.\nvalidate_transport_config({Transport, Config}) when is_atom(Transport), is_map(Config) ->\n    case Transport of\n        stdio -> validate_stdio_config(Config);\n        tcp -> validate_tcp_config(Config);\n        http -> validate_http_config(Config);\n        _ -> {error, {unknown_transport, Transport}}\n    end;\nvalidate_transport_config(_) ->\n    {error, {validation_failed, \"Transport config must be {atom(), map()}\"}}.\n\n%% @doc Get list of enabled transports\n-spec get_enabled_transports() -> [atom()].\nget_enabled_transports() ->\n    Transports = get(transports, []),\n    [Transport || {Transport, Config} <- Transports,\n                  maps:get(enabled, Config, false)].\n\n%% @doc Merge two configuration maps\n-spec merge_configs(map() | list(), map() | list()) -> map().\nmerge_configs(Base, Override) when is_list(Base) ->\n    merge_configs(maps:from_list(Base), Override);\nmerge_configs(Base, Override) when is_list(Override) ->\n    merge_configs(Base, maps:from_list(Override));\nmerge_configs(Base, Override) when is_map(Base), is_map(Override) ->\n    maps:fold(fun merge_config_key/3, Base, Override).\n\n%% @doc Persist current configuration to file\n-spec persist_config(string()) -> ok | {error, term()}.\npersist_config(File) ->\n    Config = get_all_config(),\n    ConfigTerm = [{erlmcp, maps:to_list(Config)}],\n    Content = io_lib:format(\"~p.~n\", [ConfigTerm]),\n    file:write_file(File, Content).\n\n%% @doc Backup current configuration\n-spec backup_config(string()) -> ok | {error, term()}.\nbackup_config(BackupFile) ->\n    persist_config(BackupFile).\n\n%% @doc Restore configuration from backup\n-spec restore_config(string()) -> ok | {error, term()}.\nrestore_config(BackupFile) ->\n    load_config(BackupFile).\n\n%% @doc Migrate configuration from old format\n-spec migrate_config(list()) -> {ok, map()} | {error, term()}.\nmigrate_config(OldConfig) when is_list(OldConfig) ->\n    try\n        %% Check for version\n        Version = case lists:keyfind(config_version, 1, OldConfig) of\n            {config_version, V} -> V;\n            false -> \"1.0\" % Assume old version\n        end,\n        \n        %% Apply migration based on version\n        MigratedConfig = case Version of\n            \"1.0\" -> migrate_from_v1_0(OldConfig);\n            \"2.0\" -> migrate_from_v2_0(OldConfig);\n            _ -> maps:from_list(OldConfig) % No migration needed\n        end,\n        \n        {ok, MigratedConfig}\n    catch\n        Class:CReason:CStacktrace ->\n            {error, {migration_failed, Class, CReason, CStacktrace}}\n    end.\n\n%% @doc Get all configuration as map\n-spec get_all_config() -> map().\nget_all_config() ->\n    gen_server:call(?MODULE, get_all_config).\n\n%% @doc Subscribe to configuration changes\n-spec subscribe_changes() -> ok.\nsubscribe_changes() ->\n    gen_server:call(?MODULE, {subscribe, self()}).\n\n%% @doc Unsubscribe from configuration changes\n-spec unsubscribe_changes() -> ok.\nunsubscribe_changes() ->\n    gen_server:call(?MODULE, {unsubscribe, self()}).\n\n%%--------------------------------------------------------------------\n%% gen_server Callbacks\n%%--------------------------------------------------------------------\n\ninit([]) ->\n    %% Load schema if available\n    Schema = try\n        erlmcp_config_schema:get_schema()\n    catch\n        error:undef -> undefined\n    end,\n    \n    State = #config_state{\n        config = ?DEFAULT_CONFIG,\n        schema = Schema\n    },\n    \n    %% Apply environment overrides on startup\n    {ok, NewState} = handle_call(apply_env_overrides, undefined, State),\n    \n    {ok, NewState}.\n\nhandle_call({get, Key, Default}, _From, #config_state{config = Config} = State) ->\n    Value = maps:get(Key, Config, Default),\n    {reply, Value, State};\n\nhandle_call({set_config, NewConfig}, _From, State) ->\n    NewState = State#config_state{config = NewConfig},\n    notify_subscribers(config_changed, NewConfig, NewState),\n    {reply, ok, NewState};\n\nhandle_call({update_config, Updates}, _From, #config_state{config = Config} = State) ->\n    NewConfig = maps:merge(Config, Updates),\n    case validate_config(NewConfig) of\n        ok ->\n            NewState = State#config_state{config = NewConfig},\n            notify_subscribers(config_updated, Updates, NewState),\n            {reply, ok, NewState};\n        Error ->\n            {reply, Error, State}\n    end;\n\nhandle_call({watch_file, File}, _From, State) ->\n    %% Stop existing watcher if any\n    case State#config_state.file_watcher of\n        undefined -> ok;\n        Pid -> exit(Pid, normal)\n    end,\n    \n    %% Start new file watcher\n    Watcher = spawn_link(fun() -> file_watcher(File) end),\n    NewState = State#config_state{\n        config_file = File,\n        file_watcher = Watcher\n    },\n    {reply, ok, NewState};\n\nhandle_call(stop_watching, _From, State) ->\n    case State#config_state.file_watcher of\n        undefined -> ok;\n        Pid -> exit(Pid, normal)\n    end,\n    NewState = State#config_state{\n        config_file = undefined,\n        file_watcher = undefined\n    },\n    {reply, ok, NewState};\n\nhandle_call(reload_config, _From, #config_state{config_file = undefined} = State) ->\n    {reply, {error, no_config_file}, State};\n\nhandle_call(reload_config, _From, #config_state{config_file = File} = State) ->\n    case load_config_from_file(File) of\n        {ok, NewConfig} ->\n            NewState = State#config_state{config = NewConfig},\n            notify_subscribers(config_reloaded, NewConfig, NewState),\n            {reply, ok, NewState};\n        Error ->\n            {reply, Error, State}\n    end;\n\nhandle_call(reset_to_defaults, _From, State) ->\n    NewState = State#config_state{config = ?DEFAULT_CONFIG},\n    notify_subscribers(config_reset, ?DEFAULT_CONFIG, NewState),\n    {reply, ok, NewState};\n\nhandle_call(apply_env_overrides, _From, #config_state{config = Config} = State) ->\n    NewConfig = apply_env_overrides_to_config(Config),\n    NewState = State#config_state{config = NewConfig},\n    {reply, ok, NewState};\n\nhandle_call(get_all_config, _From, #config_state{config = Config} = State) ->\n    {reply, Config, State};\n\nhandle_call({subscribe, Pid}, _From, #config_state{subscribers = Subs} = State) ->\n    monitor(process, Pid),\n    NewState = State#config_state{subscribers = [Pid | Subs]},\n    {reply, ok, NewState};\n\nhandle_call({unsubscribe, Pid}, _From, #config_state{subscribers = Subs} = State) ->\n    demonitor(Pid, [flush]),\n    NewSubs = lists:delete(Pid, Subs),\n    NewState = State#config_state{subscribers = NewSubs},\n    {reply, ok, NewState};\n\nhandle_call(_Request, _From, State) ->\n    {reply, {error, unknown_request}, State}.\n\nhandle_cast(_Request, State) ->\n    {noreply, State}.\n\nhandle_info({file_changed, File}, #config_state{config_file = File} = State) ->\n    %% Automatically reload configuration when file changes\n    case load_config_from_file(File) of\n        {ok, NewConfig} ->\n            NewState = State#config_state{config = NewConfig},\n            notify_subscribers(config_file_changed, NewConfig, NewState),\n            {noreply, NewState};\n        _Error ->\n            %% Log error but don't change state\n            {noreply, State}\n    end;\n\nhandle_info({'DOWN', _Ref, process, Pid, _Reason}, #config_state{subscribers = Subs} = State) ->\n    NewSubs = lists:delete(Pid, Subs),\n    NewState = State#config_state{subscribers = NewSubs},\n    {noreply, NewState};\n\nhandle_info({'EXIT', Pid, _Reason}, #config_state{file_watcher = Pid} = State) ->\n    %% File watcher died, clear it\n    NewState = State#config_state{file_watcher = undefined},\n    {noreply, NewState};\n\nhandle_info(_Info, State) ->\n    {noreply, State}.\n\nterminate(_Reason, #config_state{file_watcher = Watcher}) ->\n    case Watcher of\n        undefined -> ok;\n        Pid -> exit(Pid, normal)\n    end,\n    ok.\n\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\n%%--------------------------------------------------------------------\n%% Internal Functions\n%%--------------------------------------------------------------------\n\n%% @doc Basic configuration validation when schema is not available\nbasic_validate_config(Config) when is_map(Config) ->\n    RequiredKeys = [server_name, port],\n    case check_required_keys(RequiredKeys, Config) of\n        ok -> validate_config_types(Config);\n        Error -> Error\n    end.\n\n%% @doc Check if required keys are present\ncheck_required_keys([], _Config) -> ok;\ncheck_required_keys([Key | Rest], Config) ->\n    case maps:is_key(Key, Config) orelse maps:is_key(Key, ?DEFAULT_CONFIG) of\n        true -> check_required_keys(Rest, Config);\n        false -> {error, {missing_required_key, Key}}\n    end.\n\n%% @doc Validate configuration value types\nvalidate_config_types(Config) ->\n    try\n        maps:fold(fun validate_config_type/3, ok, Config)\n    catch\n        throw:Error -> Error\n    end.\n\nvalidate_config_type(server_name, Value, ok) when is_atom(Value) -> ok;\nvalidate_config_type(port, Value, ok) when is_integer(Value), Value > 0, Value < 65536 -> ok;\nvalidate_config_type(max_connections, Value, ok) when is_integer(Value), Value > 0 -> ok;\nvalidate_config_type(timeout, Value, ok) when is_integer(Value), Value > 0 -> ok;\nvalidate_config_type(acceptors, Value, ok) when is_integer(Value), Value > 0 -> ok;\nvalidate_config_type(log_level, Value, ok) when Value =:= debug; Value =:= info; Value =:= warning; Value =:= error -> ok;\nvalidate_config_type(transports, Value, ok) when is_list(Value) -> \n    validate_all_transports(Value);\nvalidate_config_type(Key, Value, ok) ->\n    %% Allow unknown keys for extensibility\n    ok;\nvalidate_config_type(Key, Value, ok) ->\n    throw({error, {invalid_type, Key, Value}}).\n\n%% @doc Validate server configuration key\nvalidate_server_key(acceptors, Value, ok) when is_integer(Value), Value > 0 -> ok;\nvalidate_server_key(server_name, Value, ok) when is_atom(Value) -> ok;\nvalidate_server_key(port, Value, ok) when is_integer(Value), Value > 0, Value < 65536 -> ok;\nvalidate_server_key(socket_opts, Value, ok) when is_list(Value) -> ok;\nvalidate_server_key(protocol_opts, Value, ok) when is_list(Value) -> ok;\nvalidate_server_key(Key, _Value, ok) ->\n    throw({error, {invalid_server_key, Key}}).\n\n%% @doc Validate all transport configurations\nvalidate_all_transports([]) -> ok;\nvalidate_all_transports([Transport | Rest]) ->\n    case validate_transport_config(Transport) of\n        ok -> validate_all_transports(Rest);\n        Error -> Error\n    end.\n\n%% @doc Validate stdio transport configuration\nvalidate_stdio_config(Config) ->\n    AllowedKeys = [enabled, buffer_size, timeout],\n    validate_transport_keys(Config, AllowedKeys).\n\n%% @doc Validate TCP transport configuration\nvalidate_tcp_config(Config) ->\n    AllowedKeys = [enabled, port, acceptors, socket_opts],\n    case validate_transport_keys(Config, AllowedKeys) of\n        ok ->\n            %% Additional TCP-specific validation\n            case maps:get(port, Config, undefined) of\n                Port when is_integer(Port), Port > 0, Port < 65536 -> ok;\n                undefined -> ok; % Optional\n                _ -> {error, {invalid_tcp_port, maps:get(port, Config)}}\n            end;\n        Error -> Error\n    end.\n\n%% @doc Validate HTTP transport configuration\nvalidate_http_config(Config) ->\n    AllowedKeys = [enabled, port, path, ssl_opts],\n    validate_transport_keys(Config, AllowedKeys).\n\n%% @doc Validate transport configuration keys\nvalidate_transport_keys(Config, AllowedKeys) ->\n    ConfigKeys = maps:keys(Config),\n    case lists:all(fun(Key) -> lists:member(Key, AllowedKeys) end, ConfigKeys) of\n        true -> ok;\n        false -> \n            InvalidKeys = ConfigKeys -- AllowedKeys,\n            {error, {invalid_transport_keys, InvalidKeys}}\n    end.\n\n%% @doc Merge configuration key with special handling\nmerge_config_key(transports, NewTransports, Base) when is_list(NewTransports) ->\n    %% Merge transport configurations\n    OldTransports = maps:get(transports, Base, []),\n    MergedTransports = merge_transports(OldTransports, NewTransports),\n    maps:put(transports, MergedTransports, Base);\nmerge_config_key(Key, Value, Base) ->\n    maps:put(Key, Value, Base).\n\n%% @doc Merge transport configurations\nmerge_transports(Old, New) ->\n    %% Convert to maps for easier merging\n    OldMap = maps:from_list(Old),\n    NewMap = maps:from_list(New),\n    MergedMap = maps:merge(OldMap, NewMap),\n    maps:to_list(MergedMap).\n\n%% @doc Apply environment variable overrides to configuration\napply_env_overrides_to_config(Config) ->\n    maps:fold(fun apply_env_override/3, Config, ?ENV_MAPPINGS).\n\napply_env_override(EnvVar, ConfigKey, Config) ->\n    case os:getenv(EnvVar) of\n        false -> Config;\n        Value -> \n            case ConfigKey of\n                {Key, Converter} ->\n                    try\n                        ConvertedValue = Converter(Value),\n                        maps:put(Key, ConvertedValue, Config)\n                    catch\n                        _:_ -> Config % Ignore conversion errors\n                    end;\n                Key ->\n                    maps:put(Key, Value, Config)\n            end\n    end.\n\n%% @doc Convert string to boolean\nstring_to_boolean(\"true\") -> true;\nstring_to_boolean(\"false\") -> false;\nstring_to_boolean(\"1\") -> true;\nstring_to_boolean(\"0\") -> false;\nstring_to_boolean(_) -> throw({error, invalid_boolean}).\n\n%% @doc Load configuration from file (internal)\nload_config_from_file(File) ->\n    case file:consult(File) of\n        {ok, [Config]} when is_list(Config) ->\n            ErlmcpConfig = case lists:keyfind(erlmcp, 1, Config) of\n                {erlmcp, AppConfig} -> AppConfig;\n                false -> Config\n            end,\n            ConfigMap = maps:from_list(ErlmcpConfig),\n            case validate_config(ConfigMap) of\n                ok -> {ok, ConfigMap};\n                Error -> Error\n            end;\n        {error, Reason} ->\n            {error, {file_error, Reason}}\n    end.\n\n%% @doc File watcher process\nfile_watcher(File) ->\n    case filelib:last_modified(File) of\n        0 -> \n            timer:sleep(1000),\n            file_watcher(File);\n        LastModified ->\n            timer:sleep(1000),\n            case filelib:last_modified(File) of\n                LastModified -> \n                    file_watcher(File);\n                _ ->\n                    ?MODULE ! {file_changed, File},\n                    file_watcher(File)\n            end\n    end.\n\n%% @doc Notify all subscribers of configuration changes\nnotify_subscribers(Event, Data, #config_state{subscribers = Subscribers}) ->\n    lists:foreach(fun(Pid) ->\n        Pid ! {config_event, Event, Data}\n    end, Subscribers).\n\n%% @doc Migration from version 1.0\nmigrate_from_v1_0(Config) ->\n    Mappings = [\n        {name, server_name},\n        {tcp_port, port},\n        {connections, max_connections}\n    ],\n    migrate_keys(Config, Mappings).\n\n%% @doc Migration from version 2.0  \nmigrate_from_v2_0(Config) ->\n    %% Minimal changes from 2.0\n    maps:from_list(Config).\n\n%% @doc Apply key mappings for migration\nmigrate_keys(Config, []) ->\n    maps:from_list(Config);\nmigrate_keys(Config, [{OldKey, NewKey} | Rest]) ->\n    case lists:keytake(OldKey, 1, Config) of\n        {value, {OldKey, Value}, NewConfig} ->\n            migrate_keys([{NewKey, Value} | NewConfig], Rest);\n        false ->\n            migrate_keys(Config, Rest)\n    end."
        }
    ]
}