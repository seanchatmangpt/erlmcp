{
    "sourceFile": "src/erlmcp_config.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1756185314751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756190592376,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n %% @doc Configuration Management Module\n %% Provides centralized configuration management with dynamic updates,\n %% environment variable support, validation, and hot reload capabilities.\n-%% \n+%%\n %% Features:\n %% - Load configuration from sys.config files\n %% - Environment variable overrides\n %% - Dynamic runtime reconfiguration\n@@ -11,94 +11,69 @@\n %% - Configuration backup/restore\n %% - Schema-based validation\n %% - Migration from old config formats\n -module(erlmcp_config).\n+\n -behaviour(gen_server).\n \n %% API\n--export([\n-    start_link/0,\n-    stop/0,\n-    get/1,\n-    get/2,\n-    set_config/1,\n-    update_config/1,\n-    load_config/1,\n-    load_and_watch/1,\n-    stop_watching/0,\n-    reload_config/0,\n-    validate_config/1,\n-    reset_to_defaults/0,\n-    apply_env_overrides/0,\n-    get_server_config/1,\n-    set_server_config/1,\n-    validate_server_config/1,\n-    get_transport_config/1,\n-    set_transport_configs/1,\n-    validate_transport_config/1,\n-    get_enabled_transports/0,\n-    merge_configs/2,\n-    persist_config/1,\n-    backup_config/1,\n-    restore_config/1,\n-    migrate_config/1,\n-    get_all_config/0,\n-    subscribe_changes/0,\n-    unsubscribe_changes/0\n-]).\n-\n+-export([start_link/0, stop/0, get/1, get/2, set_config/1, update_config/1, load_config/1,\n+         load_and_watch/1, stop_watching/0, reload_config/0, validate_config/1,\n+         reset_to_defaults/0, apply_env_overrides/0, get_server_config/1, set_server_config/1,\n+         validate_server_config/1, get_transport_config/1, set_transport_configs/1,\n+         validate_transport_config/1, get_enabled_transports/0, merge_configs/2, persist_config/1,\n+         backup_config/1, restore_config/1, migrate_config/1, get_all_config/0,\n+         subscribe_changes/0, unsubscribe_changes/0]).\n %% gen_server callbacks\n--export([\n-    init/1,\n-    handle_call/3,\n-    handle_cast/2,\n-    handle_info/2,\n-    terminate/2,\n-    code_change/3\n-]).\n+-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,\n+         code_change/3]).\n \n -include(\"erlmcp.hrl\").\n \n %% Configuration record\n--record(config_state, {\n-    config = #{} :: map(),\n-    config_file :: string() | undefined,\n-    file_watcher :: pid() | undefined,\n-    subscribers = [] :: [pid()],\n-    schema :: map() | undefined\n-}).\n+-record(config_state,\n+        {config = #{} :: map(),\n+         config_file :: string() | undefined,\n+         file_watcher :: pid() | undefined,\n+         subscribers = [] :: [pid()],\n+         schema :: map() | undefined}).\n \n %% Default configuration values\n--define(DEFAULT_CONFIG, #{\n-    server_name => erlmcp_server,\n-    port => 8080,\n-    max_connections => 100,\n-    timeout => 5000,\n-    acceptors => 10,\n-    socket_opts => [{reuseaddr, true}],\n-    protocol_opts => [],\n-    transports => [\n-        {stdio, #{enabled => true, buffer_size => 1024, timeout => 5000}},\n-        {tcp, #{enabled => false, port => 8080, acceptors => 10}},\n-        {http, #{enabled => false, port => 8081, path => \"/mcp\"}}\n-    ],\n-    log_level => info,\n-    log_file => undefined,\n-    metrics_enabled => true,\n-    tracing_enabled => false\n-}).\n-\n+-define(DEFAULT_CONFIG,\n+        #{server_name => erlmcp_server,\n+          port => 8080,\n+          max_connections => 100,\n+          timeout => 5000,\n+          acceptors => 10,\n+          socket_opts => [{reuseaddr, true}],\n+          protocol_opts => [],\n+          transports =>\n+              [{stdio,\n+                #{enabled => true,\n+                  buffer_size => 1024,\n+                  timeout => 5000}},\n+               {tcp,\n+                #{enabled => false,\n+                  port => 8080,\n+                  acceptors => 10}},\n+               {http,\n+                #{enabled => false,\n+                  port => 8081,\n+                  path => \"/mcp\"}}],\n+          log_level => info,\n+          log_file => undefined,\n+          metrics_enabled => true,\n+          tracing_enabled => false}).\n %% Environment variable mappings\n--define(ENV_MAPPINGS, #{\n-    \"ERLMCP_SERVER_NAME\" => server_name,\n-    \"ERLMCP_PORT\" => {port, fun erlang:list_to_integer/1},\n-    \"ERLMCP_MAX_CONNECTIONS\" => {max_connections, fun erlang:list_to_integer/1},\n-    \"ERLMCP_TIMEOUT\" => {timeout, fun erlang:list_to_integer/1},\n-    \"ERLMCP_LOG_LEVEL\" => {log_level, fun erlang:list_to_atom/1},\n-    \"ERLMCP_LOG_FILE\" => log_file,\n-    \"ERLMCP_METRICS_ENABLED\" => {metrics_enabled, fun string_to_boolean/1},\n-    \"ERLMCP_TRACING_ENABLED\" => {tracing_enabled, fun string_to_boolean/1}\n-}).\n+-define(ENV_MAPPINGS,\n+        #{\"ERLMCP_SERVER_NAME\" => server_name,\n+          \"ERLMCP_PORT\" => {port, fun erlang:list_to_integer/1},\n+          \"ERLMCP_MAX_CONNECTIONS\" => {max_connections, fun erlang:list_to_integer/1},\n+          \"ERLMCP_TIMEOUT\" => {timeout, fun erlang:list_to_integer/1},\n+          \"ERLMCP_LOG_LEVEL\" => {log_level, fun erlang:list_to_atom/1},\n+          \"ERLMCP_LOG_FILE\" => log_file,\n+          \"ERLMCP_METRICS_ENABLED\" => {metrics_enabled, fun string_to_boolean/1},\n+          \"ERLMCP_TRACING_ENABLED\" => {tracing_enabled, fun string_to_boolean/1}}).\n \n %%--------------------------------------------------------------------\n %% API Functions\n %%--------------------------------------------------------------------\n@@ -154,12 +129,15 @@\n     try\n         case file:consult(ConfigFile) of\n             {ok, [Config]} when is_list(Config) ->\n                 %% Extract erlmcp configuration\n-                ErlmcpConfig = case lists:keyfind(erlmcp, 1, Config) of\n-                    {erlmcp, AppConfig} -> AppConfig;\n-                    false -> Config\n-                end,\n+                ErlmcpConfig =\n+                    case lists:keyfind(erlmcp, 1, Config) of\n+                        {erlmcp, AppConfig} ->\n+                            AppConfig;\n+                        false ->\n+                            Config\n+                    end,\n                 ConfigMap = maps:from_list(ErlmcpConfig),\n                 case validate_config(ConfigMap) of\n                     ok ->\n                         gen_server:call(?MODULE, {set_config, ConfigMap}),\n@@ -232,10 +210,12 @@\n %% @doc Set server configuration\n -spec set_server_config(list() | map()) -> ok | {error, term()}.\n set_server_config(Config) ->\n     case validate_server_config(Config) of\n-        ok -> update_config(Config);\n-        Error -> Error\n+        ok ->\n+            update_config(Config);\n+        Error ->\n+            Error\n     end.\n \n %% @doc Validate server configuration\n -spec validate_server_config(term()) -> ok | {error, term()}.\n@@ -245,9 +225,10 @@\n     %% Basic server config validation\n     try\n         maps:fold(fun validate_server_key/3, ok, Config)\n     catch\n-        throw:Error -> Error\n+        Error ->\n+            Error\n     end;\n validate_server_config(_) ->\n     {error, {validation_failed, \"Server config must be a map or property list\"}}.\n \n@@ -255,10 +236,12 @@\n -spec get_transport_config(atom()) -> map() | undefined.\n get_transport_config(Transport) ->\n     Transports = get(transports, []),\n     case lists:keyfind(Transport, 1, Transports) of\n-        {Transport, Config} -> Config;\n-        false -> undefined\n+        {Transport, Config} ->\n+            Config;\n+        false ->\n+            undefined\n     end.\n \n %% @doc Set transport configurations\n -spec set_transport_configs(list()) -> ok | {error, term()}.\n@@ -274,22 +257,25 @@\n %% @doc Validate transport configuration\n -spec validate_transport_config({atom(), map()}) -> ok | {error, term()}.\n validate_transport_config({Transport, Config}) when is_atom(Transport), is_map(Config) ->\n     case Transport of\n-        stdio -> validate_stdio_config(Config);\n-        tcp -> validate_tcp_config(Config);\n-        http -> validate_http_config(Config);\n-        _ -> {error, {unknown_transport, Transport}}\n+        stdio ->\n+            validate_stdio_config(Config);\n+        tcp ->\n+            validate_tcp_config(Config);\n+        http ->\n+            validate_http_config(Config);\n+        _ ->\n+            {error, {unknown_transport, Transport}}\n     end;\n validate_transport_config(_) ->\n     {error, {validation_failed, \"Transport config must be {atom(), map()}\"}}.\n \n %% @doc Get list of enabled transports\n -spec get_enabled_transports() -> [atom()].\n get_enabled_transports() ->\n     Transports = get(transports, []),\n-    [Transport || {Transport, Config} <- Transports,\n-                  maps:get(enabled, Config, false)].\n+    [Transport || {Transport, Config} <- Transports, maps:get(enabled, Config, false)].\n \n %% @doc Merge two configuration maps\n -spec merge_configs(map() | list(), map() | list()) -> map().\n merge_configs(Base, Override) when is_list(Base) ->\n@@ -321,20 +307,27 @@\n -spec migrate_config(list()) -> {ok, map()} | {error, term()}.\n migrate_config(OldConfig) when is_list(OldConfig) ->\n     try\n         %% Check for version\n-        Version = case lists:keyfind(config_version, 1, OldConfig) of\n-            {config_version, V} -> V;\n-            false -> \"1.0\" % Assume old version\n-        end,\n-        \n+        Version =\n+            case lists:keyfind(config_version, 1, OldConfig) of\n+                {config_version, V} ->\n+                    V;\n+                false ->\n+                    \"1.0\" % Assume old version\n+            end,\n+\n         %% Apply migration based on version\n-        MigratedConfig = case Version of\n-            \"1.0\" -> migrate_from_v1_0(OldConfig);\n-            \"2.0\" -> migrate_from_v2_0(OldConfig);\n-            _ -> maps:from_list(OldConfig) % No migration needed\n-        end,\n-        \n+        MigratedConfig =\n+            case Version of\n+                \"1.0\" ->\n+                    migrate_from_v1_0(OldConfig);\n+                \"2.0\" ->\n+                    migrate_from_v2_0(OldConfig);\n+                _ ->\n+                    maps:from_list(OldConfig) % No migration needed\n+            end,\n+\n         {ok, MigratedConfig}\n     catch\n         Class:CReason:CStacktrace ->\n             {error, {migration_failed, Class, CReason, CStacktrace}}\n@@ -360,33 +353,30 @@\n %%--------------------------------------------------------------------\n \n init([]) ->\n     %% Load schema if available\n-    Schema = try\n-        erlmcp_config_schema:get_schema()\n-    catch\n-        error:undef -> undefined\n-    end,\n-    \n-    State = #config_state{\n-        config = ?DEFAULT_CONFIG,\n-        schema = Schema\n-    },\n-    \n+    Schema =\n+        try\n+            erlmcp_config_schema:get_schema()\n+        catch\n+            error:undef ->\n+                undefined\n+        end,\n+\n+    State = #config_state{config = ?DEFAULT_CONFIG, schema = Schema},\n+\n     %% Apply environment overrides on startup\n     {ok, NewState} = handle_call(apply_env_overrides, undefined, State),\n-    \n+\n     {ok, NewState}.\n \n handle_call({get, Key, Default}, _From, #config_state{config = Config} = State) ->\n     Value = maps:get(Key, Config, Default),\n     {reply, Value, State};\n-\n handle_call({set_config, NewConfig}, _From, State) ->\n     NewState = State#config_state{config = NewConfig},\n     notify_subscribers(config_changed, NewConfig, NewState),\n     {reply, ok, NewState};\n-\n handle_call({update_config, Updates}, _From, #config_state{config = Config} = State) ->\n     NewConfig = maps:merge(Config, Updates),\n     case validate_config(NewConfig) of\n         ok ->\n@@ -395,38 +385,32 @@\n             {reply, ok, NewState};\n         Error ->\n             {reply, Error, State}\n     end;\n-\n handle_call({watch_file, File}, _From, State) ->\n     %% Stop existing watcher if any\n     case State#config_state.file_watcher of\n-        undefined -> ok;\n-        Pid -> exit(Pid, normal)\n+        undefined ->\n+            ok;\n+        Pid ->\n+            exit(Pid, normal)\n     end,\n-    \n+\n     %% Start new file watcher\n     Watcher = spawn_link(fun() -> file_watcher(File) end),\n-    NewState = State#config_state{\n-        config_file = File,\n-        file_watcher = Watcher\n-    },\n+    NewState = State#config_state{config_file = File, file_watcher = Watcher},\n     {reply, ok, NewState};\n-\n handle_call(stop_watching, _From, State) ->\n     case State#config_state.file_watcher of\n-        undefined -> ok;\n-        Pid -> exit(Pid, normal)\n+        undefined ->\n+            ok;\n+        Pid ->\n+            exit(Pid, normal)\n     end,\n-    NewState = State#config_state{\n-        config_file = undefined,\n-        file_watcher = undefined\n-    },\n+    NewState = State#config_state{config_file = undefined, file_watcher = undefined},\n     {reply, ok, NewState};\n-\n handle_call(reload_config, _From, #config_state{config_file = undefined} = State) ->\n     {reply, {error, no_config_file}, State};\n-\n handle_call(reload_config, _From, #config_state{config_file = File} = State) ->\n     case load_config_from_file(File) of\n         {ok, NewConfig} ->\n             NewState = State#config_state{config = NewConfig},\n@@ -434,33 +418,27 @@\n             {reply, ok, NewState};\n         Error ->\n             {reply, Error, State}\n     end;\n-\n handle_call(reset_to_defaults, _From, State) ->\n     NewState = State#config_state{config = ?DEFAULT_CONFIG},\n     notify_subscribers(config_reset, ?DEFAULT_CONFIG, NewState),\n     {reply, ok, NewState};\n-\n handle_call(apply_env_overrides, _From, #config_state{config = Config} = State) ->\n     NewConfig = apply_env_overrides_to_config(Config),\n     NewState = State#config_state{config = NewConfig},\n     {reply, ok, NewState};\n-\n handle_call(get_all_config, _From, #config_state{config = Config} = State) ->\n     {reply, Config, State};\n-\n handle_call({subscribe, Pid}, _From, #config_state{subscribers = Subs} = State) ->\n     monitor(process, Pid),\n     NewState = State#config_state{subscribers = [Pid | Subs]},\n     {reply, ok, NewState};\n-\n handle_call({unsubscribe, Pid}, _From, #config_state{subscribers = Subs} = State) ->\n     demonitor(Pid, [flush]),\n     NewSubs = lists:delete(Pid, Subs),\n     NewState = State#config_state{subscribers = NewSubs},\n     {reply, ok, NewState};\n-\n handle_call(_Request, _From, State) ->\n     {reply, {error, unknown_request}, State}.\n \n handle_cast(_Request, State) ->\n@@ -476,26 +454,26 @@\n         _Error ->\n             %% Log error but don't change state\n             {noreply, State}\n     end;\n-\n-handle_info({'DOWN', _Ref, process, Pid, _Reason}, #config_state{subscribers = Subs} = State) ->\n+handle_info({'DOWN', _Ref, process, Pid, _Reason},\n+            #config_state{subscribers = Subs} = State) ->\n     NewSubs = lists:delete(Pid, Subs),\n     NewState = State#config_state{subscribers = NewSubs},\n     {noreply, NewState};\n-\n handle_info({'EXIT', Pid, _Reason}, #config_state{file_watcher = Pid} = State) ->\n     %% File watcher died, clear it\n     NewState = State#config_state{file_watcher = undefined},\n     {noreply, NewState};\n-\n handle_info(_Info, State) ->\n     {noreply, State}.\n \n terminate(_Reason, #config_state{file_watcher = Watcher}) ->\n     case Watcher of\n-        undefined -> ok;\n-        Pid -> exit(Pid, normal)\n+        undefined ->\n+            ok;\n+        Pid ->\n+            exit(Pid, normal)\n     end,\n     ok.\n \n code_change(_OldVsn, State, _Extra) ->\n@@ -508,57 +486,78 @@\n %% @doc Basic configuration validation when schema is not available\n basic_validate_config(Config) when is_map(Config) ->\n     RequiredKeys = [server_name, port],\n     case check_required_keys(RequiredKeys, Config) of\n-        ok -> validate_config_types(Config);\n-        Error -> Error\n+        ok ->\n+            validate_config_types(Config);\n+        Error ->\n+            Error\n     end.\n \n %% @doc Check if required keys are present\n-check_required_keys([], _Config) -> ok;\n+check_required_keys([], _Config) ->\n+    ok;\n check_required_keys([Key | Rest], Config) ->\n     case maps:is_key(Key, Config) orelse maps:is_key(Key, ?DEFAULT_CONFIG) of\n-        true -> check_required_keys(Rest, Config);\n-        false -> {error, {missing_required_key, Key}}\n+        true ->\n+            check_required_keys(Rest, Config);\n+        false ->\n+            {error, {missing_required_key, Key}}\n     end.\n \n %% @doc Validate configuration value types\n validate_config_types(Config) ->\n     try\n         maps:fold(fun validate_config_type/3, ok, Config)\n     catch\n-        throw:Error -> Error\n+        Error ->\n+            Error\n     end.\n \n-validate_config_type(server_name, Value, ok) when is_atom(Value) -> ok;\n-validate_config_type(port, Value, ok) when is_integer(Value), Value > 0, Value < 65536 -> ok;\n-validate_config_type(max_connections, Value, ok) when is_integer(Value), Value > 0 -> ok;\n-validate_config_type(timeout, Value, ok) when is_integer(Value), Value > 0 -> ok;\n-validate_config_type(acceptors, Value, ok) when is_integer(Value), Value > 0 -> ok;\n-validate_config_type(log_level, Value, ok) when Value =:= debug; Value =:= info; Value =:= warning; Value =:= error -> ok;\n-validate_config_type(transports, Value, ok) when is_list(Value) -> \n+validate_config_type(server_name, Value, ok) when is_atom(Value) ->\n+    ok;\n+validate_config_type(port, Value, ok) when is_integer(Value), Value > 0, Value < 65536 ->\n+    ok;\n+validate_config_type(max_connections, Value, ok) when is_integer(Value), Value > 0 ->\n+    ok;\n+validate_config_type(timeout, Value, ok) when is_integer(Value), Value > 0 ->\n+    ok;\n+validate_config_type(acceptors, Value, ok) when is_integer(Value), Value > 0 ->\n+    ok;\n+validate_config_type(log_level, Value, ok)\n+    when Value =:= debug; Value =:= info; Value =:= warning; Value =:= error ->\n+    ok;\n+validate_config_type(transports, Value, ok) when is_list(Value) ->\n     validate_all_transports(Value);\n validate_config_type(Key, Value, ok) ->\n     %% Allow unknown keys for extensibility\n     ok;\n validate_config_type(Key, Value, ok) ->\n     throw({error, {invalid_type, Key, Value}}).\n \n %% @doc Validate server configuration key\n-validate_server_key(acceptors, Value, ok) when is_integer(Value), Value > 0 -> ok;\n-validate_server_key(server_name, Value, ok) when is_atom(Value) -> ok;\n-validate_server_key(port, Value, ok) when is_integer(Value), Value > 0, Value < 65536 -> ok;\n-validate_server_key(socket_opts, Value, ok) when is_list(Value) -> ok;\n-validate_server_key(protocol_opts, Value, ok) when is_list(Value) -> ok;\n+validate_server_key(acceptors, Value, ok) when is_integer(Value), Value > 0 ->\n+    ok;\n+validate_server_key(server_name, Value, ok) when is_atom(Value) ->\n+    ok;\n+validate_server_key(port, Value, ok) when is_integer(Value), Value > 0, Value < 65536 ->\n+    ok;\n+validate_server_key(socket_opts, Value, ok) when is_list(Value) ->\n+    ok;\n+validate_server_key(protocol_opts, Value, ok) when is_list(Value) ->\n+    ok;\n validate_server_key(Key, _Value, ok) ->\n     throw({error, {invalid_server_key, Key}}).\n \n %% @doc Validate all transport configurations\n-validate_all_transports([]) -> ok;\n+validate_all_transports([]) ->\n+    ok;\n validate_all_transports([Transport | Rest]) ->\n     case validate_transport_config(Transport) of\n-        ok -> validate_all_transports(Rest);\n-        Error -> Error\n+        ok ->\n+            validate_all_transports(Rest);\n+        Error ->\n+            Error\n     end.\n \n %% @doc Validate stdio transport configuration\n validate_stdio_config(Config) ->\n@@ -571,13 +570,17 @@\n     case validate_transport_keys(Config, AllowedKeys) of\n         ok ->\n             %% Additional TCP-specific validation\n             case maps:get(port, Config, undefined) of\n-                Port when is_integer(Port), Port > 0, Port < 65536 -> ok;\n-                undefined -> ok; % Optional\n-                _ -> {error, {invalid_tcp_port, maps:get(port, Config)}}\n+                Port when is_integer(Port), Port > 0, Port < 65536 ->\n+                    ok;\n+                undefined ->\n+                    ok; % Optional\n+                _ ->\n+                    {error, {invalid_tcp_port, maps:get(port, Config)}}\n             end;\n-        Error -> Error\n+        Error ->\n+            Error\n     end.\n \n %% @doc Validate HTTP transport configuration\n validate_http_config(Config) ->\n@@ -587,10 +590,11 @@\n %% @doc Validate transport configuration keys\n validate_transport_keys(Config, AllowedKeys) ->\n     ConfigKeys = maps:keys(Config),\n     case lists:all(fun(Key) -> lists:member(Key, AllowedKeys) end, ConfigKeys) of\n-        true -> ok;\n-        false -> \n+        true ->\n+            ok;\n+        false ->\n             InvalidKeys = ConfigKeys -- AllowedKeys,\n             {error, {invalid_transport_keys, InvalidKeys}}\n     end.\n \n@@ -616,57 +620,69 @@\n     maps:fold(fun apply_env_override/3, Config, ?ENV_MAPPINGS).\n \n apply_env_override(EnvVar, ConfigKey, Config) ->\n     case os:getenv(EnvVar) of\n-        false -> Config;\n-        Value -> \n+        false ->\n+            Config;\n+        Value ->\n             case ConfigKey of\n                 {Key, Converter} ->\n                     try\n                         ConvertedValue = Converter(Value),\n                         maps:put(Key, ConvertedValue, Config)\n                     catch\n-                        _:_ -> Config % Ignore conversion errors\n+                        _:_ ->\n+                            Config % Ignore conversion errors\n                     end;\n                 Key ->\n                     maps:put(Key, Value, Config)\n             end\n     end.\n \n %% @doc Convert string to boolean\n-string_to_boolean(\"true\") -> true;\n-string_to_boolean(\"false\") -> false;\n-string_to_boolean(\"1\") -> true;\n-string_to_boolean(\"0\") -> false;\n-string_to_boolean(_) -> throw({error, invalid_boolean}).\n+string_to_boolean(\"true\") ->\n+    true;\n+string_to_boolean(\"false\") ->\n+    false;\n+string_to_boolean(\"1\") ->\n+    true;\n+string_to_boolean(\"0\") ->\n+    false;\n+string_to_boolean(_) ->\n+    throw({error, invalid_boolean}).\n \n %% @doc Load configuration from file (internal)\n load_config_from_file(File) ->\n     case file:consult(File) of\n         {ok, [Config]} when is_list(Config) ->\n-            ErlmcpConfig = case lists:keyfind(erlmcp, 1, Config) of\n-                {erlmcp, AppConfig} -> AppConfig;\n-                false -> Config\n-            end,\n+            ErlmcpConfig =\n+                case lists:keyfind(erlmcp, 1, Config) of\n+                    {erlmcp, AppConfig} ->\n+                        AppConfig;\n+                    false ->\n+                        Config\n+                end,\n             ConfigMap = maps:from_list(ErlmcpConfig),\n             case validate_config(ConfigMap) of\n-                ok -> {ok, ConfigMap};\n-                Error -> Error\n+                ok ->\n+                    {ok, ConfigMap};\n+                Error ->\n+                    Error\n             end;\n         {error, Reason} ->\n             {error, {file_error, Reason}}\n     end.\n \n %% @doc File watcher process\n file_watcher(File) ->\n     case filelib:last_modified(File) of\n-        0 -> \n+        0 ->\n             timer:sleep(1000),\n             file_watcher(File);\n         LastModified ->\n             timer:sleep(1000),\n             case filelib:last_modified(File) of\n-                LastModified -> \n+                LastModified ->\n                     file_watcher(File);\n                 _ ->\n                     ?MODULE ! {file_changed, File},\n                     file_watcher(File)\n@@ -674,22 +690,16 @@\n     end.\n \n %% @doc Notify all subscribers of configuration changes\n notify_subscribers(Event, Data, #config_state{subscribers = Subscribers}) ->\n-    lists:foreach(fun(Pid) ->\n-        Pid ! {config_event, Event, Data}\n-    end, Subscribers).\n+    lists:foreach(fun(Pid) -> Pid ! {config_event, Event, Data} end, Subscribers).\n \n %% @doc Migration from version 1.0\n migrate_from_v1_0(Config) ->\n-    Mappings = [\n-        {name, server_name},\n-        {tcp_port, port},\n-        {connections, max_connections}\n-    ],\n+    Mappings = [{name, server_name}, {tcp_port, port}, {connections, max_connections}],\n     migrate_keys(Config, Mappings).\n \n-%% @doc Migration from version 2.0  \n+%% @doc Migration from version 2.0\n migrate_from_v2_0(Config) ->\n     %% Minimal changes from 2.0\n     maps:from_list(Config).\n \n@@ -701,5 +711,5 @@\n         {value, {OldKey, Value}, NewConfig} ->\n             migrate_keys([{NewKey, Value} | NewConfig], Rest);\n         false ->\n             migrate_keys(Config, Rest)\n-    end.\n\\ No newline at end of file\n+    end.\n"
                }
            ],
            "date": 1756185314751,
            "name": "Commit-0",
            "content": "%% @doc Configuration Management Module\n%% Provides centralized configuration management with dynamic updates,\n%% environment variable support, validation, and hot reload capabilities.\n%% \n%% Features:\n%% - Load configuration from sys.config files\n%% - Environment variable overrides\n%% - Dynamic runtime reconfiguration\n%% - Configuration validation\n%% - Hot reload without restart\n%% - Configuration backup/restore\n%% - Schema-based validation\n%% - Migration from old config formats\n-module(erlmcp_config).\n-behaviour(gen_server).\n\n%% API\n-export([\n    start_link/0,\n    stop/0,\n    get/1,\n    get/2,\n    set_config/1,\n    update_config/1,\n    load_config/1,\n    load_and_watch/1,\n    stop_watching/0,\n    reload_config/0,\n    validate_config/1,\n    reset_to_defaults/0,\n    apply_env_overrides/0,\n    get_server_config/1,\n    set_server_config/1,\n    validate_server_config/1,\n    get_transport_config/1,\n    set_transport_configs/1,\n    validate_transport_config/1,\n    get_enabled_transports/0,\n    merge_configs/2,\n    persist_config/1,\n    backup_config/1,\n    restore_config/1,\n    migrate_config/1,\n    get_all_config/0,\n    subscribe_changes/0,\n    unsubscribe_changes/0\n]).\n\n%% gen_server callbacks\n-export([\n    init/1,\n    handle_call/3,\n    handle_cast/2,\n    handle_info/2,\n    terminate/2,\n    code_change/3\n]).\n\n-include(\"erlmcp.hrl\").\n\n%% Configuration record\n-record(config_state, {\n    config = #{} :: map(),\n    config_file :: string() | undefined,\n    file_watcher :: pid() | undefined,\n    subscribers = [] :: [pid()],\n    schema :: map() | undefined\n}).\n\n%% Default configuration values\n-define(DEFAULT_CONFIG, #{\n    server_name => erlmcp_server,\n    port => 8080,\n    max_connections => 100,\n    timeout => 5000,\n    acceptors => 10,\n    socket_opts => [{reuseaddr, true}],\n    protocol_opts => [],\n    transports => [\n        {stdio, #{enabled => true, buffer_size => 1024, timeout => 5000}},\n        {tcp, #{enabled => false, port => 8080, acceptors => 10}},\n        {http, #{enabled => false, port => 8081, path => \"/mcp\"}}\n    ],\n    log_level => info,\n    log_file => undefined,\n    metrics_enabled => true,\n    tracing_enabled => false\n}).\n\n%% Environment variable mappings\n-define(ENV_MAPPINGS, #{\n    \"ERLMCP_SERVER_NAME\" => server_name,\n    \"ERLMCP_PORT\" => {port, fun erlang:list_to_integer/1},\n    \"ERLMCP_MAX_CONNECTIONS\" => {max_connections, fun erlang:list_to_integer/1},\n    \"ERLMCP_TIMEOUT\" => {timeout, fun erlang:list_to_integer/1},\n    \"ERLMCP_LOG_LEVEL\" => {log_level, fun erlang:list_to_atom/1},\n    \"ERLMCP_LOG_FILE\" => log_file,\n    \"ERLMCP_METRICS_ENABLED\" => {metrics_enabled, fun string_to_boolean/1},\n    \"ERLMCP_TRACING_ENABLED\" => {tracing_enabled, fun string_to_boolean/1}\n}).\n\n%%--------------------------------------------------------------------\n%% API Functions\n%%--------------------------------------------------------------------\n\n%% @doc Start the configuration server\n-spec start_link() -> {ok, pid()} | {error, term()}.\nstart_link() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n\n%% @doc Stop the configuration server\n-spec stop() -> ok.\nstop() ->\n    gen_server:stop(?MODULE).\n\n%% @doc Get a configuration value\n-spec get(atom()) -> term().\nget(Key) ->\n    get(Key, undefined).\n\n%% @doc Get a configuration value with default\n-spec get(atom(), term()) -> term().\nget(Key, Default) ->\n    try\n        gen_server:call(?MODULE, {get, Key, Default})\n    catch\n        exit:{noproc, _} ->\n            %% Server not started, return from default config\n            maps:get(Key, ?DEFAULT_CONFIG, Default)\n    end.\n\n%% @doc Set entire configuration\n-spec set_config(list() | map()) -> ok | {error, term()}.\nset_config(Config) when is_list(Config) ->\n    set_config(maps:from_list(Config));\nset_config(Config) when is_map(Config) ->\n    case validate_config(Config) of\n        ok ->\n            gen_server:call(?MODULE, {set_config, Config});\n        Error ->\n            Error\n    end.\n\n%% @doc Update configuration with new values\n-spec update_config(list() | map()) -> ok | {error, term()}.\nupdate_config(Updates) when is_list(Updates) ->\n    update_config(maps:from_list(Updates));\nupdate_config(Updates) when is_map(Updates) ->\n    gen_server:call(?MODULE, {update_config, Updates}).\n\n%% @doc Load configuration from file\n-spec load_config(string()) -> {ok, map()} | {error, term()}.\nload_config(ConfigFile) ->\n    try\n        case file:consult(ConfigFile) of\n            {ok, [Config]} when is_list(Config) ->\n                %% Extract erlmcp configuration\n                ErlmcpConfig = case lists:keyfind(erlmcp, 1, Config) of\n                    {erlmcp, AppConfig} -> AppConfig;\n                    false -> Config\n                end,\n                ConfigMap = maps:from_list(ErlmcpConfig),\n                case validate_config(ConfigMap) of\n                    ok ->\n                        gen_server:call(?MODULE, {set_config, ConfigMap}),\n                        {ok, ConfigMap};\n                    Error ->\n                        Error\n                end;\n            {ok, Config} when is_list(Config) ->\n                {error, {invalid_config_format, \"Expected single term\"}};\n            {error, Reason} ->\n                {error, {file_error, Reason}}\n        end\n    catch\n        Class:CReason:CStacktrace ->\n            {error, {exception, Class, CReason, CStacktrace}}\n    end.\n\n%% @doc Load configuration and watch for changes\n-spec load_and_watch(string()) -> ok | {error, term()}.\nload_and_watch(ConfigFile) ->\n    case load_config(ConfigFile) of\n        {ok, _} ->\n            gen_server:call(?MODULE, {watch_file, ConfigFile});\n        Error ->\n            Error\n    end.\n\n%% @doc Stop watching configuration file\n-spec stop_watching() -> ok.\nstop_watching() ->\n    gen_server:call(?MODULE, stop_watching).\n\n%% @doc Reload configuration from watched file\n-spec reload_config() -> ok | {error, term()}.\nreload_config() ->\n    gen_server:call(?MODULE, reload_config).\n\n%% @doc Validate configuration\n-spec validate_config(term()) -> ok | {error, term()}.\nvalidate_config(Config) when is_map(Config) ->\n    try\n        erlmcp_config_schema:validate(Config)\n    catch\n        error:undef ->\n            %% Schema module not available, do basic validation\n            basic_validate_config(Config);\n        Class:CReason:CStacktrace ->\n            {error, {validation_exception, Class, CReason, CStacktrace}}\n    end;\nvalidate_config(Config) when is_list(Config) ->\n    validate_config(maps:from_list(Config));\nvalidate_config(_Config) ->\n    {error, {validation_failed, \"Configuration must be a map or property list\"}}.\n\n%% @doc Reset configuration to defaults\n-spec reset_to_defaults() -> ok.\nreset_to_defaults() ->\n    gen_server:call(?MODULE, reset_to_defaults).\n\n%% @doc Apply environment variable overrides\n-spec apply_env_overrides() -> ok.\napply_env_overrides() ->\n    gen_server:call(?MODULE, apply_env_overrides).\n\n%% @doc Get server configuration value\n-spec get_server_config(atom()) -> term().\nget_server_config(Key) ->\n    ?MODULE:get(Key).\n\n%% @doc Set server configuration\n-spec set_server_config(list() | map()) -> ok | {error, term()}.\nset_server_config(Config) ->\n    case validate_server_config(Config) of\n        ok -> update_config(Config);\n        Error -> Error\n    end.\n\n%% @doc Validate server configuration\n-spec validate_server_config(term()) -> ok | {error, term()}.\nvalidate_server_config(Config) when is_list(Config) ->\n    validate_server_config(maps:from_list(Config));\nvalidate_server_config(Config) when is_map(Config) ->\n    %% Basic server config validation\n    try\n        maps:fold(fun validate_server_key/3, ok, Config)\n    catch\n        throw:Error -> Error\n    end;\nvalidate_server_config(_) ->\n    {error, {validation_failed, \"Server config must be a map or property list\"}}.\n\n%% @doc Get transport configuration\n-spec get_transport_config(atom()) -> map() | undefined.\nget_transport_config(Transport) ->\n    Transports = get(transports, []),\n    case lists:keyfind(Transport, 1, Transports) of\n        {Transport, Config} -> Config;\n        false -> undefined\n    end.\n\n%% @doc Set transport configurations\n-spec set_transport_configs(list()) -> ok | {error, term()}.\nset_transport_configs(Configs) when is_list(Configs) ->\n    %% Validate all transport configs\n    case validate_all_transports(Configs) of\n        ok ->\n            update_config([{transports, Configs}]);\n        Error ->\n            Error\n    end.\n\n%% @doc Validate transport configuration\n-spec validate_transport_config({atom(), map()}) -> ok | {error, term()}.\nvalidate_transport_config({Transport, Config}) when is_atom(Transport), is_map(Config) ->\n    case Transport of\n        stdio -> validate_stdio_config(Config);\n        tcp -> validate_tcp_config(Config);\n        http -> validate_http_config(Config);\n        _ -> {error, {unknown_transport, Transport}}\n    end;\nvalidate_transport_config(_) ->\n    {error, {validation_failed, \"Transport config must be {atom(), map()}\"}}.\n\n%% @doc Get list of enabled transports\n-spec get_enabled_transports() -> [atom()].\nget_enabled_transports() ->\n    Transports = get(transports, []),\n    [Transport || {Transport, Config} <- Transports,\n                  maps:get(enabled, Config, false)].\n\n%% @doc Merge two configuration maps\n-spec merge_configs(map() | list(), map() | list()) -> map().\nmerge_configs(Base, Override) when is_list(Base) ->\n    merge_configs(maps:from_list(Base), Override);\nmerge_configs(Base, Override) when is_list(Override) ->\n    merge_configs(Base, maps:from_list(Override));\nmerge_configs(Base, Override) when is_map(Base), is_map(Override) ->\n    maps:fold(fun merge_config_key/3, Base, Override).\n\n%% @doc Persist current configuration to file\n-spec persist_config(string()) -> ok | {error, term()}.\npersist_config(File) ->\n    Config = get_all_config(),\n    ConfigTerm = [{erlmcp, maps:to_list(Config)}],\n    Content = io_lib:format(\"~p.~n\", [ConfigTerm]),\n    file:write_file(File, Content).\n\n%% @doc Backup current configuration\n-spec backup_config(string()) -> ok | {error, term()}.\nbackup_config(BackupFile) ->\n    persist_config(BackupFile).\n\n%% @doc Restore configuration from backup\n-spec restore_config(string()) -> ok | {error, term()}.\nrestore_config(BackupFile) ->\n    load_config(BackupFile).\n\n%% @doc Migrate configuration from old format\n-spec migrate_config(list()) -> {ok, map()} | {error, term()}.\nmigrate_config(OldConfig) when is_list(OldConfig) ->\n    try\n        %% Check for version\n        Version = case lists:keyfind(config_version, 1, OldConfig) of\n            {config_version, V} -> V;\n            false -> \"1.0\" % Assume old version\n        end,\n        \n        %% Apply migration based on version\n        MigratedConfig = case Version of\n            \"1.0\" -> migrate_from_v1_0(OldConfig);\n            \"2.0\" -> migrate_from_v2_0(OldConfig);\n            _ -> maps:from_list(OldConfig) % No migration needed\n        end,\n        \n        {ok, MigratedConfig}\n    catch\n        Class:CReason:CStacktrace ->\n            {error, {migration_failed, Class, CReason, CStacktrace}}\n    end.\n\n%% @doc Get all configuration as map\n-spec get_all_config() -> map().\nget_all_config() ->\n    gen_server:call(?MODULE, get_all_config).\n\n%% @doc Subscribe to configuration changes\n-spec subscribe_changes() -> ok.\nsubscribe_changes() ->\n    gen_server:call(?MODULE, {subscribe, self()}).\n\n%% @doc Unsubscribe from configuration changes\n-spec unsubscribe_changes() -> ok.\nunsubscribe_changes() ->\n    gen_server:call(?MODULE, {unsubscribe, self()}).\n\n%%--------------------------------------------------------------------\n%% gen_server Callbacks\n%%--------------------------------------------------------------------\n\ninit([]) ->\n    %% Load schema if available\n    Schema = try\n        erlmcp_config_schema:get_schema()\n    catch\n        error:undef -> undefined\n    end,\n    \n    State = #config_state{\n        config = ?DEFAULT_CONFIG,\n        schema = Schema\n    },\n    \n    %% Apply environment overrides on startup\n    {ok, NewState} = handle_call(apply_env_overrides, undefined, State),\n    \n    {ok, NewState}.\n\nhandle_call({get, Key, Default}, _From, #config_state{config = Config} = State) ->\n    Value = maps:get(Key, Config, Default),\n    {reply, Value, State};\n\nhandle_call({set_config, NewConfig}, _From, State) ->\n    NewState = State#config_state{config = NewConfig},\n    notify_subscribers(config_changed, NewConfig, NewState),\n    {reply, ok, NewState};\n\nhandle_call({update_config, Updates}, _From, #config_state{config = Config} = State) ->\n    NewConfig = maps:merge(Config, Updates),\n    case validate_config(NewConfig) of\n        ok ->\n            NewState = State#config_state{config = NewConfig},\n            notify_subscribers(config_updated, Updates, NewState),\n            {reply, ok, NewState};\n        Error ->\n            {reply, Error, State}\n    end;\n\nhandle_call({watch_file, File}, _From, State) ->\n    %% Stop existing watcher if any\n    case State#config_state.file_watcher of\n        undefined -> ok;\n        Pid -> exit(Pid, normal)\n    end,\n    \n    %% Start new file watcher\n    Watcher = spawn_link(fun() -> file_watcher(File) end),\n    NewState = State#config_state{\n        config_file = File,\n        file_watcher = Watcher\n    },\n    {reply, ok, NewState};\n\nhandle_call(stop_watching, _From, State) ->\n    case State#config_state.file_watcher of\n        undefined -> ok;\n        Pid -> exit(Pid, normal)\n    end,\n    NewState = State#config_state{\n        config_file = undefined,\n        file_watcher = undefined\n    },\n    {reply, ok, NewState};\n\nhandle_call(reload_config, _From, #config_state{config_file = undefined} = State) ->\n    {reply, {error, no_config_file}, State};\n\nhandle_call(reload_config, _From, #config_state{config_file = File} = State) ->\n    case load_config_from_file(File) of\n        {ok, NewConfig} ->\n            NewState = State#config_state{config = NewConfig},\n            notify_subscribers(config_reloaded, NewConfig, NewState),\n            {reply, ok, NewState};\n        Error ->\n            {reply, Error, State}\n    end;\n\nhandle_call(reset_to_defaults, _From, State) ->\n    NewState = State#config_state{config = ?DEFAULT_CONFIG},\n    notify_subscribers(config_reset, ?DEFAULT_CONFIG, NewState),\n    {reply, ok, NewState};\n\nhandle_call(apply_env_overrides, _From, #config_state{config = Config} = State) ->\n    NewConfig = apply_env_overrides_to_config(Config),\n    NewState = State#config_state{config = NewConfig},\n    {reply, ok, NewState};\n\nhandle_call(get_all_config, _From, #config_state{config = Config} = State) ->\n    {reply, Config, State};\n\nhandle_call({subscribe, Pid}, _From, #config_state{subscribers = Subs} = State) ->\n    monitor(process, Pid),\n    NewState = State#config_state{subscribers = [Pid | Subs]},\n    {reply, ok, NewState};\n\nhandle_call({unsubscribe, Pid}, _From, #config_state{subscribers = Subs} = State) ->\n    demonitor(Pid, [flush]),\n    NewSubs = lists:delete(Pid, Subs),\n    NewState = State#config_state{subscribers = NewSubs},\n    {reply, ok, NewState};\n\nhandle_call(_Request, _From, State) ->\n    {reply, {error, unknown_request}, State}.\n\nhandle_cast(_Request, State) ->\n    {noreply, State}.\n\nhandle_info({file_changed, File}, #config_state{config_file = File} = State) ->\n    %% Automatically reload configuration when file changes\n    case load_config_from_file(File) of\n        {ok, NewConfig} ->\n            NewState = State#config_state{config = NewConfig},\n            notify_subscribers(config_file_changed, NewConfig, NewState),\n            {noreply, NewState};\n        _Error ->\n            %% Log error but don't change state\n            {noreply, State}\n    end;\n\nhandle_info({'DOWN', _Ref, process, Pid, _Reason}, #config_state{subscribers = Subs} = State) ->\n    NewSubs = lists:delete(Pid, Subs),\n    NewState = State#config_state{subscribers = NewSubs},\n    {noreply, NewState};\n\nhandle_info({'EXIT', Pid, _Reason}, #config_state{file_watcher = Pid} = State) ->\n    %% File watcher died, clear it\n    NewState = State#config_state{file_watcher = undefined},\n    {noreply, NewState};\n\nhandle_info(_Info, State) ->\n    {noreply, State}.\n\nterminate(_Reason, #config_state{file_watcher = Watcher}) ->\n    case Watcher of\n        undefined -> ok;\n        Pid -> exit(Pid, normal)\n    end,\n    ok.\n\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\n%%--------------------------------------------------------------------\n%% Internal Functions\n%%--------------------------------------------------------------------\n\n%% @doc Basic configuration validation when schema is not available\nbasic_validate_config(Config) when is_map(Config) ->\n    RequiredKeys = [server_name, port],\n    case check_required_keys(RequiredKeys, Config) of\n        ok -> validate_config_types(Config);\n        Error -> Error\n    end.\n\n%% @doc Check if required keys are present\ncheck_required_keys([], _Config) -> ok;\ncheck_required_keys([Key | Rest], Config) ->\n    case maps:is_key(Key, Config) orelse maps:is_key(Key, ?DEFAULT_CONFIG) of\n        true -> check_required_keys(Rest, Config);\n        false -> {error, {missing_required_key, Key}}\n    end.\n\n%% @doc Validate configuration value types\nvalidate_config_types(Config) ->\n    try\n        maps:fold(fun validate_config_type/3, ok, Config)\n    catch\n        throw:Error -> Error\n    end.\n\nvalidate_config_type(server_name, Value, ok) when is_atom(Value) -> ok;\nvalidate_config_type(port, Value, ok) when is_integer(Value), Value > 0, Value < 65536 -> ok;\nvalidate_config_type(max_connections, Value, ok) when is_integer(Value), Value > 0 -> ok;\nvalidate_config_type(timeout, Value, ok) when is_integer(Value), Value > 0 -> ok;\nvalidate_config_type(acceptors, Value, ok) when is_integer(Value), Value > 0 -> ok;\nvalidate_config_type(log_level, Value, ok) when Value =:= debug; Value =:= info; Value =:= warning; Value =:= error -> ok;\nvalidate_config_type(transports, Value, ok) when is_list(Value) -> \n    validate_all_transports(Value);\nvalidate_config_type(Key, Value, ok) ->\n    %% Allow unknown keys for extensibility\n    ok;\nvalidate_config_type(Key, Value, ok) ->\n    throw({error, {invalid_type, Key, Value}}).\n\n%% @doc Validate server configuration key\nvalidate_server_key(acceptors, Value, ok) when is_integer(Value), Value > 0 -> ok;\nvalidate_server_key(server_name, Value, ok) when is_atom(Value) -> ok;\nvalidate_server_key(port, Value, ok) when is_integer(Value), Value > 0, Value < 65536 -> ok;\nvalidate_server_key(socket_opts, Value, ok) when is_list(Value) -> ok;\nvalidate_server_key(protocol_opts, Value, ok) when is_list(Value) -> ok;\nvalidate_server_key(Key, _Value, ok) ->\n    throw({error, {invalid_server_key, Key}}).\n\n%% @doc Validate all transport configurations\nvalidate_all_transports([]) -> ok;\nvalidate_all_transports([Transport | Rest]) ->\n    case validate_transport_config(Transport) of\n        ok -> validate_all_transports(Rest);\n        Error -> Error\n    end.\n\n%% @doc Validate stdio transport configuration\nvalidate_stdio_config(Config) ->\n    AllowedKeys = [enabled, buffer_size, timeout],\n    validate_transport_keys(Config, AllowedKeys).\n\n%% @doc Validate TCP transport configuration\nvalidate_tcp_config(Config) ->\n    AllowedKeys = [enabled, port, acceptors, socket_opts],\n    case validate_transport_keys(Config, AllowedKeys) of\n        ok ->\n            %% Additional TCP-specific validation\n            case maps:get(port, Config, undefined) of\n                Port when is_integer(Port), Port > 0, Port < 65536 -> ok;\n                undefined -> ok; % Optional\n                _ -> {error, {invalid_tcp_port, maps:get(port, Config)}}\n            end;\n        Error -> Error\n    end.\n\n%% @doc Validate HTTP transport configuration\nvalidate_http_config(Config) ->\n    AllowedKeys = [enabled, port, path, ssl_opts],\n    validate_transport_keys(Config, AllowedKeys).\n\n%% @doc Validate transport configuration keys\nvalidate_transport_keys(Config, AllowedKeys) ->\n    ConfigKeys = maps:keys(Config),\n    case lists:all(fun(Key) -> lists:member(Key, AllowedKeys) end, ConfigKeys) of\n        true -> ok;\n        false -> \n            InvalidKeys = ConfigKeys -- AllowedKeys,\n            {error, {invalid_transport_keys, InvalidKeys}}\n    end.\n\n%% @doc Merge configuration key with special handling\nmerge_config_key(transports, NewTransports, Base) when is_list(NewTransports) ->\n    %% Merge transport configurations\n    OldTransports = maps:get(transports, Base, []),\n    MergedTransports = merge_transports(OldTransports, NewTransports),\n    maps:put(transports, MergedTransports, Base);\nmerge_config_key(Key, Value, Base) ->\n    maps:put(Key, Value, Base).\n\n%% @doc Merge transport configurations\nmerge_transports(Old, New) ->\n    %% Convert to maps for easier merging\n    OldMap = maps:from_list(Old),\n    NewMap = maps:from_list(New),\n    MergedMap = maps:merge(OldMap, NewMap),\n    maps:to_list(MergedMap).\n\n%% @doc Apply environment variable overrides to configuration\napply_env_overrides_to_config(Config) ->\n    maps:fold(fun apply_env_override/3, Config, ?ENV_MAPPINGS).\n\napply_env_override(EnvVar, ConfigKey, Config) ->\n    case os:getenv(EnvVar) of\n        false -> Config;\n        Value -> \n            case ConfigKey of\n                {Key, Converter} ->\n                    try\n                        ConvertedValue = Converter(Value),\n                        maps:put(Key, ConvertedValue, Config)\n                    catch\n                        _:_ -> Config % Ignore conversion errors\n                    end;\n                Key ->\n                    maps:put(Key, Value, Config)\n            end\n    end.\n\n%% @doc Convert string to boolean\nstring_to_boolean(\"true\") -> true;\nstring_to_boolean(\"false\") -> false;\nstring_to_boolean(\"1\") -> true;\nstring_to_boolean(\"0\") -> false;\nstring_to_boolean(_) -> throw({error, invalid_boolean}).\n\n%% @doc Load configuration from file (internal)\nload_config_from_file(File) ->\n    case file:consult(File) of\n        {ok, [Config]} when is_list(Config) ->\n            ErlmcpConfig = case lists:keyfind(erlmcp, 1, Config) of\n                {erlmcp, AppConfig} -> AppConfig;\n                false -> Config\n            end,\n            ConfigMap = maps:from_list(ErlmcpConfig),\n            case validate_config(ConfigMap) of\n                ok -> {ok, ConfigMap};\n                Error -> Error\n            end;\n        {error, Reason} ->\n            {error, {file_error, Reason}}\n    end.\n\n%% @doc File watcher process\nfile_watcher(File) ->\n    case filelib:last_modified(File) of\n        0 -> \n            timer:sleep(1000),\n            file_watcher(File);\n        LastModified ->\n            timer:sleep(1000),\n            case filelib:last_modified(File) of\n                LastModified -> \n                    file_watcher(File);\n                _ ->\n                    ?MODULE ! {file_changed, File},\n                    file_watcher(File)\n            end\n    end.\n\n%% @doc Notify all subscribers of configuration changes\nnotify_subscribers(Event, Data, #config_state{subscribers = Subscribers}) ->\n    lists:foreach(fun(Pid) ->\n        Pid ! {config_event, Event, Data}\n    end, Subscribers).\n\n%% @doc Migration from version 1.0\nmigrate_from_v1_0(Config) ->\n    Mappings = [\n        {name, server_name},\n        {tcp_port, port},\n        {connections, max_connections}\n    ],\n    migrate_keys(Config, Mappings).\n\n%% @doc Migration from version 2.0  \nmigrate_from_v2_0(Config) ->\n    %% Minimal changes from 2.0\n    maps:from_list(Config).\n\n%% @doc Apply key mappings for migration\nmigrate_keys(Config, []) ->\n    maps:from_list(Config);\nmigrate_keys(Config, [{OldKey, NewKey} | Rest]) ->\n    case lists:keytake(OldKey, 1, Config) of\n        {value, {OldKey, Value}, NewConfig} ->\n            migrate_keys([{NewKey, Value} | NewConfig], Rest);\n        false ->\n            migrate_keys(Config, Rest)\n    end."
        }
    ]
}