{
    "sourceFile": "src/erlmcp_transport_sup.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1756189019417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756189288935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,28 +1,31 @@\n -module(erlmcp_transport_sup).\n+\n -behaviour(supervisor).\n \n--export([start_link/0, start_child/3, stop_child/1, get_child_status/1, \n-         transport_module/1, get_all_transports/0, restart_transport/1,\n-         get_transport_info/1]).\n+-export([start_link/0, start_child/3, stop_child/1, get_child_status/1,\n+         transport_module/1, get_all_transports/0, restart_transport/1, get_transport_info/1]).\n+\n %% Internal functions exported for testing\n -ifdef(TEST).\n+\n -export([validate_transport_config/2]).\n+\n -endif.\n+\n -export([init/1]).\n \n -include_lib(\"kernel/include/logger.hrl\").\n \n %% Transport state tracking\n--record(transport_info, {\n-    id :: atom(),\n-    type :: atom(),\n-    pid :: pid() | undefined,\n-    module :: module(),\n-    config :: map(),\n-    start_time :: erlang:timestamp() | undefined,\n-    restart_count = 0 :: non_neg_integer()\n-}).\n+-record(transport_info,\n+        {id :: atom(),\n+         type :: atom(),\n+         pid :: pid() | undefined,\n+         module :: module(),\n+         config :: map(),\n+         start_time :: erlang:timestamp() | undefined,\n+         restart_count = 0 :: non_neg_integer()}).\n \n %% ETS table for transport tracking\n -define(TRANSPORT_TABLE, erlmcp_transport_registry).\n \n@@ -32,53 +35,68 @@\n \n -spec start_link() -> {ok, pid()} | {error, term()}.\n start_link() ->\n     ?LOG_INFO(\"Starting transport supervisor with enhanced monitoring\"),\n-    \n+\n     % Create ETS table for transport tracking\n     case ets:info(?TRANSPORT_TABLE) of\n         undefined ->\n             ets:new(?TRANSPORT_TABLE, [named_table, public, set, {keypos, 2}]);\n         _ ->\n             ok\n     end,\n-    \n+\n     supervisor:start_link({local, ?MODULE}, ?MODULE, []).\n \n -spec start_child(atom(), atom(), map()) -> {ok, pid()} | {error, term()}.\n start_child(TransportId, Type, Config) ->\n-    ?LOG_INFO(\"Starting transport child: ~p type: ~p with config keys: ~p\", \n+    ensure_started(),\n+    ?LOG_INFO(\"Starting transport child: ~p type: ~p with config keys: ~p\",\n               [TransportId, Type, maps:keys(Config)]),\n-    \n+\n     try\n         % Validate transport type and get module\n         Module = transport_module(Type),\n-        \n+\n         % Validate configuration for the transport type\n         case validate_transport_config(Type, Config) of\n             ok ->\n                 proceed_with_start(TransportId, Type, Module, Config);\n             {error, ValidationError} ->\n-                ?LOG_ERROR(\"Configuration validation failed for transport ~p (~p): ~p\", \n-                          [TransportId, Type, ValidationError]),\n+                ?LOG_ERROR(\"Configuration validation failed for transport ~p (~p): ~p\",\n+                           [TransportId, Type, ValidationError]),\n                 {error, {config_validation_failed, ValidationError}}\n         end\n     catch\n-        error:{unknown_transport_type, _} = Error ->\n+        error:({unknown_transport_type, _} = Error) ->\n             ?LOG_ERROR(\"Unknown transport type for ~p: ~p\", [TransportId, Type]),\n             {error, Error};\n         error:StartupError:Stacktrace ->\n-            ?LOG_ERROR(\"Exception starting transport ~p: ~p~n~p\", \n-                      [TransportId, StartupError, Stacktrace]),\n+            ?LOG_ERROR(\"Exception starting transport ~p: ~p~n~p\",\n+                       [TransportId, StartupError, Stacktrace]),\n             {error, {startup_exception, StartupError}};\n         Class:ExceptionReason:Stacktrace ->\n-            ?LOG_ERROR(\"Unexpected error starting transport ~p: ~p:~p~n~p\", \n-                      [TransportId, Class, ExceptionReason, Stacktrace]),\n+            ?LOG_ERROR(\"Unexpected error starting transport ~p: ~p:~p~n~p\",\n+                       [TransportId, Class, ExceptionReason, Stacktrace]),\n             {error, {unexpected_error, {Class, ExceptionReason}}}\n     end.\n \n+%% Ensure supervisor is started before operations\n+-spec ensure_started() -> ok.\n+ensure_started() ->\n+    case whereis(?MODULE) of\n+        undefined ->\n+            case ?MODULE:start_link() of\n+                {ok, _Pid} -> ok;\n+                {error, {already_started, _Pid}} -> ok;\n+                {error, _} -> ok\n+            end;\n+        _ -> ok\n+    end.\n+\n %% Enhanced start procedure with comprehensive error handling\n--spec proceed_with_start(atom(), atom(), module(), map()) -> {ok, pid()} | {error, term()}.\n+-spec proceed_with_start(atom(), atom(), module(), map()) ->\n+                            {ok, pid()} | {error, term()}.\n proceed_with_start(TransportId, Type, Module, Config) ->\n     % Check if transport already exists\n     case get_child_status(TransportId) of\n         {ok, running} ->\n@@ -99,54 +117,53 @@\n             start_new_transport(TransportId, Type, Module, Config)\n     end.\n \n %% Start new transport with enhanced monitoring\n--spec start_new_transport(atom(), atom(), module(), map()) -> {ok, pid()} | {error, term()}.\n+-spec start_new_transport(atom(), atom(), module(), map()) ->\n+                             {ok, pid()} | {error, term()}.\n start_new_transport(TransportId, Type, Module, Config) ->\n     StartTime = erlang:timestamp(),\n-    \n+\n     % Create enhanced child specification\n-    ChildSpec = #{\n-        id => TransportId,\n-        start => {Module, start_link, [TransportId, Config]},\n-        restart => permanent,  % Use permanent restart for better reliability\n-        shutdown => 15000,     % Enhanced: Extended shutdown timeout\n-        type => worker,\n-        modules => [Module]\n-    },\n-    \n+    ChildSpec =\n+        #{id => TransportId,\n+          start => {Module, start_link, [TransportId, Config]},\n+          restart => permanent,  % Use permanent restart for better reliability\n+          shutdown => 15000,     % Enhanced: Extended shutdown timeout\n+          type => worker,\n+          modules => [Module]},\n+\n     case supervisor:start_child(?MODULE, ChildSpec) of\n         {ok, Pid} = Result ->\n-            ?LOG_INFO(\"Successfully started transport ~p (~p) with PID ~p\", \n-                     [TransportId, Type, Pid]),\n-            \n+            ?LOG_INFO(\"Successfully started transport ~p (~p) with PID ~p\",\n+                      [TransportId, Type, Pid]),\n+\n             % Store transport information\n-            TransportInfo = #transport_info{\n-                id = TransportId,\n-                type = Type,\n-                pid = Pid,\n-                module = Module,\n-                config = Config,\n-                start_time = StartTime,\n-                restart_count = get_restart_count(TransportId)\n-            },\n+            TransportInfo =\n+                #transport_info{id = TransportId,\n+                                type = Type,\n+                                pid = Pid,\n+                                module = Module,\n+                                config = Config,\n+                                start_time = StartTime,\n+                                restart_count = get_restart_count(TransportId)},\n             ets:insert(?TRANSPORT_TABLE, TransportInfo),\n-            \n+\n             % Register with health monitoring system\n             register_transport_health_monitoring(TransportId, Pid, Type),\n-            \n+\n             Result;\n         {error, {already_started, Pid}} ->\n             ?LOG_WARNING(\"Transport ~p already started with PID ~p\", [TransportId, Pid]),\n             % Update our tracking even if it was already started\n             update_transport_info(TransportId, Pid),\n             {ok, Pid};\n         {error, Reason} = Error ->\n             ?LOG_ERROR(\"Failed to start transport ~p (~p): ~p\", [TransportId, Type, Reason]),\n-            \n+\n             % Record failure for analysis\n             increment_restart_count(TransportId),\n-            \n+\n             % Attempt recovery if this is a known transport type failure\n             case should_attempt_recovery(Reason, TransportId) of\n                 true ->\n                     ?LOG_INFO(\"Attempting recovery for transport ~p\", [TransportId]),\n@@ -158,12 +175,12 @@\n \n -spec stop_child(atom()) -> ok | {error, term()}.\n stop_child(TransportId) ->\n     ?LOG_INFO(\"Stopping transport child: ~p\", [TransportId]),\n-    \n+\n     % Unregister from health monitoring first\n     unregister_transport_health_monitoring(TransportId),\n-    \n+\n     case supervisor:terminate_child(?MODULE, TransportId) of\n         ok ->\n             case supervisor:delete_child(?MODULE, TransportId) of\n                 ok ->\n@@ -191,10 +208,12 @@\n         Children when is_list(Children) ->\n             case lists:keyfind(TransportId, 1, Children) of\n                 {TransportId, Pid, worker, _} when is_pid(Pid) ->\n                     case is_process_alive(Pid) of\n-                        true -> {ok, running};\n-                        false -> {ok, stopped}\n+                        true ->\n+                            {ok, running};\n+                        false ->\n+                            {ok, stopped}\n                     end;\n                 {TransportId, undefined, worker, _} ->\n                     {ok, stopped};\n                 false ->\n@@ -206,15 +225,15 @@\n     end.\n \n %% Enhanced transport module resolution with validation and module checking\n -spec transport_module(atom()) -> module().\n-transport_module(stdio) -> \n+transport_module(stdio) ->\n     Module = erlmcp_transport_stdio_new,\n     ensure_module_loaded(Module);\n-transport_module(tcp) -> \n+transport_module(tcp) ->\n     Module = erlmcp_transport_tcp,\n     ensure_module_loaded(Module);\n-transport_module(http) -> \n+transport_module(http) ->\n     Module = erlmcp_transport_http,\n     ensure_module_loaded(Module);\n transport_module(Type) ->\n     ?LOG_ERROR(\"Unknown transport type: ~p. Supported types: stdio, tcp, http\", [Type]),\n@@ -237,20 +256,24 @@\n \n %% Enhanced health monitoring integration\n -spec register_transport_health_monitoring(atom(), pid(), atom()) -> ok.\n register_transport_health_monitoring(TransportId, Pid, Type) ->\n-    % Create transport-specific health check function\n-    HealthCheckFun = create_transport_health_check_function(Type, Pid),\n-    \n-    % Register with the health monitoring system\n-    case erlmcp_health_monitor:register_component(TransportId, Pid, HealthCheckFun) of\n-        ok ->\n-            ?LOG_DEBUG(\"Registered transport ~p with health monitoring\", [TransportId]);\n-        {error, Reason} ->\n-            ?LOG_WARNING(\"Failed to register transport ~p with health monitor: ~p\", \n-                        [TransportId, Reason])\n-    end,\n-    ok.\n+    case whereis(erlmcp_health_monitor) of\n+        undefined ->\n+            ?LOG_WARNING(\"Health monitor not available; skipping registration for ~p\", [TransportId]),\n+            ok;\n+        _ ->\n+            HealthCheckFun = create_transport_health_check_function(Type, Pid),\n+            case catch gen_server:call(erlmcp_health_monitor, {register_component, TransportId, Pid, HealthCheckFun}) of\n+                ok ->\n+                    ?LOG_DEBUG(\"Registered transport ~p with health monitoring\", [TransportId]);\n+                {error, Reason} ->\n+                    ?LOG_WARNING(\"Failed to register transport ~p with health monitor: ~p\", [TransportId, Reason]);\n+                {'EXIT', Reason2} ->\n+                    ?LOG_WARNING(\"Health monitor registration crashed: ~p\", [Reason2])\n+            end,\n+            ok\n+    end.\n \n %% Remove transport from health monitoring\n -spec unregister_transport_health_monitoring(atom()) -> ok.\n unregister_transport_health_monitoring(TransportId) ->\n@@ -258,60 +281,65 @@\n     ?LOG_DEBUG(\"Unregistered transport ~p from health monitoring\", [TransportId]),\n     ok.\n \n %% Create transport-specific health check functions\n--spec create_transport_health_check_function(atom(), pid()) -> fun(() -> healthy | unhealthy | degraded).\n+-spec create_transport_health_check_function(atom(), pid()) ->\n+                                                fun(() -> healthy | unhealthy | degraded).\n create_transport_health_check_function(Type, Pid) ->\n     fun() ->\n-        try\n-            case is_process_alive(Pid) of\n-                false ->\n-                    unhealthy;\n-                true ->\n-                    % Transport-specific health checks\n-                    case Type of\n-                        stdio ->\n-                            check_stdio_transport_health(Pid);\n-                        tcp ->\n-                            check_tcp_transport_health(Pid);\n-                        http ->\n-                            check_http_transport_health(Pid);\n-                        _ ->\n-                            healthy % Default to healthy for unknown types\n-                    end\n-            end\n-        catch\n-            _:_ ->\n-                unhealthy\n-        end\n+       try\n+           case is_process_alive(Pid) of\n+               false -> unhealthy;\n+               true ->\n+                   % Transport-specific health checks\n+                   case Type of\n+                       stdio -> check_stdio_transport_health(Pid);\n+                       tcp -> check_tcp_transport_health(Pid);\n+                       http -> check_http_transport_health(Pid);\n+                       _ ->\n+                           healthy % Default to healthy for unknown types\n+                   end\n+           end\n+       catch\n+           _:_ -> unhealthy\n+       end\n     end.\n \n %% Transport-specific health checks\n -spec check_stdio_transport_health(pid()) -> healthy | unhealthy | degraded.\n check_stdio_transport_health(Pid) ->\n     % Check if stdio transport can handle basic operations\n     case catch gen_server:call(Pid, {health_check}, 5000) of\n-        {ok, healthy} -> healthy;\n-        {ok, degraded} -> degraded;\n-        _ -> unhealthy\n+        {ok, healthy} ->\n+            healthy;\n+        {ok, degraded} ->\n+            degraded;\n+        _ ->\n+            unhealthy\n     end.\n \n -spec check_tcp_transport_health(pid()) -> healthy | unhealthy | degraded.\n check_tcp_transport_health(Pid) ->\n     % Check TCP connection status\n     case catch gen_server:call(Pid, {connection_status}, 5000) of\n-        {ok, connected} -> healthy;\n-        {ok, connecting} -> degraded;\n-        _ -> unhealthy\n+        {ok, connected} ->\n+            healthy;\n+        {ok, connecting} ->\n+            degraded;\n+        _ ->\n+            unhealthy\n     end.\n \n -spec check_http_transport_health(pid()) -> healthy | unhealthy | degraded.\n check_http_transport_health(Pid) ->\n     % Check HTTP transport responsiveness\n     case catch gen_server:call(Pid, {server_status}, 5000) of\n-        {ok, running} -> healthy;\n-        {ok, degraded} -> degraded;\n-        _ -> unhealthy\n+        {ok, running} ->\n+            healthy;\n+        {ok, degraded} ->\n+            degraded;\n+        _ ->\n+            unhealthy\n     end.\n \n %%====================================================================\n %% supervisor callbacks\n@@ -319,20 +347,19 @@\n \n -spec init([]) -> {ok, {supervisor:sup_flags(), [supervisor:child_spec()]}}.\n init([]) ->\n     ?LOG_INFO(\"Initializing transport supervisor\"),\n-    \n+\n     % Enhanced supervisor flags for better reliability and resilience\n-    SupFlags = #{\n-        strategy => one_for_one,  % Transport failures are isolated\n-        intensity => 15,          % Enhanced: Higher restart intensity for reliability\n-        period => 60,             % Period in seconds for restart intensity\n-        auto_shutdown => never    % Enhanced: Never auto-shutdown supervisor\n-    },\n-    \n+    SupFlags =\n+        #{strategy => one_for_one,  % Transport failures are isolated\n+          intensity => 15,          % Enhanced: Higher restart intensity for reliability\n+          period => 60,             % Period in seconds for restart intensity\n+          auto_shutdown => never},    % Enhanced: Never auto-shutdown supervisor\n+\n     % Start with empty child specs - transports are added dynamically\n     ChildSpecs = [],\n-    \n+\n     ?LOG_INFO(\"Transport supervisor initialized with enhanced configuration\"),\n     {ok, {SupFlags, ChildSpecs}}.\n \n %%====================================================================\n@@ -343,12 +370,13 @@\n -spec get_all_transports() -> [{atom(), pid(), atom(), map()}].\n get_all_transports() ->\n     case ets:tab2list(?TRANSPORT_TABLE) of\n         TransportInfos when is_list(TransportInfos) ->\n-            [{Info#transport_info.id, \n-              Info#transport_info.pid, \n-              Info#transport_info.type, \n-              Info#transport_info.config} || Info <- TransportInfos];\n+            [{Info#transport_info.id,\n+              Info#transport_info.pid,\n+              Info#transport_info.type,\n+              Info#transport_info.config}\n+             || Info <- TransportInfos];\n         _ ->\n             []\n     end.\n \n@@ -363,17 +391,18 @@\n                     % Wait a bit for clean shutdown\n                     timer:sleep(1000),\n                     case start_child(TransportId, Type, Config) of\n                         {ok, NewPid} = Result ->\n-                            ?LOG_INFO(\"Successfully restarted transport ~p with new PID ~p\", \n-                                     [TransportId, NewPid]),\n+                            ?LOG_INFO(\"Successfully restarted transport ~p with new PID ~p\",\n+                                      [TransportId, NewPid]),\n                             Result;\n                         {error, Reason} = Error ->\n                             ?LOG_ERROR(\"Failed to restart transport ~p: ~p\", [TransportId, Reason]),\n                             Error\n                     end;\n                 {error, Reason} = Error ->\n-                    ?LOG_ERROR(\"Failed to stop transport ~p for restart: ~p\", [TransportId, Reason]),\n+                    ?LOG_ERROR(\"Failed to stop transport ~p for restart: ~p\",\n+                               [TransportId, Reason]),\n                     Error\n             end;\n         [] ->\n             {error, transport_not_found}\n@@ -384,27 +413,34 @@\n get_transport_info(TransportId) ->\n     case ets:lookup(?TRANSPORT_TABLE, TransportId) of\n         [#transport_info{} = Info] ->\n             % Get current health status\n-            HealthStatus = case erlmcp_health_monitor:get_component_health(TransportId) of\n-                not_found -> unknown;\n-                Status -> Status\n-            end,\n-            \n-            InfoMap = #{\n-                id => Info#transport_info.id,\n-                type => Info#transport_info.type,\n-                pid => Info#transport_info.pid,\n-                module => Info#transport_info.module,\n-                config => Info#transport_info.config,\n-                start_time => Info#transport_info.start_time,\n-                restart_count => Info#transport_info.restart_count,\n-                health_status => HealthStatus,\n-                uptime_seconds => case Info#transport_info.start_time of\n-                    undefined -> 0;\n-                    StartTime -> timer:now_diff(erlang:timestamp(), StartTime) div 1000000\n-                end\n-            },\n+            HealthStatus =\n+                case erlmcp_health_monitor:get_component_health(TransportId) of\n+                    not_found ->\n+                        unknown;\n+                    Status ->\n+                        Status\n+                end,\n+\n+            InfoMap =\n+                #{id => Info#transport_info.id,\n+                  type => Info#transport_info.type,\n+                  pid => Info#transport_info.pid,\n+                  module => Info#transport_info.module,\n+                  config => Info#transport_info.config,\n+                  start_time => Info#transport_info.start_time,\n+                  restart_count => Info#transport_info.restart_count,\n+                  health_status => HealthStatus,\n+                  uptime_seconds =>\n+                      case Info#transport_info.start_time of\n+                          undefined ->\n+                              0;\n+                          StartTime ->\n+                              timer:now_diff(\n+                                  erlang:timestamp(), StartTime)\n+                              div 1000000\n+                      end},\n             {ok, InfoMap};\n         [] ->\n             {error, not_found}\n     end.\n@@ -480,30 +516,31 @@\n should_attempt_recovery(Reason, TransportId) ->\n     % Check restart count to avoid infinite restart loops\n     RestartCount = get_restart_count(TransportId),\n     MaxRestarts = 5, % Maximum automatic restarts\n-    \n+\n     case {Reason, RestartCount < MaxRestarts} of\n         {{shutdown, _}, _} ->\n             false; % Don't recover from intentional shutdown\n         {normal, _} ->\n             false; % Don't recover from normal termination\n         {_, true} ->\n             true;  % Attempt recovery if under restart limit\n         {_, false} ->\n-            ?LOG_ERROR(\"Transport ~p has exceeded maximum restart attempts (~p), giving up\", \n-                      [TransportId, MaxRestarts]),\n+            ?LOG_ERROR(\"Transport ~p has exceeded maximum restart attempts (~p), giving up\",\n+                       [TransportId, MaxRestarts]),\n             false\n     end.\n \n %% Attempt transport recovery\n--spec attempt_transport_recovery(atom(), atom(), module(), map()) -> {ok, pid()} | {error, term()}.\n+-spec attempt_transport_recovery(atom(), atom(), module(), map()) ->\n+                                    {ok, pid()} | {error, term()}.\n attempt_transport_recovery(TransportId, Type, Module, Config) ->\n     ?LOG_INFO(\"Attempting recovery for transport ~p\", [TransportId]),\n-    \n+\n     % Wait a bit before retry\n     timer:sleep(2000),\n-    \n+\n     % Try to start again\n     case start_new_transport(TransportId, Type, Module, Config) of\n         {ok, Pid} = Result ->\n             ?LOG_INFO(\"Successfully recovered transport ~p with new PID ~p\", [TransportId, Pid]),\n@@ -527,9 +564,10 @@\n -spec increment_restart_count(atom()) -> ok.\n increment_restart_count(TransportId) ->\n     case ets:lookup(?TRANSPORT_TABLE, TransportId) of\n         [#transport_info{} = Info] ->\n-            UpdatedInfo = Info#transport_info{restart_count = Info#transport_info.restart_count + 1},\n+            UpdatedInfo =\n+                Info#transport_info{restart_count = Info#transport_info.restart_count + 1},\n             ets:insert(?TRANSPORT_TABLE, UpdatedInfo);\n         [] ->\n             ok\n     end.\n@@ -538,12 +576,9 @@\n -spec update_transport_info(atom(), pid()) -> ok.\n update_transport_info(TransportId, NewPid) ->\n     case ets:lookup(?TRANSPORT_TABLE, TransportId) of\n         [#transport_info{} = Info] ->\n-            UpdatedInfo = Info#transport_info{\n-                pid = NewPid,\n-                start_time = erlang:timestamp()\n-            },\n+            UpdatedInfo = Info#transport_info{pid = NewPid, start_time = erlang:timestamp()},\n             ets:insert(?TRANSPORT_TABLE, UpdatedInfo);\n         [] ->\n             ?LOG_WARNING(\"Cannot update transport info for unknown transport ~p\", [TransportId])\n     end,\n"
                },
                {
                    "date": 1756189552612,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,13 +85,17 @@\n ensure_started() ->\n     case whereis(?MODULE) of\n         undefined ->\n             case ?MODULE:start_link() of\n-                {ok, _Pid} -> ok;\n-                {error, {already_started, _Pid}} -> ok;\n-                {error, _} -> ok\n+                {ok, _Pid} ->\n+                    ok;\n+                {error, {already_started, _Pid}} ->\n+                    ok;\n+                {error, _} ->\n+                    ok\n             end;\n-        _ -> ok\n+        _ ->\n+            ok\n     end.\n \n %% Enhanced start procedure with comprehensive error handling\n -spec proceed_with_start(atom(), atom(), module(), map()) ->\n@@ -208,17 +212,23 @@\n         Children when is_list(Children) ->\n             case lists:keyfind(TransportId, 1, Children) of\n                 {TransportId, Pid, worker, _} when is_pid(Pid) ->\n                     case is_process_alive(Pid) of\n-                        true ->\n-                            {ok, running};\n-                        false ->\n-                            {ok, stopped}\n+                        true -> {ok, running};\n+                        false -> {ok, stopped}\n                     end;\n                 {TransportId, undefined, worker, _} ->\n                     {ok, stopped};\n                 false ->\n-                    {error, not_found}\n+                    % Fall back to ETS tracking if supervisor has not reflected the child yet\n+                    case ets:lookup(?TRANSPORT_TABLE, TransportId) of\n+                        [#transport_info{pid = P}] when is_pid(P), P =/= undefined ->\n+                            case is_process_alive(P) of\n+                                true -> {ok, running};\n+                                false -> {ok, stopped}\n+                            end;\n+                        _ -> {error, not_found}\n+                    end\n             end;\n         Error ->\n             ?LOG_ERROR(\"Failed to get children list: ~p\", [Error]),\n             {error, supervisor_error}\n@@ -258,17 +268,21 @@\n -spec register_transport_health_monitoring(atom(), pid(), atom()) -> ok.\n register_transport_health_monitoring(TransportId, Pid, Type) ->\n     case whereis(erlmcp_health_monitor) of\n         undefined ->\n-            ?LOG_WARNING(\"Health monitor not available; skipping registration for ~p\", [TransportId]),\n+            ?LOG_WARNING(\"Health monitor not available; skipping registration for ~p\",\n+                         [TransportId]),\n             ok;\n         _ ->\n             HealthCheckFun = create_transport_health_check_function(Type, Pid),\n-            case catch gen_server:call(erlmcp_health_monitor, {register_component, TransportId, Pid, HealthCheckFun}) of\n+            case catch gen_server:call(erlmcp_health_monitor,\n+                                       {register_component, TransportId, Pid, HealthCheckFun})\n+            of\n                 ok ->\n                     ?LOG_DEBUG(\"Registered transport ~p with health monitoring\", [TransportId]);\n                 {error, Reason} ->\n-                    ?LOG_WARNING(\"Failed to register transport ~p with health monitor: ~p\", [TransportId, Reason]);\n+                    ?LOG_WARNING(\"Failed to register transport ~p with health monitor: ~p\",\n+                                 [TransportId, Reason]);\n                 {'EXIT', Reason2} ->\n                     ?LOG_WARNING(\"Health monitor registration crashed: ~p\", [Reason2])\n             end,\n             ok\n"
                },
                {
                    "date": 1756190131044,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,8 +15,12 @@\n -export([init/1]).\n \n -include_lib(\"kernel/include/logger.hrl\").\n \n+%% Import coordination functions\n+-import(erlmcp_coordination, [store_supervisor_decision/1, notify_coordination_hooks/3, check_transport_dependencies/2]).\n+-import(erlmcp, [validate_transport_health/2]).\n+\n %% Transport state tracking\n -record(transport_info,\n         {id :: atom(),\n          type :: atom(),\n@@ -52,32 +56,49 @@\n     ensure_started(),\n     ?LOG_INFO(\"Starting transport child: ~p type: ~p with config keys: ~p\",\n               [TransportId, Type, maps:keys(Config)]),\n \n+    % Store decision in coordination memory\n+    Decision = #{action => start_child, transport_id => TransportId, type => Type, \n+                 config_keys => maps:keys(Config), timestamp => erlang:timestamp()},\n+    store_supervisor_decision(Decision),\n+\n     try\n         % Validate transport type and get module\n         Module = transport_module(Type),\n \n-        % Validate configuration for the transport type\n+        % Enhanced validation with dependency checking\n         case validate_transport_config(Type, Config) of\n             ok ->\n-                proceed_with_start(TransportId, Type, Module, Config);\n+                case check_transport_dependencies(Type, Module) of\n+                    ok ->\n+                        proceed_with_start(TransportId, Type, Module, Config);\n+                    {error, DepError} ->\n+                        ?LOG_ERROR(\"Dependency check failed for transport ~p (~p): ~p\",\n+                                   [TransportId, Type, DepError]),\n+                        notify_coordination_hooks(start_failed, TransportId, DepError),\n+                        {error, {dependency_check_failed, DepError}}\n+                end;\n             {error, ValidationError} ->\n                 ?LOG_ERROR(\"Configuration validation failed for transport ~p (~p): ~p\",\n                            [TransportId, Type, ValidationError]),\n+                notify_coordination_hooks(validation_failed, TransportId, ValidationError),\n                 {error, {config_validation_failed, ValidationError}}\n         end\n     catch\n         error:({unknown_transport_type, _} = Error) ->\n             ?LOG_ERROR(\"Unknown transport type for ~p: ~p\", [TransportId, Type]),\n+            notify_coordination_hooks(type_error, TransportId, Error),\n             {error, Error};\n         error:StartupError:Stacktrace ->\n             ?LOG_ERROR(\"Exception starting transport ~p: ~p~n~p\",\n                        [TransportId, StartupError, Stacktrace]),\n+            notify_coordination_hooks(startup_exception, TransportId, StartupError),\n             {error, {startup_exception, StartupError}};\n         Class:ExceptionReason:Stacktrace ->\n             ?LOG_ERROR(\"Unexpected error starting transport ~p: ~p:~p~n~p\",\n                        [TransportId, Class, ExceptionReason, Stacktrace]),\n+            notify_coordination_hooks(unexpected_error, TransportId, {Class, ExceptionReason}),\n             {error, {unexpected_error, {Class, ExceptionReason}}}\n     end.\n \n %% Ensure supervisor is started before operations\n@@ -154,8 +175,16 @@\n \n             % Register with health monitoring system\n             register_transport_health_monitoring(TransportId, Pid, Type),\n \n+            % Notify coordination hooks of successful start\n+            notify_coordination_hooks(transport_started, TransportId, #{pid => Pid, type => Type}),\n+            \n+            % Store success decision in memory\n+            SuccessDecision = #{action => transport_started, transport_id => TransportId, \n+                               type => Type, pid => Pid, timestamp => erlang:timestamp()},\n+            store_supervisor_decision(SuccessDecision),\n+\n             Result;\n         {error, {already_started, Pid}} ->\n             ?LOG_WARNING(\"Transport ~p already started with PID ~p\", [TransportId, Pid]),\n             % Update our tracking even if it was already started\n@@ -163,25 +192,43 @@\n             {ok, Pid};\n         {error, Reason} = Error ->\n             ?LOG_ERROR(\"Failed to start transport ~p (~p): ~p\", [TransportId, Type, Reason]),\n \n+            % Notify coordination hooks of failure\n+            notify_coordination_hooks(transport_start_failed, TransportId, #{reason => Reason}),\n+\n+            % Store failure decision in memory\n+            FailureDecision = #{action => transport_start_failed, transport_id => TransportId, \n+                               type => Type, reason => Reason, timestamp => erlang:timestamp()},\n+            store_supervisor_decision(FailureDecision),\n+\n             % Record failure for analysis\n             increment_restart_count(TransportId),\n \n             % Attempt recovery if this is a known transport type failure\n             case should_attempt_recovery(Reason, TransportId) of\n                 true ->\n                     ?LOG_INFO(\"Attempting recovery for transport ~p\", [TransportId]),\n+                    notify_coordination_hooks(attempting_recovery, TransportId, #{reason => Reason}),\n                     attempt_transport_recovery(TransportId, Type, Module, Config);\n                 false ->\n+                    notify_coordination_hooks(recovery_abandoned, TransportId, #{reason => Reason}),\n                     Error\n             end\n     end.\n \n -spec stop_child(atom()) -> ok | {error, term()}.\n stop_child(TransportId) ->\n     ?LOG_INFO(\"Stopping transport child: ~p\", [TransportId]),\n \n+    % Store decision in coordination memory\n+    StopDecision = #{action => stop_child, transport_id => TransportId, \n+                     timestamp => erlang:timestamp()},\n+    store_supervisor_decision(StopDecision),\n+\n+    % Notify coordination hooks\n+    notify_coordination_hooks(stopping_transport, TransportId, #{}),\n+\n     % Unregister from health monitoring first\n     unregister_transport_health_monitoring(TransportId),\n \n     case supervisor:terminate_child(?MODULE, TransportId) of\n@@ -190,8 +237,16 @@\n                 ok ->\n                     % Clean up transport tracking\n                     ets:delete(?TRANSPORT_TABLE, TransportId),\n                     ?LOG_INFO(\"Successfully stopped and removed transport ~p\", [TransportId]),\n+                    \n+                    % Notify coordination hooks of successful stop\n+                    notify_coordination_hooks(transport_stopped, TransportId, #{}),\n+                    \n+                    % Store success in memory\n+                    SuccessDecision = #{action => transport_stopped, transport_id => TransportId, \n+                                       timestamp => erlang:timestamp()},\n+                    store_supervisor_decision(SuccessDecision),\n                     ok;\n                 {error, Reason} = Error ->\n                     ?LOG_ERROR(\"Failed to delete transport ~p: ~p\", [TransportId, Reason]),\n                     Error\n@@ -212,22 +267,27 @@\n         Children when is_list(Children) ->\n             case lists:keyfind(TransportId, 1, Children) of\n                 {TransportId, Pid, worker, _} when is_pid(Pid) ->\n                     case is_process_alive(Pid) of\n-                        true -> {ok, running};\n-                        false -> {ok, stopped}\n+                        true ->\n+                            {ok, running};\n+                        false ->\n+                            {ok, stopped}\n                     end;\n                 {TransportId, undefined, worker, _} ->\n                     {ok, stopped};\n                 false ->\n                     % Fall back to ETS tracking if supervisor has not reflected the child yet\n                     case ets:lookup(?TRANSPORT_TABLE, TransportId) of\n                         [#transport_info{pid = P}] when is_pid(P), P =/= undefined ->\n                             case is_process_alive(P) of\n-                                true -> {ok, running};\n-                                false -> {ok, stopped}\n+                                true ->\n+                                    {ok, running};\n+                                false ->\n+                                    {ok, stopped}\n                             end;\n-                        _ -> {error, not_found}\n+                        _ ->\n+                            {error, not_found}\n                     end\n             end;\n         Error ->\n             ?LOG_ERROR(\"Failed to get children list: ~p\", [Error]),\n@@ -496,20 +556,20 @@\n         Error ->\n             Error\n     end.\n \n-%% HTTP configuration validation\n+%% HTTP configuration validation (require url)\n -spec validate_http_config(map()) -> ok | {error, term()}.\n validate_http_config(Config) ->\n-    RequiredKeys = [port],\n+    RequiredKeys = [url],\n     case validate_required_keys(Config, RequiredKeys) of\n         ok ->\n             % Additional HTTP-specific validation\n-            case maps:get(port, Config) of\n-                Port when is_integer(Port), Port > 0, Port =< 65535 ->\n+            case maps:get(url, Config) of\n+                Url when is_list(Url); is_binary(Url) ->\n                     ok;\n-                InvalidPort ->\n-                    {error, {invalid_port, InvalidPort}}\n+                InvalidUrl ->\n+                    {error, {invalid_url, InvalidUrl}}\n             end;\n         Error ->\n             Error\n     end.\n"
                },
                {
                    "date": 1756190592732,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,10 @@\n \n -behaviour(supervisor).\n \n -export([start_link/0, start_child/3, stop_child/1, get_child_status/1,\n-         transport_module/1, get_all_transports/0, restart_transport/1, get_transport_info/1]).\n+         transport_module/1, get_all_transports/0, restart_transport/1, get_transport_info/1,\n+         discover_available_transports/0, get_transport_metrics/1, graceful_shutdown/1]).\n \n %% Internal functions exported for testing\n -ifdef(TEST).\n \n@@ -15,11 +16,9 @@\n -export([init/1]).\n \n -include_lib(\"kernel/include/logger.hrl\").\n \n-%% Import coordination functions\n--import(erlmcp_coordination, [store_supervisor_decision/1, notify_coordination_hooks/3, check_transport_dependencies/2]).\n--import(erlmcp, [validate_transport_health/2]).\n+%% Enhanced exports for coordination and monitoring\n \n %% Transport state tracking\n -record(transport_info,\n         {id :: atom(),\n@@ -57,10 +56,14 @@\n     ?LOG_INFO(\"Starting transport child: ~p type: ~p with config keys: ~p\",\n               [TransportId, Type, maps:keys(Config)]),\n \n     % Store decision in coordination memory\n-    Decision = #{action => start_child, transport_id => TransportId, type => Type, \n-                 config_keys => maps:keys(Config), timestamp => erlang:timestamp()},\n+    Decision =\n+        #{action => start_child,\n+          transport_id => TransportId,\n+          type => Type,\n+          config_keys => maps:keys(Config),\n+          timestamp => erlang:timestamp()},\n     store_supervisor_decision(Decision),\n \n     try\n         % Validate transport type and get module\n@@ -147,14 +150,27 @@\n                              {ok, pid()} | {error, term()}.\n start_new_transport(TransportId, Type, Module, Config) ->\n     StartTime = erlang:timestamp(),\n \n-    % Create enhanced child specification\n+    % Create enhanced child specification with adaptive restart strategy\n+    RestartCount = get_restart_count(TransportId),\n+    RestartStrategy = determine_restart_strategy(Type, TransportId, RestartCount),\n+    \n+    % Check circuit breaker before proceeding\n+    CircuitState = check_circuit_breaker(TransportId),\n+    case CircuitState of\n+        open ->\n+            ?LOG_WARNING(\"Circuit breaker OPEN for transport ~p, delaying start\", [TransportId]),\n+            timer:sleep(5000);  % Brief delay to prevent immediate restart storms\n+        _ ->\n+            ok\n+    end,\n+    \n     ChildSpec =\n         #{id => TransportId,\n           start => {Module, start_link, [TransportId, Config]},\n-          restart => permanent,  % Use permanent restart for better reliability\n-          shutdown => 15000,     % Enhanced: Extended shutdown timeout\n+          restart => RestartStrategy,  % Enhanced: Adaptive restart strategy\n+          shutdown => 15000,           % Enhanced: Extended shutdown timeout\n           type => worker,\n           modules => [Module]},\n \n     case supervisor:start_child(?MODULE, ChildSpec) of\n@@ -175,14 +191,21 @@\n \n             % Register with health monitoring system\n             register_transport_health_monitoring(TransportId, Pid, Type),\n \n+            % Reset circuit breaker on successful start\n+            update_circuit_breaker(TransportId, closed),\n+\n             % Notify coordination hooks of successful start\n             notify_coordination_hooks(transport_started, TransportId, #{pid => Pid, type => Type}),\n-            \n+\n             % Store success decision in memory\n-            SuccessDecision = #{action => transport_started, transport_id => TransportId, \n-                               type => Type, pid => Pid, timestamp => erlang:timestamp()},\n+            SuccessDecision =\n+                #{action => transport_started,\n+                  transport_id => TransportId,\n+                  type => Type,\n+                  pid => Pid,\n+                  timestamp => erlang:timestamp()},\n             store_supervisor_decision(SuccessDecision),\n \n             Result;\n         {error, {already_started, Pid}} ->\n@@ -192,38 +215,61 @@\n             {ok, Pid};\n         {error, Reason} = Error ->\n             ?LOG_ERROR(\"Failed to start transport ~p (~p): ~p\", [TransportId, Type, Reason]),\n \n+            % Record failure in circuit breaker\n+            record_transport_failure(TransportId),\n+\n             % Notify coordination hooks of failure\n             notify_coordination_hooks(transport_start_failed, TransportId, #{reason => Reason}),\n \n             % Store failure decision in memory\n-            FailureDecision = #{action => transport_start_failed, transport_id => TransportId, \n-                               type => Type, reason => Reason, timestamp => erlang:timestamp()},\n+            FailureDecision =\n+                #{action => transport_start_failed,\n+                  transport_id => TransportId,\n+                  type => Type,\n+                  reason => Reason,\n+                  circuit_state => check_circuit_breaker(TransportId),\n+                  restart_count => get_restart_count(TransportId),\n+                  timestamp => erlang:timestamp()},\n             store_supervisor_decision(FailureDecision),\n \n             % Record failure for analysis\n             increment_restart_count(TransportId),\n \n-            % Attempt recovery if this is a known transport type failure\n-            case should_attempt_recovery(Reason, TransportId) of\n-                true ->\n-                    ?LOG_INFO(\"Attempting recovery for transport ~p\", [TransportId]),\n-                    notify_coordination_hooks(attempting_recovery, TransportId, #{reason => Reason}),\n-                    attempt_transport_recovery(TransportId, Type, Module, Config);\n-                false ->\n-                    notify_coordination_hooks(recovery_abandoned, TransportId, #{reason => Reason}),\n-                    Error\n+            % Check circuit breaker state before recovery attempts\n+            case check_circuit_breaker(TransportId) of\n+                open ->\n+                    ?LOG_WARNING(\"Circuit breaker OPEN for transport ~p, skipping recovery\", [TransportId]),\n+                    notify_coordination_hooks(recovery_blocked_by_circuit_breaker, \n+                                              TransportId, #{reason => Reason}),\n+                    Error;\n+                _ ->\n+                    % Attempt recovery if this is a known transport type failure\n+                    case should_attempt_recovery(Reason, TransportId) of\n+                        true ->\n+                            ?LOG_INFO(\"Attempting recovery for transport ~p\", [TransportId]),\n+                            notify_coordination_hooks(attempting_recovery,\n+                                                      TransportId,\n+                                                      #{reason => Reason}),\n+                            attempt_transport_recovery(TransportId, Type, Module, Config);\n+                        false ->\n+                            notify_coordination_hooks(recovery_abandoned, \n+                                                    TransportId, #{reason => Reason}),\n+                            Error\n+                    end\n             end\n     end.\n \n -spec stop_child(atom()) -> ok | {error, term()}.\n stop_child(TransportId) ->\n     ?LOG_INFO(\"Stopping transport child: ~p\", [TransportId]),\n \n     % Store decision in coordination memory\n-    StopDecision = #{action => stop_child, transport_id => TransportId, \n-                     timestamp => erlang:timestamp()},\n+    StopDecision =\n+        #{action => stop_child,\n+          transport_id => TransportId,\n+          timestamp => erlang:timestamp()},\n     store_supervisor_decision(StopDecision),\n \n     % Notify coordination hooks\n     notify_coordination_hooks(stopping_transport, TransportId, #{}),\n@@ -237,15 +283,17 @@\n                 ok ->\n                     % Clean up transport tracking\n                     ets:delete(?TRANSPORT_TABLE, TransportId),\n                     ?LOG_INFO(\"Successfully stopped and removed transport ~p\", [TransportId]),\n-                    \n+\n                     % Notify coordination hooks of successful stop\n                     notify_coordination_hooks(transport_stopped, TransportId, #{}),\n-                    \n+\n                     % Store success in memory\n-                    SuccessDecision = #{action => transport_stopped, transport_id => TransportId, \n-                                       timestamp => erlang:timestamp()},\n+                    SuccessDecision =\n+                        #{action => transport_stopped,\n+                          transport_id => TransportId,\n+                          timestamp => erlang:timestamp()},\n                     store_supervisor_decision(SuccessDecision),\n                     ok;\n                 {error, Reason} = Error ->\n                     ?LOG_ERROR(\"Failed to delete transport ~p: ~p\", [TransportId, Reason]),\n@@ -425,9 +473,9 @@\n \n     % Enhanced supervisor flags for better reliability and resilience\n     SupFlags =\n         #{strategy => one_for_one,  % Transport failures are isolated\n-          intensity => 15,          % Enhanced: Higher restart intensity for reliability\n+          intensity => 20,          % Enhanced: Higher restart intensity for reliability\n           period => 60,             % Period in seconds for restart intensity\n           auto_shutdown => never},    % Enhanced: Never auto-shutdown supervisor\n \n     % Start with empty child specs - transports are added dynamically\n@@ -519,11 +567,161 @@\n             {error, not_found}\n     end.\n \n %%====================================================================\n-%% Enhanced Internal Functions\n+%% Enhanced Internal Functions with Advanced Error Recovery\n %%====================================================================\n \n+%% Circuit breaker pattern for transport health monitoring\n+-record(circuit_breaker,\n+        {transport_id :: atom(),\n+         state :: closed | open | half_open,\n+         failure_count = 0 :: non_neg_integer(),\n+         failure_threshold = 5 :: non_neg_integer(),\n+         recovery_timeout = 30000 :: pos_integer(),\n+         last_failure_time :: erlang:timestamp() | undefined}).\n+\n+%% Transport module resolution cache\n+-define(MODULE_CACHE_TABLE, erlmcp_transport_module_cache).\n+\n+%% Initialize module cache if not exists\n+-spec ensure_module_cache() -> ok.\n+ensure_module_cache() ->\n+    case ets:info(?MODULE_CACHE_TABLE) of\n+        undefined ->\n+            ets:new(?MODULE_CACHE_TABLE, [named_table, public, set]);\n+        _ ->\n+            ok\n+    end,\n+    ok.\n+\n+%% Enhanced transport module resolution with caching\n+-spec transport_module_cached(atom()) -> module().\n+transport_module_cached(Type) ->\n+    ensure_module_cache(),\n+    case ets:lookup(?MODULE_CACHE_TABLE, Type) of\n+        [{Type, Module, true}] ->\n+            Module;\n+        _ ->\n+            try\n+                Module = transport_module(Type),\n+                ets:insert(?MODULE_CACHE_TABLE, {Type, Module, true}),\n+                Module\n+            catch\n+                error:({unknown_transport_type, _} = Error) ->\n+                    ets:insert(?MODULE_CACHE_TABLE, {Type, undefined, false}),\n+                    error(Error)\n+            end\n+    end.\n+\n+%% Circuit breaker management for transport health\n+-spec check_circuit_breaker(atom()) -> closed | open | half_open.\n+check_circuit_breaker(TransportId) ->\n+    case ets:lookup(?TRANSPORT_TABLE, {circuit_breaker, TransportId}) of\n+        [{_, #circuit_breaker{state = State, \n+                             failure_count = Count,\n+                             failure_threshold = Threshold,\n+                             recovery_timeout = Timeout,\n+                             last_failure_time = LastFailure}}] ->\n+            case State of\n+                open when LastFailure =/= undefined ->\n+                    TimeSinceFailure = timer:now_diff(erlang:timestamp(), LastFailure) div 1000,\n+                    if TimeSinceFailure >= Timeout ->\n+                           update_circuit_breaker(TransportId, half_open),\n+                           half_open;\n+                       true ->\n+                           open\n+                    end;\n+                closed when Count >= Threshold ->\n+                    update_circuit_breaker(TransportId, open),\n+                    open;\n+                Other ->\n+                    Other\n+            end;\n+        [] ->\n+            init_circuit_breaker(TransportId),\n+            closed\n+    end.\n+\n+%% Initialize circuit breaker for transport\n+-spec init_circuit_breaker(atom()) -> ok.\n+init_circuit_breaker(TransportId) ->\n+    CircuitBreaker = #circuit_breaker{\n+        transport_id = TransportId,\n+        state = closed\n+    },\n+    ets:insert(?TRANSPORT_TABLE, {{circuit_breaker, TransportId}, CircuitBreaker}),\n+    ok.\n+\n+%% Update circuit breaker state\n+-spec update_circuit_breaker(atom(), closed | open | half_open) -> ok.\n+update_circuit_breaker(TransportId, NewState) ->\n+    case ets:lookup(?TRANSPORT_TABLE, {circuit_breaker, TransportId}) of\n+        [{_, CircuitBreaker}] ->\n+            UpdatedCB = case NewState of\n+                open ->\n+                    CircuitBreaker#circuit_breaker{\n+                        state = open,\n+                        last_failure_time = erlang:timestamp()\n+                    };\n+                closed ->\n+                    CircuitBreaker#circuit_breaker{\n+                        state = closed,\n+                        failure_count = 0\n+                    };\n+                half_open ->\n+                    CircuitBreaker#circuit_breaker{\n+                        state = half_open\n+                    }\n+            end,\n+            ets:insert(?TRANSPORT_TABLE, {{circuit_breaker, TransportId}, UpdatedCB});\n+        [] ->\n+            init_circuit_breaker(TransportId)\n+    end,\n+    ?LOG_DEBUG(\"Circuit breaker for transport ~p updated to state: ~p\", [TransportId, NewState]),\n+    ok.\n+\n+%% Record transport failure for circuit breaker\n+-spec record_transport_failure(atom()) -> ok.\n+record_transport_failure(TransportId) ->\n+    case ets:lookup(?TRANSPORT_TABLE, {circuit_breaker, TransportId}) of\n+        [{_, CircuitBreaker}] ->\n+            UpdatedCB = CircuitBreaker#circuit_breaker{\n+                failure_count = CircuitBreaker#circuit_breaker.failure_count + 1,\n+                last_failure_time = erlang:timestamp()\n+            },\n+            ets:insert(?TRANSPORT_TABLE, {{circuit_breaker, TransportId}, UpdatedCB}),\n+            ?LOG_WARNING(\"Transport ~p failure recorded, count: ~p\", \n+                        [TransportId, UpdatedCB#circuit_breaker.failure_count]);\n+        [] ->\n+            init_circuit_breaker(TransportId),\n+            record_transport_failure(TransportId)\n+    end,\n+    ok.\n+\n+%% Enhanced restart strategy based on transport type and history\n+-spec determine_restart_strategy(atom(), atom(), non_neg_integer()) -> permanent | temporary | transient.\n+determine_restart_strategy(Type, TransportId, RestartCount) ->\n+    CircuitState = check_circuit_breaker(TransportId),\n+    \n+    Strategy = case {Type, RestartCount, CircuitState} of\n+        {stdio, Count, _} when Count < 3 -> permanent;  % STDIO is critical, restart aggressively\n+        {stdio, _, open} -> temporary;                   % Circuit open, back off\n+        {stdio, _, _} -> transient;                      % Moderate restart for STDIO\n+        \n+        {tcp, Count, _} when Count < 5 -> permanent;     % TCP can handle more restarts\n+        {tcp, _, open} -> temporary;                     % Circuit open, back off\n+        {tcp, _, _} -> transient;                        % Standard TCP restart\n+        \n+        {http, Count, _} when Count < 2 -> transient;    % HTTP is less critical\n+        {http, _, open} -> temporary;                    % Circuit open, minimal restart\n+        {_, _, _} -> temporary                           % Conservative default\n+    end,\n+    \n+    ?LOG_DEBUG(\"Determined restart strategy for transport ~p (~p): ~p (restarts: ~p, circuit: ~p)\",\n+               [TransportId, Type, Strategy, RestartCount, CircuitState]),\n+    Strategy.\n+\n %% Validate transport configuration\n -spec validate_transport_config(atom(), map()) -> ok | {error, term()}.\n validate_transport_config(stdio, Config) ->\n     validate_stdio_config(Config);\n@@ -617,11 +815,23 @@\n     % Try to start again\n     case start_new_transport(TransportId, Type, Module, Config) of\n         {ok, Pid} = Result ->\n             ?LOG_INFO(\"Successfully recovered transport ~p with new PID ~p\", [TransportId, Pid]),\n+            notify_coordination_hooks(transport_recovered, TransportId, #{pid => Pid}),\n+            \n+            % Store recovery success in memory\n+            RecoveryDecision = #{action => transport_recovered, transport_id => TransportId, \n+                                type => Type, new_pid => Pid, timestamp => erlang:timestamp()},\n+            store_supervisor_decision(RecoveryDecision),\n             Result;\n         {error, Reason} = Error ->\n             ?LOG_ERROR(\"Recovery failed for transport ~p: ~p\", [TransportId, Reason]),\n+            notify_coordination_hooks(transport_recovery_failed, TransportId, #{reason => Reason}),\n+            \n+            % Store recovery failure in memory\n+            FailureDecision = #{action => transport_recovery_failed, transport_id => TransportId, \n+                               type => Type, reason => Reason, timestamp => erlang:timestamp()},\n+            store_supervisor_decision(FailureDecision),\n             Error\n     end.\n \n %% Get restart count for a transport\n@@ -656,4 +866,143 @@\n         [] ->\n             ?LOG_WARNING(\"Cannot update transport info for unknown transport ~p\", [TransportId])\n     end,\n     ok.\n+\n+%%====================================================================\n+%% Enhanced API Functions\n+%%====================================================================\n+\n+%% Discover available transport types\n+-spec discover_available_transports() -> [{atom(), module(), boolean()}].\n+discover_available_transports() ->\n+    TransportTypes = [stdio, tcp, http],\n+    [{Type, catch_transport_module(Type), is_transport_available(Type)} \n+     || Type <- TransportTypes].\n+\n+%% Safe transport module lookup\n+-spec catch_transport_module(atom()) -> module() | undefined.\n+catch_transport_module(Type) ->\n+    try\n+        transport_module(Type)\n+    catch\n+        error:{unknown_transport_type, _} ->\n+            undefined;\n+        _:_ ->\n+            undefined\n+    end.\n+\n+%% Check if transport module is available and functioning\n+-spec is_transport_available(atom()) -> boolean().\n+is_transport_available(Type) ->\n+    try\n+        Module = transport_module(Type),\n+        case code:ensure_loaded(Module) of\n+            {module, Module} ->\n+                % Check if module exports required functions\n+                case erlang:function_exported(Module, start_link, 2) of\n+                    true -> true;\n+                    false -> false\n+                end;\n+            _ ->\n+                false\n+        end\n+    catch\n+        _:_ -> false\n+    end.\n+\n+%% Get transport performance metrics\n+-spec get_transport_metrics(atom()) -> {ok, map()} | {error, not_found}.\n+get_transport_metrics(TransportId) ->\n+    case ets:lookup(?TRANSPORT_TABLE, TransportId) of\n+        [#transport_info{pid = Pid, start_time = StartTime}] when is_pid(Pid) ->\n+            try\n+                % Get basic process info\n+                ProcessInfo = case process_info(Pid, [memory, message_queue_len, reductions]) of\n+                    undefined -> #{};\n+                    Info -> maps:from_list(Info)\n+                end,\n+                \n+                % Calculate uptime\n+                UptimeSeconds = case StartTime of\n+                    undefined -> 0;\n+                    ST -> timer:now_diff(erlang:timestamp(), ST) div 1000000\n+                end,\n+                \n+                % Try to get transport-specific metrics\n+                TransportMetrics = case catch gen_server:call(Pid, {get_metrics}, 5000) of\n+                    {ok, Metrics} when is_map(Metrics) -> Metrics;\n+                    _ -> #{}\n+                end,\n+                \n+                AllMetrics = ProcessInfo#{uptime_seconds => UptimeSeconds,\n+                                         transport_metrics => TransportMetrics},\n+                {ok, AllMetrics}\n+            catch\n+                _:_ -> {error, metrics_unavailable}\n+            end;\n+        _ ->\n+            {error, not_found}\n+    end.\n+\n+%% Graceful shutdown of transport\n+-spec graceful_shutdown(atom()) -> ok | {error, term()}.\n+graceful_shutdown(TransportId) ->\n+    ?LOG_INFO(\"Initiating graceful shutdown for transport ~p\", [TransportId]),\n+    \n+    case ets:lookup(?TRANSPORT_TABLE, TransportId) of\n+        [#transport_info{pid = Pid, type = Type}] when is_pid(Pid) ->\n+            % Notify coordination hooks\n+            notify_coordination_hooks(graceful_shutdown_initiated, TransportId, #{type => Type}),\n+            \n+            % Store decision\n+            ShutdownDecision = #{action => graceful_shutdown_initiated, transport_id => TransportId, \n+                                type => Type, timestamp => erlang:timestamp()},\n+            store_supervisor_decision(ShutdownDecision),\n+            \n+            try\n+                % Try graceful shutdown first\n+                case catch gen_server:call(Pid, {prepare_shutdown}, 10000) of\n+                    ok ->\n+                        ?LOG_INFO(\"Transport ~p prepared for shutdown\", [TransportId]),\n+                        timer:sleep(1000), % Give it time to finish current operations\n+                        stop_child(TransportId);\n+                    {error, Reason} ->\n+                        ?LOG_WARNING(\"Transport ~p graceful shutdown preparation failed: ~p\", \n+                                    [TransportId, Reason]),\n+                        stop_child(TransportId);\n+                    _ ->\n+                        ?LOG_INFO(\"Transport ~p doesn't support graceful shutdown, proceeding with normal stop\", \n+                                 [TransportId]),\n+                        stop_child(TransportId)\n+                end\n+            catch\n+                _:_ ->\n+                    ?LOG_WARNING(\"Exception during graceful shutdown of ~p, proceeding with normal stop\", \n+                                [TransportId]),\n+                    stop_child(TransportId)\n+            end;\n+        _ ->\n+            {error, transport_not_found}\n+    end.\n+\n+%%====================================================================\n+%% Coordination and Memory Functions\n+%%====================================================================\n+\n+%% Store supervisor decision in coordination memory\n+-spec store_supervisor_decision(map()) -> ok.\n+store_supervisor_decision(Decision) ->\n+    try\n+        % Convert decision to storable format\n+        DecisionStr = io_lib:format(\"~p\", [Decision]),\n+        Key = io_lib:format(\"phase3/supervisor/~w/~p\", \n+                           [maps:get(transport_id, Decision, unknown),\n+                            maps:get(action, Decision, unknown_action)]),\n+        KeyStr = lists:flatten(Key),\n+        \n+        % Store in ETS as primary method\n+        case ets:info(?TRANSPORT_TABLE) of\n+            undefined -> \n+                % Table doesn't exist, just log\n+                ?LOG_DEBUG(\"Supervisor decision (no table): ~p\", [Decision]);\n+            _ ->\n"
                }
            ],
            "date": 1756189019417,
            "name": "Commit-0",
            "content": "-module(erlmcp_transport_sup).\n-behaviour(supervisor).\n\n-export([start_link/0, start_child/3, stop_child/1, get_child_status/1, \n         transport_module/1, get_all_transports/0, restart_transport/1,\n         get_transport_info/1]).\n%% Internal functions exported for testing\n-ifdef(TEST).\n-export([validate_transport_config/2]).\n-endif.\n-export([init/1]).\n\n-include_lib(\"kernel/include/logger.hrl\").\n\n%% Transport state tracking\n-record(transport_info, {\n    id :: atom(),\n    type :: atom(),\n    pid :: pid() | undefined,\n    module :: module(),\n    config :: map(),\n    start_time :: erlang:timestamp() | undefined,\n    restart_count = 0 :: non_neg_integer()\n}).\n\n%% ETS table for transport tracking\n-define(TRANSPORT_TABLE, erlmcp_transport_registry).\n\n%%====================================================================\n%% API Functions\n%%====================================================================\n\n-spec start_link() -> {ok, pid()} | {error, term()}.\nstart_link() ->\n    ?LOG_INFO(\"Starting transport supervisor with enhanced monitoring\"),\n    \n    % Create ETS table for transport tracking\n    case ets:info(?TRANSPORT_TABLE) of\n        undefined ->\n            ets:new(?TRANSPORT_TABLE, [named_table, public, set, {keypos, 2}]);\n        _ ->\n            ok\n    end,\n    \n    supervisor:start_link({local, ?MODULE}, ?MODULE, []).\n\n-spec start_child(atom(), atom(), map()) -> {ok, pid()} | {error, term()}.\nstart_child(TransportId, Type, Config) ->\n    ?LOG_INFO(\"Starting transport child: ~p type: ~p with config keys: ~p\", \n              [TransportId, Type, maps:keys(Config)]),\n    \n    try\n        % Validate transport type and get module\n        Module = transport_module(Type),\n        \n        % Validate configuration for the transport type\n        case validate_transport_config(Type, Config) of\n            ok ->\n                proceed_with_start(TransportId, Type, Module, Config);\n            {error, ValidationError} ->\n                ?LOG_ERROR(\"Configuration validation failed for transport ~p (~p): ~p\", \n                          [TransportId, Type, ValidationError]),\n                {error, {config_validation_failed, ValidationError}}\n        end\n    catch\n        error:{unknown_transport_type, _} = Error ->\n            ?LOG_ERROR(\"Unknown transport type for ~p: ~p\", [TransportId, Type]),\n            {error, Error};\n        error:StartupError:Stacktrace ->\n            ?LOG_ERROR(\"Exception starting transport ~p: ~p~n~p\", \n                      [TransportId, StartupError, Stacktrace]),\n            {error, {startup_exception, StartupError}};\n        Class:ExceptionReason:Stacktrace ->\n            ?LOG_ERROR(\"Unexpected error starting transport ~p: ~p:~p~n~p\", \n                      [TransportId, Class, ExceptionReason, Stacktrace]),\n            {error, {unexpected_error, {Class, ExceptionReason}}}\n    end.\n\n%% Enhanced start procedure with comprehensive error handling\n-spec proceed_with_start(atom(), atom(), module(), map()) -> {ok, pid()} | {error, term()}.\nproceed_with_start(TransportId, Type, Module, Config) ->\n    % Check if transport already exists\n    case get_child_status(TransportId) of\n        {ok, running} ->\n            ?LOG_WARNING(\"Transport ~p already running, returning existing PID\", [TransportId]),\n            case supervisor:which_children(?MODULE) of\n                Children when is_list(Children) ->\n                    case lists:keyfind(TransportId, 1, Children) of\n                        {TransportId, Pid, worker, _} when is_pid(Pid) ->\n                            {ok, Pid};\n                        _ ->\n                            {error, inconsistent_state}\n                    end;\n                Error ->\n                    {error, {supervisor_query_failed, Error}}\n            end;\n        _ ->\n            % Proceed with starting new transport\n            start_new_transport(TransportId, Type, Module, Config)\n    end.\n\n%% Start new transport with enhanced monitoring\n-spec start_new_transport(atom(), atom(), module(), map()) -> {ok, pid()} | {error, term()}.\nstart_new_transport(TransportId, Type, Module, Config) ->\n    StartTime = erlang:timestamp(),\n    \n    % Create enhanced child specification\n    ChildSpec = #{\n        id => TransportId,\n        start => {Module, start_link, [TransportId, Config]},\n        restart => permanent,  % Use permanent restart for better reliability\n        shutdown => 15000,     % Enhanced: Extended shutdown timeout\n        type => worker,\n        modules => [Module]\n    },\n    \n    case supervisor:start_child(?MODULE, ChildSpec) of\n        {ok, Pid} = Result ->\n            ?LOG_INFO(\"Successfully started transport ~p (~p) with PID ~p\", \n                     [TransportId, Type, Pid]),\n            \n            % Store transport information\n            TransportInfo = #transport_info{\n                id = TransportId,\n                type = Type,\n                pid = Pid,\n                module = Module,\n                config = Config,\n                start_time = StartTime,\n                restart_count = get_restart_count(TransportId)\n            },\n            ets:insert(?TRANSPORT_TABLE, TransportInfo),\n            \n            % Register with health monitoring system\n            register_transport_health_monitoring(TransportId, Pid, Type),\n            \n            Result;\n        {error, {already_started, Pid}} ->\n            ?LOG_WARNING(\"Transport ~p already started with PID ~p\", [TransportId, Pid]),\n            % Update our tracking even if it was already started\n            update_transport_info(TransportId, Pid),\n            {ok, Pid};\n        {error, Reason} = Error ->\n            ?LOG_ERROR(\"Failed to start transport ~p (~p): ~p\", [TransportId, Type, Reason]),\n            \n            % Record failure for analysis\n            increment_restart_count(TransportId),\n            \n            % Attempt recovery if this is a known transport type failure\n            case should_attempt_recovery(Reason, TransportId) of\n                true ->\n                    ?LOG_INFO(\"Attempting recovery for transport ~p\", [TransportId]),\n                    attempt_transport_recovery(TransportId, Type, Module, Config);\n                false ->\n                    Error\n            end\n    end.\n\n-spec stop_child(atom()) -> ok | {error, term()}.\nstop_child(TransportId) ->\n    ?LOG_INFO(\"Stopping transport child: ~p\", [TransportId]),\n    \n    % Unregister from health monitoring first\n    unregister_transport_health_monitoring(TransportId),\n    \n    case supervisor:terminate_child(?MODULE, TransportId) of\n        ok ->\n            case supervisor:delete_child(?MODULE, TransportId) of\n                ok ->\n                    % Clean up transport tracking\n                    ets:delete(?TRANSPORT_TABLE, TransportId),\n                    ?LOG_INFO(\"Successfully stopped and removed transport ~p\", [TransportId]),\n                    ok;\n                {error, Reason} = Error ->\n                    ?LOG_ERROR(\"Failed to delete transport ~p: ~p\", [TransportId, Reason]),\n                    Error\n            end;\n        {error, not_found} ->\n            % Transport was already stopped, clean up tracking\n            ets:delete(?TRANSPORT_TABLE, TransportId),\n            ?LOG_INFO(\"Transport ~p was already stopped, cleaned up tracking\", [TransportId]),\n            ok;\n        {error, Reason} = Error ->\n            ?LOG_ERROR(\"Failed to terminate transport ~p: ~p\", [TransportId, Reason]),\n            Error\n    end.\n\n-spec get_child_status(atom()) -> {ok, running | stopped} | {error, not_found}.\nget_child_status(TransportId) ->\n    case supervisor:which_children(?MODULE) of\n        Children when is_list(Children) ->\n            case lists:keyfind(TransportId, 1, Children) of\n                {TransportId, Pid, worker, _} when is_pid(Pid) ->\n                    case is_process_alive(Pid) of\n                        true -> {ok, running};\n                        false -> {ok, stopped}\n                    end;\n                {TransportId, undefined, worker, _} ->\n                    {ok, stopped};\n                false ->\n                    {error, not_found}\n            end;\n        Error ->\n            ?LOG_ERROR(\"Failed to get children list: ~p\", [Error]),\n            {error, supervisor_error}\n    end.\n\n%% Enhanced transport module resolution with validation and module checking\n-spec transport_module(atom()) -> module().\ntransport_module(stdio) -> \n    Module = erlmcp_transport_stdio_new,\n    ensure_module_loaded(Module);\ntransport_module(tcp) -> \n    Module = erlmcp_transport_tcp,\n    ensure_module_loaded(Module);\ntransport_module(http) -> \n    Module = erlmcp_transport_http,\n    ensure_module_loaded(Module);\ntransport_module(Type) ->\n    ?LOG_ERROR(\"Unknown transport type: ~p. Supported types: stdio, tcp, http\", [Type]),\n    error({unknown_transport_type, Type}).\n\n%% Ensure the transport module is loaded and available\n-spec ensure_module_loaded(module()) -> module().\nensure_module_loaded(Module) ->\n    case code:ensure_loaded(Module) of\n        {module, Module} ->\n            Module;\n        {error, Reason} ->\n            ?LOG_ERROR(\"Failed to load transport module ~p: ~p\", [Module, Reason]),\n            error({module_load_failed, Module, Reason})\n    end.\n\n%%====================================================================\n%% Internal Functions\n%%====================================================================\n\n%% Enhanced health monitoring integration\n-spec register_transport_health_monitoring(atom(), pid(), atom()) -> ok.\nregister_transport_health_monitoring(TransportId, Pid, Type) ->\n    % Create transport-specific health check function\n    HealthCheckFun = create_transport_health_check_function(Type, Pid),\n    \n    % Register with the health monitoring system\n    case erlmcp_health_monitor:register_component(TransportId, Pid, HealthCheckFun) of\n        ok ->\n            ?LOG_DEBUG(\"Registered transport ~p with health monitoring\", [TransportId]);\n        {error, Reason} ->\n            ?LOG_WARNING(\"Failed to register transport ~p with health monitor: ~p\", \n                        [TransportId, Reason])\n    end,\n    ok.\n\n%% Remove transport from health monitoring\n-spec unregister_transport_health_monitoring(atom()) -> ok.\nunregister_transport_health_monitoring(TransportId) ->\n    erlmcp_health_monitor:unregister_component(TransportId),\n    ?LOG_DEBUG(\"Unregistered transport ~p from health monitoring\", [TransportId]),\n    ok.\n\n%% Create transport-specific health check functions\n-spec create_transport_health_check_function(atom(), pid()) -> fun(() -> healthy | unhealthy | degraded).\ncreate_transport_health_check_function(Type, Pid) ->\n    fun() ->\n        try\n            case is_process_alive(Pid) of\n                false ->\n                    unhealthy;\n                true ->\n                    % Transport-specific health checks\n                    case Type of\n                        stdio ->\n                            check_stdio_transport_health(Pid);\n                        tcp ->\n                            check_tcp_transport_health(Pid);\n                        http ->\n                            check_http_transport_health(Pid);\n                        _ ->\n                            healthy % Default to healthy for unknown types\n                    end\n            end\n        catch\n            _:_ ->\n                unhealthy\n        end\n    end.\n\n%% Transport-specific health checks\n-spec check_stdio_transport_health(pid()) -> healthy | unhealthy | degraded.\ncheck_stdio_transport_health(Pid) ->\n    % Check if stdio transport can handle basic operations\n    case catch gen_server:call(Pid, {health_check}, 5000) of\n        {ok, healthy} -> healthy;\n        {ok, degraded} -> degraded;\n        _ -> unhealthy\n    end.\n\n-spec check_tcp_transport_health(pid()) -> healthy | unhealthy | degraded.\ncheck_tcp_transport_health(Pid) ->\n    % Check TCP connection status\n    case catch gen_server:call(Pid, {connection_status}, 5000) of\n        {ok, connected} -> healthy;\n        {ok, connecting} -> degraded;\n        _ -> unhealthy\n    end.\n\n-spec check_http_transport_health(pid()) -> healthy | unhealthy | degraded.\ncheck_http_transport_health(Pid) ->\n    % Check HTTP transport responsiveness\n    case catch gen_server:call(Pid, {server_status}, 5000) of\n        {ok, running} -> healthy;\n        {ok, degraded} -> degraded;\n        _ -> unhealthy\n    end.\n\n%%====================================================================\n%% supervisor callbacks\n%%====================================================================\n\n-spec init([]) -> {ok, {supervisor:sup_flags(), [supervisor:child_spec()]}}.\ninit([]) ->\n    ?LOG_INFO(\"Initializing transport supervisor\"),\n    \n    % Enhanced supervisor flags for better reliability and resilience\n    SupFlags = #{\n        strategy => one_for_one,  % Transport failures are isolated\n        intensity => 15,          % Enhanced: Higher restart intensity for reliability\n        period => 60,             % Period in seconds for restart intensity\n        auto_shutdown => never    % Enhanced: Never auto-shutdown supervisor\n    },\n    \n    % Start with empty child specs - transports are added dynamically\n    ChildSpecs = [],\n    \n    ?LOG_INFO(\"Transport supervisor initialized with enhanced configuration\"),\n    {ok, {SupFlags, ChildSpecs}}.\n\n%%====================================================================\n%% Additional API Functions\n%%====================================================================\n\n%% Get all active transports\n-spec get_all_transports() -> [{atom(), pid(), atom(), map()}].\nget_all_transports() ->\n    case ets:tab2list(?TRANSPORT_TABLE) of\n        TransportInfos when is_list(TransportInfos) ->\n            [{Info#transport_info.id, \n              Info#transport_info.pid, \n              Info#transport_info.type, \n              Info#transport_info.config} || Info <- TransportInfos];\n        _ ->\n            []\n    end.\n\n%% Restart a specific transport\n-spec restart_transport(atom()) -> {ok, pid()} | {error, term()}.\nrestart_transport(TransportId) ->\n    ?LOG_INFO(\"Restarting transport ~p\", [TransportId]),\n    case ets:lookup(?TRANSPORT_TABLE, TransportId) of\n        [#transport_info{type = Type, config = Config}] ->\n            case stop_child(TransportId) of\n                ok ->\n                    % Wait a bit for clean shutdown\n                    timer:sleep(1000),\n                    case start_child(TransportId, Type, Config) of\n                        {ok, NewPid} = Result ->\n                            ?LOG_INFO(\"Successfully restarted transport ~p with new PID ~p\", \n                                     [TransportId, NewPid]),\n                            Result;\n                        {error, Reason} = Error ->\n                            ?LOG_ERROR(\"Failed to restart transport ~p: ~p\", [TransportId, Reason]),\n                            Error\n                    end;\n                {error, Reason} = Error ->\n                    ?LOG_ERROR(\"Failed to stop transport ~p for restart: ~p\", [TransportId, Reason]),\n                    Error\n            end;\n        [] ->\n            {error, transport_not_found}\n    end.\n\n%% Get detailed transport information\n-spec get_transport_info(atom()) -> {ok, map()} | {error, not_found}.\nget_transport_info(TransportId) ->\n    case ets:lookup(?TRANSPORT_TABLE, TransportId) of\n        [#transport_info{} = Info] ->\n            % Get current health status\n            HealthStatus = case erlmcp_health_monitor:get_component_health(TransportId) of\n                not_found -> unknown;\n                Status -> Status\n            end,\n            \n            InfoMap = #{\n                id => Info#transport_info.id,\n                type => Info#transport_info.type,\n                pid => Info#transport_info.pid,\n                module => Info#transport_info.module,\n                config => Info#transport_info.config,\n                start_time => Info#transport_info.start_time,\n                restart_count => Info#transport_info.restart_count,\n                health_status => HealthStatus,\n                uptime_seconds => case Info#transport_info.start_time of\n                    undefined -> 0;\n                    StartTime -> timer:now_diff(erlang:timestamp(), StartTime) div 1000000\n                end\n            },\n            {ok, InfoMap};\n        [] ->\n            {error, not_found}\n    end.\n\n%%====================================================================\n%% Enhanced Internal Functions\n%%====================================================================\n\n%% Validate transport configuration\n-spec validate_transport_config(atom(), map()) -> ok | {error, term()}.\nvalidate_transport_config(stdio, Config) ->\n    validate_stdio_config(Config);\nvalidate_transport_config(tcp, Config) ->\n    validate_tcp_config(Config);\nvalidate_transport_config(http, Config) ->\n    validate_http_config(Config);\nvalidate_transport_config(Type, _Config) ->\n    {error, {unknown_transport_type, Type}}.\n\n%% STDIO configuration validation\n-spec validate_stdio_config(map()) -> ok | {error, term()}.\nvalidate_stdio_config(_Config) ->\n    % STDIO transport has minimal configuration requirements\n    ok.\n\n%% TCP configuration validation\n-spec validate_tcp_config(map()) -> ok | {error, term()}.\nvalidate_tcp_config(Config) ->\n    RequiredKeys = [host, port],\n    case validate_required_keys(Config, RequiredKeys) of\n        ok ->\n            % Additional TCP-specific validation\n            case maps:get(port, Config) of\n                Port when is_integer(Port), Port > 0, Port =< 65535 ->\n                    ok;\n                InvalidPort ->\n                    {error, {invalid_port, InvalidPort}}\n            end;\n        Error ->\n            Error\n    end.\n\n%% HTTP configuration validation\n-spec validate_http_config(map()) -> ok | {error, term()}.\nvalidate_http_config(Config) ->\n    RequiredKeys = [port],\n    case validate_required_keys(Config, RequiredKeys) of\n        ok ->\n            % Additional HTTP-specific validation\n            case maps:get(port, Config) of\n                Port when is_integer(Port), Port > 0, Port =< 65535 ->\n                    ok;\n                InvalidPort ->\n                    {error, {invalid_port, InvalidPort}}\n            end;\n        Error ->\n            Error\n    end.\n\n%% Validate required configuration keys\n-spec validate_required_keys(map(), [atom()]) -> ok | {error, term()}.\nvalidate_required_keys(Config, RequiredKeys) ->\n    MissingKeys = [Key || Key <- RequiredKeys, not maps:is_key(Key, Config)],\n    case MissingKeys of\n        [] ->\n            ok;\n        _ ->\n            {error, {missing_required_keys, MissingKeys}}\n    end.\n\n%% Recovery and restart management\n-spec should_attempt_recovery(term(), atom()) -> boolean().\nshould_attempt_recovery(Reason, TransportId) ->\n    % Check restart count to avoid infinite restart loops\n    RestartCount = get_restart_count(TransportId),\n    MaxRestarts = 5, % Maximum automatic restarts\n    \n    case {Reason, RestartCount < MaxRestarts} of\n        {{shutdown, _}, _} ->\n            false; % Don't recover from intentional shutdown\n        {normal, _} ->\n            false; % Don't recover from normal termination\n        {_, true} ->\n            true;  % Attempt recovery if under restart limit\n        {_, false} ->\n            ?LOG_ERROR(\"Transport ~p has exceeded maximum restart attempts (~p), giving up\", \n                      [TransportId, MaxRestarts]),\n            false\n    end.\n\n%% Attempt transport recovery\n-spec attempt_transport_recovery(atom(), atom(), module(), map()) -> {ok, pid()} | {error, term()}.\nattempt_transport_recovery(TransportId, Type, Module, Config) ->\n    ?LOG_INFO(\"Attempting recovery for transport ~p\", [TransportId]),\n    \n    % Wait a bit before retry\n    timer:sleep(2000),\n    \n    % Try to start again\n    case start_new_transport(TransportId, Type, Module, Config) of\n        {ok, Pid} = Result ->\n            ?LOG_INFO(\"Successfully recovered transport ~p with new PID ~p\", [TransportId, Pid]),\n            Result;\n        {error, Reason} = Error ->\n            ?LOG_ERROR(\"Recovery failed for transport ~p: ~p\", [TransportId, Reason]),\n            Error\n    end.\n\n%% Get restart count for a transport\n-spec get_restart_count(atom()) -> non_neg_integer().\nget_restart_count(TransportId) ->\n    case ets:lookup(?TRANSPORT_TABLE, TransportId) of\n        [#transport_info{restart_count = Count}] ->\n            Count;\n        [] ->\n            0\n    end.\n\n%% Increment restart count\n-spec increment_restart_count(atom()) -> ok.\nincrement_restart_count(TransportId) ->\n    case ets:lookup(?TRANSPORT_TABLE, TransportId) of\n        [#transport_info{} = Info] ->\n            UpdatedInfo = Info#transport_info{restart_count = Info#transport_info.restart_count + 1},\n            ets:insert(?TRANSPORT_TABLE, UpdatedInfo);\n        [] ->\n            ok\n    end.\n\n%% Update transport info with new PID\n-spec update_transport_info(atom(), pid()) -> ok.\nupdate_transport_info(TransportId, NewPid) ->\n    case ets:lookup(?TRANSPORT_TABLE, TransportId) of\n        [#transport_info{} = Info] ->\n            UpdatedInfo = Info#transport_info{\n                pid = NewPid,\n                start_time = erlang:timestamp()\n            },\n            ets:insert(?TRANSPORT_TABLE, UpdatedInfo);\n        [] ->\n            ?LOG_WARNING(\"Cannot update transport info for unknown transport ~p\", [TransportId])\n    end,\n    ok.\n"
        }
    ]
}