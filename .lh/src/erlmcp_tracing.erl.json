{
    "sourceFile": "src/erlmcp_tracing.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1756186304603,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1756186304603,
            "name": "Commit-0",
            "content": "-module(erlmcp_tracing).\n\n-export([\n    start_span/1, start_span/2, start_span/3,\n    end_span/1,\n    set_attributes/2,\n    record_exception/3, record_exception/4,\n    with_span/2, with_span/3, with_span/4,\n    set_status/2,\n    add_event/2, add_event/3,\n    current_span_ctx/0,\n    get_tracer/0,\n    % Convenience functions\n    start_transport_span/3,\n    start_server_span/2,\n    start_registry_span/1,\n    record_performance_metrics/2,\n    record_message_metrics/3,\n    record_error_details/3,\n    % Testing helpers\n    normalize_attr_key/1,\n    normalize_attr_value/1\n]).\n\n%% Opentelemetry header may be unavailable in minimal test env; keep include for when present\n-include_lib(\"opentelemetry_api/include/otel_tracer.hrl\").\n\n%% Default tracer name\n-define(TRACER_NAME, 'erlmcp.tracer').\n\n%% Common attribute keys\n-define(TRANSPORT_ID, <<\"transport.id\">>).\n-define(TRANSPORT_TYPE, <<\"transport.type\">>).\n-define(SERVER_ID, <<\"server.id\">>).\n-define(MESSAGE_SIZE, <<\"message.size\">>).\n-define(REQUEST_ID, <<\"request.id\">>).\n-define(METHOD, <<\"method\">>).\n-define(RESOURCE_URI, <<\"resource.uri\">>).\n-define(TOOL_NAME, <<\"tool.name\">>).\n-define(ERROR_TYPE, <<\"error.type\">>).\n-define(ERROR_MESSAGE, <<\"error.message\">>).\n-define(OPERATION, <<\"operation\">>).\n-define(COMPONENT, <<\"component\">>).\n\n%% Performance metrics\n-define(LATENCY_MS, <<\"latency.ms\">>).\n-define(THROUGHPUT_OPS, <<\"throughput.ops_per_sec\">>).\n-define(BUFFER_SIZE, <<\"buffer.size\">>).\n-define(QUEUE_LENGTH, <<\"queue.length\">>).\n-define(CONNECTION_COUNT, <<\"connection.count\">>).\n-define(RETRY_COUNT, <<\"retry.count\">>).\n-define(MEMORY_USAGE, <<\"memory.usage_bytes\">>).\n\n%%====================================================================\n%% Public API\n%%====================================================================\n\n%% Start a span with just a name\n-spec start_span(binary()) -> term().\nstart_span(Name) ->\n    start_span(Name, #{}).\n\n%% Start a span with name and attributes\n-spec start_span(binary(), map()) -> term().\nstart_span(Name, Attributes) ->\n    start_span(Name, Attributes, #{}).\n\n%% Start a span with name, attributes, and options\n-spec start_span(binary(), map(), map()) -> term().\nstart_span(Name, Attributes, Options) ->\n    case otel_available() of\n        true ->\n            Tracer = get_tracer(),\n            SpanCtx = otel_tracer:start_span(Tracer, Name, Options),\n            set_attributes(SpanCtx, Attributes),\n            SpanCtx;\n        false -> undefined\n    end.\n\n%% End a span\n-spec end_span(term()) -> ok.\nend_span(SpanCtx) ->\n    case otel_available() of\n        true -> otel_span:end_span(SpanCtx);\n        false -> ok\n    end,\n    ok.\n\n%% Set multiple attributes on a span\n-spec set_attributes(term(), map()) -> ok.\nset_attributes(_SpanCtx, Attrs) when map_size(Attrs) =:= 0 ->\n    ok;\nset_attributes(SpanCtx, Attributes) ->\n    case otel_available() of\n        true ->\n            AttrList = maps:fold(fun(K, V, Acc) ->\n                [{normalize_attr_key(K), normalize_attr_value(V)} | Acc]\n            end, [], Attributes),\n            otel_span:set_attributes(SpanCtx, AttrList);\n        false -> ok\n    end,\n    ok.\n\n%% Record an exception with class and reason\n-spec record_exception(term(), atom(), term()) -> ok.\nrecord_exception(SpanCtx, Class, Reason) ->\n    record_exception(SpanCtx, Class, Reason, []).\n\n%% Record an exception with class, reason, and stacktrace\n-spec record_exception(term(), atom(), term(), list()) -> ok.\nrecord_exception(SpanCtx, Class, Reason, Stacktrace) ->\n    case otel_available() of\n        true ->\n            otel_span:record_exception(SpanCtx, Class, Reason, Stacktrace),\n            otel_span:set_status(SpanCtx, {error, format_error(Class, Reason)});\n        false -> ok\n    end,\n    ok.\n\n%% Execute a function within a span context\n-spec with_span(binary(), fun(() -> Result)) -> Result.\nwith_span(Name, Fun) ->\n    with_span(Name, #{}, Fun).\n\n%% Execute a function within a span context with attributes\n-spec with_span(binary(), map(), fun(() -> Result)) -> Result.\nwith_span(Name, Attributes, Fun) ->\n    with_span(Name, Attributes, #{}, Fun).\n\n%% Execute a function within a span context with attributes and options\n-spec with_span(binary(), map(), map(), fun(() -> Result)) -> Result.\nwith_span(Name, Attributes, Options, Fun) ->\n    case otel_available() of\n        true ->\n            SpanCtx = start_span(Name, Attributes, Options),\n            try\n                Result = Fun(),\n                set_status(SpanCtx, ok),\n                Result\n            catch\n                Class:Reason:Stacktrace ->\n                    record_exception(SpanCtx, Class, Reason, Stacktrace),\n                    erlang:raise(Class, Reason, Stacktrace)\n            after\n                end_span(SpanCtx)\n            end;\n        false -> Fun()\n    end.\n\n%% Set span status\n-spec set_status(term(), ok | {error, term()}) -> ok.\nset_status(SpanCtx, ok) ->\n    case otel_available() of\n        true -> otel_span:set_status(SpanCtx, opentelemetry:status(ok));\n        false -> ok\n    end,\n    ok;\nset_status(SpanCtx, {error, Reason}) ->\n    case otel_available() of\n        true -> otel_span:set_status(SpanCtx, opentelemetry:status(error, format_error(error, Reason)));\n        false -> ok\n    end,\n    ok.\n\n%% Add an event to the span\n-spec add_event(term(), binary()) -> ok.\nadd_event(SpanCtx, Name) ->\n    add_event(SpanCtx, Name, #{}).\n\n%% Add an event with attributes to the span\n-spec add_event(term(), binary(), map()) -> ok.\nadd_event(SpanCtx, Name, Attributes) ->\n    case otel_available() of\n        true ->\n            AttrList = maps:fold(fun(K, V, Acc) ->\n                [{normalize_attr_key(K), normalize_attr_value(V)} | Acc]\n            end, [], Attributes),\n            otel_span:add_event(SpanCtx, Name, AttrList);\n        false -> ok\n    end,\n    ok.\n\n%% Get current span context\n-spec current_span_ctx() -> term() | undefined.\ncurrent_span_ctx() ->\n    case otel_available() of\n        true -> otel_tracer:current_span_ctx();\n        false -> undefined\n    end.\n\n%% Get the configured tracer\n-spec get_tracer() -> term().\nget_tracer() ->\n    case otel_available() of\n        true -> otel_tracer:get_tracer(?TRACER_NAME);\n        false -> undefined\n    end.\n\n%%====================================================================\n%% Convenience Functions for Transport Operations\n%%====================================================================\n\n%% Start transport operation span\n-spec start_transport_span(binary(), atom(), atom()) -> term().\nstart_transport_span(Operation, TransportId, TransportType) ->\n    start_span(Operation, #{\n        ?COMPONENT => <<\"transport\">>,\n        ?TRANSPORT_ID => TransportId,\n        ?TRANSPORT_TYPE => TransportType,\n        ?OPERATION => Operation\n    }).\n\n%% Start server operation span  \n-spec start_server_span(binary(), atom()) -> term().\nstart_server_span(Operation, ServerId) ->\n    start_span(Operation, #{\n        ?COMPONENT => <<\"server\">>,\n        ?SERVER_ID => ServerId,\n        ?OPERATION => Operation\n    }).\n\n%% Start registry operation span\n-spec start_registry_span(binary()) -> term().\nstart_registry_span(Operation) ->\n    start_span(Operation, #{\n        ?COMPONENT => <<\"registry\">>,\n        ?OPERATION => Operation\n    }).\n\n%% Record performance metrics\n-spec record_performance_metrics(term(), map()) -> ok.\nrecord_performance_metrics(SpanCtx, Metrics) ->\n    PerfAttrs = maps:fold(fun\n        (latency, Value, Acc) when is_number(Value) ->\n            Acc#{?LATENCY_MS => Value};\n        (throughput, Value, Acc) when is_number(Value) ->\n            Acc#{?THROUGHPUT_OPS => Value};\n        (buffer_size, Value, Acc) when is_integer(Value) ->\n            Acc#{?BUFFER_SIZE => Value};\n        (queue_length, Value, Acc) when is_integer(Value) ->\n            Acc#{?QUEUE_LENGTH => Value};\n        (connection_count, Value, Acc) when is_integer(Value) ->\n            Acc#{?CONNECTION_COUNT => Value};\n        (retry_count, Value, Acc) when is_integer(Value) ->\n            Acc#{?RETRY_COUNT => Value};\n        (memory_usage, Value, Acc) when is_integer(Value) ->\n            Acc#{?MEMORY_USAGE => Value};\n        (_, _, Acc) ->\n            Acc\n    end, #{}, Metrics),\n    set_attributes(SpanCtx, PerfAttrs).\n\n%% Record message processing metrics\n-spec record_message_metrics(term(), binary(), integer()) -> ok.\nrecord_message_metrics(SpanCtx, Method, Size) ->\n    set_attributes(SpanCtx, #{\n        ?METHOD => Method,\n        ?MESSAGE_SIZE => Size\n    }).\n\n%% Record error details\n-spec record_error_details(term(), atom(), term()) -> ok.\n\n%% Check if otel modules are available at runtime\notel_available() ->\n    case code:which(otel_tracer) of\n        non_existing -> false;\n        _ -> true\n    end.\nrecord_error_details(SpanCtx, Type, Message) ->\n    set_attributes(SpanCtx, #{\n        ?ERROR_TYPE => Type,\n        ?ERROR_MESSAGE => format_error(Type, Message)\n    }).\n\n%%====================================================================\n%% Internal Functions\n%%====================================================================\n\n%% Normalize attribute key to binary\n-spec normalize_attr_key(term()) -> binary().\nnormalize_attr_key(Key) when is_binary(Key) -> Key;\nnormalize_attr_key(Key) when is_atom(Key) -> atom_to_binary(Key, utf8);\nnormalize_attr_key(Key) when is_list(Key) -> list_to_binary(Key);\nnormalize_attr_key(Key) -> iolist_to_binary(io_lib:format(\"~p\", [Key])).\n\n%% Normalize attribute value\n-spec normalize_attr_value(term()) -> term().\nnormalize_attr_value(Value) when is_binary(Value) -> Value;\nnormalize_attr_value(Value) when is_atom(Value) -> atom_to_binary(Value, utf8);\nnormalize_attr_value(Value) when is_list(Value) -> list_to_binary(Value);\nnormalize_attr_value(Value) when is_integer(Value) -> Value;\nnormalize_attr_value(Value) when is_float(Value) -> Value;\nnormalize_attr_value(Value) when is_boolean(Value) -> Value;\nnormalize_attr_value(Value) -> iolist_to_binary(io_lib:format(\"~p\", [Value])).\n\n%% Format error for consistent error reporting\n-spec format_error(atom(), term()) -> binary().\nformat_error(Class, Reason) ->\n    iolist_to_binary(io_lib:format(\"~p:~p\", [Class, Reason]))."
        }
    ]
}