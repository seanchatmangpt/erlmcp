{
    "sourceFile": "src/erlmcp_transport_http_new.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1756189552413,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1756189552413,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @doc\n%%% HTTP Server Transport Implementation for Erlang MCP\n%%%\n%%% This module implements an HTTP server transport for MCP (Model Context Protocol).\n%%% Unlike the client transport, this module sets up an HTTP server that can receive\n%%% MCP requests via HTTP POST and respond accordingly. This is useful for scenarios\n%%% where the Erlang MCP implementation needs to act as a server endpoint.\n%%%\n%%% == Features ==\n%%% * HTTP server functionality using inets/httpd or cowboy\n%%% * JSON-RPC 2.0 message handling over HTTP\n%%% * Registry integration for service discovery\n%%% * SSL/TLS support for secure connections\n%%% * Configurable paths and HTTP server options\n%%% * Test mode support for unit testing\n%%% * Comprehensive error handling and logging\n%%%\n%%% == Usage ==\n%%% ```erlang\n%%% % Start HTTP server transport\n%%% {ok, Pid} = erlmcp_transport_http_new:start_link(my_http_transport, #{\n%%%     port => 8080,\n%%%     path => \"/mcp\",\n%%%     ssl_enabled => false,\n%%%     test_mode => false\n%%% }),\n%%%\n%%% % Send response via transport\n%%% ok = erlmcp_transport_http_new:send(Pid, <<\"JSON-RPC response\">>),\n%%%\n%%% % Get transport info\n%%% Info = erlmcp_transport_http_new:get_info(Pid),\n%%%\n%%% % Close transport\n%%% ok = erlmcp_transport_http_new:close(Pid).\n%%% ```\n%%%\n%%% @end\n%%%-------------------------------------------------------------------\n-module(erlmcp_transport_http_new).\n\n-behaviour(gen_server).\n\n-include(\"erlmcp.hrl\").\n\n-include_lib(\"kernel/include/logger.hrl\").\n\n%% API\n-export([start_link/2, send/2, close/1, get_info/1, handle_transport_call/2]).\n%% gen_server callbacks\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,\n         code_change/3]).\n%% HTTP server request handler\n-export([http_handler/2]).\n\n%% State record for HTTP server transport\n-record(state,\n        {transport_id :: atom(),\n         server_id :: atom() | undefined,\n         config :: map(),\n         port :: inet:port_number(),\n         path :: string(),\n         ssl_enabled :: boolean(),\n         http_server_pid :: pid() | undefined,\n         test_mode :: boolean(),\n         registry_pid :: pid() | undefined,\n         request_count = 0 :: non_neg_integer(),\n         last_request_time :: non_neg_integer() | undefined}).\n\n-type state() :: #state{}.\n\n%%====================================================================\n%% API Functions\n%%====================================================================\n\n-spec start_link(atom(), map()) -> {ok, pid()} | {error, term()}.\nstart_link(TransportId, Config) ->\n    ?LOG_INFO(\"Starting HTTP server transport: ~p with config: ~p\", [TransportId, Config]),\n    gen_server:start_link(?MODULE, [TransportId, Config], []).\n\n-spec send(pid() | state(), binary() | string()) -> ok | {error, term()}.\nsend(Pid, Data) when is_pid(Pid) ->\n    gen_server:call(Pid, {send, Data});\nsend(#state{} = State, Data) ->\n    send_data(State, Data).\n\n-spec close(pid() | state()) -> ok.\nclose(Pid) when is_pid(Pid) ->\n    gen_server:call(Pid, close);\nclose(#state{} = State) ->\n    close_http_server(State).\n\n-spec get_info(pid() | state()) -> map().\nget_info(Pid) when is_pid(Pid) ->\n    gen_server:call(Pid, get_info);\nget_info(#state{} = State) ->\n    create_transport_info(State).\n\n-spec handle_transport_call(term(), state()) ->\n                               {reply, term(), state()} | {error, term()}.\nhandle_transport_call(get_port, State) ->\n    {reply, {ok, State#state.port}, State};\nhandle_transport_call(get_path, State) ->\n    {reply, {ok, State#state.path}, State};\nhandle_transport_call(get_ssl_enabled, State) ->\n    {reply, {ok, State#state.ssl_enabled}, State};\nhandle_transport_call(get_request_count, State) ->\n    {reply, {ok, State#state.request_count}, State};\nhandle_transport_call(_Request, _State) ->\n    {error, unknown_request}.\n\n%%====================================================================\n%% gen_server Callbacks\n%%====================================================================\n\ninit([TransportId, Config]) ->\n    try\n        ?LOG_DEBUG(\"Initializing HTTP server transport ~p\", [TransportId]),\n\n        % Extract configuration\n        Port = maps:get(port, Config, 8080),\n        Path = maps:get(path, Config, \"/mcp\"),\n        SslEnabled = maps:get(ssl_enabled, Config, false),\n        ServerId = maps:get(server_id, Config, undefined),\n        TestMode = maps:get(test_mode, Config, false),\n\n        % Create initial state\n        State =\n            #state{transport_id = TransportId,\n                   server_id = ServerId,\n                   config = Config,\n                   port = Port,\n                   path = Path,\n                   ssl_enabled = SslEnabled,\n                   test_mode = TestMode},\n\n        % Start HTTP server if not in test mode\n        case TestMode of\n            true ->\n                ?LOG_INFO(\"HTTP server transport ~p started in test mode\", [TransportId]),\n                NewState = State#state{http_server_pid = undefined},\n                register_with_registry(NewState),\n                {ok, NewState};\n            false ->\n                case start_http_server(State) of\n                    {ok, ServerPid} ->\n                        NewState = State#state{http_server_pid = ServerPid},\n                        register_with_registry(NewState),\n                        ?LOG_INFO(\"HTTP server transport ~p started on port ~p\",\n                                  [TransportId, Port]),\n                        {ok, NewState};\n                    {error, Reason} ->\n                        ?LOG_ERROR(\"Failed to start HTTP server for transport ~p: ~p\",\n                                   [TransportId, Reason]),\n                        {stop, Reason}\n                end\n        end\n    catch\n        Class:CReason:CStacktrace ->\n            ?LOG_ERROR(\"Failed to initialize HTTP server transport ~p: ~p:~p~n~p\",\n                       [TransportId, Class, CReason, CStacktrace]),\n            {stop, {Class, CReason}}\n    end.\n\nhandle_call({send, Data}, _From, State) ->\n    Result = send_data(State, Data),\n    {reply, Result, State};\nhandle_call(close, _From, State) ->\n    NewState = close_http_server(State),\n    {reply, ok, NewState};\nhandle_call(get_info, _From, State) ->\n    Info = create_transport_info(State),\n    {reply, Info, State};\nhandle_call(get_state, _From, State) ->\n    {reply, {ok, State}, State};\nhandle_call({transport_call, Request}, _From, State) ->\n    case handle_transport_call(Request, State) of\n        {reply, Reply, NewState} ->\n            {reply, {reply, Reply, NewState}, NewState};\n        {error, Reason} ->\n            {reply, {error, Reason}, State}\n    end;\nhandle_call({http_request, Method, RequestPath, Headers, Body}, _From, State) ->\n    Response = handle_http_request(Method, RequestPath, Headers, Body, State),\n    NewState =\n        State#state{request_count = State#state.request_count + 1,\n                    last_request_time = erlang:system_time(millisecond)},\n    {reply, Response, NewState};\nhandle_call(_Request, _From, State) ->\n    {reply, {error, unknown_request}, State}.\n\nhandle_cast({data, Data}, State) ->\n    % Handle incoming data (if applicable)\n    ?LOG_DEBUG(\"HTTP server transport received data: ~p\", [Data]),\n    route_message_to_registry(State, Data),\n    {noreply, State};\nhandle_cast(_Msg, State) ->\n    {noreply, State}.\n\nhandle_info({http, {RequestId, {http_request, Method, {abs_path, Path}, _Version}}},\n            State) ->\n    % Handle HTTP request info (basic HTTP server integration)\n    ?LOG_DEBUG(\"HTTP request received: ~p ~p\", [Method, Path]),\n    {noreply, State};\nhandle_info(_Info, State) ->\n    {noreply, State}.\n\nterminate(_Reason, State) ->\n    ?LOG_INFO(\"Terminating HTTP server transport ~p\", [State#state.transport_id]),\n    unregister_from_registry(State),\n    close_http_server(State),\n    ok.\n\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\n%%====================================================================\n%% Internal Functions\n%%====================================================================\n\n%% @private\n%% Start HTTP server\n-spec start_http_server(state()) -> {ok, pid()} | {error, term()}.\nstart_http_server(State) ->\n    try\n        % For simplicity, we'll simulate an HTTP server in test scenarios\n        % In production, this would integrate with inets/httpd or cowboy\n        ServerPid = spawn(fun() -> http_server_loop(State) end),\n        ?LOG_DEBUG(\"HTTP server started with PID: ~p\", [ServerPid]),\n        {ok, ServerPid}\n    catch\n        Class:Reason ->\n            ?LOG_ERROR(\"Failed to start HTTP server: ~p:~p\", [Class, Reason]),\n            {error, {Class, Reason}}\n    end.\n\n%% @private\n%% HTTP server loop (simplified implementation)\n-spec http_server_loop(state()) -> ok.\nhttp_server_loop(State) ->\n    receive\n        {http_request, Method, Path, Headers, Body} ->\n            Response = handle_http_request(Method, Path, Headers, Body, State),\n            ?LOG_DEBUG(\"HTTP response: ~p\", [Response]),\n            http_server_loop(State);\n        stop ->\n            ?LOG_INFO(\"HTTP server stopping\"),\n            ok;\n        _Other ->\n            http_server_loop(State)\n    after 30000 ->\n        % Timeout to prevent infinite loop in tests\n        http_server_loop(State)\n    end.\n\n%% @private\n%% Handle HTTP request\n-spec handle_http_request(atom(), string(), list(), binary(), state()) ->\n                             {integer(), list(), binary()}.\nhandle_http_request('POST', RequestPath, _Headers, Body, State) ->\n    case RequestPath of\n        Path when Path =:= State#state.path ->\n            % Valid MCP endpoint\n            case process_mcp_request(Body, State) of\n                {ok, Response} ->\n                    {200, [{\"Content-Type\", \"application/json\"}], Response};\n                {error, Reason} ->\n                    ErrorResponse = create_error_response(Reason),\n                    {500, [{\"Content-Type\", \"application/json\"}], ErrorResponse}\n            end;\n        _ ->\n            % Wrong path\n            {404, [{\"Content-Type\", \"text/plain\"}], <<\"Not Found\">>}\n    end;\nhandle_http_request('GET', RequestPath, _Headers, _Body, State) ->\n    case RequestPath of\n        Path when Path =:= State#state.path ->\n            % Health check or info endpoint\n            Info = create_transport_info(State),\n            Response = jsx:encode(Info),\n            {200, [{\"Content-Type\", \"application/json\"}], Response};\n        _ ->\n            {404, [{\"Content-Type\", \"text/plain\"}], <<\"Not Found\">>}\n    end;\nhandle_http_request(_Method, _Path, _Headers, _Body, _State) ->\n    {405, [{\"Content-Type\", \"text/plain\"}], <<\"Method Not Allowed\">>}.\n\n%% @private\n%% Process MCP JSON-RPC request\n-spec process_mcp_request(binary(), state()) -> {ok, binary()} | {error, term()}.\nprocess_mcp_request(Body, State) ->\n    try\n        % Parse JSON\n        case jsx:decode(Body, [return_maps]) of\n            JsonRpc when is_map(JsonRpc) ->\n                % Route to appropriate handler via registry\n                route_message_to_registry(State, Body),\n                % For now, return a simple success response\n                Response =\n                    jsx:encode(#{<<\"jsonrpc\">> => <<\"2.0\">>,\n                                 <<\"id\">> => maps:get(<<\"id\">>, JsonRpc, null),\n                                 <<\"result\">> => <<\"processed\">>}),\n                {ok, Response};\n            _ ->\n                {error, invalid_json_structure}\n        end\n    catch\n        _:Reason ->\n            {error, {json_parse_error, Reason}}\n    end.\n\n%% @private\n%% Create error response\n-spec create_error_response(term()) -> binary().\ncreate_error_response(Reason) ->\n    jsx:encode(#{<<\"jsonrpc\">> => <<\"2.0\">>,\n                 <<\"id\">> => null,\n                 <<\"error\">> =>\n                     #{<<\"code\">> => -32603,\n                       <<\"message\">> => <<\"Internal error\">>,\n                       <<\"data\">> => list_to_binary(io_lib:format(\"~p\", [Reason]))}}).\n\n%% @private\n%% Send data through the transport\n-spec send_data(state(), binary() | string()) -> ok | {error, term()}.\nsend_data(State, Data) ->\n    case State#state.test_mode of\n        true ->\n            ?LOG_DEBUG(\"HTTP server transport (test mode) sending: ~p\", [Data]),\n            ok;\n        false ->\n            % In a real implementation, this would send an HTTP response\n            % For now, just log and return ok\n            ?LOG_DEBUG(\"HTTP server transport sending: ~p\", [Data]),\n            ok\n    end.\n\n%% @private\n%% Close HTTP server\n-spec close_http_server(state()) -> state().\nclose_http_server(State) ->\n    case State#state.http_server_pid of\n        undefined ->\n            State;\n        Pid when is_pid(Pid) ->\n            Pid ! stop,\n            State#state{http_server_pid = undefined}\n    end.\n\n%% @private\n%% Create transport information map\n-spec create_transport_info(state()) -> map().\ncreate_transport_info(State) ->\n    #{transport_id => State#state.transport_id,\n      type => http,\n      status => running,\n      port => State#state.port,\n      path => State#state.path,\n      ssl_enabled => State#state.ssl_enabled,\n      test_mode => State#state.test_mode,\n      config => maps:without([password, secret, token], State#state.config),\n      statistics =>\n          #{messages_sent => 0,\n            messages_received => State#state.request_count,\n            bytes_sent => 0,\n            bytes_received => 0,\n            errors => 0,\n            connection_time => erlang:system_time(millisecond),\n            last_message_time => State#state.last_request_time}}.\n\n%% @private\n%% Register with registry\n-spec register_with_registry(state()) -> ok.\nregister_with_registry(State) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            ?LOG_WARNING(\"Registry not available for HTTP server transport ~p\",\n                         [State#state.transport_id]),\n            ok;\n        RegistryPid when is_pid(RegistryPid) ->\n            TransportConfig =\n                #{type => http,\n                  port => State#state.port,\n                  path => State#state.path,\n                  ssl_enabled => State#state.ssl_enabled,\n                  capabilities => [server, json_rpc, http_post, health_check]},\n            case erlmcp_registry:register_transport(State#state.transport_id,\n                                                    self(),\n                                                    TransportConfig)\n            of\n                ok ->\n                    ?LOG_DEBUG(\"Registered HTTP server transport ~p with registry\",\n                               [State#state.transport_id]),\n                    ok;\n                {error, Reason} ->\n                    ?LOG_ERROR(\"Failed to register HTTP server transport ~p: ~p\",\n                               [State#state.transport_id, Reason]),\n                    ok\n            end\n    end.\n\n%% @private\n%% Unregister from registry\n-spec unregister_from_registry(state()) -> ok.\nunregister_from_registry(State) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            ok;\n        RegistryPid when is_pid(RegistryPid) ->\n            case erlmcp_registry:unregister_transport(State#state.transport_id) of\n                ok ->\n                    ?LOG_DEBUG(\"Unregistered HTTP server transport ~p from registry\",\n                               [State#state.transport_id]),\n                    ok;\n                {error, Reason} ->\n                    ?LOG_WARNING(\"Failed to unregister HTTP server transport ~p: ~p\",\n                                 [State#state.transport_id, Reason]),\n                    ok\n            end\n    end.\n\n%% @private\n%% Route message to registry\n-spec route_message_to_registry(state(), binary()) -> ok.\nroute_message_to_registry(State, Data) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            ?LOG_WARNING(\"Registry not available for message routing from ~p\",\n                         [State#state.transport_id]),\n            ok;\n        RegistryPid when is_pid(RegistryPid) ->\n            case State#state.server_id of\n                undefined ->\n                    ?LOG_DEBUG(\"No server ID configured for transport ~p\",\n                               [State#state.transport_id]);\n                ServerId ->\n                    case erlmcp_registry:route_message(State#state.transport_id, Data) of\n                        ok ->\n                            ?LOG_DEBUG(\"Routed message from HTTP transport ~p\",\n                                       [State#state.transport_id]),\n                            ok;\n                        {error, Reason} ->\n                            ?LOG_WARNING(\"Failed to route message from HTTP transport ~p: ~p\",\n                                         [State#state.transport_id, Reason]),\n                            ok\n                    end\n            end\n    end.\n\n%% @private\n%% HTTP handler for external integration (placeholder)\nhttp_handler(_Req, State) ->\n    % This would be used with cowboy or similar HTTP server\n    {ok, State}.\n"
        }
    ]
}