{
    "sourceFile": "src/erlmcp_registry.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1756186304603,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756187355535,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,55 +1,46 @@\n -module(erlmcp_registry).\n+\n -behaviour(gen_server).\n \n--include(\"erlmcp.hrl\").\n-% Disable opentelemetry for now until dependency is available\n-% -include_lib(\"opentelemetry/include/otel_tracer.hrl\").\n+-include(\"erlmcp.hrl\").% Disable opentelemetry for now until dependency is available\n+                       % -include_lib(\"opentelemetry/include/otel_tracer.hrl\").\n \n %% API exports\n--export([\n-    start_link/0,\n-    register_server/3, register_transport/3,\n-    unregister_server/1, unregister_transport/1,\n-    route_to_server/3, route_to_transport/3,\n-    find_server/1, find_transport/1,\n-    list_servers/0, list_transports/0,\n-    bind_transport_to_server/2, unbind_transport/1,\n-    get_server_for_transport/1\n-]).\n-\n+-export([start_link/0, register_server/3, register_transport/3, unregister_server/1,\n+         unregister_transport/1, route_to_server/3, route_to_transport/3, find_server/1,\n+         find_transport/1, list_servers/0, list_transports/0, bind_transport_to_server/2,\n+         unbind_transport/1, get_server_for_transport/1]).\n %% gen_server callbacks\n--export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).\n+-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,\n+         code_change/3]).\n \n %% Types\n -type server_id() :: atom() | binary().\n -type transport_id() :: atom() | binary().\n--type server_config() :: #{\n-    capabilities => #mcp_server_capabilities{},\n-    options => map(),\n-    _ => _\n-}.\n--type transport_config() :: #{\n-    type => stdio | tcp | http,\n-    server_id => server_id(),\n-    config => map(),\n-    _ => _\n-}.\n+-type server_config() ::\n+    #{capabilities => #mcp_server_capabilities{},\n+      options => map(),\n+      _ => _}.\n+-type transport_config() ::\n+    #{type => stdio | tcp | http,\n+      server_id => server_id(),\n+      config => map(),\n+      _ => _}.\n \n -export_type([server_id/0, transport_id/0]).\n \n--record(registry_state, {\n-    servers = #{} :: #{server_id() => {pid(), server_config()}},\n-    transports = #{} :: #{transport_id() => {pid(), transport_config()}},\n-    server_transport_map = #{} :: #{transport_id() => server_id()},\n-    capabilities = #{} :: #{server_id() => #mcp_server_capabilities{}},\n-    monitors = #{} :: #{pid() => {server_id() | transport_id(), server | transport}},\n-    monitor_refs = #{} :: #{pid() => reference()},  % Track monitor references\n-    %% Optional fields used by some diagnostic calls; provide defaults\n-    metadata = #{} :: map(),\n-    route_count = 0 :: non_neg_integer(),\n-    start_time = erlang:system_time(second) :: integer()\n-}).\n+-record(registry_state,\n+        {servers = #{} :: #{server_id() => {pid(), server_config()}},\n+         transports = #{} :: #{transport_id() => {pid(), transport_config()}},\n+         server_transport_map = #{} :: #{transport_id() => server_id()},\n+         capabilities = #{} :: #{server_id() => #mcp_server_capabilities{}},\n+         monitors = #{} :: #{pid() => {server_id() | transport_id(), server | transport}},\n+         monitor_refs = #{} :: #{pid() => reference()},  % Track monitor references\n+         %% Optional fields used by some diagnostic calls; provide defaults\n+         metadata = #{} :: map(),\n+         route_count = 0 :: non_neg_integer(),\n+         start_time = erlang:system_time(second) :: integer()}).\n \n -type state() :: #registry_state{}.\n \n %%====================================================================\n@@ -59,13 +50,21 @@\n -spec start_link() -> {ok, pid()} | {error, term()}.\n start_link() ->\n     gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n \n+-spec stop() -> ok.\n+stop() ->\n+    case whereis(?MODULE) of\n+        undefined -> ok;\n+        Pid -> gen_server:stop(Pid)\n+    end.\n+\n -spec register_server(server_id(), pid(), server_config()) -> ok | {error, term()}.\n register_server(ServerId, ServerPid, Config) when is_pid(ServerPid) ->\n     gen_server:call(?MODULE, {register_server, ServerId, ServerPid, Config}).\n \n--spec register_transport(transport_id(), pid(), transport_config()) -> ok | {error, term()}.\n+-spec register_transport(transport_id(), pid(), transport_config()) ->\n+                            ok | {error, term()}.\n register_transport(TransportId, TransportPid, Config) when is_pid(TransportPid) ->\n     gen_server:call(?MODULE, {register_transport, TransportId, TransportPid, Config}).\n \n -spec unregister_server(server_id()) -> ok.\n@@ -79,18 +78,21 @@\n -spec route_to_server(server_id(), transport_id(), term()) -> ok | {error, term()}.\n route_to_server(ServerId, TransportId, Message) ->\n     SpanCtx = erlmcp_tracing:start_registry_span(<<\"registry.route_to_server\">>),\n     try\n-        MessageSize = case Message of\n-            M when is_binary(M) -> byte_size(M);\n-            M when is_list(M) -> iolist_size(M);\n-            _ -> unknown\n-        end,\n-        erlmcp_tracing:set_attributes(SpanCtx, #{\n-            <<\"server_id\">> => ServerId,\n-            <<\"transport_id\">> => TransportId,\n-            <<\"message.size\">> => MessageSize\n-        }),\n+        MessageSize =\n+            case Message of\n+                M when is_binary(M) ->\n+                    byte_size(M);\n+                M when is_list(M) ->\n+                    iolist_size(M);\n+                _ ->\n+                    unknown\n+            end,\n+        erlmcp_tracing:set_attributes(SpanCtx,\n+                                      #{<<\"server_id\">> => ServerId,\n+                                        <<\"transport_id\">> => TransportId,\n+                                        <<\"message.size\">> => MessageSize}),\n         Result = gen_server:cast(?MODULE, {route_to_server, ServerId, TransportId, Message}),\n         erlmcp_tracing:set_status(SpanCtx, ok),\n         Result\n     catch\n@@ -104,18 +106,21 @@\n -spec route_to_transport(transport_id(), server_id(), term()) -> ok | {error, term()}.\n route_to_transport(TransportId, ServerId, Message) ->\n     SpanCtx = erlmcp_tracing:start_registry_span(<<\"registry.route_to_transport\">>),\n     try\n-        MessageSize = case Message of\n-            M when is_binary(M) -> byte_size(M);\n-            M when is_list(M) -> iolist_size(M);\n-            _ -> unknown\n-        end,\n-        erlmcp_tracing:set_attributes(SpanCtx, #{\n-            <<\"transport_id\">> => TransportId,\n-            <<\"server_id\">> => ServerId,\n-            <<\"message.size\">> => MessageSize\n-        }),\n+        MessageSize =\n+            case Message of\n+                M when is_binary(M) ->\n+                    byte_size(M);\n+                M when is_list(M) ->\n+                    iolist_size(M);\n+                _ ->\n+                    unknown\n+            end,\n+        erlmcp_tracing:set_attributes(SpanCtx,\n+                                      #{<<\"transport_id\">> => TransportId,\n+                                        <<\"server_id\">> => ServerId,\n+                                        <<\"message.size\">> => MessageSize}),\n         Result = gen_server:cast(?MODULE, {route_to_transport, TransportId, ServerId, Message}),\n         erlmcp_tracing:set_status(SpanCtx, ok),\n         Result\n     catch\n@@ -129,9 +134,10 @@\n -spec find_server(server_id()) -> {ok, {pid(), server_config()}} | {error, not_found}.\n find_server(ServerId) ->\n     gen_server:call(?MODULE, {find_server, ServerId}).\n \n--spec find_transport(transport_id()) -> {ok, {pid(), transport_config()}} | {error, not_found}.\n+-spec find_transport(transport_id()) ->\n+                        {ok, {pid(), transport_config()}} | {error, not_found}.\n find_transport(TransportId) ->\n     gen_server:call(?MODULE, {find_transport, TransportId}).\n \n -spec list_servers() -> [{server_id(), {pid(), server_config()}}].\n@@ -163,43 +169,45 @@\n     process_flag(trap_exit, true),\n     logger:info(\"Starting MCP registry\"),\n     {ok, #registry_state{}}.\n \n--spec handle_call(term(), {pid(), term()}, state()) -> \n-    {reply, term(), state()}.\n-\n+-spec handle_call(term(), {pid(), term()}, state()) -> {reply, term(), state()}.\n handle_call({register_server, ServerId, ServerPid, Config}, _From, State) ->\n     SpanCtx = erlmcp_tracing:start_registry_span(<<\"registry.handle_register_server\">>),\n     try\n-        erlmcp_tracing:set_attributes(SpanCtx, #{\n-            <<\"server_id\">> => ServerId,\n-            <<\"server_pid\">> => ServerPid,\n-            <<\"existing_servers_count\">> => maps:size(State#registry_state.servers)\n-        }),\n-        \n+        erlmcp_tracing:set_attributes(SpanCtx,\n+                                      #{<<\"server_id\">> => ServerId,\n+                                        <<\"server_pid\">> => ServerPid,\n+                                        <<\"existing_servers_count\">> =>\n+                                            maps:size(State#registry_state.servers)}),\n+\n         case maps:get(ServerId, State#registry_state.servers, undefined) of\n             undefined ->\n                 MonitorRef = monitor(process, ServerPid),\n                 Capabilities = maps:get(capabilities, Config, undefined),\n-                \n+\n                 NewServers = maps:put(ServerId, {ServerPid, Config}, State#registry_state.servers),\n-                NewCapabilities = case Capabilities of\n-                    undefined -> State#registry_state.capabilities;\n-                    _ -> maps:put(ServerId, Capabilities, State#registry_state.capabilities)\n-                end,\n-                NewMonitors = maps:put(ServerPid, {ServerId, server}, State#registry_state.monitors),\n+                NewCapabilities =\n+                    case Capabilities of\n+                        undefined ->\n+                            State#registry_state.capabilities;\n+                        _ ->\n+                            maps:put(ServerId, Capabilities, State#registry_state.capabilities)\n+                    end,\n+                NewMonitors =\n+                    maps:put(ServerPid, {ServerId, server}, State#registry_state.monitors),\n                 NewMonitorRefs = maps:put(ServerPid, MonitorRef, State#registry_state.monitor_refs),\n-                \n-                NewState = State#registry_state{\n-                    servers = NewServers,\n-                    capabilities = NewCapabilities,\n-                    monitors = NewMonitors,\n-                    monitor_refs = NewMonitorRefs\n-                },\n-                \n-                erlmcp_tracing:record_performance_metrics(SpanCtx, #{\n-                    memory_usage => erlang:process_info(self(), memory)\n-                }),\n+\n+                NewState =\n+                    State#registry_state{servers = NewServers,\n+                                         capabilities = NewCapabilities,\n+                                         monitors = NewMonitors,\n+                                         monitor_refs = NewMonitorRefs},\n+\n+                erlmcp_tracing:record_performance_metrics(SpanCtx,\n+                                                          #{memory_usage =>\n+                                                                erlang:process_info(self(),\n+                                                                                    memory)}),\n                 erlmcp_tracing:set_status(SpanCtx, ok),\n                 logger:info(\"Registered server ~p with pid ~p\", [ServerId, ServerPid]),\n                 {reply, ok, NewState};\n             {ExistingPid, _} ->\n@@ -213,122 +221,128 @@\n             erlang:raise(Class, Reason, Stacktrace)\n     after\n         erlmcp_tracing:end_span(SpanCtx)\n     end;\n-\n handle_call({register_transport, TransportId, TransportPid, Config}, _From, State) ->\n     case maps:get(TransportId, State#registry_state.transports, undefined) of\n         undefined ->\n             MonitorRef = monitor(process, TransportPid),\n-            \n-            NewTransports = maps:put(TransportId, {TransportPid, Config}, State#registry_state.transports),\n-            NewMonitors = maps:put(TransportPid, {TransportId, transport}, State#registry_state.monitors),\n+\n+            NewTransports =\n+                maps:put(TransportId, {TransportPid, Config}, State#registry_state.transports),\n+            NewMonitors =\n+                maps:put(TransportPid, {TransportId, transport}, State#registry_state.monitors),\n             NewMonitorRefs = maps:put(TransportPid, MonitorRef, State#registry_state.monitor_refs),\n-            \n-            NewState = State#registry_state{\n-                transports = NewTransports,\n-                monitors = NewMonitors,\n-                monitor_refs = NewMonitorRefs\n-            },\n-            \n+\n+            NewState =\n+                State#registry_state{transports = NewTransports,\n+                                     monitors = NewMonitors,\n+                                     monitor_refs = NewMonitorRefs},\n+\n             % Auto-bind to server if specified in config\n-            FinalState = case maps:get(server_id, Config, undefined) of\n-                undefined -> NewState;\n-                ServerId -> \n-                    NewMap = maps:put(TransportId, ServerId, NewState#registry_state.server_transport_map),\n-                    NewState#registry_state{server_transport_map = NewMap}\n-            end,\n-            \n+            FinalState =\n+                case maps:get(server_id, Config, undefined) of\n+                    undefined ->\n+                        NewState;\n+                    ServerId ->\n+                        NewMap =\n+                            maps:put(TransportId,\n+                                     ServerId,\n+                                     NewState#registry_state.server_transport_map),\n+                        NewState#registry_state{server_transport_map = NewMap}\n+                end,\n+\n             logger:info(\"Registered transport ~p with pid ~p\", [TransportId, TransportPid]),\n             {reply, ok, FinalState};\n         {ExistingPid, _} ->\n-            logger:warning(\"Transport ~p already registered with pid ~p\", [TransportId, ExistingPid]),\n+            logger:warning(\"Transport ~p already registered with pid ~p\",\n+                           [TransportId, ExistingPid]),\n             {reply, {error, already_registered}, State}\n     end;\n-\n handle_call({unregister_server, ServerId}, _From, State) ->\n     case maps:take(ServerId, State#registry_state.servers) of\n         {{ServerPid, _Config}, NewServers} ->\n             % Demonitor the process\n             case maps:get(ServerPid, State#registry_state.monitor_refs, undefined) of\n-                undefined -> ok;\n-                MonitorRef -> demonitor(MonitorRef, [flush])\n+                undefined ->\n+                    ok;\n+                MonitorRef ->\n+                    demonitor(MonitorRef, [flush])\n             end,\n-            \n+\n             % Remove from monitors\n             NewMonitors = maps:remove(ServerPid, State#registry_state.monitors),\n             NewMonitorRefs = maps:remove(ServerPid, State#registry_state.monitor_refs),\n             % Remove capabilities\n             NewCapabilities = maps:remove(ServerId, State#registry_state.capabilities),\n             % Remove any transport bindings\n-            NewTransportMap = maps:filter(fun(_, SId) -> SId =/= ServerId end, \n-                                         State#registry_state.server_transport_map),\n-            \n-            NewState = State#registry_state{\n-                servers = NewServers,\n-                capabilities = NewCapabilities,\n-                server_transport_map = NewTransportMap,\n-                monitors = NewMonitors,\n-                monitor_refs = NewMonitorRefs\n-            },\n-            \n+            NewTransportMap =\n+                maps:filter(fun(_, SId) -> SId =/= ServerId end,\n+                            State#registry_state.server_transport_map),\n+\n+            NewState =\n+                State#registry_state{servers = NewServers,\n+                                     capabilities = NewCapabilities,\n+                                     server_transport_map = NewTransportMap,\n+                                     monitors = NewMonitors,\n+                                     monitor_refs = NewMonitorRefs},\n+\n             logger:info(\"Unregistered server ~p\", [ServerId]),\n             {reply, ok, NewState};\n         error ->\n             {reply, ok, State}  % Already unregistered\n     end;\n-\n handle_call({unregister_transport, TransportId}, _From, State) ->\n     case maps:take(TransportId, State#registry_state.transports) of\n         {{TransportPid, _Config}, NewTransports} ->\n             % Demonitor the process\n             case maps:get(TransportPid, State#registry_state.monitor_refs, undefined) of\n-                undefined -> ok;\n-                MonitorRef -> demonitor(MonitorRef, [flush])\n+                undefined ->\n+                    ok;\n+                MonitorRef ->\n+                    demonitor(MonitorRef, [flush])\n             end,\n-            \n+\n             % Remove from monitors\n             NewMonitors = maps:remove(TransportPid, State#registry_state.monitors),\n             NewMonitorRefs = maps:remove(TransportPid, State#registry_state.monitor_refs),\n             % Remove binding\n             NewTransportMap = maps:remove(TransportId, State#registry_state.server_transport_map),\n-            \n-            NewState = State#registry_state{\n-                transports = NewTransports,\n-                server_transport_map = NewTransportMap,\n-                monitors = NewMonitors,\n-                monitor_refs = NewMonitorRefs\n-            },\n-            \n+\n+            NewState =\n+                State#registry_state{transports = NewTransports,\n+                                     server_transport_map = NewTransportMap,\n+                                     monitors = NewMonitors,\n+                                     monitor_refs = NewMonitorRefs},\n+\n             logger:info(\"Unregistered transport ~p\", [TransportId]),\n             {reply, ok, NewState};\n         error ->\n             {reply, ok, State}  % Already unregistered\n     end;\n-\n handle_call({find_server, ServerId}, _From, State) ->\n     case maps:get(ServerId, State#registry_state.servers, undefined) of\n-        undefined -> {reply, {error, not_found}, State};\n-        ServerData -> {reply, {ok, ServerData}, State}\n+        undefined ->\n+            {reply, {error, not_found}, State};\n+        ServerData ->\n+            {reply, {ok, ServerData}, State}\n     end;\n-\n handle_call({find_transport, TransportId}, _From, State) ->\n     case maps:get(TransportId, State#registry_state.transports, undefined) of\n-        undefined -> {reply, {error, not_found}, State};\n-        TransportData -> {reply, {ok, TransportData}, State}\n+        undefined ->\n+            {reply, {error, not_found}, State};\n+        TransportData ->\n+            {reply, {ok, TransportData}, State}\n     end;\n-\n handle_call(list_servers, _From, State) ->\n     {reply, maps:to_list(State#registry_state.servers), State};\n-\n handle_call(list_transports, _From, State) ->\n     {reply, maps:to_list(State#registry_state.transports), State};\n-\n handle_call({bind_transport_to_server, TransportId, ServerId}, _From, State) ->\n     % Verify both exist\n     ServerExists = maps:is_key(ServerId, State#registry_state.servers),\n     TransportExists = maps:is_key(TransportId, State#registry_state.transports),\n-    \n+\n     case {ServerExists, TransportExists} of\n         {true, true} ->\n             NewMap = maps:put(TransportId, ServerId, State#registry_state.server_transport_map),\n             NewState = State#registry_state{server_transport_map = NewMap},\n@@ -338,62 +352,58 @@\n             {reply, {error, server_not_found}, State};\n         {_, false} ->\n             {reply, {error, transport_not_found}, State}\n     end;\n-\n handle_call({unbind_transport, TransportId}, _From, State) ->\n     NewMap = maps:remove(TransportId, State#registry_state.server_transport_map),\n     NewState = State#registry_state{server_transport_map = NewMap},\n     {reply, ok, NewState};\n-\n handle_call({get_server_for_transport, TransportId}, _From, State) ->\n     case maps:get(TransportId, State#registry_state.server_transport_map, undefined) of\n-        undefined -> {reply, {error, not_found}, State};\n-        ServerId -> {reply, {ok, ServerId}, State}\n+        undefined ->\n+            {reply, {error, not_found}, State};\n+        ServerId ->\n+            {reply, {ok, ServerId}, State}\n     end;\n-\n handle_call({test_health_check}, _From, State) ->\n     % Simple health check response\n     {reply, {ok, healthy}, State};\n-\n handle_call(get_health_status, _From, State) ->\n-    HealthStatus = #{\n-        servers_count => maps:size(State#registry_state.servers),\n-        transports_count => maps:size(State#registry_state.transports),\n-        metadata_count => maps:size(State#registry_state.metadata),\n-        uptime => erlang:system_time(second) - State#registry_state.start_time,\n-        status => healthy\n-    },\n+    HealthStatus =\n+        #{servers_count => maps:size(State#registry_state.servers),\n+          transports_count => maps:size(State#registry_state.transports),\n+          metadata_count => maps:size(State#registry_state.metadata),\n+          uptime => erlang:system_time(second) - State#registry_state.start_time,\n+          status => healthy},\n     {reply, HealthStatus, State};\n-\n handle_call(get_registry_stats, _From, State) ->\n-    Stats = #{\n-        servers => maps:keys(State#registry_state.servers),\n-        transports => maps:keys(State#registry_state.transports),\n-        metadata_keys => maps:keys(State#registry_state.metadata),\n-        total_routes => State#registry_state.route_count\n-    },\n+    Stats =\n+        #{servers => maps:keys(State#registry_state.servers),\n+          transports => maps:keys(State#registry_state.transports),\n+          metadata_keys => maps:keys(State#registry_state.metadata),\n+          total_routes => State#registry_state.route_count},\n     {reply, Stats, State};\n-\n handle_call(_Request, _From, State) ->\n     {reply, {error, unknown_request}, State}.\n \n -spec handle_cast(term(), state()) -> {noreply, state()}.\n-\n handle_cast({route_to_server, ServerId, TransportId, Message}, State) ->\n     SpanCtx = erlmcp_tracing:start_registry_span(<<\"registry.handle_route_to_server\">>),\n     try\n-        MessageSize = case Message of\n-            M when is_binary(M) -> byte_size(M);\n-            M when is_list(M) -> iolist_size(M);\n-            _ -> unknown\n-        end,\n-        erlmcp_tracing:set_attributes(SpanCtx, #{\n-            <<\"server_id\">> => ServerId,\n-            <<\"transport_id\">> => TransportId,\n-            <<\"message.size\">> => MessageSize\n-        }),\n-        \n+        MessageSize =\n+            case Message of\n+                M when is_binary(M) ->\n+                    byte_size(M);\n+                M when is_list(M) ->\n+                    iolist_size(M);\n+                _ ->\n+                    unknown\n+            end,\n+        erlmcp_tracing:set_attributes(SpanCtx,\n+                                      #{<<\"server_id\">> => ServerId,\n+                                        <<\"transport_id\">> => TransportId,\n+                                        <<\"message.size\">> => MessageSize}),\n+\n         case get_server_pid(ServerId, State) of\n             {ok, ServerPid} ->\n                 erlmcp_tracing:set_attributes(SpanCtx, #{<<\"server_pid\">> => ServerPid}),\n                 ServerPid ! {mcp_message, TransportId, Message},\n@@ -410,23 +420,25 @@\n             {noreply, State}\n     after\n         erlmcp_tracing:end_span(SpanCtx)\n     end;\n-\n handle_cast({route_to_transport, TransportId, ServerId, Message}, State) ->\n     SpanCtx = erlmcp_tracing:start_registry_span(<<\"registry.handle_route_to_transport\">>),\n     try\n-        MessageSize = case Message of\n-            M when is_binary(M) -> byte_size(M);\n-            M when is_list(M) -> iolist_size(M);\n-            _ -> unknown\n-        end,\n-        erlmcp_tracing:set_attributes(SpanCtx, #{\n-            <<\"transport_id\">> => TransportId,\n-            <<\"server_id\">> => ServerId,\n-            <<\"message.size\">> => MessageSize\n-        }),\n-        \n+        MessageSize =\n+            case Message of\n+                M when is_binary(M) ->\n+                    byte_size(M);\n+                M when is_list(M) ->\n+                    iolist_size(M);\n+                _ ->\n+                    unknown\n+            end,\n+        erlmcp_tracing:set_attributes(SpanCtx,\n+                                      #{<<\"transport_id\">> => TransportId,\n+                                        <<\"server_id\">> => ServerId,\n+                                        <<\"message.size\">> => MessageSize}),\n+\n         case get_transport_pid(TransportId, State) of\n             {ok, TransportPid} ->\n                 erlmcp_tracing:set_attributes(SpanCtx, #{<<\"transport_pid\">> => TransportPid}),\n                 TransportPid ! {mcp_response, ServerId, Message},\n@@ -443,15 +455,12 @@\n             {noreply, State}\n     after\n         erlmcp_tracing:end_span(SpanCtx)\n     end;\n-\n handle_cast(_Msg, State) ->\n     {noreply, State}.\n \n--spec handle_info(term(), state()) -> \n-    {noreply, state()}.\n-\n+-spec handle_info(term(), state()) -> {noreply, state()}.\n handle_info({'DOWN', MonitorRef, process, Pid, Reason}, State) ->\n     case maps:get(Pid, State#registry_state.monitors, undefined) of\n         {Id, server} ->\n             logger:warning(\"Server ~p (pid ~p) died: ~p\", [Id, Pid, Reason]),\n@@ -466,18 +475,16 @@\n             catch demonitor(MonitorRef, [flush]),\n             logger:warning(\"Unknown monitored process ~p died: ~p\", [Pid, Reason]),\n             {noreply, State}\n     end;\n-\n handle_info(_Info, State) ->\n     {noreply, State}.\n \n -spec terminate(term(), state()) -> ok.\n terminate(_Reason, State) ->\n     % Clean up all monitors\n-    maps:foreach(fun(_Pid, MonitorRef) ->\n-        catch demonitor(MonitorRef, [flush])\n-    end, State#registry_state.monitor_refs),\n+    maps:foreach(fun(_Pid, MonitorRef) -> catch demonitor(MonitorRef, [flush]) end,\n+                 State#registry_state.monitor_refs),\n     logger:info(\"MCP registry terminating\"),\n     ok.\n \n -spec code_change(term(), state(), term()) -> {ok, state()}.\n@@ -490,59 +497,64 @@\n \n -spec get_server_pid(server_id(), state()) -> {ok, pid()} | {error, not_found}.\n get_server_pid(ServerId, State) ->\n     case maps:get(ServerId, State#registry_state.servers, undefined) of\n-        undefined -> {error, not_found};\n-        {ServerPid, _Config} -> {ok, ServerPid}\n+        undefined ->\n+            {error, not_found};\n+        {ServerPid, _Config} ->\n+            {ok, ServerPid}\n     end.\n \n -spec get_transport_pid(transport_id(), state()) -> {ok, pid()} | {error, not_found}.\n get_transport_pid(TransportId, State) ->\n     case maps:get(TransportId, State#registry_state.transports, undefined) of\n-        undefined -> {error, not_found};\n-        {TransportPid, _Config} -> {ok, TransportPid}\n+        undefined ->\n+            {error, not_found};\n+        {TransportPid, _Config} ->\n+            {ok, TransportPid}\n     end.\n \n -spec cleanup_server(server_id(), pid(), state()) -> state().\n cleanup_server(ServerId, ServerPid, State) ->\n     % Demonitor if we have a reference\n     case maps:get(ServerPid, State#registry_state.monitor_refs, undefined) of\n-        undefined -> ok;\n-        MonitorRef -> catch demonitor(MonitorRef, [flush])\n+        undefined ->\n+            ok;\n+        MonitorRef ->\n+            catch demonitor(MonitorRef, [flush])\n     end,\n-    \n+\n     NewServers = maps:remove(ServerId, State#registry_state.servers),\n     NewCapabilities = maps:remove(ServerId, State#registry_state.capabilities),\n     NewMonitors = maps:remove(ServerPid, State#registry_state.monitors),\n     NewMonitorRefs = maps:remove(ServerPid, State#registry_state.monitor_refs),\n-    \n+\n     % Remove any transport bindings\n-    NewTransportMap = maps:filter(fun(_, SId) -> SId =/= ServerId end,\n-                                 State#registry_state.server_transport_map),\n-    \n-    State#registry_state{\n-        servers = NewServers,\n-        capabilities = NewCapabilities,\n-        server_transport_map = NewTransportMap,\n-        monitors = NewMonitors,\n-        monitor_refs = NewMonitorRefs\n-    }.\n+    NewTransportMap =\n+        maps:filter(fun(_, SId) -> SId =/= ServerId end,\n+                    State#registry_state.server_transport_map),\n \n+    State#registry_state{servers = NewServers,\n+                         capabilities = NewCapabilities,\n\\ No newline at end of file\n+                         server_transport_map = NewTransportMap,\n+                         monitors = NewMonitors,\n+                         monitor_refs = NewMonitorRefs}.\n+\n -spec cleanup_transport(transport_id(), pid(), state()) -> state().\n cleanup_transport(TransportId, TransportPid, State) ->\n     % Demonitor if we have a reference\n     case maps:get(TransportPid, State#registry_state.monitor_refs, undefined) of\n-        undefined -> ok;\n-        MonitorRef -> catch demonitor(MonitorRef, [flush])\n+        undefined ->\n+            ok;\n+        MonitorRef ->\n+            catch demonitor(MonitorRef, [flush])\n     end,\n-    \n+\n     NewTransports = maps:remove(TransportId, State#registry_state.transports),\n     NewTransportMap = maps:remove(TransportId, State#registry_state.server_transport_map),\n     NewMonitors = maps:remove(TransportPid, State#registry_state.monitors),\n     NewMonitorRefs = maps:remove(TransportPid, State#registry_state.monitor_refs),\n-    \n-    State#registry_state{\n-        transports = NewTransports,\n-        server_transport_map = NewTransportMap,\n-        monitors = NewMonitors,\n-        monitor_refs = NewMonitorRefs\n-    }.\n+\n+    State#registry_state{transports = NewTransports,\n+                         server_transport_map = NewTransportMap,\n+                         monitors = NewMonitors,\n+                         monitor_refs = NewMonitorRefs}.\n"
                }
            ],
            "date": 1756186304603,
            "name": "Commit-0",
            "content": "-module(erlmcp_registry).\n-behaviour(gen_server).\n\n-include(\"erlmcp.hrl\").\n% Disable opentelemetry for now until dependency is available\n% -include_lib(\"opentelemetry/include/otel_tracer.hrl\").\n\n%% API exports\n-export([\n    start_link/0,\n    register_server/3, register_transport/3,\n    unregister_server/1, unregister_transport/1,\n    route_to_server/3, route_to_transport/3,\n    find_server/1, find_transport/1,\n    list_servers/0, list_transports/0,\n    bind_transport_to_server/2, unbind_transport/1,\n    get_server_for_transport/1\n]).\n\n%% gen_server callbacks\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).\n\n%% Types\n-type server_id() :: atom() | binary().\n-type transport_id() :: atom() | binary().\n-type server_config() :: #{\n    capabilities => #mcp_server_capabilities{},\n    options => map(),\n    _ => _\n}.\n-type transport_config() :: #{\n    type => stdio | tcp | http,\n    server_id => server_id(),\n    config => map(),\n    _ => _\n}.\n\n-export_type([server_id/0, transport_id/0]).\n\n-record(registry_state, {\n    servers = #{} :: #{server_id() => {pid(), server_config()}},\n    transports = #{} :: #{transport_id() => {pid(), transport_config()}},\n    server_transport_map = #{} :: #{transport_id() => server_id()},\n    capabilities = #{} :: #{server_id() => #mcp_server_capabilities{}},\n    monitors = #{} :: #{pid() => {server_id() | transport_id(), server | transport}},\n    monitor_refs = #{} :: #{pid() => reference()},  % Track monitor references\n    %% Optional fields used by some diagnostic calls; provide defaults\n    metadata = #{} :: map(),\n    route_count = 0 :: non_neg_integer(),\n    start_time = erlang:system_time(second) :: integer()\n}).\n\n-type state() :: #registry_state{}.\n\n%%====================================================================\n%% API Functions\n%%====================================================================\n\n-spec start_link() -> {ok, pid()} | {error, term()}.\nstart_link() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n\n-spec register_server(server_id(), pid(), server_config()) -> ok | {error, term()}.\nregister_server(ServerId, ServerPid, Config) when is_pid(ServerPid) ->\n    gen_server:call(?MODULE, {register_server, ServerId, ServerPid, Config}).\n\n-spec register_transport(transport_id(), pid(), transport_config()) -> ok | {error, term()}.\nregister_transport(TransportId, TransportPid, Config) when is_pid(TransportPid) ->\n    gen_server:call(?MODULE, {register_transport, TransportId, TransportPid, Config}).\n\n-spec unregister_server(server_id()) -> ok.\nunregister_server(ServerId) ->\n    gen_server:call(?MODULE, {unregister_server, ServerId}).\n\n-spec unregister_transport(transport_id()) -> ok.\nunregister_transport(TransportId) ->\n    gen_server:call(?MODULE, {unregister_transport, TransportId}).\n\n-spec route_to_server(server_id(), transport_id(), term()) -> ok | {error, term()}.\nroute_to_server(ServerId, TransportId, Message) ->\n    SpanCtx = erlmcp_tracing:start_registry_span(<<\"registry.route_to_server\">>),\n    try\n        MessageSize = case Message of\n            M when is_binary(M) -> byte_size(M);\n            M when is_list(M) -> iolist_size(M);\n            _ -> unknown\n        end,\n        erlmcp_tracing:set_attributes(SpanCtx, #{\n            <<\"server_id\">> => ServerId,\n            <<\"transport_id\">> => TransportId,\n            <<\"message.size\">> => MessageSize\n        }),\n        Result = gen_server:cast(?MODULE, {route_to_server, ServerId, TransportId, Message}),\n        erlmcp_tracing:set_status(SpanCtx, ok),\n        Result\n    catch\n        Class:Reason:Stacktrace ->\n            erlmcp_tracing:record_exception(SpanCtx, Class, Reason, Stacktrace),\n            erlang:raise(Class, Reason, Stacktrace)\n    after\n        erlmcp_tracing:end_span(SpanCtx)\n    end.\n\n-spec route_to_transport(transport_id(), server_id(), term()) -> ok | {error, term()}.\nroute_to_transport(TransportId, ServerId, Message) ->\n    SpanCtx = erlmcp_tracing:start_registry_span(<<\"registry.route_to_transport\">>),\n    try\n        MessageSize = case Message of\n            M when is_binary(M) -> byte_size(M);\n            M when is_list(M) -> iolist_size(M);\n            _ -> unknown\n        end,\n        erlmcp_tracing:set_attributes(SpanCtx, #{\n            <<\"transport_id\">> => TransportId,\n            <<\"server_id\">> => ServerId,\n            <<\"message.size\">> => MessageSize\n        }),\n        Result = gen_server:cast(?MODULE, {route_to_transport, TransportId, ServerId, Message}),\n        erlmcp_tracing:set_status(SpanCtx, ok),\n        Result\n    catch\n        Class:Reason:Stacktrace ->\n            erlmcp_tracing:record_exception(SpanCtx, Class, Reason, Stacktrace),\n            erlang:raise(Class, Reason, Stacktrace)\n    after\n        erlmcp_tracing:end_span(SpanCtx)\n    end.\n\n-spec find_server(server_id()) -> {ok, {pid(), server_config()}} | {error, not_found}.\nfind_server(ServerId) ->\n    gen_server:call(?MODULE, {find_server, ServerId}).\n\n-spec find_transport(transport_id()) -> {ok, {pid(), transport_config()}} | {error, not_found}.\nfind_transport(TransportId) ->\n    gen_server:call(?MODULE, {find_transport, TransportId}).\n\n-spec list_servers() -> [{server_id(), {pid(), server_config()}}].\nlist_servers() ->\n    gen_server:call(?MODULE, list_servers).\n\n-spec list_transports() -> [{transport_id(), {pid(), transport_config()}}].\nlist_transports() ->\n    gen_server:call(?MODULE, list_transports).\n\n-spec bind_transport_to_server(transport_id(), server_id()) -> ok | {error, term()}.\nbind_transport_to_server(TransportId, ServerId) ->\n    gen_server:call(?MODULE, {bind_transport_to_server, TransportId, ServerId}).\n\n-spec unbind_transport(transport_id()) -> ok.\nunbind_transport(TransportId) ->\n    gen_server:call(?MODULE, {unbind_transport, TransportId}).\n\n-spec get_server_for_transport(transport_id()) -> {ok, server_id()} | {error, not_found}.\nget_server_for_transport(TransportId) ->\n    gen_server:call(?MODULE, {get_server_for_transport, TransportId}).\n\n%%====================================================================\n%% gen_server callbacks\n%%====================================================================\n\n-spec init([]) -> {ok, state()}.\ninit([]) ->\n    process_flag(trap_exit, true),\n    logger:info(\"Starting MCP registry\"),\n    {ok, #registry_state{}}.\n\n-spec handle_call(term(), {pid(), term()}, state()) -> \n    {reply, term(), state()}.\n\nhandle_call({register_server, ServerId, ServerPid, Config}, _From, State) ->\n    SpanCtx = erlmcp_tracing:start_registry_span(<<\"registry.handle_register_server\">>),\n    try\n        erlmcp_tracing:set_attributes(SpanCtx, #{\n            <<\"server_id\">> => ServerId,\n            <<\"server_pid\">> => ServerPid,\n            <<\"existing_servers_count\">> => maps:size(State#registry_state.servers)\n        }),\n        \n        case maps:get(ServerId, State#registry_state.servers, undefined) of\n            undefined ->\n                MonitorRef = monitor(process, ServerPid),\n                Capabilities = maps:get(capabilities, Config, undefined),\n                \n                NewServers = maps:put(ServerId, {ServerPid, Config}, State#registry_state.servers),\n                NewCapabilities = case Capabilities of\n                    undefined -> State#registry_state.capabilities;\n                    _ -> maps:put(ServerId, Capabilities, State#registry_state.capabilities)\n                end,\n                NewMonitors = maps:put(ServerPid, {ServerId, server}, State#registry_state.monitors),\n                NewMonitorRefs = maps:put(ServerPid, MonitorRef, State#registry_state.monitor_refs),\n                \n                NewState = State#registry_state{\n                    servers = NewServers,\n                    capabilities = NewCapabilities,\n                    monitors = NewMonitors,\n                    monitor_refs = NewMonitorRefs\n                },\n                \n                erlmcp_tracing:record_performance_metrics(SpanCtx, #{\n                    memory_usage => erlang:process_info(self(), memory)\n                }),\n                erlmcp_tracing:set_status(SpanCtx, ok),\n                logger:info(\"Registered server ~p with pid ~p\", [ServerId, ServerPid]),\n                {reply, ok, NewState};\n            {ExistingPid, _} ->\n                erlmcp_tracing:record_error_details(SpanCtx, already_registered, ExistingPid),\n                logger:warning(\"Server ~p already registered with pid ~p\", [ServerId, ExistingPid]),\n                {reply, {error, already_registered}, State}\n        end\n    catch\n        Class:Reason:Stacktrace ->\n            erlmcp_tracing:record_exception(SpanCtx, Class, Reason, Stacktrace),\n            erlang:raise(Class, Reason, Stacktrace)\n    after\n        erlmcp_tracing:end_span(SpanCtx)\n    end;\n\nhandle_call({register_transport, TransportId, TransportPid, Config}, _From, State) ->\n    case maps:get(TransportId, State#registry_state.transports, undefined) of\n        undefined ->\n            MonitorRef = monitor(process, TransportPid),\n            \n            NewTransports = maps:put(TransportId, {TransportPid, Config}, State#registry_state.transports),\n            NewMonitors = maps:put(TransportPid, {TransportId, transport}, State#registry_state.monitors),\n            NewMonitorRefs = maps:put(TransportPid, MonitorRef, State#registry_state.monitor_refs),\n            \n            NewState = State#registry_state{\n                transports = NewTransports,\n                monitors = NewMonitors,\n                monitor_refs = NewMonitorRefs\n            },\n            \n            % Auto-bind to server if specified in config\n            FinalState = case maps:get(server_id, Config, undefined) of\n                undefined -> NewState;\n                ServerId -> \n                    NewMap = maps:put(TransportId, ServerId, NewState#registry_state.server_transport_map),\n                    NewState#registry_state{server_transport_map = NewMap}\n            end,\n            \n            logger:info(\"Registered transport ~p with pid ~p\", [TransportId, TransportPid]),\n            {reply, ok, FinalState};\n        {ExistingPid, _} ->\n            logger:warning(\"Transport ~p already registered with pid ~p\", [TransportId, ExistingPid]),\n            {reply, {error, already_registered}, State}\n    end;\n\nhandle_call({unregister_server, ServerId}, _From, State) ->\n    case maps:take(ServerId, State#registry_state.servers) of\n        {{ServerPid, _Config}, NewServers} ->\n            % Demonitor the process\n            case maps:get(ServerPid, State#registry_state.monitor_refs, undefined) of\n                undefined -> ok;\n                MonitorRef -> demonitor(MonitorRef, [flush])\n            end,\n            \n            % Remove from monitors\n            NewMonitors = maps:remove(ServerPid, State#registry_state.monitors),\n            NewMonitorRefs = maps:remove(ServerPid, State#registry_state.monitor_refs),\n            % Remove capabilities\n            NewCapabilities = maps:remove(ServerId, State#registry_state.capabilities),\n            % Remove any transport bindings\n            NewTransportMap = maps:filter(fun(_, SId) -> SId =/= ServerId end, \n                                         State#registry_state.server_transport_map),\n            \n            NewState = State#registry_state{\n                servers = NewServers,\n                capabilities = NewCapabilities,\n                server_transport_map = NewTransportMap,\n                monitors = NewMonitors,\n                monitor_refs = NewMonitorRefs\n            },\n            \n            logger:info(\"Unregistered server ~p\", [ServerId]),\n            {reply, ok, NewState};\n        error ->\n            {reply, ok, State}  % Already unregistered\n    end;\n\nhandle_call({unregister_transport, TransportId}, _From, State) ->\n    case maps:take(TransportId, State#registry_state.transports) of\n        {{TransportPid, _Config}, NewTransports} ->\n            % Demonitor the process\n            case maps:get(TransportPid, State#registry_state.monitor_refs, undefined) of\n                undefined -> ok;\n                MonitorRef -> demonitor(MonitorRef, [flush])\n            end,\n            \n            % Remove from monitors\n            NewMonitors = maps:remove(TransportPid, State#registry_state.monitors),\n            NewMonitorRefs = maps:remove(TransportPid, State#registry_state.monitor_refs),\n            % Remove binding\n            NewTransportMap = maps:remove(TransportId, State#registry_state.server_transport_map),\n            \n            NewState = State#registry_state{\n                transports = NewTransports,\n                server_transport_map = NewTransportMap,\n                monitors = NewMonitors,\n                monitor_refs = NewMonitorRefs\n            },\n            \n            logger:info(\"Unregistered transport ~p\", [TransportId]),\n            {reply, ok, NewState};\n        error ->\n            {reply, ok, State}  % Already unregistered\n    end;\n\nhandle_call({find_server, ServerId}, _From, State) ->\n    case maps:get(ServerId, State#registry_state.servers, undefined) of\n        undefined -> {reply, {error, not_found}, State};\n        ServerData -> {reply, {ok, ServerData}, State}\n    end;\n\nhandle_call({find_transport, TransportId}, _From, State) ->\n    case maps:get(TransportId, State#registry_state.transports, undefined) of\n        undefined -> {reply, {error, not_found}, State};\n        TransportData -> {reply, {ok, TransportData}, State}\n    end;\n\nhandle_call(list_servers, _From, State) ->\n    {reply, maps:to_list(State#registry_state.servers), State};\n\nhandle_call(list_transports, _From, State) ->\n    {reply, maps:to_list(State#registry_state.transports), State};\n\nhandle_call({bind_transport_to_server, TransportId, ServerId}, _From, State) ->\n    % Verify both exist\n    ServerExists = maps:is_key(ServerId, State#registry_state.servers),\n    TransportExists = maps:is_key(TransportId, State#registry_state.transports),\n    \n    case {ServerExists, TransportExists} of\n        {true, true} ->\n            NewMap = maps:put(TransportId, ServerId, State#registry_state.server_transport_map),\n            NewState = State#registry_state{server_transport_map = NewMap},\n            logger:info(\"Bound transport ~p to server ~p\", [TransportId, ServerId]),\n            {reply, ok, NewState};\n        {false, _} ->\n            {reply, {error, server_not_found}, State};\n        {_, false} ->\n            {reply, {error, transport_not_found}, State}\n    end;\n\nhandle_call({unbind_transport, TransportId}, _From, State) ->\n    NewMap = maps:remove(TransportId, State#registry_state.server_transport_map),\n    NewState = State#registry_state{server_transport_map = NewMap},\n    {reply, ok, NewState};\n\nhandle_call({get_server_for_transport, TransportId}, _From, State) ->\n    case maps:get(TransportId, State#registry_state.server_transport_map, undefined) of\n        undefined -> {reply, {error, not_found}, State};\n        ServerId -> {reply, {ok, ServerId}, State}\n    end;\n\nhandle_call({test_health_check}, _From, State) ->\n    % Simple health check response\n    {reply, {ok, healthy}, State};\n\nhandle_call(get_health_status, _From, State) ->\n    HealthStatus = #{\n        servers_count => maps:size(State#registry_state.servers),\n        transports_count => maps:size(State#registry_state.transports),\n        metadata_count => maps:size(State#registry_state.metadata),\n        uptime => erlang:system_time(second) - State#registry_state.start_time,\n        status => healthy\n    },\n    {reply, HealthStatus, State};\n\nhandle_call(get_registry_stats, _From, State) ->\n    Stats = #{\n        servers => maps:keys(State#registry_state.servers),\n        transports => maps:keys(State#registry_state.transports),\n        metadata_keys => maps:keys(State#registry_state.metadata),\n        total_routes => State#registry_state.route_count\n    },\n    {reply, Stats, State};\n\nhandle_call(_Request, _From, State) ->\n    {reply, {error, unknown_request}, State}.\n\n-spec handle_cast(term(), state()) -> {noreply, state()}.\n\nhandle_cast({route_to_server, ServerId, TransportId, Message}, State) ->\n    SpanCtx = erlmcp_tracing:start_registry_span(<<\"registry.handle_route_to_server\">>),\n    try\n        MessageSize = case Message of\n            M when is_binary(M) -> byte_size(M);\n            M when is_list(M) -> iolist_size(M);\n            _ -> unknown\n        end,\n        erlmcp_tracing:set_attributes(SpanCtx, #{\n            <<\"server_id\">> => ServerId,\n            <<\"transport_id\">> => TransportId,\n            <<\"message.size\">> => MessageSize\n        }),\n        \n        case get_server_pid(ServerId, State) of\n            {ok, ServerPid} ->\n                erlmcp_tracing:set_attributes(SpanCtx, #{<<\"server_pid\">> => ServerPid}),\n                ServerPid ! {mcp_message, TransportId, Message},\n                erlmcp_tracing:set_status(SpanCtx, ok),\n                {noreply, State};\n            {error, not_found} ->\n                erlmcp_tracing:record_error_details(SpanCtx, server_not_found, ServerId),\n                logger:warning(\"Cannot route to server ~p: not found\", [ServerId]),\n                {noreply, State}\n        end\n    catch\n        Class:Reason:Stacktrace ->\n            erlmcp_tracing:record_exception(SpanCtx, Class, Reason, Stacktrace),\n            {noreply, State}\n    after\n        erlmcp_tracing:end_span(SpanCtx)\n    end;\n\nhandle_cast({route_to_transport, TransportId, ServerId, Message}, State) ->\n    SpanCtx = erlmcp_tracing:start_registry_span(<<\"registry.handle_route_to_transport\">>),\n    try\n        MessageSize = case Message of\n            M when is_binary(M) -> byte_size(M);\n            M when is_list(M) -> iolist_size(M);\n            _ -> unknown\n        end,\n        erlmcp_tracing:set_attributes(SpanCtx, #{\n            <<\"transport_id\">> => TransportId,\n            <<\"server_id\">> => ServerId,\n            <<\"message.size\">> => MessageSize\n        }),\n        \n        case get_transport_pid(TransportId, State) of\n            {ok, TransportPid} ->\n                erlmcp_tracing:set_attributes(SpanCtx, #{<<\"transport_pid\">> => TransportPid}),\n                TransportPid ! {mcp_response, ServerId, Message},\n                erlmcp_tracing:set_status(SpanCtx, ok),\n                {noreply, State};\n            {error, not_found} ->\n                erlmcp_tracing:record_error_details(SpanCtx, transport_not_found, TransportId),\n                logger:warning(\"Cannot route to transport ~p: not found\", [TransportId]),\n                {noreply, State}\n        end\n    catch\n        Class:Reason:Stacktrace ->\n            erlmcp_tracing:record_exception(SpanCtx, Class, Reason, Stacktrace),\n            {noreply, State}\n    after\n        erlmcp_tracing:end_span(SpanCtx)\n    end;\n\nhandle_cast(_Msg, State) ->\n    {noreply, State}.\n\n-spec handle_info(term(), state()) -> \n    {noreply, state()}.\n\nhandle_info({'DOWN', MonitorRef, process, Pid, Reason}, State) ->\n    case maps:get(Pid, State#registry_state.monitors, undefined) of\n        {Id, server} ->\n            logger:warning(\"Server ~p (pid ~p) died: ~p\", [Id, Pid, Reason]),\n            NewState = cleanup_server(Id, Pid, State),\n            {noreply, NewState};\n        {Id, transport} ->\n            logger:warning(\"Transport ~p (pid ~p) died: ~p\", [Id, Pid, Reason]),\n            NewState = cleanup_transport(Id, Pid, State),\n            {noreply, NewState};\n        undefined ->\n            % Try to demonitor in case it's a stale reference\n            catch demonitor(MonitorRef, [flush]),\n            logger:warning(\"Unknown monitored process ~p died: ~p\", [Pid, Reason]),\n            {noreply, State}\n    end;\n\nhandle_info(_Info, State) ->\n    {noreply, State}.\n\n-spec terminate(term(), state()) -> ok.\nterminate(_Reason, State) ->\n    % Clean up all monitors\n    maps:foreach(fun(_Pid, MonitorRef) ->\n        catch demonitor(MonitorRef, [flush])\n    end, State#registry_state.monitor_refs),\n    logger:info(\"MCP registry terminating\"),\n    ok.\n\n-spec code_change(term(), state(), term()) -> {ok, state()}.\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\n%%====================================================================\n%% Internal Functions\n%%====================================================================\n\n-spec get_server_pid(server_id(), state()) -> {ok, pid()} | {error, not_found}.\nget_server_pid(ServerId, State) ->\n    case maps:get(ServerId, State#registry_state.servers, undefined) of\n        undefined -> {error, not_found};\n        {ServerPid, _Config} -> {ok, ServerPid}\n    end.\n\n-spec get_transport_pid(transport_id(), state()) -> {ok, pid()} | {error, not_found}.\nget_transport_pid(TransportId, State) ->\n    case maps:get(TransportId, State#registry_state.transports, undefined) of\n        undefined -> {error, not_found};\n        {TransportPid, _Config} -> {ok, TransportPid}\n    end.\n\n-spec cleanup_server(server_id(), pid(), state()) -> state().\ncleanup_server(ServerId, ServerPid, State) ->\n    % Demonitor if we have a reference\n    case maps:get(ServerPid, State#registry_state.monitor_refs, undefined) of\n        undefined -> ok;\n        MonitorRef -> catch demonitor(MonitorRef, [flush])\n    end,\n    \n    NewServers = maps:remove(ServerId, State#registry_state.servers),\n    NewCapabilities = maps:remove(ServerId, State#registry_state.capabilities),\n    NewMonitors = maps:remove(ServerPid, State#registry_state.monitors),\n    NewMonitorRefs = maps:remove(ServerPid, State#registry_state.monitor_refs),\n    \n    % Remove any transport bindings\n    NewTransportMap = maps:filter(fun(_, SId) -> SId =/= ServerId end,\n                                 State#registry_state.server_transport_map),\n    \n    State#registry_state{\n        servers = NewServers,\n        capabilities = NewCapabilities,\n        server_transport_map = NewTransportMap,\n        monitors = NewMonitors,\n        monitor_refs = NewMonitorRefs\n    }.\n\n-spec cleanup_transport(transport_id(), pid(), state()) -> state().\ncleanup_transport(TransportId, TransportPid, State) ->\n    % Demonitor if we have a reference\n    case maps:get(TransportPid, State#registry_state.monitor_refs, undefined) of\n        undefined -> ok;\n        MonitorRef -> catch demonitor(MonitorRef, [flush])\n    end,\n    \n    NewTransports = maps:remove(TransportId, State#registry_state.transports),\n    NewTransportMap = maps:remove(TransportId, State#registry_state.server_transport_map),\n    NewMonitors = maps:remove(TransportPid, State#registry_state.monitors),\n    NewMonitorRefs = maps:remove(TransportPid, State#registry_state.monitor_refs),\n    \n    State#registry_state{\n        transports = NewTransports,\n        server_transport_map = NewTransportMap,\n        monitors = NewMonitors,\n        monitor_refs = NewMonitorRefs\n    }."
        }
    ]
}