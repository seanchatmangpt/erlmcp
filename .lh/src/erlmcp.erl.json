{
    "sourceFile": "src/erlmcp.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1756188161125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1756188161125,
            "name": "Commit-0",
            "content": "-module(erlmcp).\n\n-include(\"erlmcp.hrl\").\n\n%% Application management API\n-export([\n    start_server/1, start_server/2, stop_server/1, list_servers/0,\n    start_transport/2, start_transport/3, stop_transport/1, list_transports/0,\n    bind_transport_to_server/2, unbind_transport/1\n]).\n\n%% Server operations API\n-export([\n    add_resource/3, add_resource/4,\n    add_tool/3, add_tool/4,\n    add_prompt/3, add_prompt/4\n]).\n\n%% Configuration API\n-export([\n    get_server_config/1, update_server_config/2,\n    get_transport_config/1, update_transport_config/2,\n    validate_transport_config/1, get_config_schema/1,\n    validate_config_field/3\n]).\n\n%% Legacy compatibility for stdio server\n-export([\n    start_stdio_server/0, start_stdio_server/1, stop_stdio_server/0\n]).\n\n%% Convenience functions\n-export([\n    start_stdio_setup/2, start_tcp_setup/3, start_http_setup/3,\n    setup_server_components/2, quick_stdio_server/3,\n    validate_transport_config/2, get_transport_bindings/0,\n    cleanup_transport_bindings/1, list_supported_transport_types/0,\n    get_config_examples/0\n]).\n\n%% Enhanced API functions - Phase 3 Step 7\n-export([\n    format_validation_error/3, format_transport_error/4, format_setup_error/4,\n    get_transport_binding_info/1, list_transport_bindings/0,\n    rebind_transport/2, validate_transport_binding/2,\n    audit_transport_bindings/0, cleanup_failed_setup/3\n]).\n\n%% Types\n-type server_id() :: atom().\n-type transport_id() :: atom().\n-type transport_type() :: stdio | tcp | http.\n\n-export_type([server_id/0, transport_id/0, transport_type/0]).\n\n%%====================================================================\n%% Application Management API - Updated for Phase 2\n%%====================================================================\n\n-spec start_server(server_id()) -> {ok, pid()} | {error, term()}.\nstart_server(ServerId) ->\n    start_server(ServerId, #{}).\n\n-spec start_server(server_id(), map()) -> {ok, pid()} | {error, term()}.\nstart_server(ServerId, Config) ->\n    % Ensure default capabilities if not provided\n    DefaultCaps = #mcp_server_capabilities{\n        resources = #mcp_capability{enabled = true},\n        tools = #mcp_capability{enabled = true},\n        prompts = #mcp_capability{enabled = true}\n    },\n    \n    % Merge with provided config\n    FinalConfig = case maps:get(capabilities, Config, undefined) of\n        undefined ->\n            Config#{capabilities => DefaultCaps};\n        _ ->\n            Config\n    end,\n    \n    % Start server using the refactored erlmcp_server\n    case start_server_process(ServerId, FinalConfig) of\n        {ok, ServerPid} ->\n            % Register with registry if available\n            case register_server_with_registry(ServerId, ServerPid, FinalConfig) of\n                ok -> \n                    logger:info(\"Started and registered server ~p\", [ServerId]),\n                    {ok, ServerPid};\n                {error, Reason} -> \n                    % Registration failed, but server started - log warning and continue\n                    logger:warning(\"Server ~p started but registry registration failed: ~p\", [ServerId, Reason]),\n                    {ok, ServerPid}\n            end;\n        {error, _} = Error ->\n            Error\n    end.\n\n-spec stop_server(server_id()) -> ok | {error, term()}.\nstop_server(ServerId) ->\n    % Try registry approach first\n    case whereis(erlmcp_registry) of\n        undefined ->\n            % No registry, try to find server process by registered name or other means\n            logger:warning(\"Registry not available for server ~p cleanup\", [ServerId]),\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_server(ServerId) of\n                {ok, {ServerPid, _Config}} ->\n                    erlmcp_registry:unregister_server(ServerId),\n                    case is_process_alive(ServerPid) of\n                        true -> \n                            erlmcp_server:stop(ServerPid),\n                            logger:info(\"Stopped server ~p\", [ServerId]),\n                            ok;\n                        false -> \n                            logger:info(\"Server ~p already stopped\", [ServerId]),\n                            ok\n                    end;\n                {error, not_found} ->\n                    logger:warning(\"Server ~p not found in registry\", [ServerId]),\n                    ok\n            end\n    end.\n\n-spec list_servers() -> [{server_id(), {pid(), map()}}].\nlist_servers() ->\n    case whereis(erlmcp_registry) of\n        undefined -> \n            logger:warning(\"Registry not available for listing servers\"),\n            [];\n        _ -> \n            erlmcp_registry:list_servers()\n    end.\n\n-spec start_transport(transport_id(), transport_type()) -> {ok, pid()} | {error, term()}.\nstart_transport(TransportId, Type) ->\n    start_transport(TransportId, Type, #{}).\n\n-spec start_transport(transport_id(), transport_type(), map()) -> {ok, pid()} | {error, term()}.\nstart_transport(TransportId, Type, Config) ->\n    logger:info(\"Starting transport ~p of type ~p with config validation\", [TransportId, Type]),\n    \n    % Enhanced validation using dedicated validation module\n    ConfigWithType = Config#{type => Type},\n    case erlmcp_transport_validation:validate_transport_config(Type, ConfigWithType) of\n        ok ->\n            case start_transport_impl(TransportId, Type, ConfigWithType) of\n                {ok, TransportPid} ->\n                    TransportConfig = ConfigWithType#{\n                        started_at => erlang:timestamp(),\n                        validation_passed => true\n                    },\n                    case register_transport_with_registry(TransportId, TransportPid, TransportConfig) of\n                        ok -> \n                            logger:info(\"Successfully started and registered transport ~p (~p) with validation\", \n                                      [TransportId, Type]),\n                            {ok, TransportPid};\n                        {error, Reason} ->\n                            logger:warning(\"Transport ~p started but registry registration failed: ~p\", \n                                         [TransportId, Reason]),\n                            {ok, TransportPid}\n                    end;\n                {error, Reason} ->\n                    logger:error(\"Failed to start transport ~p (~p): ~p\", [TransportId, Type, Reason]),\n                    erlmcp_transport_behavior:format_transport_error(TransportId, start_failed, Reason)\n            end;\n        {error, ValidationError} ->\n            logger:error(\"Transport config validation failed for ~p (~p): ~p\", \n                        [TransportId, Type, ValidationError]),\n            format_validation_error(TransportId, Type, ValidationError)\n    end.\n\n-spec stop_transport(transport_id()) -> ok | {error, term()}.\nstop_transport(TransportId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_transport(TransportId) of\n                {ok, {TransportPid, _Config}} ->\n                    erlmcp_registry:unregister_transport(TransportId),\n                    case is_process_alive(TransportPid) of\n                        true -> \n                            erlmcp_transport_stdio_new:close(TransportPid),\n                            logger:info(\"Stopped transport ~p\", [TransportId]),\n                            ok;\n                        false -> ok\n                    end;\n                {error, not_found} ->\n                    ok\n            end\n    end.\n\n-spec list_transports() -> [{transport_id(), {pid(), map()}}].\nlist_transports() ->\n    case whereis(erlmcp_registry) of\n        undefined -> [];\n        _ -> erlmcp_registry:list_transports()\n    end.\n\n-spec bind_transport_to_server(transport_id(), server_id()) -> ok | {error, term()}.\nbind_transport_to_server(TransportId, ServerId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            erlmcp_registry:bind_transport_to_server(TransportId, ServerId)\n    end.\n\n-spec unbind_transport(transport_id()) -> ok.\nunbind_transport(TransportId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            erlmcp_registry:unbind_transport(TransportId)\n    end.\n\n%%====================================================================\n%% Server Operations API - Updated for Registry-based Architecture\n%%====================================================================\n\n-spec add_resource(server_id(), binary(), fun()) -> ok | {error, term()}.\nadd_resource(ServerId, Uri, Handler) ->\n    add_resource(ServerId, Uri, Handler, #{}).\n\n-spec add_resource(server_id(), binary(), fun(), map()) -> ok | {error, term()}.\nadd_resource(ServerId, Uri, Handler, Options) ->\n    case find_server_process(ServerId) of\n        {ok, ServerPid} ->\n            case maps:get(template, Options, false) of\n                true ->\n                    Name = maps:get(name, Options, Uri),\n                    erlmcp_server:add_resource_template(ServerPid, Uri, Name, Handler);\n                false ->\n                    erlmcp_server:add_resource(ServerPid, Uri, Handler)\n            end;\n        {error, not_found} ->\n            {error, server_not_found}\n    end.\n\n-spec add_tool(server_id(), binary(), fun()) -> ok | {error, term()}.\nadd_tool(ServerId, Name, Handler) ->\n    add_tool(ServerId, Name, Handler, #{}).\n\n-spec add_tool(server_id(), binary(), fun(), map()) -> ok | {error, term()}.\nadd_tool(ServerId, Name, Handler, Options) ->\n    case find_server_process(ServerId) of\n        {ok, ServerPid} ->\n            case maps:get(schema, Options, undefined) of\n                undefined ->\n                    erlmcp_server:add_tool(ServerPid, Name, Handler);\n                Schema ->\n                    erlmcp_server:add_tool_with_schema(ServerPid, Name, Handler, Schema)\n            end;\n        {error, not_found} ->\n            {error, server_not_found}\n    end.\n\n-spec add_prompt(server_id(), binary(), fun()) -> ok | {error, term()}.\nadd_prompt(ServerId, Name, Handler) ->\n    add_prompt(ServerId, Name, Handler, #{}).\n\n-spec add_prompt(server_id(), binary(), fun(), map()) -> ok | {error, term()}.\nadd_prompt(ServerId, Name, Handler, Options) ->\n    case find_server_process(ServerId) of\n        {ok, ServerPid} ->\n            case maps:get(arguments, Options, undefined) of\n                undefined ->\n                    erlmcp_server:add_prompt(ServerPid, Name, Handler);\n                Arguments ->\n                    erlmcp_server:add_prompt_with_args(ServerPid, Name, Handler, Arguments)\n            end;\n        {error, not_found} ->\n            {error, server_not_found}\n    end.\n\n%%====================================================================\n%% Configuration API\n%%====================================================================\n\n-spec get_server_config(server_id()) -> {ok, map()} | {error, term()}.\nget_server_config(ServerId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_server(ServerId) of\n                {ok, {_ServerPid, Config}} ->\n                    {ok, Config};\n                {error, not_found} ->\n                    {error, server_not_found}\n            end\n    end.\n\n-spec update_server_config(server_id(), map()) -> ok | {error, term()}.\nupdate_server_config(ServerId, NewConfig) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_server(ServerId) of\n                {ok, {ServerPid, OldConfig}} ->\n                    UpdatedConfig = maps:merge(OldConfig, NewConfig),\n                    erlmcp_registry:register_server(ServerId, ServerPid, UpdatedConfig);\n                {error, not_found} ->\n                    {error, server_not_found}\n            end\n    end.\n\n-spec get_transport_config(transport_id()) -> {ok, map()} | {error, term()}.\nget_transport_config(TransportId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_transport(TransportId) of\n                {ok, {_TransportPid, Config}} ->\n                    {ok, Config};\n                {error, not_found} ->\n                    {error, transport_not_found}\n            end\n    end.\n\n-spec update_transport_config(transport_id(), map()) -> ok | {error, term()}.\nupdate_transport_config(TransportId, NewConfig) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_transport(TransportId) of\n                {ok, {TransportPid, OldConfig}} ->\n                    UpdatedConfig = maps:merge(OldConfig, NewConfig),\n                    % Validate the updated configuration\n                    case validate_transport_config(UpdatedConfig) of\n                        ok ->\n                            erlmcp_registry:register_transport(TransportId, TransportPid, UpdatedConfig);\n                        {error, ValidationError} ->\n                            {error, ValidationError}\n                    end;\n                {error, not_found} ->\n                    {error, transport_not_found}\n            end\n    end.\n\n%%====================================================================\n%% Configuration Validation API - Enhanced with Schema Support\n%%====================================================================\n\n%% @doc Configuration schema definitions for all transport types\n-define(STDIO_CONFIG_SCHEMA, #{\n    required_fields => [type],\n    optional_fields => [server_id, test_mode, buffer_size],\n    field_validators => #{\n        type => fun(stdio) -> ok; (_) -> {error, \"must be 'stdio'\"} end,\n        server_id => fun(Id) when is_atom(Id) -> ok; (_) -> {error, \"must be an atom\"} end,\n        test_mode => fun(Bool) when is_boolean(Bool) -> ok; (_) -> {error, \"must be boolean\"} end,\n        buffer_size => fun(Size) when is_integer(Size), Size > 0 -> ok; (_) -> {error, \"must be positive integer\"} end\n    },\n    description => \"STDIO transport configuration for direct process communication\"\n}).\n\n-define(TCP_CONFIG_SCHEMA, #{\n    required_fields => [type, host, port],\n    optional_fields => [keepalive, connect_timeout, max_reconnect_attempts, server_id, ssl, certfile, keyfile],\n    field_validators => #{\n        type => fun(tcp) -> ok; (_) -> {error, \"must be 'tcp'\"} end,\n        host => fun(H) when is_binary(H); is_list(H) -> \n            case iolist_size([H]) > 0 of\n                true -> ok;\n                false -> {error, \"cannot be empty\"}\n            end;\n            (_) -> {error, \"must be binary or string\"}\n        end,\n        port => fun(P) when is_integer(P), P >= 1, P =< 65535 -> ok;\n            (_) -> {error, \"must be integer between 1 and 65535\"}\n        end,\n        keepalive => fun(Bool) when is_boolean(Bool) -> ok; (_) -> {error, \"must be boolean\"} end,\n        connect_timeout => fun(T) when is_integer(T), T > 0 -> ok; (_) -> {error, \"must be positive integer (milliseconds)\"} end,\n        max_reconnect_attempts => fun(A) when is_integer(A), A >= 0 -> ok; (_) -> {error, \"must be non-negative integer\"} end,\n        ssl => fun(Bool) when is_boolean(Bool) -> ok; (_) -> {error, \"must be boolean\"} end,\n        certfile => fun(F) when is_list(F) -> \n            case filelib:is_file(F) of\n                true -> ok;\n                false -> {error, \"SSL certificate file does not exist\"}\n            end;\n            (_) -> {error, \"must be valid file path\"}\n        end,\n        keyfile => fun(F) when is_list(F) -> \n            case filelib:is_file(F) of\n                true -> ok;\n                false -> {error, \"SSL key file does not exist\"}\n            end;\n            (_) -> {error, \"must be valid file path\"}\n        end\n    },\n    description => \"TCP transport configuration for network communication\"\n}).\n\n-define(HTTP_CONFIG_SCHEMA, #{\n    required_fields => [type, url],\n    optional_fields => [method, headers, timeout, server_id, cors, max_body_size],\n    field_validators => #{\n        type => fun(http) -> ok; (_) -> {error, \"must be 'http'\"} end,\n        url => fun(U) when is_binary(U); is_list(U) -> \n            case validate_url_format(iolist_to_binary([U])) of\n                true -> ok;\n                false -> {error, \"must be valid HTTP/HTTPS URL\"}\n            end;\n            (_) -> {error, \"must be binary or string\"}\n        end,\n        method => fun(M) when M =:= get; M =:= post; M =:= put; M =:= delete; \n                             M =:= patch; M =:= head; M =:= options -> ok;\n            (_) -> {error, \"must be valid HTTP method (get|post|put|delete|patch|head|options)\"}\n        end,\n        headers => fun(H) when is_map(H) -> validate_http_headers(H);\n            (_) -> {error, \"must be a map of header name/value pairs\"}\n        end,\n        timeout => fun(T) when is_integer(T), T > 0 -> ok; (_) -> {error, \"must be positive integer (milliseconds)\"} end,\n        cors => fun(false) -> ok;\n                   (true) -> ok;\n                   (Origins) when is_list(Origins) -> \n                       try\n                           lists:foreach(fun\n                               (Origin) when is_binary(Origin); is_list(Origin) -> ok;\n                               (_) -> throw({error, \"CORS origins must be strings\"})\n                           end, Origins),\n                           ok\n                       catch\n                           throw:Error -> Error\n                       end;\n                   (_) -> {error, \"must be boolean or list of origin URLs\"}\n                end,\n        max_body_size => fun(Size) when is_integer(Size), Size > 0 -> ok; (_) -> {error, \"must be positive integer (bytes)\"} end\n    },\n    description => \"HTTP transport configuration for web-based communication\"\n}).\n\n%% @doc Validate transport configuration using schema-based approach\n-spec validate_transport_config(map()) -> ok | {error, term()}.\nvalidate_transport_config(Config) ->\n    case maps:get(type, Config, undefined) of\n        undefined ->\n            format_validation_error(missing_required_field, type, \n                \"Configuration must specify transport type. Valid types: stdio, tcp, http\");\n        Type ->\n            validate_transport_config_with_schema(Type, Config)\n    end.\n\n%% @doc Enhanced schema-based validation\n-spec validate_transport_config_with_schema(atom(), map()) -> ok | {error, term()}.\nvalidate_transport_config_with_schema(stdio, Config) ->\n    validate_config_against_schema(Config, ?STDIO_CONFIG_SCHEMA);\nvalidate_transport_config_with_schema(tcp, Config) ->\n    validate_config_against_schema(Config, ?TCP_CONFIG_SCHEMA);\nvalidate_transport_config_with_schema(http, Config) ->\n    validate_config_against_schema(Config, ?HTTP_CONFIG_SCHEMA);\nvalidate_transport_config_with_schema(Type, _Config) ->\n    format_validation_error(unknown_transport_type, Type, \n        \"Unknown transport type. Supported types: stdio, tcp, http\").\n\n%% @doc Generic schema validation\n-spec validate_config_against_schema(map(), map()) -> ok | {error, term()}.\nvalidate_config_against_schema(Config, Schema) ->\n    RequiredFields = maps:get(required_fields, Schema),\n    OptionalFields = maps:get(optional_fields, Schema),\n    FieldValidators = maps:get(field_validators, Schema),\n    Description = maps:get(description, Schema),\n    \n    case validate_schema_fields(Config, RequiredFields, OptionalFields) of\n        ok ->\n            validate_schema_field_values(Config, FieldValidators);\n        {error, {validation_error, ErrorType, Field}} ->\n            case ErrorType of\n                missing_required_field ->\n                    format_validation_error(ErrorType, Field, \n                        io_lib:format(\"Required field missing for ~s. Required fields: ~p\", \n                                     [Description, RequiredFields]));\n                unknown_field ->\n                    AllowedFields = RequiredFields ++ OptionalFields,\n                    format_validation_error(ErrorType, Field, \n                        io_lib:format(\"Unknown field for ~s. Allowed fields: ~p\", \n                                     [Description, AllowedFields]));\n                _ ->\n                    {error, {validation_error, ErrorType, Field}}\n            end;\n        Error ->\n            Error\n    end.\n\n%% @doc Validate schema field presence and allowed fields\n-spec validate_schema_fields(map(), [atom()], [atom()]) -> ok | {error, term()}.\nvalidate_schema_fields(Config, RequiredFields, OptionalFields) ->\n    case validate_required_fields(Config, RequiredFields) of\n        ok ->\n            AllowedFields = RequiredFields ++ OptionalFields,\n            validate_allowed_fields(Config, AllowedFields);\n        Error ->\n            Error\n    end.\n\n%% @doc Validate field values using validators\n-spec validate_schema_field_values(map(), map()) -> ok | {error, term()}.\nvalidate_schema_field_values(Config, FieldValidators) ->\n    try\n        maps:fold(fun(Field, Value, _Acc) ->\n            case maps:get(Field, FieldValidators, undefined) of\n                undefined -> ok; % Field not in schema validators, skip\n                Validator when is_function(Validator, 1) ->\n                    case Validator(Value) of\n                        ok -> ok;\n                        {error, Reason} ->\n                            throw({validation_error, invalid_field_value, Field, Reason})\n                    end\n            end\n        end, ok, Config),\n        ok\n    catch\n        throw:{validation_error, ErrorType, Field, Reason} ->\n            format_validation_error(ErrorType, Field, Reason)\n    end.\n\n%% @doc Format validation errors with helpful messages\n-spec format_validation_error(atom(), term(), string()) -> {error, term()}.\nformat_validation_error(ErrorType, Field, Reason) ->\n    FormattedReason = case io_lib:char_list(Reason) of\n        true -> Reason;\n        false -> io_lib:format(\"~p\", [Reason])\n    end,\n    {error, {\n        validation_error, \n        ErrorType, \n        Field, \n        lists:flatten(FormattedReason)\n    }}.\n\n%% @doc Legacy validation function - now delegates to schema-based approach\n-spec validate_transport_config_by_type(atom(), map()) -> ok | {error, term()}.\nvalidate_transport_config_by_type(Type, Config) ->\n    validate_transport_config_with_schema(Type, Config).\n\n\n%% @doc Helper function to validate required and optional fields\n-spec validate_fields(map(), [atom()], [atom()]) -> ok | {error, term()}.\nvalidate_fields(Config, RequiredFields, OptionalFields) ->\n    case validate_required_fields(Config, RequiredFields) of\n        ok ->\n            validate_allowed_fields(Config, RequiredFields ++ OptionalFields);\n        Error ->\n            Error\n    end.\n\n%% @doc Validate that all required fields are present\n-spec validate_required_fields(map(), [atom()]) -> ok | {error, term()}.\nvalidate_required_fields(Config, RequiredFields) ->\n    Missing = [Field || Field <- RequiredFields, not maps:is_key(Field, Config)],\n    case Missing of\n        [] ->\n            ok;\n        [Field] ->\n            {error, {validation_error, missing_required_field, Field}};\n        Fields ->\n            {error, {validation_error, missing_required_fields, Fields}}\n    end.\n\n%% @doc Validate that only allowed fields are present\n-spec validate_allowed_fields(map(), [atom()]) -> ok | {error, term()}.\nvalidate_allowed_fields(Config, AllowedFields) ->\n    ConfigFields = maps:keys(Config),\n    Unknown = [Field || Field <- ConfigFields, not lists:member(Field, AllowedFields)],\n    case Unknown of\n        [] ->\n            ok;\n        [Field] ->\n            {error, {validation_error, unknown_field, Field, \n                     io_lib:format(\"allowed fields: ~p\", [AllowedFields])}};\n        Fields ->\n            {error, {validation_error, unknown_fields, Fields,\n                     io_lib:format(\"allowed fields: ~p\", [AllowedFields])}}\n    end.\n\n%% @doc Validate TCP-specific fields\n-spec validate_tcp_fields(map()) -> ok | {error, term()}.\nvalidate_tcp_fields(Config) ->\n    % Validate host\n    case validate_host_field(maps:get(host, Config)) of\n        ok ->\n            % Validate port\n            case validate_port_field(maps:get(port, Config)) of\n                ok ->\n                    % Validate optional fields\n                    validate_tcp_optional_fields(Config);\n                Error ->\n                    Error\n            end;\n        Error ->\n            Error\n    end.\n\n%% @doc Validate TCP optional fields\n-spec validate_tcp_optional_fields(map()) -> ok | {error, term()}.\nvalidate_tcp_optional_fields(Config) ->\n    % Validate keepalive\n    case maps:get(keepalive, Config, undefined) of\n        undefined -> \n            % Continue to next validation\n            validate_tcp_connect_timeout(Config);\n        Boolean when is_boolean(Boolean) -> \n            % Continue to next validation\n            validate_tcp_connect_timeout(Config);\n        _ -> {error, {validation_error, invalid_field_type, keepalive, \"must be boolean\"}}\n    end.\n\n%% @doc Validate TCP connect_timeout field\n-spec validate_tcp_connect_timeout(map()) -> ok | {error, term()}.\nvalidate_tcp_connect_timeout(Config) ->\n    case maps:get(connect_timeout, Config, undefined) of\n        undefined -> \n            validate_tcp_max_reconnect(Config);\n        Timeout when is_integer(Timeout), Timeout > 0 -> \n            validate_tcp_max_reconnect(Config);\n        _ -> {error, {validation_error, invalid_field_type, connect_timeout, \"must be positive integer\"}}\n    end.\n\n%% @doc Validate TCP max_reconnect_attempts field\n-spec validate_tcp_max_reconnect(map()) -> ok | {error, term()}.\nvalidate_tcp_max_reconnect(Config) ->\n    case maps:get(max_reconnect_attempts, Config, undefined) of\n        undefined -> ok;\n        Attempts when is_integer(Attempts), Attempts >= 0 -> ok;\n        _ -> {error, {validation_error, invalid_field_type, max_reconnect_attempts, \"must be non-negative integer\"}}\n    end.\n\n%% @doc Validate HTTP-specific fields\n-spec validate_http_fields(map()) -> ok | {error, term()}.\nvalidate_http_fields(Config) ->\n    % Validate URL\n    case validate_url_field(maps:get(url, Config)) of\n        ok ->\n            validate_http_optional_fields(Config);\n        Error ->\n            Error\n    end.\n\n%% @doc Validate HTTP optional fields\n-spec validate_http_optional_fields(map()) -> ok | {error, term()}.\nvalidate_http_optional_fields(Config) ->\n    % Validate method\n    case maps:get(method, Config, get) of\n        Method when Method =:= get; Method =:= post; Method =:= put; Method =:= delete; \n                   Method =:= patch; Method =:= head; Method =:= options -> \n            validate_http_headers_field(Config);\n        _ -> {error, {validation_error, invalid_field_value, method, \"must be valid HTTP method\"}}\n    end.\n\n%% @doc Validate HTTP headers field\n-spec validate_http_headers_field(map()) -> ok | {error, term()}.\nvalidate_http_headers_field(Config) ->\n    case maps:get(headers, Config, undefined) of\n        undefined -> \n            validate_http_timeout_field(Config);\n        Headers when is_map(Headers) -> \n            case validate_http_headers(Headers) of\n                ok -> validate_http_timeout_field(Config);\n                Error -> Error\n            end;\n        _ -> {error, {validation_error, invalid_field_type, headers, \"must be a map\"}}\n    end.\n\n%% @doc Validate HTTP timeout field\n-spec validate_http_timeout_field(map()) -> ok | {error, term()}.\nvalidate_http_timeout_field(Config) ->\n    case maps:get(timeout, Config, undefined) of\n        undefined -> ok;\n        Timeout when is_integer(Timeout), Timeout > 0 -> ok;\n        _ -> {error, {validation_error, invalid_field_type, timeout, \"must be positive integer\"}}\n    end.\n\n%% @doc Validate HTTP headers map\n-spec validate_http_headers(map()) -> ok | {error, term()}.\nvalidate_http_headers(Headers) ->\n    try\n        maps:fold(fun(Key, Value, _Acc) ->\n            case {is_binary(Key) orelse is_list(Key), is_binary(Value) orelse is_list(Value)} of\n                {true, true} -> ok;\n                {false, _} -> throw({error, {validation_error, invalid_header_key, Key, \"must be binary or string\"}});\n                {_, false} -> throw({error, {validation_error, invalid_header_value, Value, \"must be binary or string\"}})\n            end\n        end, ok, Headers),\n        ok\n    catch\n        throw:Error -> Error\n    end.\n\n%% @doc Validate host field\n-spec validate_host_field(term()) -> ok | {error, term()}.\nvalidate_host_field(Host) when is_binary(Host) ->\n    case byte_size(Host) > 0 of\n        true -> ok;\n        false -> {error, {validation_error, invalid_field_value, host, \"cannot be empty\"}}\n    end;\nvalidate_host_field(Host) when is_list(Host) ->\n    case length(Host) > 0 of\n        true -> ok;\n        false -> {error, {validation_error, invalid_field_value, host, \"cannot be empty\"}}\n    end;\nvalidate_host_field(_) ->\n    {error, {validation_error, invalid_field_type, host, \"must be binary or string\"}}.\n\n%% @doc Validate port field\n-spec validate_port_field(term()) -> ok | {error, term()}.\nvalidate_port_field(Port) when is_integer(Port), Port > 0, Port =< 65535 ->\n    ok;\nvalidate_port_field(Port) when is_integer(Port) ->\n    {error, {validation_error, invalid_field_value, port, \"must be between 1 and 65535\"}};\nvalidate_port_field(_) ->\n    {error, {validation_error, invalid_field_type, port, \"must be integer\"}}.\n\n%% @doc Validate URL field\n-spec validate_url_field(term()) -> ok | {error, term()}.\nvalidate_url_field(Url) when is_binary(Url) ->\n    case validate_url_format(Url) of\n        true -> ok;\n        false -> {error, {validation_error, invalid_field_value, url, \"must be valid HTTP/HTTPS URL\"}}\n    end;\nvalidate_url_field(Url) when is_list(Url) ->\n    case validate_url_format(list_to_binary(Url)) of\n        true -> ok;\n        false -> {error, {validation_error, invalid_field_value, url, \"must be valid HTTP/HTTPS URL\"}}\n    end;\nvalidate_url_field(_) ->\n    {error, {validation_error, invalid_field_type, url, \"must be binary or string\"}}.\n\n%% @doc Simple URL format validation\n-spec validate_url_format(binary()) -> boolean().\nvalidate_url_format(Url) ->\n    case binary:split(Url, <<\"://\">>) of\n        [Scheme, _Rest] when Scheme =:= <<\"http\">>; Scheme =:= <<\"https\">> ->\n            byte_size(Url) > 10;  % Basic length check\n        _ ->\n            false\n    end.\n\n%%====================================================================\n%% Legacy Compatibility API - Enhanced for Phase 2\n%%====================================================================\n\n-spec start_stdio_server() -> {ok, pid()} | {error, term()}.\nstart_stdio_server() ->\n    start_stdio_server(#{}).\n\n-spec start_stdio_server(map()) -> {ok, pid()} | {error, term()}.\nstart_stdio_server(Options) ->\n    % Use the new architecture by default, fall back to legacy if needed\n    case is_new_architecture_available() of\n        true ->\n            % Use new registry-based approach\n            case start_stdio_setup(default_stdio_server, Options) of\n                {ok, #{server := ServerPid}} ->\n                    {ok, ServerPid};\n                {error, _} = Error ->\n                    % Fall back to legacy approach\n                    logger:warning(\"New stdio setup failed, falling back to legacy: ~p\", [Error]),\n                    start_legacy_stdio_server(Options)\n            end;\n        false ->\n            % Registry not available, use legacy approach\n            start_legacy_stdio_server(Options)\n    end.\n\n-spec stop_stdio_server() -> ok.\nstop_stdio_server() ->\n    % Try new architecture first\n    case is_new_architecture_available() of\n        true ->\n            _ = stop_transport(default_stdio_transport),\n            _ = stop_server(default_stdio_server),\n            % Also stop legacy server if it exists\n            stop_legacy_stdio_server(),\n            ok;\n        false ->\n            % Fall back to legacy approach\n            stop_legacy_stdio_server(),\n            ok\n    end.\n\n%%====================================================================\n%% Convenience Functions - Updated for Phase 2\n%%====================================================================\n\n%% Create a complete MCP server setup with stdio transport\n-spec start_stdio_setup(server_id(), map()) -> {ok, #{server => pid(), transport => pid()}} | {error, term()}.\nstart_stdio_setup(ServerId, Config) ->\n    case start_server(ServerId, Config) of\n        {ok, ServerPid} ->\n            TransportId = create_transport_id(ServerId, <<\"stdio\">>),\n            TransportConfig = #{server_id => ServerId},\n            case start_transport(TransportId, stdio, TransportConfig) of\n                {ok, TransportPid} ->\n                    % Ensure they're bound together\n                    case bind_transport_to_server(TransportId, ServerId) of\n                        ok ->\n                            {ok, #{server => ServerPid, transport => TransportPid}};\n                        {error, BindError} ->\n                            logger:warning(\"Server and transport started but binding failed: ~p\", [BindError]),\n                            {ok, #{server => ServerPid, transport => TransportPid}}\n                    end;\n                {error, TransportError} ->\n                    _ = stop_server(ServerId),\n                    {error, TransportError}\n            end;\n        {error, _} = ServerError ->\n            ServerError\n    end.\n\n%% Create a complete MCP server setup with TCP transport\n-spec start_tcp_setup(server_id(), map(), map()) -> {ok, #{server => pid(), transport => pid()}} | {error, term()}.\nstart_tcp_setup(ServerId, ServerConfig, TcpConfig) ->\n    logger:info(\"Setting up TCP server ~p with enhanced validation\", [ServerId]),\n    \n    % Enhanced validation with detailed error reporting\n    case erlmcp_transport_validation:validate_transport_config(tcp, TcpConfig) of\n        ok ->\n            case start_server(ServerId, ServerConfig) of\n                {ok, ServerPid} ->\n                    TransportId = create_transport_id(ServerId, <<\"tcp\">>),\n                    % Enhanced config with validation metadata\n                    TransportConfig = maps:merge(#{\n                        server_id => ServerId,\n                        transport_type => tcp,\n                        setup_type => convenience_function\n                    }, TcpConfig),\n                    \n                    case start_transport(TransportId, tcp, TransportConfig) of\n                        {ok, TransportPid} ->\n                            case bind_transport_to_server(TransportId, ServerId) of\n                                ok ->\n                                    logger:info(\"TCP setup completed successfully for ~p (~p:~p)\", \n                                              [ServerId, maps:get(host, TcpConfig, \"localhost\"), \n                                               maps:get(port, TcpConfig, 8080)]),\n                                    {ok, #{server => ServerPid, transport => TransportPid, \n                                          transport_id => TransportId, config => TransportConfig}};\n                                {error, BindError} ->\n                                    logger:warning(\"TCP server ~p started but binding failed: ~p\", \n                                                 [ServerId, BindError]),\n                                    {ok, #{server => ServerPid, transport => TransportPid,\n                                          transport_id => TransportId, binding_warning => BindError}}\n                            end;\n                        {error, TransportError} ->\n                            logger:error(\"TCP transport setup failed for ~p: ~p\", [ServerId, TransportError]),\n                            cleanup_failed_setup(ServerId, tcp, TransportError)\n                    end;\n                {error, ServerError} ->\n                    logger:error(\"Server setup failed for TCP ~p: ~p\", [ServerId, ServerError]),\n                    format_setup_error(ServerId, tcp, server_start_failed, ServerError)\n            end;\n        {error, ValidationError} ->\n            logger:error(\"TCP config validation failed for ~p: ~p\", [ServerId, ValidationError]),\n            format_validation_error(ServerId, tcp, ValidationError)\n    end.\n\n%% Create a complete MCP server setup with HTTP transport\n-spec start_http_setup(server_id(), map(), map()) -> {ok, #{server => pid(), transport => pid()}} | {error, term()}.\nstart_http_setup(ServerId, ServerConfig, HttpConfig) ->\n    logger:info(\"Setting up HTTP server ~p with enhanced validation\", [ServerId]),\n    \n    % Enhanced validation with detailed error reporting\n    case erlmcp_transport_validation:validate_transport_config(http, HttpConfig) of\n        ok ->\n            case start_server(ServerId, ServerConfig) of\n                {ok, ServerPid} ->\n                    TransportId = create_transport_id(ServerId, <<\"http\">>),\n                    % Enhanced config with validation metadata\n                    TransportConfig = maps:merge(#{\n                        server_id => ServerId,\n                        transport_type => http,\n                        setup_type => convenience_function\n                    }, HttpConfig),\n                    \n                    case start_transport(TransportId, http, TransportConfig) of\n                        {ok, TransportPid} ->\n                            case bind_transport_to_server(TransportId, ServerId) of\n                                ok ->\n                                    logger:info(\"HTTP setup completed successfully for ~p (~s)\", \n                                              [ServerId, maps:get(url, HttpConfig, \"http://localhost:8000/mcp\")]),\n                                    {ok, #{server => ServerPid, transport => TransportPid, \n                                          transport_id => TransportId, config => TransportConfig}};\n                                {error, BindError} ->\n                                    logger:warning(\"HTTP server ~p started but binding failed: ~p\", \n                                                 [ServerId, BindError]),\n                                    {ok, #{server => ServerPid, transport => TransportPid,\n                                          transport_id => TransportId, binding_warning => BindError}}\n                            end;\n                        {error, TransportError} ->\n                            logger:error(\"HTTP transport setup failed for ~p: ~p\", [ServerId, TransportError]),\n                            cleanup_failed_setup(ServerId, http, TransportError)\n                    end;\n                {error, ServerError} ->\n                    logger:error(\"Server setup failed for HTTP ~p: ~p\", [ServerId, ServerError]),\n                    format_setup_error(ServerId, http, server_start_failed, ServerError)\n            end;\n        {error, ValidationError} ->\n            logger:error(\"HTTP config validation failed for ~p: ~p\", [ServerId, ValidationError]),\n            format_validation_error(ServerId, http, ValidationError)\n    end.\n\n%% Batch add multiple resources, tools, and prompts\n-spec setup_server_components(server_id(), map()) -> ok | {error, term()}.\nsetup_server_components(ServerId, Components) ->\n    Resources = maps:get(resources, Components, []),\n    Tools = maps:get(tools, Components, []),\n    Prompts = maps:get(prompts, Components, []),\n    \n    try\n        % Add resources\n        lists:foreach(fun\n            ({Uri, Handler}) ->\n                ok = add_resource(ServerId, Uri, Handler);\n            ({Uri, Handler, Options}) ->\n                ok = add_resource(ServerId, Uri, Handler, Options)\n        end, Resources),\n        \n        % Add tools\n        lists:foreach(fun\n            ({Name, Handler}) ->\n                ok = add_tool(ServerId, Name, Handler);\n            ({Name, Handler, Options}) ->\n                ok = add_tool(ServerId, Name, Handler, Options)\n        end, Tools),\n        \n        % Add prompts\n        lists:foreach(fun\n            ({Name, Handler}) ->\n                ok = add_prompt(ServerId, Name, Handler);\n            ({Name, Handler, Options}) ->\n                ok = add_prompt(ServerId, Name, Handler, Options)\n        end, Prompts),\n        \n        ok\n    catch\n        error:{badmatch, {error, Reason}} ->\n            {error, Reason};\n        Class:Exception ->\n            {error, {Class, Exception}}\n    end.\n\n%% Quick way to create a complete stdio MCP server with components\n-spec quick_stdio_server(server_id(), map(), map()) -> {ok, #{server => pid(), transport => pid()}} | {error, term()}.\nquick_stdio_server(ServerId, ServerConfig, Components) ->\n    case start_stdio_setup(ServerId, ServerConfig) of\n        {ok, Result} ->\n            case setup_server_components(ServerId, Components) of\n                ok ->\n                    {ok, Result};\n                {error, SetupError} ->\n                    TransportId = create_transport_id(ServerId, <<\"stdio\">>),\n                    _ = stop_server(ServerId),\n                    _ = stop_transport(TransportId),\n                    {error, SetupError}\n            end;\n        {error, _} = Error ->\n            Error\n    end.\n\n%%====================================================================\n%% Configuration Schema and Documentation API\n%%====================================================================\n\n%% @doc Get configuration schema for a transport type\n-spec get_config_schema(atom()) -> {ok, map()} | {error, term()}.\nget_config_schema(stdio) -> {ok, ?STDIO_CONFIG_SCHEMA};\nget_config_schema(tcp) -> {ok, ?TCP_CONFIG_SCHEMA};\nget_config_schema(http) -> {ok, ?HTTP_CONFIG_SCHEMA};\nget_config_schema(Type) -> {error, {unknown_transport_type, Type}}.\n\n%% @doc Validate a single configuration field\n-spec validate_config_field(atom(), atom(), term()) -> ok | {error, term()}.\nvalidate_config_field(TransportType, Field, Value) ->\n    case get_config_schema(TransportType) of\n        {ok, Schema} ->\n            FieldValidators = maps:get(field_validators, Schema),\n            case maps:get(Field, FieldValidators, undefined) of\n                undefined ->\n                    {error, {unknown_field, Field, TransportType}};\n                Validator when is_function(Validator, 1) ->\n                    case Validator(Value) of\n                        ok -> ok;\n                        {error, Reason} -> \n                            format_validation_error(invalid_field_value, Field, Reason)\n                    end\n            end;\n        Error -> Error\n    end.\n\n%% @doc List all supported transport types\n-spec list_supported_transport_types() -> [atom()].\nlist_supported_transport_types() ->\n    [stdio, tcp, http].\n\n%% @doc Get example configurations for all transport types\n-spec get_config_examples() -> map().\nget_config_examples() ->\n    #{\n        stdio => #{\n            type => stdio,\n            server_id => my_server,\n            test_mode => false,\n            buffer_size => 8192\n        },\n        tcp => #{\n            type => tcp,\n            host => \"localhost\",\n            port => 8080,\n            keepalive => true,\n            connect_timeout => 5000,\n            max_reconnect_attempts => 3,\n            ssl => false\n        },\n        http => #{\n            type => http,\n            url => \"https://api.example.com/mcp\",\n            method => post,\n            headers => #{<<\"Content-Type\">> => <<\"application/json\">>},\n            timeout => 30000,\n            cors => true,\n            max_body_size => 1048576\n        }\n    }.\n\n%%====================================================================\n%% Enhanced API Functions - Phase 3\n%%====================================================================\n\n%% Transport implementation helper\n-spec start_transport_impl(transport_id(), transport_type(), map()) -> {ok, pid()} | {error, term()}.\nstart_transport_impl(TransportId, stdio, Config) ->\n    erlmcp_transport_stdio_new:start_link(TransportId, Config);\nstart_transport_impl(_TransportId, tcp, Config) ->\n    % Placeholder for TCP implementation\n    Port = maps:get(port, Config, 8080),\n    Host = maps:get(host, Config, \"localhost\"),\n    logger:info(\"TCP transport would start on ~s:~p\", [Host, Port]),\n    {error, {transport_not_implemented, tcp}};\nstart_transport_impl(_TransportId, http, Config) ->\n    % Placeholder for HTTP implementation\n    Port = maps:get(port, Config, 8000),\n    Path = maps:get(path, Config, \"/mcp\"),\n    logger:info(\"HTTP transport would start on port ~p path ~s\", [Port, Path]),\n    {error, {transport_not_implemented, http}};\nstart_transport_impl(_TransportId, Type, _Config) ->\n    {error, {unknown_transport_type, Type}}.\n\n%% Enhanced configuration validation (delegated to validation module)\n-spec validate_transport_config(transport_type(), map()) -> ok | {error, term()}.\nvalidate_transport_config(Type, Config) ->\n    % Delegate to validation module for comprehensive validation\n    erlmcp_transport_validation:validate_transport_config(Type, Config).\n\n%% Get all transport bindings\n-spec get_transport_bindings() -> [{transport_id(), server_id()}] | {error, term()}.\nget_transport_bindings() ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            try\n                Transports = erlmcp_registry:list_transports(),\n                Bindings = lists:filtermap(fun({TransportId, {_Pid, Config}}) ->\n                    case maps:get(server_id, Config, undefined) of\n                        undefined -> false;\n                        ServerId -> {true, {TransportId, ServerId}}\n                    end\n                end, Transports),\n                Bindings\n            catch\n                _:Error -> {error, Error}\n            end\n    end.\n\n%% Cleanup orphaned transport bindings\n-spec cleanup_transport_bindings(server_id()) -> ok | {error, term()}.\ncleanup_transport_bindings(ServerId) ->\n    case get_transport_bindings() of\n        {error, _} = Error -> Error;\n        Bindings ->\n            OrphanedTransports = [TId || {TId, SId} <- Bindings, SId =:= ServerId],\n            lists:foreach(fun(TransportId) ->\n                case unbind_transport(TransportId) of\n                    ok -> \n                        logger:info(\"Cleaned up orphaned transport binding: ~p\", [TransportId]);\n                    {error, Reason} -> \n                        logger:warning(\"Failed to cleanup transport binding ~p: ~p\", [TransportId, Reason])\n                end\n            end, OrphanedTransports),\n            ok\n    end.\n\n%%====================================================================\n%% Internal Helper Functions - Phase 2 Specific\n%%====================================================================\n\n-spec start_server_process(server_id(), map()) -> {ok, pid()} | {error, term()}.\nstart_server_process(ServerId, Config) ->\n    % Try supervisor approach first, fall back to direct start\n    case whereis(erlmcp_server_sup) of\n        undefined ->\n            % Supervisor not available, create server directly\n            Capabilities = maps:get(capabilities, Config, #mcp_server_capabilities{}),\n            erlmcp_server:start_link(ServerId, Capabilities);\n        _Pid ->\n            % Use supervisor\n            erlmcp_server_sup:start_child(ServerId, Config)\n    end.\n\n-spec register_server_with_registry(server_id(), pid(), map()) -> ok | {error, term()}.\nregister_server_with_registry(ServerId, ServerPid, Config) ->\n    case whereis(erlmcp_registry) of\n        undefined -> \n            % Registry not available - this is OK for some deployments\n            ok;\n        _ -> \n            erlmcp_registry:register_server(ServerId, ServerPid, Config)\n    end.\n\n-spec register_transport_with_registry(transport_id(), pid(), map()) -> ok | {error, term()}.\nregister_transport_with_registry(TransportId, TransportPid, Config) ->\n    case whereis(erlmcp_registry) of\n        undefined -> \n            ok; % Registry not available - this is OK\n        _ -> \n            erlmcp_registry:register_transport(TransportId, TransportPid, Config)\n    end.\n\n-spec find_server_process(server_id()) -> {ok, pid()} | {error, not_found}.\nfind_server_process(ServerId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            % Registry not available, try other approaches\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_server(ServerId) of\n                {ok, {ServerPid, _Config}} ->\n                    {ok, ServerPid};\n                {error, not_found} ->\n                    {error, not_found}\n            end\n    end.\n\n-spec is_new_architecture_available() -> boolean().\nis_new_architecture_available() ->\n    whereis(erlmcp_registry) =/= undefined andalso\n    whereis(erlmcp_server_sup) =/= undefined andalso\n    whereis(erlmcp_transport_sup) =/= undefined.\n\n-spec create_transport_id(server_id(), binary()) -> transport_id().\ncreate_transport_id(ServerId, Type) ->\n    binary_to_atom(<<(atom_to_binary(ServerId))/binary, \"_\", Type/binary>>, utf8).\n\n%%====================================================================\n%% Legacy Support Functions\n%%====================================================================\n\n-spec start_legacy_stdio_server(map()) -> {ok, pid()} | {error, term()}.\nstart_legacy_stdio_server(Options) ->\n    case erlmcp_stdio_server:start_link(Options) of\n        {ok, ServerPid} ->\n            % Register as default stdio server if registry is available\n            case whereis(erlmcp_registry) of\n                undefined -> \n                    {ok, ServerPid};\n                _ ->\n                    ServerConfig = #{\n                        capabilities => #mcp_server_capabilities{\n                            resources = #mcp_capability{enabled = true},\n                            tools = #mcp_capability{enabled = true},\n                            prompts = #mcp_capability{enabled = true}\n                        },\n                        options => Options,\n                        legacy => true\n                    },\n                    case erlmcp_registry:register_server(default_stdio_server, ServerPid, ServerConfig) of\n                        ok -> {ok, ServerPid};\n                        {error, already_registered} -> {ok, ServerPid};\n                        {error, Reason} -> \n                            logger:warning(\"Legacy server started but registration failed: ~p\", [Reason]),\n                            {ok, ServerPid}\n                    end\n            end;\n        Error -> Error\n    end.\n\n-spec stop_legacy_stdio_server() -> ok.\nstop_legacy_stdio_server() ->\n    case whereis(erlmcp_stdio_server) of\n        undefined -> ok;\n        _Pid -> \n            erlmcp_stdio_server:stop(),\n            ok\n    end.\n\n%%====================================================================\n%% Enhanced Error Handling Functions - Phase 3 Step 7\n%%====================================================================\n\n%% @doc Format transport error with context\n-spec format_transport_error(transport_id(), transport_type(), atom(), term()) -> \n    {error, term()}.\nformat_transport_error(TransportId, Type, ErrorType, Reason) ->\n    {error, #{\n        error_type => ErrorType,\n        transport_id => TransportId,\n        transport_type => Type,\n        reason => Reason,\n        suggestion => get_transport_suggestion(Type, ErrorType, Reason),\n        timestamp => erlang:timestamp()\n    }}.\n\n%% @doc Format setup error with context\n-spec format_setup_error(server_id(), transport_type(), atom(), term()) -> \n    {error, term()}.\nformat_setup_error(ServerId, Type, ErrorType, Reason) ->\n    {error, #{\n        error_type => ErrorType,\n        server_id => ServerId,\n        transport_type => Type,\n        reason => Reason,\n        suggestion => get_setup_suggestion(Type, ErrorType),\n        timestamp => erlang:timestamp()\n    }}.\n\n%% @doc Format validation error details\n-spec format_validation_details(term()) -> map().\nformat_validation_details({validation_error, ErrorType, Field, Message}) ->\n    #{\n        type => ErrorType,\n        field => Field,\n        message => Message,\n        severity => error\n    };\nformat_validation_details(Errors) when is_list(Errors) ->\n    #{\n        type => multiple_validation_errors,\n        errors => [format_validation_details(E) || E <- Errors],\n        severity => error\n    };\nformat_validation_details(Error) ->\n    #{\n        type => unknown_validation_error,\n        details => Error,\n        severity => error\n    }.\n\n%% @doc Get validation suggestion based on error\n-spec get_validation_suggestion(transport_type(), term()) -> string().\nget_validation_suggestion(tcp, {validation_error, missing_field, host, _}) ->\n    \"TCP transport requires 'host' field. Example: #{host => \\\"localhost\\\"}\";\nget_validation_suggestion(tcp, {validation_error, missing_field, port, _}) ->\n    \"TCP transport requires 'port' field. Example: #{port => 8080}\";\nget_validation_suggestion(tcp, {validation_error, invalid_value, port, _}) ->\n    \"TCP port must be between 1 and 65535. Example: #{port => 8080}\";\nget_validation_suggestion(http, {validation_error, missing_field, url, _}) ->\n    \"HTTP transport requires 'url' field. Example: #{url => \\\"http://localhost:8000/mcp\\\"}\";\nget_validation_suggestion(http, {validation_error, invalid_value, url, _}) ->\n    \"HTTP URL must be valid HTTP/HTTPS URL. Example: #{url => \\\"https://api.example.com/mcp\\\"}\";\nget_validation_suggestion(stdio, {validation_error, invalid_type, test_mode, _}) ->\n    \"STDIO test_mode must be boolean. Example: #{test_mode => true}\";\nget_validation_suggestion(_Type, Error) ->\n    io_lib:format(\"Check transport configuration documentation. Error: ~p\", [Error]).\n\n%% @doc Get transport suggestion based on error\n-spec get_transport_suggestion(transport_type(), atom(), term()) -> string().\nget_transport_suggestion(tcp, start_failed, {port_in_use, Port}) ->\n    io_lib:format(\"Port ~p is already in use. Try a different port number\", [Port]);\nget_transport_suggestion(tcp, start_failed, connection_refused) ->\n    \"Connection refused. Check if the target host is reachable and accepting connections\";\nget_transport_suggestion(http, start_failed, {port_in_use, Port}) ->\n    io_lib:format(\"HTTP port ~p is already in use. Try a different port\", [Port]);\nget_transport_suggestion(http, start_failed, invalid_url) ->\n    \"Invalid HTTP URL format. Use format: http://host:port/path or https://host:port/path\";\nget_transport_suggestion(stdio, start_failed, _Reason) ->\n    \"STDIO transport failed. Ensure standard input/output streams are available\";\nget_transport_suggestion(Type, ErrorType, Reason) ->\n    io_lib:format(\"Transport ~p failed with ~p: ~p. Check transport logs for details\", \n                  [Type, ErrorType, Reason]).\n\n%% @doc Get setup suggestion based on error\n-spec get_setup_suggestion(transport_type(), atom()) -> string().\nget_setup_suggestion(_Type, server_start_failed) ->\n    \"Server startup failed. Check server configuration and ensure required dependencies are available\";\nget_setup_suggestion(tcp, transport_start_failed) ->\n    \"TCP transport setup failed. Verify host/port availability and network configuration\";\nget_setup_suggestion(http, transport_start_failed) ->\n    \"HTTP transport setup failed. Check URL accessibility and server configuration\";\nget_setup_suggestion(Type, ErrorType) ->\n    io_lib:format(\"Setup failed for ~p transport with error ~p. Check system logs and configuration\", \n                  [Type, ErrorType]).\n\n%% @doc Clean up after failed setup\n-spec cleanup_failed_setup(server_id(), transport_type(), term()) -> {error, term()}.\ncleanup_failed_setup(ServerId, Type, TransportError) ->\n    logger:info(\"Cleaning up after failed ~p setup for server ~p\", [Type, ServerId]),\n    _ = stop_server(ServerId),\n    format_setup_error(ServerId, Type, transport_start_failed, TransportError).\n\n%%====================================================================\n%% Enhanced Transport Binding Management - Phase 3 Step 7\n%%====================================================================\n\n%% @doc Get detailed transport binding information\n-spec get_transport_binding_info(transport_id()) -> {ok, map()} | {error, term()}.\nget_transport_binding_info(TransportId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_transport(TransportId) of\n                {ok, {TransportPid, Config}} ->\n                    ServerId = maps:get(server_id, Config, undefined),\n                    {ok, #{\n                        transport_id => TransportId,\n                        transport_pid => TransportPid,\n                        server_id => ServerId,\n                        transport_type => maps:get(type, Config, unknown),\n                        bound => ServerId =/= undefined,\n                        config => Config,\n                        status => get_process_status(TransportPid)\n                    }};\n                {error, not_found} ->\n                    {error, transport_not_found}\n            end\n    end.\n\n%% @doc List all transport bindings with detailed information\n-spec list_transport_bindings() -> [{transport_id(), map()}] | {error, term()}.\nlist_transport_bindings() ->\n    case get_transport_bindings() of\n        {error, _} = Error -> Error;\n        Bindings ->\n            DetailedBindings = lists:map(fun({TransportId, ServerId}) ->\n                case get_transport_binding_info(TransportId) of\n                    {ok, Info} -> {TransportId, Info#{server_id => ServerId}};\n                    {error, _} -> {TransportId, #{server_id => ServerId, status => unknown}}\n                end\n            end, Bindings),\n            DetailedBindings\n    end.\n\n%% @doc Force rebind transport to different server\n-spec rebind_transport(transport_id(), server_id()) -> ok | {error, term()}.\nrebind_transport(TransportId, NewServerId) ->\n    case unbind_transport(TransportId) of\n        ok ->\n            case bind_transport_to_server(TransportId, NewServerId) of\n                ok ->\n                    logger:info(\"Successfully rebound transport ~p to server ~p\", \n                              [TransportId, NewServerId]),\n                    ok;\n                {error, Reason} = Error ->\n                    logger:error(\"Failed to rebind transport ~p to server ~p: ~p\", \n                               [TransportId, NewServerId, Reason]),\n                    Error\n            end;\n        {error, Reason} = Error ->\n            logger:error(\"Failed to unbind transport ~p before rebinding: ~p\", \n                       [TransportId, Reason]),\n            Error\n    end.\n\n%% @doc Validate transport binding compatibility\n-spec validate_transport_binding(transport_id(), server_id()) -> ok | {error, term()}.\nvalidate_transport_binding(TransportId, ServerId) ->\n    case {get_transport_config(TransportId), get_server_config(ServerId)} of\n        {{ok, TransportConfig}, {ok, ServerConfig}} ->\n            TransportType = maps:get(type, TransportConfig, unknown),\n            ServerCapabilities = maps:get(capabilities, ServerConfig, #{}),\n            \n            case is_compatible_binding(TransportType, ServerCapabilities) of\n                true -> ok;\n                false -> {error, {incompatible_binding, \n                                 io_lib:format(\"Transport ~p not compatible with server ~p\", \n                                             [TransportType, ServerId])}}\n            end;\n        {{error, transport_not_found}, _} ->\n            {error, transport_not_found};\n        {_, {error, server_not_found}} ->\n            {error, server_not_found};\n        {Error, _} ->\n            Error\n    end.\n\n%% @doc Check if binding is compatible\n-spec is_compatible_binding(atom(), map()) -> boolean().\nis_compatible_binding(stdio, _ServerCapabilities) ->\n    true; % STDIO is compatible with all servers\nis_compatible_binding(tcp, ServerCapabilities) ->\n    % TCP requires network-capable server\n    maps:get(network_enabled, ServerCapabilities, true);\nis_compatible_binding(http, ServerCapabilities) ->\n    % HTTP requires web-capable server\n    maps:get(web_enabled, ServerCapabilities, true) andalso\n    maps:get(http_enabled, ServerCapabilities, true);\nis_compatible_binding(_Type, _Capabilities) ->\n    false.\n\n%% @doc Get process status\n-spec get_process_status(pid()) -> atom().\nget_process_status(Pid) ->\n    case is_process_alive(Pid) of\n        true -> \n            case process_info(Pid, status) of\n                {status, Status} -> Status;\n                undefined -> dead\n            end;\n        false -> dead\n    end.\n\n%% @doc Audit transport bindings for consistency\n-spec audit_transport_bindings() -> {ok, map()} | {error, term()}.\naudit_transport_bindings() ->\n    case list_transport_bindings() of\n        {error, _} = Error -> Error;\n        Bindings ->\n            Issues = lists:foldl(fun({TransportId, Info}, Acc) ->\n                case audit_single_binding(TransportId, Info) of\n                    [] -> Acc;\n                    BindingIssues -> [{TransportId, BindingIssues} | Acc]\n                end\n            end, [], Bindings),\n            \n            {ok, #{\n                total_bindings => length(Bindings),\n                healthy_bindings => length(Bindings) - length(Issues),\n                issues => Issues,\n                audit_time => erlang:timestamp()\n            }}\n    end.\n\n%% @doc Audit single binding\n-spec audit_single_binding(transport_id(), map()) -> [atom()].\naudit_single_binding(TransportId, Info) ->\n    Issues = [],\n    \n    % Check if transport process is alive\n    Issues1 = case maps:get(status, Info, unknown) of\n        dead -> [dead_transport | Issues];\n        _ -> Issues\n    end,\n    \n    % Check if server binding is valid\n    Issues2 = case maps:get(server_id, Info, undefined) of\n        undefined -> [unbound_transport | Issues1];\n        SrvId ->\n            case get_server_config(SrvId) of\n                {ok, _} -> Issues1;\n                {error, server_not_found} -> [orphaned_binding | Issues1];\n                {error, _} -> [server_unreachable | Issues1]\n            end\n    end,\n    \n    % Check transport type compatibility\n    Issues3 = case maps:get(server_id, Info, undefined) of\n        undefined -> Issues2;\n        ServerIdForBinding ->\n            case validate_transport_binding(TransportId, ServerIdForBinding) of\n                ok -> Issues2;\n                {error, {incompatible_binding, _}} -> [incompatible_binding | Issues2];\n                {error, _} -> [binding_validation_failed | Issues2]\n            end\n    end,\n    \n    Issues3.\n"
        }
    ]
}