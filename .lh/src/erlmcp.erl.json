{
    "sourceFile": "src/erlmcp.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1756188161125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756189552603,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,50 +2,31 @@\n \n -include(\"erlmcp.hrl\").\n \n %% Application management API\n--export([\n-    start_server/1, start_server/2, stop_server/1, list_servers/0,\n-    start_transport/2, start_transport/3, stop_transport/1, list_transports/0,\n-    bind_transport_to_server/2, unbind_transport/1\n-]).\n-\n+-export([start_server/1, start_server/2, stop_server/1, list_servers/0, start_transport/2,\n+         start_transport/3, stop_transport/1, list_transports/0, bind_transport_to_server/2,\n+         unbind_transport/1]).\n %% Server operations API\n--export([\n-    add_resource/3, add_resource/4,\n-    add_tool/3, add_tool/4,\n-    add_prompt/3, add_prompt/4\n-]).\n-\n+-export([add_resource/3, add_resource/4, add_tool/3, add_tool/4, add_prompt/3,\n+         add_prompt/4]).\n %% Configuration API\n--export([\n-    get_server_config/1, update_server_config/2,\n-    get_transport_config/1, update_transport_config/2,\n-    validate_transport_config/1, get_config_schema/1,\n-    validate_config_field/3\n-]).\n-\n+-export([get_server_config/1, update_server_config/2, get_transport_config/1,\n+         update_transport_config/2, validate_transport_config/1, get_config_schema/1,\n+         validate_config_field/3]).\n %% Legacy compatibility for stdio server\n--export([\n-    start_stdio_server/0, start_stdio_server/1, stop_stdio_server/0\n-]).\n-\n+-export([start_stdio_server/0, start_stdio_server/1, stop_stdio_server/0]).\n %% Convenience functions\n--export([\n-    start_stdio_setup/2, start_tcp_setup/3, start_http_setup/3,\n-    setup_server_components/2, quick_stdio_server/3,\n-    validate_transport_config/2, get_transport_bindings/0,\n-    cleanup_transport_bindings/1, list_supported_transport_types/0,\n-    get_config_examples/0\n-]).\n-\n+-export([start_stdio_setup/2, start_tcp_setup/3, start_http_setup/3,\n+         setup_server_components/2, quick_stdio_server/3, validate_transport_config/2,\n+         get_transport_bindings/0, cleanup_transport_bindings/1, list_supported_transport_types/0,\n+         get_config_examples/0]).\n %% Enhanced API functions - Phase 3 Step 7\n--export([\n-    format_validation_error/3, format_transport_error/4, format_setup_error/4,\n-    get_transport_binding_info/1, list_transport_bindings/0,\n-    rebind_transport/2, validate_transport_binding/2,\n-    audit_transport_bindings/0, cleanup_failed_setup/3\n-]).\n+-export([format_validation_error/3, format_validation_error_enhanced/3, format_transport_error/4, format_setup_error/4,\n+         get_transport_binding_info/1, list_transport_bindings/0, rebind_transport/2,\n+         validate_transport_binding/2, audit_transport_bindings/0, cleanup_failed_setup/3,\n+         validate_setup_prerequisites/1, ensure_transport_supervisor/0, retry_transport_binding/3,\n+         get_enhanced_transport_status/1, bulk_transport_operation/2, cleanup_stale_transports/0]).\n \n %% Types\n -type server_id() :: atom().\n -type transport_id() :: atom().\n@@ -63,33 +44,34 @@\n \n -spec start_server(server_id(), map()) -> {ok, pid()} | {error, term()}.\n start_server(ServerId, Config) ->\n     % Ensure default capabilities if not provided\n-    DefaultCaps = #mcp_server_capabilities{\n-        resources = #mcp_capability{enabled = true},\n-        tools = #mcp_capability{enabled = true},\n-        prompts = #mcp_capability{enabled = true}\n-    },\n-    \n+    DefaultCaps =\n+        #mcp_server_capabilities{resources = #mcp_capability{enabled = true},\n+                                 tools = #mcp_capability{enabled = true},\n+                                 prompts = #mcp_capability{enabled = true}},\n+\n     % Merge with provided config\n-    FinalConfig = case maps:get(capabilities, Config, undefined) of\n-        undefined ->\n-            Config#{capabilities => DefaultCaps};\n-        _ ->\n-            Config\n-    end,\n-    \n+    FinalConfig =\n+        case maps:get(capabilities, Config, undefined) of\n+            undefined ->\n+                Config#{capabilities => DefaultCaps};\n+            _ ->\n+                Config\n+        end,\n+\n     % Start server using the refactored erlmcp_server\n     case start_server_process(ServerId, FinalConfig) of\n         {ok, ServerPid} ->\n             % Register with registry if available\n             case register_server_with_registry(ServerId, ServerPid, FinalConfig) of\n-                ok -> \n+                ok ->\n                     logger:info(\"Started and registered server ~p\", [ServerId]),\n                     {ok, ServerPid};\n-                {error, Reason} -> \n+                {error, Reason} ->\n                     % Registration failed, but server started - log warning and continue\n-                    logger:warning(\"Server ~p started but registry registration failed: ~p\", [ServerId, Reason]),\n+                    logger:warning(\"Server ~p started but registry registration failed: ~p\",\n+                                   [ServerId, Reason]),\n                     {ok, ServerPid}\n             end;\n         {error, _} = Error ->\n             Error\n@@ -107,13 +89,13 @@\n             case erlmcp_registry:find_server(ServerId) of\n                 {ok, {ServerPid, _Config}} ->\n                     erlmcp_registry:unregister_server(ServerId),\n                     case is_process_alive(ServerPid) of\n-                        true -> \n+                        true ->\n                             erlmcp_server:stop(ServerPid),\n                             logger:info(\"Stopped server ~p\", [ServerId]),\n                             ok;\n-                        false -> \n+                        false ->\n                             logger:info(\"Server ~p already stopped\", [ServerId]),\n                             ok\n                     end;\n                 {error, not_found} ->\n@@ -124,51 +106,68 @@\n \n -spec list_servers() -> [{server_id(), {pid(), map()}}].\n list_servers() ->\n     case whereis(erlmcp_registry) of\n-        undefined -> \n+        undefined ->\n             logger:warning(\"Registry not available for listing servers\"),\n             [];\n-        _ -> \n+        _ ->\n             erlmcp_registry:list_servers()\n     end.\n \n -spec start_transport(transport_id(), transport_type()) -> {ok, pid()} | {error, term()}.\n start_transport(TransportId, Type) ->\n     start_transport(TransportId, Type, #{}).\n \n--spec start_transport(transport_id(), transport_type(), map()) -> {ok, pid()} | {error, term()}.\n+-spec start_transport(transport_id(), transport_type(), map()) ->\n+                         {ok, pid()} | {error, term()}.\n start_transport(TransportId, Type, Config) ->\n-    logger:info(\"Starting transport ~p of type ~p with config validation\", [TransportId, Type]),\n-    \n-    % Enhanced validation using dedicated validation module\n+    logger:info(\"Starting transport ~p of type ~p with enhanced validation\",\n+                [TransportId, Type]),\n+\n+    % Enhanced validation using dedicated validation module with comprehensive error handling\n     ConfigWithType = Config#{type => Type},\n     case erlmcp_transport_validation:validate_transport_config(Type, ConfigWithType) of\n         ok ->\n-            case start_transport_impl(TransportId, Type, ConfigWithType) of\n-                {ok, TransportPid} ->\n-                    TransportConfig = ConfigWithType#{\n-                        started_at => erlang:timestamp(),\n-                        validation_passed => true\n-                    },\n-                    case register_transport_with_registry(TransportId, TransportPid, TransportConfig) of\n-                        ok -> \n-                            logger:info(\"Successfully started and registered transport ~p (~p) with validation\", \n-                                      [TransportId, Type]),\n-                            {ok, TransportPid};\n+            % Ensure transport supervisor is available\n+            case ensure_transport_supervisor() of\n+                ok ->\n+                    case start_transport_impl(TransportId, Type, ConfigWithType) of\n+                        {ok, TransportPid} ->\n+                            % Enhanced transport configuration with metadata\n+                            TransportConfig =\n+                                ConfigWithType#{started_at => erlang:timestamp(),\n+                                                validation_passed => true,\n+                                                transport_version => \"1.0\",\n+                                                startup_method => enhanced_api},\n+                            case register_transport_with_registry(TransportId,\n+                                                                  TransportPid,\n+                                                                  TransportConfig)\n+                            of\n+                                ok ->\n+                                    logger:info(\"Successfully started and registered transport ~p (~p) with \"\n+                                                \"enhanced validation\",\n+                                                [TransportId, Type]),\n+                                    {ok, TransportPid};\n+                                {error, Reason} ->\n+                                    logger:warning(\"Transport ~p started but registry registration failed: ~p\",\n+                                                   [TransportId, Reason]),\n+                                    {ok, TransportPid}\n+                            end;\n                         {error, Reason} ->\n-                            logger:warning(\"Transport ~p started but registry registration failed: ~p\", \n-                                         [TransportId, Reason]),\n-                            {ok, TransportPid}\n+                            logger:error(\"Failed to start transport ~p (~p): ~p\",\n+                                         [TransportId, Type, Reason]),\n+                            format_transport_error(TransportId, Type, start_failed, Reason)\n                     end;\n-                {error, Reason} ->\n-                    logger:error(\"Failed to start transport ~p (~p): ~p\", [TransportId, Type, Reason]),\n-                    erlmcp_transport_behavior:format_transport_error(TransportId, start_failed, Reason)\n+                {error, SupervisorError} ->\n+                    logger:error(\"Transport supervisor unavailable for ~p (~p): ~p\",\n+                                 [TransportId, Type, SupervisorError]),\n+                    format_setup_error(TransportId, Type, supervisor_unavailable, SupervisorError)\n             end;\n         {error, ValidationError} ->\n-            logger:error(\"Transport config validation failed for ~p (~p): ~p\", \n-                        [TransportId, Type, ValidationError]),\n-            format_validation_error(TransportId, Type, ValidationError)\n+            logger:error(\"Transport config validation failed for ~p (~p): ~p\",\n+                         [TransportId, Type, ValidationError]),\n+            format_validation_error_enhanced(TransportId, Type, ValidationError)\n     end.\n \n -spec stop_transport(transport_id()) -> ok | {error, term()}.\n stop_transport(TransportId) ->\n@@ -179,13 +178,14 @@\n             case erlmcp_registry:find_transport(TransportId) of\n                 {ok, {TransportPid, _Config}} ->\n                     erlmcp_registry:unregister_transport(TransportId),\n                     case is_process_alive(TransportPid) of\n-                        true -> \n+                        true ->\n                             erlmcp_transport_stdio_new:close(TransportPid),\n                             logger:info(\"Stopped transport ~p\", [TransportId]),\n                             ok;\n-                        false -> ok\n+                        false ->\n+                            ok\n                     end;\n                 {error, not_found} ->\n                     ok\n             end\n@@ -193,10 +193,12 @@\n \n -spec list_transports() -> [{transport_id(), {pid(), map()}}].\n list_transports() ->\n     case whereis(erlmcp_registry) of\n-        undefined -> [];\n-        _ -> erlmcp_registry:list_transports()\n+        undefined ->\n+            [];\n+        _ ->\n+            erlmcp_registry:list_transports()\n     end.\n \n -spec bind_transport_to_server(transport_id(), server_id()) -> ok | {error, term()}.\n bind_transport_to_server(TransportId, ServerId) ->\n@@ -333,9 +335,11 @@\n                     UpdatedConfig = maps:merge(OldConfig, NewConfig),\n                     % Validate the updated configuration\n                     case validate_transport_config(UpdatedConfig) of\n                         ok ->\n-                            erlmcp_registry:register_transport(TransportId, TransportPid, UpdatedConfig);\n+                            erlmcp_registry:register_transport(TransportId,\n+                                                               TransportPid,\n+                                                               UpdatedConfig);\n                         {error, ValidationError} ->\n                             {error, ValidationError}\n                     end;\n                 {error, not_found} ->\n@@ -347,103 +351,204 @@\n %% Configuration Validation API - Enhanced with Schema Support\n %%====================================================================\n \n %% @doc Configuration schema definitions for all transport types\n--define(STDIO_CONFIG_SCHEMA, #{\n-    required_fields => [type],\n-    optional_fields => [server_id, test_mode, buffer_size],\n-    field_validators => #{\n-        type => fun(stdio) -> ok; (_) -> {error, \"must be 'stdio'\"} end,\n-        server_id => fun(Id) when is_atom(Id) -> ok; (_) -> {error, \"must be an atom\"} end,\n-        test_mode => fun(Bool) when is_boolean(Bool) -> ok; (_) -> {error, \"must be boolean\"} end,\n-        buffer_size => fun(Size) when is_integer(Size), Size > 0 -> ok; (_) -> {error, \"must be positive integer\"} end\n-    },\n-    description => \"STDIO transport configuration for direct process communication\"\n-}).\n+-define(STDIO_CONFIG_SCHEMA,\n+        #{required_fields => [type],\n+          optional_fields => [server_id, test_mode, buffer_size],\n+          field_validators =>\n+              #{type =>\n+                    fun (stdio) ->\n+                            ok;\n+                        (_) ->\n+                            {error, \"must be 'stdio'\"}\n+                    end,\n+                server_id =>\n+                    fun (Id) when is_atom(Id) ->\n+                            ok;\n+                        (_) ->\n+                            {error, \"must be an atom\"}\n+                    end,\n+                test_mode =>\n+                    fun (Bool) when is_boolean(Bool) ->\n+                            ok;\n+                        (_) ->\n+                            {error, \"must be boolean\"}\n+                    end,\n+                buffer_size =>\n+                    fun (Size) when is_integer(Size), Size > 0 ->\n+                            ok;\n+                        (_) ->\n+                            {error, \"must be positive integer\"}\n+                    end},\n+          description => \"STDIO transport configuration for direct process communication\"}).\n+-define(TCP_CONFIG_SCHEMA,\n+        #{required_fields => [type, host, port],\n+          optional_fields =>\n+              [keepalive,\n+               connect_timeout,\n+               max_reconnect_attempts,\n+               server_id,\n+               ssl,\n+               certfile,\n+               keyfile],\n+          field_validators =>\n+              #{type =>\n+                    fun (tcp) ->\n+                            ok;\n+                        (_) ->\n+                            {error, \"must be 'tcp'\"}\n+                    end,\n+                host =>\n+                    fun (H) when is_binary(H); is_list(H) ->\n+                            case iolist_size([H]) > 0 of\n+                                true ->\n+                                    ok;\n+                                false ->\n+                                    {error, \"cannot be empty\"}\n+                            end;\n+                        (_) ->\n+                            {error, \"must be binary or string\"}\n+                    end,\n+                port =>\n+                    fun (P) when is_integer(P), P >= 1, P =< 65535 ->\n+                            ok;\n+                        (_) ->\n+                            {error, \"must be integer between 1 and 65535\"}\n+                    end,\n+                keepalive =>\n+                    fun (Bool) when is_boolean(Bool) ->\n+                            ok;\n+                        (_) ->\n+                            {error, \"must be boolean\"}\n+                    end,\n+                connect_timeout =>\n+                    fun (T) when is_integer(T), T > 0 ->\n+                            ok;\n+                        (_) ->\n+                            {error, \"must be positive integer (milliseconds)\"}\n+                    end,\n+                max_reconnect_attempts =>\n+                    fun (A) when is_integer(A), A >= 0 ->\n+                            ok;\n+                        (_) ->\n+                            {error, \"must be non-negative integer\"}\n+                    end,\n+                ssl =>\n+                    fun (Bool) when is_boolean(Bool) ->\n+                            ok;\n+                        (_) ->\n+                            {error, \"must be boolean\"}\n+                    end,\n+                certfile =>\n+                    fun (F) when is_list(F) ->\n+                            case filelib:is_file(F) of\n+                                true ->\n+                                    ok;\n+                                false ->\n+                                    {error, \"SSL certificate file does not exist\"}\n+                            end;\n+                        (_) ->\n+                            {error, \"must be valid file path\"}\n+                    end,\n+                keyfile =>\n+                    fun (F) when is_list(F) ->\n+                            case filelib:is_file(F) of\n+                                true ->\n+                                    ok;\n+                                false ->\n+                                    {error, \"SSL key file does not exist\"}\n+                            end;\n+                        (_) ->\n+                            {error, \"must be valid file path\"}\n+                    end},\n+          description => \"TCP transport configuration for network communication\"}).\n+-define(HTTP_CONFIG_SCHEMA,\n+        #{required_fields => [type, url],\n+          optional_fields => [method, headers, timeout, server_id, cors, max_body_size],\n+          field_validators =>\n+              #{type =>\n+                    fun (http) ->\n+                            ok;\n+                        (_) ->\n+                            {error, \"must be 'http'\"}\n+                    end,\n+                url =>\n+                    fun (U) when is_binary(U); is_list(U) ->\n+                            case validate_url_format(iolist_to_binary([U])) of\n+                                true ->\n+                                    ok;\n+                                false ->\n+                                    {error, \"must be valid HTTP/HTTPS URL\"}\n+                            end;\n+                        (_) ->\n+                            {error, \"must be binary or string\"}\n+                    end,\n+                method =>\n+                    fun (M)\n+                            when M =:= get;\n+                                 M =:= post;\n+                                 M =:= put;\n+                                 M =:= delete;\n+                                 M =:= patch;\n+                                 M =:= head;\n+                                 M =:= options ->\n+                            ok;\n+                        (_) ->\n+                            {error,\n+                             \"must be valid HTTP method (get|post|put|delete|patch|head|options)\"}\n+                    end,\n+                headers =>\n+                    fun (H) when is_map(H) ->\n+                            validate_http_headers(H);\n+                        (_) ->\n+                            {error, \"must be a map of header name/value pairs\"}\n+                    end,\n+                timeout =>\n+                    fun (T) when is_integer(T), T > 0 ->\n+                            ok;\n+                        (_) ->\n+                            {error, \"must be positive integer (milliseconds)\"}\n+                    end,\n+                cors =>\n+                    fun (false) ->\n+                            ok;\n+                        (true) ->\n+                            ok;\n+                        (Origins) when is_list(Origins) ->\n+                            try\n+                                lists:foreach(fun (Origin)\n+                                                      when is_binary(Origin); is_list(Origin) ->\n+                                                      ok;\n+                                                  (_) ->\n+                                                      throw({error, \"CORS origins must be strings\"})\n+                                              end,\n+                                              Origins),\n+                                ok\n+                            catch\n+                                Error ->\n+                                    Error\n+                            end;\n+                        (_) ->\n+                            {error, \"must be boolean or list of origin URLs\"}\n+                    end,\n+                max_body_size =>\n+                    fun (Size) when is_integer(Size), Size > 0 ->\n+                            ok;\n+                        (_) ->\n+                            {error, \"must be positive integer (bytes)\"}\n+                    end},\n+          description => \"HTTP transport configuration for web-based communication\"}).\n \n--define(TCP_CONFIG_SCHEMA, #{\n-    required_fields => [type, host, port],\n-    optional_fields => [keepalive, connect_timeout, max_reconnect_attempts, server_id, ssl, certfile, keyfile],\n-    field_validators => #{\n-        type => fun(tcp) -> ok; (_) -> {error, \"must be 'tcp'\"} end,\n-        host => fun(H) when is_binary(H); is_list(H) -> \n-            case iolist_size([H]) > 0 of\n-                true -> ok;\n-                false -> {error, \"cannot be empty\"}\n-            end;\n-            (_) -> {error, \"must be binary or string\"}\n-        end,\n-        port => fun(P) when is_integer(P), P >= 1, P =< 65535 -> ok;\n-            (_) -> {error, \"must be integer between 1 and 65535\"}\n-        end,\n-        keepalive => fun(Bool) when is_boolean(Bool) -> ok; (_) -> {error, \"must be boolean\"} end,\n-        connect_timeout => fun(T) when is_integer(T), T > 0 -> ok; (_) -> {error, \"must be positive integer (milliseconds)\"} end,\n-        max_reconnect_attempts => fun(A) when is_integer(A), A >= 0 -> ok; (_) -> {error, \"must be non-negative integer\"} end,\n-        ssl => fun(Bool) when is_boolean(Bool) -> ok; (_) -> {error, \"must be boolean\"} end,\n-        certfile => fun(F) when is_list(F) -> \n-            case filelib:is_file(F) of\n-                true -> ok;\n-                false -> {error, \"SSL certificate file does not exist\"}\n-            end;\n-            (_) -> {error, \"must be valid file path\"}\n-        end,\n-        keyfile => fun(F) when is_list(F) -> \n-            case filelib:is_file(F) of\n-                true -> ok;\n-                false -> {error, \"SSL key file does not exist\"}\n-            end;\n-            (_) -> {error, \"must be valid file path\"}\n-        end\n-    },\n-    description => \"TCP transport configuration for network communication\"\n-}).\n-\n--define(HTTP_CONFIG_SCHEMA, #{\n-    required_fields => [type, url],\n-    optional_fields => [method, headers, timeout, server_id, cors, max_body_size],\n-    field_validators => #{\n-        type => fun(http) -> ok; (_) -> {error, \"must be 'http'\"} end,\n-        url => fun(U) when is_binary(U); is_list(U) -> \n-            case validate_url_format(iolist_to_binary([U])) of\n-                true -> ok;\n-                false -> {error, \"must be valid HTTP/HTTPS URL\"}\n-            end;\n-            (_) -> {error, \"must be binary or string\"}\n-        end,\n-        method => fun(M) when M =:= get; M =:= post; M =:= put; M =:= delete; \n-                             M =:= patch; M =:= head; M =:= options -> ok;\n-            (_) -> {error, \"must be valid HTTP method (get|post|put|delete|patch|head|options)\"}\n-        end,\n-        headers => fun(H) when is_map(H) -> validate_http_headers(H);\n-            (_) -> {error, \"must be a map of header name/value pairs\"}\n-        end,\n-        timeout => fun(T) when is_integer(T), T > 0 -> ok; (_) -> {error, \"must be positive integer (milliseconds)\"} end,\n-        cors => fun(false) -> ok;\n-                   (true) -> ok;\n-                   (Origins) when is_list(Origins) -> \n-                       try\n-                           lists:foreach(fun\n-                               (Origin) when is_binary(Origin); is_list(Origin) -> ok;\n-                               (_) -> throw({error, \"CORS origins must be strings\"})\n-                           end, Origins),\n-                           ok\n-                       catch\n-                           throw:Error -> Error\n-                       end;\n-                   (_) -> {error, \"must be boolean or list of origin URLs\"}\n-                end,\n-        max_body_size => fun(Size) when is_integer(Size), Size > 0 -> ok; (_) -> {error, \"must be positive integer (bytes)\"} end\n-    },\n-    description => \"HTTP transport configuration for web-based communication\"\n-}).\n-\n %% @doc Validate transport configuration using schema-based approach\n -spec validate_transport_config(map()) -> ok | {error, term()}.\n validate_transport_config(Config) ->\n     case maps:get(type, Config, undefined) of\n         undefined ->\n-            format_validation_error(missing_required_field, type, \n-                \"Configuration must specify transport type. Valid types: stdio, tcp, http\");\n+            format_validation_error(missing_required_field,\n+                                    type,\n+                                    \"Configuration must specify transport type. Valid types: stdio, \"\n+                                    \"tcp, http\");\n         Type ->\n             validate_transport_config_with_schema(Type, Config)\n     end.\n \n@@ -455,33 +560,36 @@\n     validate_config_against_schema(Config, ?TCP_CONFIG_SCHEMA);\n validate_transport_config_with_schema(http, Config) ->\n     validate_config_against_schema(Config, ?HTTP_CONFIG_SCHEMA);\n validate_transport_config_with_schema(Type, _Config) ->\n-    format_validation_error(unknown_transport_type, Type, \n-        \"Unknown transport type. Supported types: stdio, tcp, http\").\n+    format_validation_error(unknown_transport_type,\n+                            Type,\n+                            \"Unknown transport type. Supported types: stdio, tcp, http\").\n \n %% @doc Generic schema validation\n -spec validate_config_against_schema(map(), map()) -> ok | {error, term()}.\n validate_config_against_schema(Config, Schema) ->\n     RequiredFields = maps:get(required_fields, Schema),\n     OptionalFields = maps:get(optional_fields, Schema),\n     FieldValidators = maps:get(field_validators, Schema),\n     Description = maps:get(description, Schema),\n-    \n+\n     case validate_schema_fields(Config, RequiredFields, OptionalFields) of\n         ok ->\n             validate_schema_field_values(Config, FieldValidators);\n         {error, {validation_error, ErrorType, Field}} ->\n             case ErrorType of\n                 missing_required_field ->\n-                    format_validation_error(ErrorType, Field, \n-                        io_lib:format(\"Required field missing for ~s. Required fields: ~p\", \n-                                     [Description, RequiredFields]));\n+                    format_validation_error(ErrorType,\n+                                            Field,\n+                                            io_lib:format(\"Required field missing for ~s. Required fields: ~p\",\n+                                                          [Description, RequiredFields]));\n                 unknown_field ->\n                     AllowedFields = RequiredFields ++ OptionalFields,\n-                    format_validation_error(ErrorType, Field, \n-                        io_lib:format(\"Unknown field for ~s. Allowed fields: ~p\", \n-                                     [Description, AllowedFields]));\n+                    format_validation_error(ErrorType,\n+                                            Field,\n+                                            io_lib:format(\"Unknown field for ~s. Allowed fields: ~p\",\n+                                                          [Description, AllowedFields]));\n                 _ ->\n                     {error, {validation_error, ErrorType, Field}}\n             end;\n         Error ->\n@@ -503,44 +611,87 @@\n -spec validate_schema_field_values(map(), map()) -> ok | {error, term()}.\n validate_schema_field_values(Config, FieldValidators) ->\n     try\n         maps:fold(fun(Field, Value, _Acc) ->\n-            case maps:get(Field, FieldValidators, undefined) of\n-                undefined -> ok; % Field not in schema validators, skip\n-                Validator when is_function(Validator, 1) ->\n-                    case Validator(Value) of\n-                        ok -> ok;\n-                        {error, Reason} ->\n-                            throw({validation_error, invalid_field_value, Field, Reason})\n-                    end\n-            end\n-        end, ok, Config),\n+                     case maps:get(Field, FieldValidators, undefined) of\n+                         undefined -> ok; % Field not in schema validators, skip\n+                         Validator when is_function(Validator, 1) ->\n+                             case Validator(Value) of\n+                                 ok -> ok;\n+                                 {error, Reason} ->\n+                                     throw({validation_error, invalid_field_value, Field, Reason})\n+                             end\n+                     end\n+                  end,\n+                  ok,\n+                  Config),\n         ok\n     catch\n-        throw:{validation_error, ErrorType, Field, Reason} ->\n+        {validation_error, ErrorType, Field, Reason} ->\n             format_validation_error(ErrorType, Field, Reason)\n     end.\n \n-%% @doc Format validation errors with helpful messages\n+%% @doc Format validation errors with helpful messages (backward compatibility)\n -spec format_validation_error(atom(), term(), string()) -> {error, term()}.\n format_validation_error(ErrorType, Field, Reason) ->\n-    FormattedReason = case io_lib:char_list(Reason) of\n-        true -> Reason;\n-        false -> io_lib:format(\"~p\", [Reason])\n-    end,\n-    {error, {\n-        validation_error, \n-        ErrorType, \n-        Field, \n-        lists:flatten(FormattedReason)\n-    }}.\n+    FormattedReason =\n+        case io_lib:char_list(Reason) of\n+            true ->\n+                Reason;\n+            false ->\n+                io_lib:format(\"~p\", [Reason])\n+        end,\n+    {error, {validation_error, ErrorType, Field, lists:flatten(FormattedReason)}}.\n \n+%% @doc Format validation error with enhanced context for Phase 3\n+format_validation_error_enhanced(TransportId, Type, ValidationError) ->\n+    case ValidationError of\n+        {validation_error, ErrorType, Field, Message} ->\n+            EnhancedError = #{\n+                error_category => validation_error,\n+                transport_id => TransportId,\n+                transport_type => Type,\n+                error_type => ErrorType,\n+                field => Field,\n+                message => lists:flatten(io_lib:format(\"~s\", [Message])),\n+                suggestion => get_validation_suggestion(Type, ValidationError),\n+                timestamp => erlang:timestamp(),\n+                phase => 3,\n+                step => 7\n+            },\n+            {error, EnhancedError};\n+        {validation_error, ErrorType, Fields, Message} when is_list(Fields) ->\n+            EnhancedError = #{\n+                error_category => validation_error,\n+                transport_id => TransportId,\n+                transport_type => Type,\n+                error_type => ErrorType,\n+                fields => Fields,\n+                message => lists:flatten(io_lib:format(\"~s\", [Message])),\n+                suggestion => get_validation_suggestion(Type, ValidationError),\n+                timestamp => erlang:timestamp(),\n+                phase => 3,\n+                step => 7\n+            },\n+            {error, EnhancedError};\n+        Other ->\n+            {error, #{\n+                error_category => validation_error,\n+                transport_id => TransportId,\n+                transport_type => Type,\n+                error_type => unknown_validation_error,\n+                details => Other,\n+                timestamp => erlang:timestamp(),\n+                phase => 3,\n+                step => 7\n+            }}\n+    end.\n+\n %% @doc Legacy validation function - now delegates to schema-based approach\n -spec validate_transport_config_by_type(atom(), map()) -> ok | {error, term()}.\n validate_transport_config_by_type(Type, Config) ->\n     validate_transport_config_with_schema(Type, Config).\n \n-\n %% @doc Helper function to validate required and optional fields\n -spec validate_fields(map(), [atom()], [atom()]) -> ok | {error, term()}.\n validate_fields(Config, RequiredFields, OptionalFields) ->\n     case validate_required_fields(Config, RequiredFields) of\n@@ -571,13 +722,19 @@\n     case Unknown of\n         [] ->\n             ok;\n         [Field] ->\n-            {error, {validation_error, unknown_field, Field, \n-                     io_lib:format(\"allowed fields: ~p\", [AllowedFields])}};\n+            {error,\n+             {validation_error,\n+              unknown_field,\n+              Field,\n+              io_lib:format(\"allowed fields: ~p\", [AllowedFields])}};\n         Fields ->\n-            {error, {validation_error, unknown_fields, Fields,\n-                     io_lib:format(\"allowed fields: ~p\", [AllowedFields])}}\n+            {error,\n+             {validation_error,\n+              unknown_fields,\n+              Fields,\n+              io_lib:format(\"allowed fields: ~p\", [AllowedFields])}}\n     end.\n \n %% @doc Validate TCP-specific fields\n -spec validate_tcp_fields(map()) -> ok | {error, term()}.\n@@ -601,35 +758,45 @@\n -spec validate_tcp_optional_fields(map()) -> ok | {error, term()}.\n validate_tcp_optional_fields(Config) ->\n     % Validate keepalive\n     case maps:get(keepalive, Config, undefined) of\n-        undefined -> \n+        undefined ->\n             % Continue to next validation\n             validate_tcp_connect_timeout(Config);\n-        Boolean when is_boolean(Boolean) -> \n+        Boolean when is_boolean(Boolean) ->\n             % Continue to next validation\n             validate_tcp_connect_timeout(Config);\n-        _ -> {error, {validation_error, invalid_field_type, keepalive, \"must be boolean\"}}\n+        _ ->\n+            {error, {validation_error, invalid_field_type, keepalive, \"must be boolean\"}}\n     end.\n \n %% @doc Validate TCP connect_timeout field\n -spec validate_tcp_connect_timeout(map()) -> ok | {error, term()}.\n validate_tcp_connect_timeout(Config) ->\n     case maps:get(connect_timeout, Config, undefined) of\n-        undefined -> \n+        undefined ->\n             validate_tcp_max_reconnect(Config);\n-        Timeout when is_integer(Timeout), Timeout > 0 -> \n+        Timeout when is_integer(Timeout), Timeout > 0 ->\n             validate_tcp_max_reconnect(Config);\n-        _ -> {error, {validation_error, invalid_field_type, connect_timeout, \"must be positive integer\"}}\n+        _ ->\n+            {error,\n+             {validation_error, invalid_field_type, connect_timeout, \"must be positive integer\"}}\n     end.\n \n %% @doc Validate TCP max_reconnect_attempts field\n -spec validate_tcp_max_reconnect(map()) -> ok | {error, term()}.\n validate_tcp_max_reconnect(Config) ->\n     case maps:get(max_reconnect_attempts, Config, undefined) of\n-        undefined -> ok;\n-        Attempts when is_integer(Attempts), Attempts >= 0 -> ok;\n-        _ -> {error, {validation_error, invalid_field_type, max_reconnect_attempts, \"must be non-negative integer\"}}\n+        undefined ->\n+            ok;\n+        Attempts when is_integer(Attempts), Attempts >= 0 ->\n+            ok;\n+        _ ->\n+            {error,\n+             {validation_error,\n+              invalid_field_type,\n+              max_reconnect_attempts,\n+              \"must be non-negative integer\"}}\n     end.\n \n %% @doc Validate HTTP-specific fields\n -spec validate_http_fields(map()) -> ok | {error, term()}.\n@@ -646,64 +813,96 @@\n -spec validate_http_optional_fields(map()) -> ok | {error, term()}.\n validate_http_optional_fields(Config) ->\n     % Validate method\n     case maps:get(method, Config, get) of\n-        Method when Method =:= get; Method =:= post; Method =:= put; Method =:= delete; \n-                   Method =:= patch; Method =:= head; Method =:= options -> \n+        Method\n+            when Method =:= get;\n+                 Method =:= post;\n+                 Method =:= put;\n+                 Method =:= delete;\n+                 Method =:= patch;\n+                 Method =:= head;\n+                 Method =:= options ->\n             validate_http_headers_field(Config);\n-        _ -> {error, {validation_error, invalid_field_value, method, \"must be valid HTTP method\"}}\n+        _ ->\n+            {error, {validation_error, invalid_field_value, method, \"must be valid HTTP method\"}}\n     end.\n \n %% @doc Validate HTTP headers field\n -spec validate_http_headers_field(map()) -> ok | {error, term()}.\n validate_http_headers_field(Config) ->\n     case maps:get(headers, Config, undefined) of\n-        undefined -> \n+        undefined ->\n             validate_http_timeout_field(Config);\n-        Headers when is_map(Headers) -> \n+        Headers when is_map(Headers) ->\n             case validate_http_headers(Headers) of\n-                ok -> validate_http_timeout_field(Config);\n-                Error -> Error\n+                ok ->\n+                    validate_http_timeout_field(Config);\n+                Error ->\n+                    Error\n             end;\n-        _ -> {error, {validation_error, invalid_field_type, headers, \"must be a map\"}}\n+        _ ->\n+            {error, {validation_error, invalid_field_type, headers, \"must be a map\"}}\n     end.\n \n %% @doc Validate HTTP timeout field\n -spec validate_http_timeout_field(map()) -> ok | {error, term()}.\n validate_http_timeout_field(Config) ->\n     case maps:get(timeout, Config, undefined) of\n-        undefined -> ok;\n-        Timeout when is_integer(Timeout), Timeout > 0 -> ok;\n-        _ -> {error, {validation_error, invalid_field_type, timeout, \"must be positive integer\"}}\n+        undefined ->\n+            ok;\n+        Timeout when is_integer(Timeout), Timeout > 0 ->\n+            ok;\n+        _ ->\n+            {error, {validation_error, invalid_field_type, timeout, \"must be positive integer\"}}\n     end.\n \n %% @doc Validate HTTP headers map\n -spec validate_http_headers(map()) -> ok | {error, term()}.\n validate_http_headers(Headers) ->\n     try\n         maps:fold(fun(Key, Value, _Acc) ->\n-            case {is_binary(Key) orelse is_list(Key), is_binary(Value) orelse is_list(Value)} of\n-                {true, true} -> ok;\n-                {false, _} -> throw({error, {validation_error, invalid_header_key, Key, \"must be binary or string\"}});\n-                {_, false} -> throw({error, {validation_error, invalid_header_value, Value, \"must be binary or string\"}})\n-            end\n-        end, ok, Headers),\n+                     case {is_binary(Key) orelse is_list(Key),\n+                           is_binary(Value) orelse is_list(Value)}\n+                     of\n+                         {true, true} -> ok;\n+                         {false, _} ->\n+                             throw({error,\n+                                    {validation_error,\n+                                     invalid_header_key,\n+                                     Key,\n+                                     \"must be binary or string\"}});\n+                         {_, false} ->\n+                             throw({error,\n+                                    {validation_error,\n+                                     invalid_header_value,\n+                                     Value,\n+                                     \"must be binary or string\"}})\n+                     end\n+                  end,\n+                  ok,\n+                  Headers),\n         ok\n     catch\n-        throw:Error -> Error\n+        Error ->\n+            Error\n     end.\n \n %% @doc Validate host field\n -spec validate_host_field(term()) -> ok | {error, term()}.\n validate_host_field(Host) when is_binary(Host) ->\n     case byte_size(Host) > 0 of\n-        true -> ok;\n-        false -> {error, {validation_error, invalid_field_value, host, \"cannot be empty\"}}\n+        true ->\n+            ok;\n+        false ->\n+            {error, {validation_error, invalid_field_value, host, \"cannot be empty\"}}\n     end;\n validate_host_field(Host) when is_list(Host) ->\n     case length(Host) > 0 of\n-        true -> ok;\n-        false -> {error, {validation_error, invalid_field_value, host, \"cannot be empty\"}}\n+        true ->\n+            ok;\n+        false ->\n+            {error, {validation_error, invalid_field_value, host, \"cannot be empty\"}}\n     end;\n validate_host_field(_) ->\n     {error, {validation_error, invalid_field_type, host, \"must be binary or string\"}}.\n \n@@ -719,15 +918,19 @@\n %% @doc Validate URL field\n -spec validate_url_field(term()) -> ok | {error, term()}.\n validate_url_field(Url) when is_binary(Url) ->\n     case validate_url_format(Url) of\n-        true -> ok;\n-        false -> {error, {validation_error, invalid_field_value, url, \"must be valid HTTP/HTTPS URL\"}}\n+        true ->\n+            ok;\n+        false ->\n+            {error, {validation_error, invalid_field_value, url, \"must be valid HTTP/HTTPS URL\"}}\n     end;\n validate_url_field(Url) when is_list(Url) ->\n     case validate_url_format(list_to_binary(Url)) of\n-        true -> ok;\n-        false -> {error, {validation_error, invalid_field_value, url, \"must be valid HTTP/HTTPS URL\"}}\n+        true ->\n+            ok;\n+        false ->\n+            {error, {validation_error, invalid_field_value, url, \"must be valid HTTP/HTTPS URL\"}}\n     end;\n validate_url_field(_) ->\n     {error, {validation_error, invalid_field_type, url, \"must be binary or string\"}}.\n \n@@ -788,9 +991,10 @@\n %% Convenience Functions - Updated for Phase 2\n %%====================================================================\n \n %% Create a complete MCP server setup with stdio transport\n--spec start_stdio_setup(server_id(), map()) -> {ok, #{server => pid(), transport => pid()}} | {error, term()}.\n+-spec start_stdio_setup(server_id(), map()) ->\n+                           {ok, #{server => pid(), transport => pid()}} | {error, term()}.\n start_stdio_setup(ServerId, Config) ->\n     case start_server(ServerId, Config) of\n         {ok, ServerPid} ->\n             TransportId = create_transport_id(ServerId, <<\"stdio\">>),\n@@ -801,9 +1005,10 @@\n                     case bind_transport_to_server(TransportId, ServerId) of\n                         ok ->\n                             {ok, #{server => ServerPid, transport => TransportPid}};\n                         {error, BindError} ->\n-                            logger:warning(\"Server and transport started but binding failed: ~p\", [BindError]),\n+                            logger:warning(\"Server and transport started but binding failed: ~p\",\n+                                           [BindError]),\n                             {ok, #{server => ServerPid, transport => TransportPid}}\n                     end;\n                 {error, TransportError} ->\n                     _ = stop_server(ServerId),\n@@ -812,131 +1017,212 @@\n         {error, _} = ServerError ->\n             ServerError\n     end.\n \n-%% Create a complete MCP server setup with TCP transport\n--spec start_tcp_setup(server_id(), map(), map()) -> {ok, #{server => pid(), transport => pid()}} | {error, term()}.\n+%% Create a complete MCP server setup with TCP transport - Enhanced Phase 3 Implementation\n+-spec start_tcp_setup(server_id(), map(), map()) ->\n+                         {ok, #{server => pid(), transport => pid()}} | {error, term()}.\n start_tcp_setup(ServerId, ServerConfig, TcpConfig) ->\n-    logger:info(\"Setting up TCP server ~p with enhanced validation\", [ServerId]),\n-    \n-    % Enhanced validation with detailed error reporting\n-    case erlmcp_transport_validation:validate_transport_config(tcp, TcpConfig) of\n+    logger:info(\"Setting up TCP server ~p with Phase 3 enhanced validation and error handling\", [ServerId]),\n+\n+    % Pre-flight checks before starting setup\n+    case validate_setup_prerequisites(tcp) of\n         ok ->\n-            case start_server(ServerId, ServerConfig) of\n-                {ok, ServerPid} ->\n-                    TransportId = create_transport_id(ServerId, <<\"tcp\">>),\n-                    % Enhanced config with validation metadata\n-                    TransportConfig = maps:merge(#{\n-                        server_id => ServerId,\n-                        transport_type => tcp,\n-                        setup_type => convenience_function\n-                    }, TcpConfig),\n-                    \n-                    case start_transport(TransportId, tcp, TransportConfig) of\n-                        {ok, TransportPid} ->\n-                            case bind_transport_to_server(TransportId, ServerId) of\n-                                ok ->\n-                                    logger:info(\"TCP setup completed successfully for ~p (~p:~p)\", \n-                                              [ServerId, maps:get(host, TcpConfig, \"localhost\"), \n-                                               maps:get(port, TcpConfig, 8080)]),\n-                                    {ok, #{server => ServerPid, transport => TransportPid, \n-                                          transport_id => TransportId, config => TransportConfig}};\n-                                {error, BindError} ->\n-                                    logger:warning(\"TCP server ~p started but binding failed: ~p\", \n-                                                 [ServerId, BindError]),\n-                                    {ok, #{server => ServerPid, transport => TransportPid,\n-                                          transport_id => TransportId, binding_warning => BindError}}\n+            % Enhanced validation with detailed error reporting\n+            case erlmcp_transport_validation:validate_transport_config(tcp, TcpConfig) of\n+                ok ->\n+                    case start_server(ServerId, ServerConfig) of\n+                        {ok, ServerPid} ->\n+                            TransportId = create_transport_id(ServerId, <<\"tcp\">>),\n+                            % Enhanced config with comprehensive metadata\n+                            TransportConfig =\n+                                maps:merge(#{server_id => ServerId,\n+                                             transport_type => tcp,\n+                                             setup_type => convenience_function,\n+                                             setup_version => \"3.0\",\n+                                             created_at => erlang:timestamp(),\n+                                             binding_strategy => automatic},\n+                                           TcpConfig),\n+\n+                            case start_transport(TransportId, tcp, TransportConfig) of\n+                                {ok, TransportPid} ->\n+                                    % Enhanced binding with validation\n+                                    case validate_transport_binding(TransportId, ServerId) of\n+                                        ok ->\n+                                            case bind_transport_to_server(TransportId, ServerId) of\n+                                                ok ->\n+                                                    logger:info(\"TCP setup completed successfully for ~p (~s:~p) with enhanced features\",\n+                                                                [ServerId,\n+                                                                 maps:get(host, TcpConfig, \"localhost\"),\n+                                                                 maps:get(port, TcpConfig, 8080)]),\n+                                                    {ok,\n+                                                     #{server => ServerPid,\n+                                                       transport => TransportPid,\n+                                                       transport_id => TransportId,\n+                                                       config => TransportConfig,\n+                                                       setup_metadata => #{type => tcp,\n+                                                                           version => \"3.0\",\n+                                                                           binding_validated => true}}};\n+                                                {error, BindError} ->\n+                                                    logger:warning(\"TCP server ~p started but binding failed: ~p. Attempting recovery.\",\n+                                                                   [ServerId, BindError]),\n+                                                    % Attempt to recover by retrying the binding\n+                                                    case bind_transport_to_server(TransportId, ServerId) of\n+                                                        ok ->\n+                                                            {ok,\n+                                                             #{server => ServerPid,\n+                                                               transport => TransportPid,\n+                                                               transport_id => TransportId,\n+                                                               binding_recovered => true}};\n+                                                        {error, FinalBindError} ->\n+                                                            {ok,\n+                                                             #{server => ServerPid,\n+                                                               transport => TransportPid,\n+                                                               transport_id => TransportId,\n+                                                               binding_warning => FinalBindError}}\n+                                                    end\n+                                            end;\n+                                        {error, BindingValidationError} ->\n+                                            logger:error(\"TCP binding validation failed for ~p: ~p\",\n+                                                         [ServerId, BindingValidationError]),\n+                                            cleanup_failed_setup(ServerId, tcp, BindingValidationError)\n+                                    end;\n+                                {error, TransportError} ->\n+                                    logger:error(\"TCP transport setup failed for ~p: ~p\",\n+                                                 [ServerId, TransportError]),\n+                                    cleanup_failed_setup(ServerId, tcp, TransportError)\n                             end;\n-                        {error, TransportError} ->\n-                            logger:error(\"TCP transport setup failed for ~p: ~p\", [ServerId, TransportError]),\n-                            cleanup_failed_setup(ServerId, tcp, TransportError)\n+                        {error, ServerError} ->\n+                            logger:error(\"Server setup failed for TCP ~p: ~p\", [ServerId, ServerError]),\n+                            format_setup_error(ServerId, tcp, server_start_failed, ServerError)\n                     end;\n-                {error, ServerError} ->\n-                    logger:error(\"Server setup failed for TCP ~p: ~p\", [ServerId, ServerError]),\n-                    format_setup_error(ServerId, tcp, server_start_failed, ServerError)\n+                {error, ValidationError} ->\n+                    logger:error(\"TCP config validation failed for ~p: ~p\", [ServerId, ValidationError]),\n+                    format_validation_error(ServerId, tcp, ValidationError)\n             end;\n-        {error, ValidationError} ->\n-            logger:error(\"TCP config validation failed for ~p: ~p\", [ServerId, ValidationError]),\n-            format_validation_error(ServerId, tcp, ValidationError)\n+        {error, PrereqError} ->\n+            logger:error(\"TCP setup prerequisites not met for ~p: ~p\", [ServerId, PrereqError]),\n+            format_setup_error(ServerId, tcp, prerequisites_failed, PrereqError)\n     end.\n \n-%% Create a complete MCP server setup with HTTP transport\n--spec start_http_setup(server_id(), map(), map()) -> {ok, #{server => pid(), transport => pid()}} | {error, term()}.\n+%% Create a complete MCP server setup with HTTP transport - Enhanced Phase 3 Implementation\n+-spec start_http_setup(server_id(), map(), map()) ->\n+                          {ok, #{server => pid(), transport => pid()}} | {error, term()}.\n start_http_setup(ServerId, ServerConfig, HttpConfig) ->\n-    logger:info(\"Setting up HTTP server ~p with enhanced validation\", [ServerId]),\n-    \n-    % Enhanced validation with detailed error reporting\n+    logger:info(\"Setting up HTTP server ~p with Phase 3 enhanced validation and error handling\", [ServerId]),\n+\n+    % Pre-flight checks before starting setup\n     case erlmcp_transport_validation:validate_transport_config(http, HttpConfig) of\n         ok ->\n-            case start_server(ServerId, ServerConfig) of\n-                {ok, ServerPid} ->\n-                    TransportId = create_transport_id(ServerId, <<\"http\">>),\n-                    % Enhanced config with validation metadata\n-                    TransportConfig = maps:merge(#{\n-                        server_id => ServerId,\n-                        transport_type => http,\n-                        setup_type => convenience_function\n-                    }, HttpConfig),\n-                    \n-                    case start_transport(TransportId, http, TransportConfig) of\n-                        {ok, TransportPid} ->\n-                            case bind_transport_to_server(TransportId, ServerId) of\n-                                ok ->\n-                                    logger:info(\"HTTP setup completed successfully for ~p (~s)\", \n-                                              [ServerId, maps:get(url, HttpConfig, \"http://localhost:8000/mcp\")]),\n-                                    {ok, #{server => ServerPid, transport => TransportPid, \n-                                          transport_id => TransportId, config => TransportConfig}};\n-                                {error, BindError} ->\n-                                    logger:warning(\"HTTP server ~p started but binding failed: ~p\", \n-                                                 [ServerId, BindError]),\n-                                    {ok, #{server => ServerPid, transport => TransportPid,\n-                                          transport_id => TransportId, binding_warning => BindError}}\n+                    case start_server(ServerId, ServerConfig) of\n+                        {ok, ServerPid} ->\n+                            TransportId = create_transport_id(ServerId, <<\"http\">>),\n+                            % Enhanced config with comprehensive metadata\n+                            TransportConfig =\n+                                maps:merge(#{server_id => ServerId,\n+                                             transport_type => http,\n+                                             setup_type => convenience_function,\n+                                             setup_version => \"3.0\",\n+                                             created_at => erlang:timestamp(),\n+                                             binding_strategy => automatic,\n+                                             cors_enabled => maps:get(cors, HttpConfig, false)},\n+                                           HttpConfig),\n+\n+                            case start_transport(TransportId, http, TransportConfig) of\n+                                {ok, TransportPid} ->\n+                                    % Enhanced binding with validation\n+                                    case validate_transport_binding(TransportId, ServerId) of\n+                                        ok ->\n+                                            case bind_transport_to_server(TransportId, ServerId) of\n+                                                ok ->\n+                                                    logger:info(\"HTTP setup completed successfully for ~p (~s) with enhanced features\",\n+                                                                [ServerId,\n+                                                                 maps:get(url,\n+                                                                          HttpConfig,\n+                                                                          \"http://localhost:8000/mcp\")]),\n+                                                    {ok,\n+                                                     #{server => ServerPid,\n+                                                       transport => TransportPid,\n+                                                       transport_id => TransportId,\n+                                                       config => TransportConfig,\n+                                                       setup_metadata => #{type => http,\n+                                                                           version => \"3.0\",\n+                                                                           binding_validated => true,\n+                                                                           url => maps:get(url, HttpConfig, \"http://localhost:8000/mcp\")}}};\n+                                                {error, BindError} ->\n+                                                    logger:warning(\"HTTP server ~p started but binding failed: ~p. Attempting recovery.\",\n+                                                                   [ServerId, BindError]),\n+                                                    % Attempt to recover by retrying the binding\n+                                                    case bind_transport_to_server(TransportId, ServerId) of\n+                                                        ok ->\n+                                                            {ok,\n+                                                             #{server => ServerPid,\n+                                                               transport => TransportPid,\n+                                                               transport_id => TransportId,\n+                                                               binding_recovered => true}};\n+                                                        {error, FinalBindError} ->\n+                                                            {ok,\n+                                                             #{server => ServerPid,\n+                                                               transport => TransportPid,\n+                                                               transport_id => TransportId,\n+                                                               binding_warning => FinalBindError}}\n+                                                    end\n+                                            end;\n+                                        {error, BindingValidationError} ->\n+                                            logger:error(\"HTTP binding validation failed for ~p: ~p\",\n+                                                         [ServerId, BindingValidationError]),\n+                                            cleanup_failed_setup(ServerId, http, BindingValidationError)\n+                                    end;\n+                                {error, TransportError} ->\n+                                    logger:error(\"HTTP transport setup failed for ~p: ~p\",\n+                                                 [ServerId, TransportError]),\n+                                    cleanup_failed_setup(ServerId, http, TransportError)\n                             end;\n-                        {error, TransportError} ->\n-                            logger:error(\"HTTP transport setup failed for ~p: ~p\", [ServerId, TransportError]),\n-                            cleanup_failed_setup(ServerId, http, TransportError)\n+                        {error, ServerError} ->\n+                            logger:error(\"Server setup failed for HTTP ~p: ~p\", [ServerId, ServerError]),\n+                            format_setup_error(ServerId, http, server_start_failed, ServerError)\n                     end;\n-                {error, ServerError} ->\n-                    logger:error(\"Server setup failed for HTTP ~p: ~p\", [ServerId, ServerError]),\n-                    format_setup_error(ServerId, http, server_start_failed, ServerError)\n+                {error, ValidationError} ->\n+                    logger:error(\"HTTP config validation failed for ~p: ~p\", [ServerId, ValidationError]),\n+                    format_validation_error(ServerId, http, ValidationError)\n             end;\n-        {error, ValidationError} ->\n-            logger:error(\"HTTP config validation failed for ~p: ~p\", [ServerId, ValidationError]),\n-            format_validation_error(ServerId, http, ValidationError)\n+        {error, PrereqError} ->\n+            logger:error(\"HTTP setup prerequisites not met for ~p: ~p\", [ServerId, PrereqError]),\n+            format_setup_error(ServerId, http, prerequisites_failed, PrereqError)\n     end.\n \n %% Batch add multiple resources, tools, and prompts\n -spec setup_server_components(server_id(), map()) -> ok | {error, term()}.\n setup_server_components(ServerId, Components) ->\n     Resources = maps:get(resources, Components, []),\n     Tools = maps:get(tools, Components, []),\n     Prompts = maps:get(prompts, Components, []),\n-    \n+\n     try\n         % Add resources\n-        lists:foreach(fun\n-            ({Uri, Handler}) ->\n-                ok = add_resource(ServerId, Uri, Handler);\n-            ({Uri, Handler, Options}) ->\n-                ok = add_resource(ServerId, Uri, Handler, Options)\n-        end, Resources),\n-        \n+        lists:foreach(fun ({Uri, Handler}) ->\n+                              ok = add_resource(ServerId, Uri, Handler);\n+                          ({Uri, Handler, Options}) ->\n+                              ok = add_resource(ServerId, Uri, Handler, Options)\n+                      end,\n+                      Resources),\n+\n         % Add tools\n-        lists:foreach(fun\n-            ({Name, Handler}) ->\n-                ok = add_tool(ServerId, Name, Handler);\n-            ({Name, Handler, Options}) ->\n-                ok = add_tool(ServerId, Name, Handler, Options)\n-        end, Tools),\n-        \n+        lists:foreach(fun ({Name, Handler}) ->\n+                              ok = add_tool(ServerId, Name, Handler);\n+                          ({Name, Handler, Options}) ->\n+                              ok = add_tool(ServerId, Name, Handler, Options)\n+                      end,\n+                      Tools),\n+\n         % Add prompts\n-        lists:foreach(fun\n-            ({Name, Handler}) ->\n-                ok = add_prompt(ServerId, Name, Handler);\n-            ({Name, Handler, Options}) ->\n-                ok = add_prompt(ServerId, Name, Handler, Options)\n-        end, Prompts),\n-        \n+        lists:foreach(fun ({Name, Handler}) ->\n+                              ok = add_prompt(ServerId, Name, Handler);\n+                          ({Name, Handler, Options}) ->\n+                              ok = add_prompt(ServerId, Name, Handler, Options)\n+                      end,\n+                      Prompts),\n+\n         ok\n     catch\n         error:{badmatch, {error, Reason}} ->\n             {error, Reason};\n@@ -944,9 +1230,10 @@\n             {error, {Class, Exception}}\n     end.\n \n %% Quick way to create a complete stdio MCP server with components\n--spec quick_stdio_server(server_id(), map(), map()) -> {ok, #{server => pid(), transport => pid()}} | {error, term()}.\n+-spec quick_stdio_server(server_id(), map(), map()) ->\n+                            {ok, #{server => pid(), transport => pid()}} | {error, term()}.\n quick_stdio_server(ServerId, ServerConfig, Components) ->\n     case start_stdio_setup(ServerId, ServerConfig) of\n         {ok, Result} ->\n             case setup_server_components(ServerId, Components) of\n@@ -967,12 +1254,16 @@\n %%====================================================================\n \n %% @doc Get configuration schema for a transport type\n -spec get_config_schema(atom()) -> {ok, map()} | {error, term()}.\n-get_config_schema(stdio) -> {ok, ?STDIO_CONFIG_SCHEMA};\n-get_config_schema(tcp) -> {ok, ?TCP_CONFIG_SCHEMA};\n-get_config_schema(http) -> {ok, ?HTTP_CONFIG_SCHEMA};\n-get_config_schema(Type) -> {error, {unknown_transport_type, Type}}.\n+get_config_schema(stdio) ->\n+    {ok, ?STDIO_CONFIG_SCHEMA};\n+get_config_schema(tcp) ->\n+    {ok, ?TCP_CONFIG_SCHEMA};\n+get_config_schema(http) ->\n+    {ok, ?HTTP_CONFIG_SCHEMA};\n+get_config_schema(Type) ->\n+    {error, {unknown_transport_type, Type}}.\n \n %% @doc Validate a single configuration field\n -spec validate_config_field(atom(), atom(), term()) -> ok | {error, term()}.\n validate_config_field(TransportType, Field, Value) ->\n@@ -983,14 +1274,16 @@\n                 undefined ->\n                     {error, {unknown_field, Field, TransportType}};\n                 Validator when is_function(Validator, 1) ->\n                     case Validator(Value) of\n-                        ok -> ok;\n-                        {error, Reason} -> \n+                        ok ->\n+                            ok;\n+                        {error, Reason} ->\n                             format_validation_error(invalid_field_value, Field, Reason)\n                     end\n             end;\n-        Error -> Error\n+        Error ->\n+            Error\n     end.\n \n %% @doc List all supported transport types\n -spec list_supported_transport_types() -> [atom()].\n@@ -999,41 +1292,83 @@\n \n %% @doc Get example configurations for all transport types\n -spec get_config_examples() -> map().\n get_config_examples() ->\n-    #{\n-        stdio => #{\n-            type => stdio,\n+    #{stdio =>\n+          #{type => stdio,\n             server_id => my_server,\n             test_mode => false,\n-            buffer_size => 8192\n-        },\n-        tcp => #{\n-            type => tcp,\n+            buffer_size => 8192},\n+      tcp =>\n+          #{type => tcp,\n             host => \"localhost\",\n             port => 8080,\n             keepalive => true,\n             connect_timeout => 5000,\n             max_reconnect_attempts => 3,\n-            ssl => false\n-        },\n-        http => #{\n-            type => http,\n+            ssl => false},\n+      http =>\n+          #{type => http,\n             url => \"https://api.example.com/mcp\",\n             method => post,\n             headers => #{<<\"Content-Type\">> => <<\"application/json\">>},\n             timeout => 30000,\n             cors => true,\n-            max_body_size => 1048576\n-        }\n-    }.\n+            max_body_size => 1048576}}.\n \n %%====================================================================\n-%% Enhanced API Functions - Phase 3\n+%% Enhanced API Functions - Phase 3 Step 7 Implementation\n %%====================================================================\n \n+%% @doc Validate setup prerequisites before starting transport\n+-spec validate_setup_prerequisites(transport_type()) -> ok | {error, term()}.\n+validate_setup_prerequisites(stdio) ->\n+    ok; % STDIO has no special prerequisites\n+validate_setup_prerequisites(tcp) ->\n+    % Check if network stack is available\n+    case inet:getifaddrs() of\n+        {ok, _Interfaces} ->\n+            ok;\n+        {error, Reason} ->\n+            {error, {network_unavailable, Reason}}\n+    end;\n+validate_setup_prerequisites(http) ->\n+    % Check if HTTP dependencies are available\n+    case code:is_loaded(httpc) of\n+        {file, _} ->\n+            ok;\n+        false ->\n+            case code:load_file(httpc) of\n+                {module, httpc} ->\n+                    ok;\n+                {error, Reason} ->\n+                    {error, {http_client_unavailable, Reason}}\n+            end;\n+        true ->\n+            ok\n+    end;\n+validate_setup_prerequisites(Type) ->\n+    {error, {unknown_transport_type, Type}}.\n+\n+%% @doc Ensure transport supervisor is started\n+-spec ensure_transport_supervisor() -> ok | {error, term()}.\n+ensure_transport_supervisor() ->\n+    case whereis(erlmcp_transport_sup) of\n+        undefined ->\n+            case erlmcp_transport_sup:ensure_started() of\n+                ok ->\n+                    ok;\n+                Error ->\n+                    {error, Error}\n+            end;\n+        _Pid ->\n+            ok\n+    end.\n+\n+\n %% Transport implementation helper\n--spec start_transport_impl(transport_id(), transport_type(), map()) -> {ok, pid()} | {error, term()}.\n+-spec start_transport_impl(transport_id(), transport_type(), map()) ->\n+                              {ok, pid()} | {error, term()}.\n start_transport_impl(TransportId, stdio, Config) ->\n     erlmcp_transport_stdio_new:start_link(TransportId, Config);\n start_transport_impl(_TransportId, tcp, Config) ->\n     % Placeholder for TCP implementation\n@@ -1064,35 +1399,42 @@\n             {error, registry_not_available};\n         _ ->\n             try\n                 Transports = erlmcp_registry:list_transports(),\n-                Bindings = lists:filtermap(fun({TransportId, {_Pid, Config}}) ->\n-                    case maps:get(server_id, Config, undefined) of\n-                        undefined -> false;\n-                        ServerId -> {true, {TransportId, ServerId}}\n-                    end\n-                end, Transports),\n+                Bindings =\n+                    lists:filtermap(fun({TransportId, {_Pid, Config}}) ->\n+                                       case maps:get(server_id, Config, undefined) of\n+                                           undefined -> false;\n+                                           ServerId -> {true, {TransportId, ServerId}}\n+                                       end\n+                                    end,\n+                                    Transports),\n                 Bindings\n             catch\n-                _:Error -> {error, Error}\n+                _:Error ->\n+                    {error, Error}\n             end\n     end.\n \n %% Cleanup orphaned transport bindings\n -spec cleanup_transport_bindings(server_id()) -> ok | {error, term()}.\n cleanup_transport_bindings(ServerId) ->\n     case get_transport_bindings() of\n-        {error, _} = Error -> Error;\n+        {error, _} = Error ->\n+            Error;\n         Bindings ->\n             OrphanedTransports = [TId || {TId, SId} <- Bindings, SId =:= ServerId],\n             lists:foreach(fun(TransportId) ->\n-                case unbind_transport(TransportId) of\n-                    ok -> \n-                        logger:info(\"Cleaned up orphaned transport binding: ~p\", [TransportId]);\n-                    {error, Reason} -> \n-                        logger:warning(\"Failed to cleanup transport binding ~p: ~p\", [TransportId, Reason])\n-                end\n-            end, OrphanedTransports),\n+                             case unbind_transport(TransportId) of\n+                                 ok ->\n+                                     logger:info(\"Cleaned up orphaned transport binding: ~p\",\n+                                                 [TransportId]);\n+                                 {error, Reason} ->\n+                                     logger:warning(\"Failed to cleanup transport binding ~p: ~p\",\n+                                                    [TransportId, Reason])\n+                             end\n+                          end,\n+                          OrphanedTransports),\n             ok\n     end.\n \n %%====================================================================\n@@ -1114,21 +1456,22 @@\n \n -spec register_server_with_registry(server_id(), pid(), map()) -> ok | {error, term()}.\n register_server_with_registry(ServerId, ServerPid, Config) ->\n     case whereis(erlmcp_registry) of\n-        undefined -> \n+        undefined ->\n             % Registry not available - this is OK for some deployments\n             ok;\n-        _ -> \n+        _ ->\n             erlmcp_registry:register_server(ServerId, ServerPid, Config)\n     end.\n \n--spec register_transport_with_registry(transport_id(), pid(), map()) -> ok | {error, term()}.\n+-spec register_transport_with_registry(transport_id(), pid(), map()) ->\n+                                          ok | {error, term()}.\n register_transport_with_registry(TransportId, TransportPid, Config) ->\n     case whereis(erlmcp_registry) of\n-        undefined -> \n+        undefined ->\n             ok; % Registry not available - this is OK\n-        _ -> \n+        _ ->\n             erlmcp_registry:register_transport(TransportId, TransportPid, Config)\n     end.\n \n -spec find_server_process(server_id()) -> {ok, pid()} | {error, not_found}.\n@@ -1147,11 +1490,11 @@\n     end.\n \n -spec is_new_architecture_available() -> boolean().\n is_new_architecture_available() ->\n-    whereis(erlmcp_registry) =/= undefined andalso\n-    whereis(erlmcp_server_sup) =/= undefined andalso\n-    whereis(erlmcp_transport_sup) =/= undefined.\n+    whereis(erlmcp_registry) =/= undefined\n+    andalso whereis(erlmcp_server_sup) =/= undefined\n+    andalso whereis(erlmcp_transport_sup) =/= undefined.\n \n -spec create_transport_id(server_id(), binary()) -> transport_id().\n create_transport_id(ServerId, Type) ->\n     binary_to_atom(<<(atom_to_binary(ServerId))/binary, \"_\", Type/binary>>, utf8).\n@@ -1165,36 +1508,42 @@\n     case erlmcp_stdio_server:start_link(Options) of\n         {ok, ServerPid} ->\n             % Register as default stdio server if registry is available\n             case whereis(erlmcp_registry) of\n-                undefined -> \n+                undefined ->\n                     {ok, ServerPid};\n                 _ ->\n-                    ServerConfig = #{\n-                        capabilities => #mcp_server_capabilities{\n-                            resources = #mcp_capability{enabled = true},\n-                            tools = #mcp_capability{enabled = true},\n-                            prompts = #mcp_capability{enabled = true}\n-                        },\n-                        options => Options,\n-                        legacy => true\n-                    },\n-                    case erlmcp_registry:register_server(default_stdio_server, ServerPid, ServerConfig) of\n-                        ok -> {ok, ServerPid};\n-                        {error, already_registered} -> {ok, ServerPid};\n-                        {error, Reason} -> \n-                            logger:warning(\"Legacy server started but registration failed: ~p\", [Reason]),\n+                    ServerConfig =\n+                        #{capabilities =>\n+                              #mcp_server_capabilities{resources = #mcp_capability{enabled = true},\n+                                                       tools = #mcp_capability{enabled = true},\n+                                                       prompts = #mcp_capability{enabled = true}},\n+                          options => Options,\n+                          legacy => true},\n+                    case erlmcp_registry:register_server(default_stdio_server,\n+                                                         ServerPid,\n+                                                         ServerConfig)\n+                    of\n+                        ok ->\n+                            {ok, ServerPid};\n+                        {error, already_registered} ->\n+                            {ok, ServerPid};\n+                        {error, Reason} ->\n+                            logger:warning(\"Legacy server started but registration failed: ~p\",\n+                                           [Reason]),\n                             {ok, ServerPid}\n                     end\n             end;\n-        Error -> Error\n+        Error ->\n+            Error\n     end.\n \n -spec stop_legacy_stdio_server() -> ok.\n stop_legacy_stdio_server() ->\n     case whereis(erlmcp_stdio_server) of\n-        undefined -> ok;\n-        _Pid -> \n+        undefined ->\n+            ok;\n+        _Pid ->\n             erlmcp_stdio_server:stop(),\n             ok\n     end.\n \n@@ -1202,54 +1551,46 @@\n %% Enhanced Error Handling Functions - Phase 3 Step 7\n %%====================================================================\n \n %% @doc Format transport error with context\n--spec format_transport_error(transport_id(), transport_type(), atom(), term()) -> \n-    {error, term()}.\n+-spec format_transport_error(transport_id(), transport_type(), atom(), term()) ->\n+                                {error, term()}.\n format_transport_error(TransportId, Type, ErrorType, Reason) ->\n-    {error, #{\n-        error_type => ErrorType,\n-        transport_id => TransportId,\n-        transport_type => Type,\n-        reason => Reason,\n-        suggestion => get_transport_suggestion(Type, ErrorType, Reason),\n-        timestamp => erlang:timestamp()\n-    }}.\n+    {error,\n+     #{error_type => ErrorType,\n+       transport_id => TransportId,\n+       transport_type => Type,\n+       reason => Reason,\n+       suggestion => get_transport_suggestion(Type, ErrorType, Reason),\n+       timestamp => erlang:timestamp()}}.\n \n %% @doc Format setup error with context\n--spec format_setup_error(server_id(), transport_type(), atom(), term()) -> \n-    {error, term()}.\n+-spec format_setup_error(server_id(), transport_type(), atom(), term()) ->\n+                            {error, term()}.\n format_setup_error(ServerId, Type, ErrorType, Reason) ->\n-    {error, #{\n-        error_type => ErrorType,\n-        server_id => ServerId,\n-        transport_type => Type,\n-        reason => Reason,\n-        suggestion => get_setup_suggestion(Type, ErrorType),\n-        timestamp => erlang:timestamp()\n-    }}.\n+    {error,\n+     #{error_type => ErrorType,\n+       server_id => ServerId,\n+       transport_type => Type,\n+       reason => Reason,\n+       suggestion => get_setup_suggestion(Type, ErrorType),\n+       timestamp => erlang:timestamp()}}.\n \n %% @doc Format validation error details\n -spec format_validation_details(term()) -> map().\n format_validation_details({validation_error, ErrorType, Field, Message}) ->\n-    #{\n-        type => ErrorType,\n-        field => Field,\n-        message => Message,\n-        severity => error\n-    };\n+    #{type => ErrorType,\n+      field => Field,\n+      message => Message,\n+      severity => error};\n format_validation_details(Errors) when is_list(Errors) ->\n-    #{\n-        type => multiple_validation_errors,\n-        errors => [format_validation_details(E) || E <- Errors],\n-        severity => error\n-    };\n+    #{type => multiple_validation_errors,\n+      errors => [format_validation_details(E) || E <- Errors],\n+      severity => error};\n format_validation_details(Error) ->\n-    #{\n-        type => unknown_validation_error,\n-        details => Error,\n-        severity => error\n-    }.\n+    #{type => unknown_validation_error,\n+      details => Error,\n+      severity => error}.\n \n %% @doc Get validation suggestion based on error\n -spec get_validation_suggestion(transport_type(), term()) -> string().\n get_validation_suggestion(tcp, {validation_error, missing_field, host, _}) ->\n@@ -1258,11 +1599,13 @@\n     \"TCP transport requires 'port' field. Example: #{port => 8080}\";\n get_validation_suggestion(tcp, {validation_error, invalid_value, port, _}) ->\n     \"TCP port must be between 1 and 65535. Example: #{port => 8080}\";\n get_validation_suggestion(http, {validation_error, missing_field, url, _}) ->\n-    \"HTTP transport requires 'url' field. Example: #{url => \\\"http://localhost:8000/mcp\\\"}\";\n+    \"HTTP transport requires 'url' field. Example: #{url => \\\"http://loca\"\n+    \"lhost:8000/mcp\\\"}\";\n get_validation_suggestion(http, {validation_error, invalid_value, url, _}) ->\n-    \"HTTP URL must be valid HTTP/HTTPS URL. Example: #{url => \\\"https://api.example.com/mcp\\\"}\";\n+    \"HTTP URL must be valid HTTP/HTTPS URL. Example: #{url => \\\"https://a\"\n+    \"pi.example.com/mcp\\\"}\";\n get_validation_suggestion(stdio, {validation_error, invalid_type, test_mode, _}) ->\n     \"STDIO test_mode must be boolean. Example: #{test_mode => true}\";\n get_validation_suggestion(_Type, Error) ->\n     io_lib:format(\"Check transport configuration documentation. Error: ~p\", [Error]).\n@@ -1271,29 +1614,36 @@\n -spec get_transport_suggestion(transport_type(), atom(), term()) -> string().\n get_transport_suggestion(tcp, start_failed, {port_in_use, Port}) ->\n     io_lib:format(\"Port ~p is already in use. Try a different port number\", [Port]);\n get_transport_suggestion(tcp, start_failed, connection_refused) ->\n-    \"Connection refused. Check if the target host is reachable and accepting connections\";\n+    \"Connection refused. Check if the target host is reachable and \"\n+    \"accepting connections\";\n get_transport_suggestion(http, start_failed, {port_in_use, Port}) ->\n     io_lib:format(\"HTTP port ~p is already in use. Try a different port\", [Port]);\n get_transport_suggestion(http, start_failed, invalid_url) ->\n-    \"Invalid HTTP URL format. Use format: http://host:port/path or https://host:port/path\";\n+    \"Invalid HTTP URL format. Use format: http://host:port/path \"\n+    \"or https://host:port/path\";\n get_transport_suggestion(stdio, start_failed, _Reason) ->\n-    \"STDIO transport failed. Ensure standard input/output streams are available\";\n+    \"STDIO transport failed. Ensure standard input/output streams \"\n+    \"are available\";\n get_transport_suggestion(Type, ErrorType, Reason) ->\n-    io_lib:format(\"Transport ~p failed with ~p: ~p. Check transport logs for details\", \n+    io_lib:format(\"Transport ~p failed with ~p: ~p. Check transport logs for details\",\n                   [Type, ErrorType, Reason]).\n \n %% @doc Get setup suggestion based on error\n -spec get_setup_suggestion(transport_type(), atom()) -> string().\n get_setup_suggestion(_Type, server_start_failed) ->\n-    \"Server startup failed. Check server configuration and ensure required dependencies are available\";\n+    \"Server startup failed. Check server configuration and ensure \"\n+    \"required dependencies are available\";\n get_setup_suggestion(tcp, transport_start_failed) ->\n-    \"TCP transport setup failed. Verify host/port availability and network configuration\";\n+    \"TCP transport setup failed. Verify host/port availability and \"\n+    \"network configuration\";\n get_setup_suggestion(http, transport_start_failed) ->\n-    \"HTTP transport setup failed. Check URL accessibility and server configuration\";\n+    \"HTTP transport setup failed. Check URL accessibility and server \"\n+    \"configuration\";\n get_setup_suggestion(Type, ErrorType) ->\n-    io_lib:format(\"Setup failed for ~p transport with error ~p. Check system logs and configuration\", \n+    io_lib:format(\"Setup failed for ~p transport with error ~p. Check system logs \"\n+                  \"and configuration\",\n                   [Type, ErrorType]).\n \n %% @doc Clean up after failed setup\n -spec cleanup_failed_setup(server_id(), transport_type(), term()) -> {error, term()}.\n@@ -1315,17 +1665,16 @@\n         _ ->\n             case erlmcp_registry:find_transport(TransportId) of\n                 {ok, {TransportPid, Config}} ->\n                     ServerId = maps:get(server_id, Config, undefined),\n-                    {ok, #{\n-                        transport_id => TransportId,\n-                        transport_pid => TransportPid,\n-                        server_id => ServerId,\n-                        transport_type => maps:get(type, Config, unknown),\n-                        bound => ServerId =/= undefined,\n-                        config => Config,\n-                        status => get_process_status(TransportPid)\n-                    }};\n+                    {ok,\n+                     #{transport_id => TransportId,\n+                       transport_pid => TransportPid,\n+                       server_id => ServerId,\n+                       transport_type => maps:get(type, Config, unknown),\n+                       bound => ServerId =/= undefined,\n+                       config => Config,\n+                       status => get_process_status(TransportPid)}};\n                 {error, not_found} ->\n                     {error, transport_not_found}\n             end\n     end.\n@@ -1333,16 +1682,20 @@\n %% @doc List all transport bindings with detailed information\n -spec list_transport_bindings() -> [{transport_id(), map()}] | {error, term()}.\n list_transport_bindings() ->\n     case get_transport_bindings() of\n-        {error, _} = Error -> Error;\n+        {error, _} = Error ->\n+            Error;\n         Bindings ->\n-            DetailedBindings = lists:map(fun({TransportId, ServerId}) ->\n-                case get_transport_binding_info(TransportId) of\n-                    {ok, Info} -> {TransportId, Info#{server_id => ServerId}};\n-                    {error, _} -> {TransportId, #{server_id => ServerId, status => unknown}}\n-                end\n-            end, Bindings),\n+            DetailedBindings =\n+                lists:map(fun({TransportId, ServerId}) ->\n+                             case get_transport_binding_info(TransportId) of\n+                                 {ok, Info} -> {TransportId, Info#{server_id => ServerId}};\n+                                 {error, _} ->\n+                                     {TransportId, #{server_id => ServerId, status => unknown}}\n+                             end\n+                          end,\n+                          Bindings),\n             DetailedBindings\n     end.\n \n %% @doc Force rebind transport to different server\n@@ -1351,19 +1704,19 @@\n     case unbind_transport(TransportId) of\n         ok ->\n             case bind_transport_to_server(TransportId, NewServerId) of\n                 ok ->\n-                    logger:info(\"Successfully rebound transport ~p to server ~p\", \n-                              [TransportId, NewServerId]),\n+                    logger:info(\"Successfully rebound transport ~p to server ~p\",\n+                                [TransportId, NewServerId]),\n                     ok;\n                 {error, Reason} = Error ->\n-                    logger:error(\"Failed to rebind transport ~p to server ~p: ~p\", \n-                               [TransportId, NewServerId, Reason]),\n+                    logger:error(\"Failed to rebind transport ~p to server ~p: ~p\",\n+                                 [TransportId, NewServerId, Reason]),\n                     Error\n             end;\n         {error, Reason} = Error ->\n-            logger:error(\"Failed to unbind transport ~p before rebinding: ~p\", \n-                       [TransportId, Reason]),\n+            logger:error(\"Failed to unbind transport ~p before rebinding: ~p\",\n+                         [TransportId, Reason]),\n             Error\n     end.\n \n %% @doc Validate transport binding compatibility\n@@ -1372,14 +1725,17 @@\n     case {get_transport_config(TransportId), get_server_config(ServerId)} of\n         {{ok, TransportConfig}, {ok, ServerConfig}} ->\n             TransportType = maps:get(type, TransportConfig, unknown),\n             ServerCapabilities = maps:get(capabilities, ServerConfig, #{}),\n-            \n+\n             case is_compatible_binding(TransportType, ServerCapabilities) of\n-                true -> ok;\n-                false -> {error, {incompatible_binding, \n-                                 io_lib:format(\"Transport ~p not compatible with server ~p\", \n-                                             [TransportType, ServerId])}}\n+                true ->\n+                    ok;\n+                false ->\n+                    {error,\n+                     {incompatible_binding,\n+                      io_lib:format(\"Transport ~p not compatible with server ~p\",\n+                                    [TransportType, ServerId])}}\n             end;\n         {{error, transport_not_found}, _} ->\n             {error, transport_not_found};\n         {_, {error, server_not_found}} ->\n@@ -1396,76 +1752,253 @@\n     % TCP requires network-capable server\n     maps:get(network_enabled, ServerCapabilities, true);\n is_compatible_binding(http, ServerCapabilities) ->\n     % HTTP requires web-capable server\n-    maps:get(web_enabled, ServerCapabilities, true) andalso\n-    maps:get(http_enabled, ServerCapabilities, true);\n+    maps:get(web_enabled, ServerCapabilities, true)\n+    andalso maps:get(http_enabled, ServerCapabilities, true);\n is_compatible_binding(_Type, _Capabilities) ->\n     false.\n \n %% @doc Get process status\n -spec get_process_status(pid()) -> atom().\n get_process_status(Pid) ->\n     case is_process_alive(Pid) of\n-        true -> \n+        true ->\n             case process_info(Pid, status) of\n-                {status, Status} -> Status;\n-                undefined -> dead\n+                {status, Status} ->\n+                    Status;\n+                undefined ->\n+                    dead\n             end;\n-        false -> dead\n+        false ->\n+            dead\n     end.\n \n %% @doc Audit transport bindings for consistency\n -spec audit_transport_bindings() -> {ok, map()} | {error, term()}.\n audit_transport_bindings() ->\n     case list_transport_bindings() of\n-        {error, _} = Error -> Error;\n+        {error, _} = Error ->\n+            Error;\n         Bindings ->\n-            Issues = lists:foldl(fun({TransportId, Info}, Acc) ->\n-                case audit_single_binding(TransportId, Info) of\n-                    [] -> Acc;\n-                    BindingIssues -> [{TransportId, BindingIssues} | Acc]\n-                end\n-            end, [], Bindings),\n-            \n-            {ok, #{\n-                total_bindings => length(Bindings),\n-                healthy_bindings => length(Bindings) - length(Issues),\n-                issues => Issues,\n-                audit_time => erlang:timestamp()\n-            }}\n+            Issues =\n+                lists:foldl(fun({TransportId, Info}, Acc) ->\n+                               case audit_single_binding(TransportId, Info) of\n+                                   [] -> Acc;\n+                                   BindingIssues -> [{TransportId, BindingIssues} | Acc]\n+                               end\n+                            end,\n+                            [],\n+                            Bindings),\n+\n+            {ok,\n+             #{total_bindings => length(Bindings),\n+               healthy_bindings => length(Bindings) - length(Issues),\n+               issues => Issues,\n+               audit_time => erlang:timestamp()}}\n     end.\n \n %% @doc Audit single binding\n -spec audit_single_binding(transport_id(), map()) -> [atom()].\n audit_single_binding(TransportId, Info) ->\n     Issues = [],\n-    \n+\n     % Check if transport process is alive\n-    Issues1 = case maps:get(status, Info, unknown) of\n-        dead -> [dead_transport | Issues];\n-        _ -> Issues\n-    end,\n-    \n+    Issues1 =\n+        case maps:get(status, Info, unknown) of\n+            dead ->\n+                [dead_transport | Issues];\n+            _ ->\n+                Issues\n+        end,\n+\n     % Check if server binding is valid\n-    Issues2 = case maps:get(server_id, Info, undefined) of\n-        undefined -> [unbound_transport | Issues1];\n-        SrvId ->\n-            case get_server_config(SrvId) of\n-                {ok, _} -> Issues1;\n-                {error, server_not_found} -> [orphaned_binding | Issues1];\n-                {error, _} -> [server_unreachable | Issues1]\n-            end\n-    end,\n+    Issues2 =\n+        case maps:get(server_id, Info, undefined) of\n+            undefined ->\n+                [unbound_transport | Issues1];\n+            SrvId ->\n+                case get_server_config(SrvId) of\n+                    {ok, _} ->\n+                        Issues1;\n+                    {error, server_not_found} ->\n+                        [orphaned_binding | Issues1];\n+                    {error, _} ->\n+                        [server_unreachable | Issues1]\n+                end\n+        end,\n+\n+    % Check transport type compatibility\n+    Issues3 =\n+        case maps:get(server_id, Info, undefined) of\n+            undefined ->\n+                Issues2;\n+            ServerIdForBinding ->\n+                case validate_transport_binding(TransportId, ServerIdForBinding) of\n+                    ok ->\n+                        Issues2;\n+                    {error, {incompatible_binding, _}} ->\n+                        [incompatible_binding | Issues2];\n+                    {error, _} ->\n+                        [binding_validation_failed | Issues2]\n+                end\n+        end,\n+\n+    Issues3.\n+\n+%%====================================================================\n+%% Additional Enhanced API Functions - Phase 3 Step 7 Extensions\n+%%====================================================================\n+\n+%% @doc Get enhanced transport status with comprehensive information\n+-spec get_enhanced_transport_status(transport_id()) -> {ok, map()} | {error, term()}.\n+get_enhanced_transport_status(TransportId) ->\n+    case get_transport_binding_info(TransportId) of\n+        {ok, BasicInfo} ->\n+            % Enhance with additional runtime information\n+            Config = maps:get(config, BasicInfo, #{}),\n+            Pid = maps:get(transport_pid, BasicInfo),\n+            \n+            % Get process information\n+            ProcessInfo = case is_process_alive(Pid) of\n+                true ->\n+                    #{\n+                        message_queue_len => element(2, process_info(Pid, message_queue_len)),\n+                        memory => element(2, process_info(Pid, memory)),\n+                        reductions => element(2, process_info(Pid, reductions)),\n+                        status => element(2, process_info(Pid, status))\n+                    };\n+                false ->\n+                    #{status => dead}\n+            end,\n+            \n+            % Calculate uptime\n+            StartedAt = maps:get(started_at, Config, erlang:timestamp()),\n+            Now = erlang:timestamp(),\n+            UptimeMs = timer:now_diff(Now, StartedAt) div 1000,\n+            \n+            EnhancedInfo = BasicInfo#{\n+                process_info => ProcessInfo,\n+                uptime_ms => UptimeMs,\n+                config_hash => erlang:phash2(Config),\n+                last_checked => Now,\n+                enhanced => true\n+            },\n+            \n+            {ok, EnhancedInfo};\n+        Error ->\n+            Error\n+    end.\n+\n+%% @doc Perform bulk operations on multiple transports\n+-spec bulk_transport_operation(atom(), [transport_id()]) -> [{transport_id(), ok | {error, term()}}].\n+bulk_transport_operation(Operation, TransportIds) ->\n+    logger:info(\"Performing bulk transport operation ~p on ~p transports\", \n+               [Operation, length(TransportIds)]),\n     \n-    % Check transport type compatibility\n-    Issues3 = case maps:get(server_id, Info, undefined) of\n-        undefined -> Issues2;\n-        ServerIdForBinding ->\n-            case validate_transport_binding(TransportId, ServerIdForBinding) of\n-                ok -> Issues2;\n-                {error, {incompatible_binding, _}} -> [incompatible_binding | Issues2];\n-                {error, _} -> [binding_validation_failed | Issues2]\n+    Results = lists:map(fun(TransportId) ->\n+        Result = case Operation of\n+            stop ->\n+                stop_transport(TransportId);\n+            restart ->\n+                case stop_transport(TransportId) of\n+                    ok ->\n+                        timer:sleep(100), % Brief pause between stop and start\n+                        case get_transport_config(TransportId) of\n+                            {ok, Config} ->\n+                                Type = maps:get(type, Config, stdio),\n+                                start_transport(TransportId, Type, Config);\n+                            Error ->\n+                                Error\n+                        end;\n+                    Error ->\n+                        Error\n+                end;\n+            status ->\n+                get_enhanced_transport_status(TransportId);\n+            unbind ->\n+                unbind_transport(TransportId);\n+            _ ->\n+                {error, {unknown_operation, Operation}}\n+        end,\n+        {TransportId, Result}\n+    end, TransportIds),\n+    \n+    % Log summary\n+    SuccessCount = length([R || {_, ok} = R <- Results]) + \n+                   length([R || {_, {ok, _}} = R <- Results]),\n+    FailureCount = length(TransportIds) - SuccessCount,\n+    logger:info(\"Bulk operation ~p completed: ~p successes, ~p failures\", \n+               [Operation, SuccessCount, FailureCount]),\n+    \n+    Results.\n+\n+%% @doc Clean up stale or orphaned transports\n+-spec cleanup_stale_transports() -> {ok, map()} | {error, term()}.\n+cleanup_stale_transports() ->\n+    logger:info(\"Starting cleanup of stale transports\"),\n+    \n+    case list_transports() of\n+        [] ->\n+            {ok, #{cleaned => 0, errors => 0, total_checked => 0}};\n+        Transports ->\n+            Results = lists:map(fun({TransportId, {Pid, Config}}) ->\n+                case is_transport_stale(TransportId, Pid, Config) of\n+                    true ->\n+                        logger:info(\"Cleaning up stale transport ~p\", [TransportId]),\n+                        case stop_transport(TransportId) of\n+                            ok ->\n+                                {TransportId, cleaned};\n+                            Error ->\n+                                {TransportId, {error, Error}}\n+                        end;\n+                    false ->\n+                        {TransportId, healthy}\n+                end\n+            end, Transports),\n+            \n+            CleanedCount = length([R || {_, cleaned} = R <- Results]),\n+            ErrorCount = length([R || {_, {error, _}} = R <- Results]),\n+            HealthyCount = length([R || {_, healthy} = R <- Results]),\n+            \n+            Summary = #{\n+                cleaned => CleanedCount,\n+                errors => ErrorCount,\n+                healthy => HealthyCount,\n+                total_checked => length(Transports),\n+                details => Results\n+            },\n+            \n+            logger:info(\"Stale transport cleanup completed: ~p\", [Summary]),\n+            {ok, Summary}\n+    end.\n+\n+%% @doc Check if a transport is stale\n+-spec is_transport_stale(transport_id(), pid(), map()) -> boolean().\n+is_transport_stale(TransportId, Pid, Config) ->\n+    % Check if process is dead\n+    case is_process_alive(Pid) of\n+        false ->\n+            logger:debug(\"Transport ~p is stale: process dead\", [TransportId]),\n+            true;\n+        true ->\n+            % Check if transport has been idle too long\n+            StartedAt = maps:get(started_at, Config, erlang:timestamp()),\n+            Now = erlang:timestamp(),\n+            UptimeSeconds = timer:now_diff(Now, StartedAt) div 1000000,\n+            MaxIdleTime = maps:get(max_idle_seconds, Config, 3600), % 1 hour default\n+            \n+            case UptimeSeconds > MaxIdleTime of\n+                true ->\n+                    % Check if transport has been active recently\n+                    case process_info(Pid, message_queue_len) of\n+                        {message_queue_len, 0} ->\n+                            logger:debug(\"Transport ~p is stale: idle for ~p seconds\", \n+                                        [TransportId, UptimeSeconds]),\n+                            true;\n+                        _ ->\n+                            false\n+                    end;\n+                false ->\n+                    false\n             end\n-    end,\n-    \n-    Issues3.\n+    end.\n"
                },
                {
                    "date": 1756189703281,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1065,9 +1065,9 @@\n                                                 {error, BindError} ->\n                                                     logger:warning(\"TCP server ~p started but binding failed: ~p. Attempting recovery.\",\n                                                                    [ServerId, BindError]),\n                                                     % Attempt to recover by retrying the binding\n-                                                    case bind_transport_to_server(TransportId, ServerId) of\n+                                                    case retry_transport_binding(TransportId, ServerId, 3) of\n                                                         ok ->\n                                                             {ok,\n                                                              #{server => ServerPid,\n                                                                transport => TransportPid,\n@@ -1110,10 +1110,13 @@\n start_http_setup(ServerId, ServerConfig, HttpConfig) ->\n     logger:info(\"Setting up HTTP server ~p with Phase 3 enhanced validation and error handling\", [ServerId]),\n \n     % Pre-flight checks before starting setup\n-    case erlmcp_transport_validation:validate_transport_config(http, HttpConfig) of\n+    case validate_setup_prerequisites(http) of\n         ok ->\n+            % Enhanced validation with detailed error reporting\n+            case erlmcp_transport_validation:validate_transport_config(http, HttpConfig) of\n+                ok ->\n                     case start_server(ServerId, ServerConfig) of\n                         {ok, ServerPid} ->\n                             TransportId = create_transport_id(ServerId, <<\"http\">>),\n                             % Enhanced config with comprehensive metadata\n@@ -1151,9 +1154,9 @@\n                                                 {error, BindError} ->\n                                                     logger:warning(\"HTTP server ~p started but binding failed: ~p. Attempting recovery.\",\n                                                                    [ServerId, BindError]),\n                                                     % Attempt to recover by retrying the binding\n-                                                    case bind_transport_to_server(TransportId, ServerId) of\n+                                                    case retry_transport_binding(TransportId, ServerId, 3) of\n                                                         ok ->\n                                                             {ok,\n                                                              #{server => ServerPid,\n                                                                transport => TransportPid,\n@@ -1189,8 +1192,29 @@\n             logger:error(\"HTTP setup prerequisites not met for ~p: ~p\", [ServerId, PrereqError]),\n             format_setup_error(ServerId, http, prerequisites_failed, PrereqError)\n     end.\n \n+%% @doc Retry transport binding with exponential backoff\n+-spec retry_transport_binding(transport_id(), server_id(), non_neg_integer()) -> \n+    ok | {error, term()}.\n+retry_transport_binding(_TransportId, _ServerId, 0) ->\n+    {error, max_retries_exceeded};\n+retry_transport_binding(TransportId, ServerId, RetriesLeft) ->\n+    case bind_transport_to_server(TransportId, ServerId) of\n+        ok ->\n+            logger:info(\"Transport binding succeeded after retry: ~p -> ~p\", \n+                       [TransportId, ServerId]),\n+            ok;\n+        {error, _Reason} when RetriesLeft > 1 ->\n+            SleepTime = (4 - RetriesLeft) * 100, % 100, 200, 300ms\n+            timer:sleep(SleepTime),\n+            retry_transport_binding(TransportId, ServerId, RetriesLeft - 1);\n+        {error, FinalReason} ->\n+            logger:warning(\"Final retry failed for transport binding ~p -> ~p: ~p\",\n+                          [TransportId, ServerId, FinalReason]),\n+            {error, FinalReason}\n+    end.\n+\n %% Batch add multiple resources, tools, and prompts\n -spec setup_server_components(server_id(), map()) -> ok | {error, term()}.\n setup_server_components(ServerId, Components) ->\n     Resources = maps:get(resources, Components, []),\n@@ -1368,21 +1392,14 @@\n %% Transport implementation helper\n -spec start_transport_impl(transport_id(), transport_type(), map()) ->\n                               {ok, pid()} | {error, term()}.\n start_transport_impl(TransportId, stdio, Config) ->\n-    erlmcp_transport_stdio_new:start_link(TransportId, Config);\n-start_transport_impl(_TransportId, tcp, Config) ->\n-    % Placeholder for TCP implementation\n-    Port = maps:get(port, Config, 8080),\n-    Host = maps:get(host, Config, \"localhost\"),\n-    logger:info(\"TCP transport would start on ~s:~p\", [Host, Port]),\n-    {error, {transport_not_implemented, tcp}};\n-start_transport_impl(_TransportId, http, Config) ->\n+    erlmcp_transport_sup:start_child(TransportId, stdio, Config);\n+start_transport_impl(TransportId, tcp, Config) ->\n+    erlmcp_transport_sup:start_child(TransportId, tcp, Config);\n+start_transport_impl(TransportId, http, Config) ->\n     % Placeholder for HTTP implementation\n-    Port = maps:get(port, Config, 8000),\n-    Path = maps:get(path, Config, \"/mcp\"),\n-    logger:info(\"HTTP transport would start on port ~p path ~s\", [Port, Path]),\n-    {error, {transport_not_implemented, http}};\n+    erlmcp_transport_sup:start_child(TransportId, http, Config);\n start_transport_impl(_TransportId, Type, _Config) ->\n     {error, {unknown_transport_type, Type}}.\n \n %% Enhanced configuration validation (delegated to validation module)\n"
                },
                {
                    "date": 1756190231820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,21 +12,27 @@\n %% Configuration API\n -export([get_server_config/1, update_server_config/2, get_transport_config/1,\n          update_transport_config/2, validate_transport_config/1, get_config_schema/1,\n          validate_config_field/3]).\n+\n+%% Phase 3 configuration validation coordination API\n+-export([store_validation_schemas/0, get_validation_schemas_from_memory/0,\n+         validate_transport_with_coordination/2, initialize_config_validation/0]).\n %% Legacy compatibility for stdio server\n -export([start_stdio_server/0, start_stdio_server/1, stop_stdio_server/0]).\n %% Convenience functions\n -export([start_stdio_setup/2, start_tcp_setup/3, start_http_setup/3,\n          setup_server_components/2, quick_stdio_server/3, validate_transport_config/2,\n          get_transport_bindings/0, cleanup_transport_bindings/1, list_supported_transport_types/0,\n          get_config_examples/0]).\n %% Enhanced API functions - Phase 3 Step 7\n--export([format_validation_error/3, format_validation_error_enhanced/3, format_transport_error/4, format_setup_error/4,\n-         get_transport_binding_info/1, list_transport_bindings/0, rebind_transport/2,\n-         validate_transport_binding/2, audit_transport_bindings/0, cleanup_failed_setup/3,\n-         validate_setup_prerequisites/1, ensure_transport_supervisor/0, retry_transport_binding/3,\n-         get_enhanced_transport_status/1, bulk_transport_operation/2, cleanup_stale_transports/0]).\n+-export([format_validation_error/3, format_validation_error_enhanced/3,\n+         format_transport_error/4, format_setup_error/4, get_transport_binding_info/1,\n+         list_transport_bindings/0, rebind_transport/2, validate_transport_binding/2,\n+         audit_transport_bindings/0, cleanup_failed_setup/3, validate_setup_prerequisites/1,\n+         ensure_transport_supervisor/0, retry_transport_binding/3, get_enhanced_transport_status/1,\n+         bulk_transport_operation/2, cleanup_stale_transports/0, validate_transport_health/2,\n+         start_transport_enhanced/3, start_transport_with_retry/4]).\n \n %% Types\n -type server_id() :: atom().\n -type transport_id() :: atom().\n@@ -120,54 +126,75 @@\n \n -spec start_transport(transport_id(), transport_type(), map()) ->\n                          {ok, pid()} | {error, term()}.\n start_transport(TransportId, Type, Config) ->\n-    logger:info(\"Starting transport ~p of type ~p with enhanced validation\",\n+    logger:info(\"Starting transport ~p of type ~p with Phase 3 enhanced validation and management\",\n                 [TransportId, Type]),\n \n-    % Enhanced validation using dedicated validation module with comprehensive error handling\n-    ConfigWithType = Config#{type => Type},\n-    case erlmcp_transport_validation:validate_transport_config(Type, ConfigWithType) of\n+    % Phase 3 Enhancement: Pre-flight validation and prerequisite checks\n+    case validate_setup_prerequisites(Type) of\n         ok ->\n-            % Ensure transport supervisor is available\n-            case ensure_transport_supervisor() of\n+            % Enhanced validation using dedicated validation module with comprehensive error handling\n+            ConfigWithType = Config#{type => Type, \n+                                     phase => 3,\n+                                     api_version => \"3.0\",\n+                                     enhancement_level => high_level_api},\n+            case erlmcp_transport_validation:validate_transport_config(Type, ConfigWithType) of\n                 ok ->\n-                    case start_transport_impl(TransportId, Type, ConfigWithType) of\n-                        {ok, TransportPid} ->\n-                            % Enhanced transport configuration with metadata\n-                            TransportConfig =\n-                                ConfigWithType#{started_at => erlang:timestamp(),\n-                                                validation_passed => true,\n-                                                transport_version => \"1.0\",\n-                                                startup_method => enhanced_api},\n-                            case register_transport_with_registry(TransportId,\n-                                                                  TransportPid,\n-                                                                  TransportConfig)\n-                            of\n-                                ok ->\n-                                    logger:info(\"Successfully started and registered transport ~p (~p) with \"\n-                                                \"enhanced validation\",\n-                                                [TransportId, Type]),\n-                                    {ok, TransportPid};\n+                    % Ensure transport supervisor is available with enhanced startup\n+                    case ensure_transport_supervisor() of\n+                        ok ->\n+                            case start_transport_impl(TransportId, Type, ConfigWithType) of\n+                                {ok, TransportPid} ->\n+                                    % Phase 3 Enhanced transport configuration with comprehensive metadata\n+                                    TransportConfig =\n+                                        ConfigWithType#{started_at => erlang:timestamp(),\n+                                                        validation_passed => true,\n+                                                        transport_version => \"3.0\",\n+                                                        startup_method => enhanced_phase3_api,\n+                                                        health_check_interval => 30000,\n+                                                        auto_recovery_enabled => true,\n+                                                        binding_validation_enabled => true},\n+                                    case register_transport_with_registry(TransportId,\n+                                                                          TransportPid,\n+                                                                          TransportConfig)\n+                                    of\n+                                        ok ->\n+                                            % Phase 3: Post-startup validation and health check\n+                                            case validate_transport_health(TransportId, TransportPid) of\n+                                                ok ->\n+                                                    logger:info(\"Phase 3: Successfully started, registered and validated transport ~p (~p) with \"\n+                                                                \"enhanced features\",\n+                                                                [TransportId, Type]),\n+                                                    {ok, TransportPid};\n+                                                {error, HealthError} ->\n+                                                    logger:warning(\"Transport ~p started but health check failed: ~p\",\n+                                                                   [TransportId, HealthError]),\n+                                                    {ok, TransportPid} % Still return success but log warning\n+                                            end;\n+                                        {error, Reason} ->\n+                                            logger:warning(\"Transport ~p started but registry registration failed: ~p\",\n+                                                           [TransportId, Reason]),\n+                                            {ok, TransportPid}\n+                                    end;\n                                 {error, Reason} ->\n-                                    logger:warning(\"Transport ~p started but registry registration failed: ~p\",\n-                                                   [TransportId, Reason]),\n-                                    {ok, TransportPid}\n+                                    logger:error(\"Failed to start transport ~p (~p): ~p\",\n+                                                 [TransportId, Type, Reason]),\n+                                    format_transport_error(TransportId, Type, start_failed, Reason)\n                             end;\n-                        {error, Reason} ->\n-                            logger:error(\"Failed to start transport ~p (~p): ~p\",\n-                                         [TransportId, Type, Reason]),\n-                            format_transport_error(TransportId, Type, start_failed, Reason)\n+                        {error, SupervisorError} ->\n+                            logger:error(\"Transport supervisor unavailable for ~p (~p): ~p\",\n+                                         [TransportId, Type, SupervisorError]),\n+                            format_setup_error(TransportId, Type, supervisor_unavailable, SupervisorError)\n                     end;\n-                {error, SupervisorError} ->\n-                    logger:error(\"Transport supervisor unavailable for ~p (~p): ~p\",\n-                                 [TransportId, Type, SupervisorError]),\n-                    format_setup_error(TransportId, Type, supervisor_unavailable, SupervisorError)\n+                {error, ValidationError} ->\n+                    logger:error(\"Transport config validation failed for ~p (~p): ~p\",\n+                                 [TransportId, Type, ValidationError]),\n+                    format_validation_error_enhanced(TransportId, Type, ValidationError)\n             end;\n-        {error, ValidationError} ->\n-            logger:error(\"Transport config validation failed for ~p (~p): ~p\",\n-                         [TransportId, Type, ValidationError]),\n-            format_validation_error_enhanced(TransportId, Type, ValidationError)\n+        {error, PrereqError} ->\n+            logger:error(\"Transport prerequisites not met for ~p (~p): ~p\", [TransportId, Type, PrereqError]),\n+            format_setup_error(TransportId, Type, prerequisites_failed, PrereqError)\n     end.\n \n -spec stop_transport(transport_id()) -> ok | {error, term()}.\n stop_transport(TransportId) ->\n@@ -538,19 +565,37 @@\n                             {error, \"must be positive integer (bytes)\"}\n                     end},\n           description => \"HTTP transport configuration for web-based communication\"}).\n \n-%% @doc Validate transport configuration using schema-based approach\n+%% @doc Validate transport configuration using schema-based approach with coordination hooks\n -spec validate_transport_config(map()) -> ok | {error, term()}.\n validate_transport_config(Config) ->\n+    %% Store validation attempt in memory for coordination\n+    ValidationKey = \"phase3/config/validation\",\n+    ValidationData = #{\n+        timestamp => erlang:timestamp(),\n+        config_hash => erlang:phash2(Config),\n+        validation_attempt => true,\n+        config_type => maps:get(type, Config, unknown)\n+    },\n+    store_in_memory(ValidationKey, ValidationData),\n+    \n     case maps:get(type, Config, undefined) of\n         undefined ->\n-            format_validation_error(missing_required_field,\n+            ValidationError = format_validation_error(missing_required_field,\n                                     type,\n                                     \"Configuration must specify transport type. Valid types: stdio, \"\n-                                    \"tcp, http\");\n+                                    \"tcp, http\"),\n+            %% Log validation failure in memory\n+            ErrorKey = \"phase3/config/validation/errors\",\n+            store_validation_error(ErrorKey, ValidationError, Config),\n+            ValidationError;\n         Type ->\n-            validate_transport_config_with_schema(Type, Config)\n+            Result = validate_transport_config_with_schema(Type, Config),\n+            %% Log validation result in memory\n+            ResultKey = \"phase3/config/validation/results\",\n+            store_validation_result(ResultKey, Type, Result, Config),\n+            Result\n     end.\n \n %% @doc Enhanced schema-based validation\n -spec validate_transport_config_with_schema(atom(), map()) -> ok | {error, term()}.\n@@ -645,46 +690,47 @@\n %% @doc Format validation error with enhanced context for Phase 3\n format_validation_error_enhanced(TransportId, Type, ValidationError) ->\n     case ValidationError of\n         {validation_error, ErrorType, Field, Message} ->\n-            EnhancedError = #{\n-                error_category => validation_error,\n-                transport_id => TransportId,\n-                transport_type => Type,\n-                error_type => ErrorType,\n-                field => Field,\n-                message => lists:flatten(io_lib:format(\"~s\", [Message])),\n-                suggestion => get_validation_suggestion(Type, ValidationError),\n-                timestamp => erlang:timestamp(),\n-                phase => 3,\n-                step => 7\n-            },\n+            EnhancedError =\n+                #{error_category => validation_error,\n+                  transport_id => TransportId,\n+                  transport_type => Type,\n+                  error_type => ErrorType,\n+                  field => Field,\n+                  message =>\n+                      lists:flatten(\n+                          io_lib:format(\"~s\", [Message])),\n+                  suggestion => get_validation_suggestion(Type, ValidationError),\n+                  timestamp => erlang:timestamp(),\n+                  phase => 3,\n+                  step => 7},\n             {error, EnhancedError};\n         {validation_error, ErrorType, Fields, Message} when is_list(Fields) ->\n-            EnhancedError = #{\n-                error_category => validation_error,\n-                transport_id => TransportId,\n-                transport_type => Type,\n-                error_type => ErrorType,\n-                fields => Fields,\n-                message => lists:flatten(io_lib:format(\"~s\", [Message])),\n-                suggestion => get_validation_suggestion(Type, ValidationError),\n-                timestamp => erlang:timestamp(),\n-                phase => 3,\n-                step => 7\n-            },\n+            EnhancedError =\n+                #{error_category => validation_error,\n+                  transport_id => TransportId,\n+                  transport_type => Type,\n+                  error_type => ErrorType,\n+                  fields => Fields,\n+                  message =>\n+                      lists:flatten(\n+                          io_lib:format(\"~s\", [Message])),\n+                  suggestion => get_validation_suggestion(Type, ValidationError),\n+                  timestamp => erlang:timestamp(),\n+                  phase => 3,\n+                  step => 7},\n             {error, EnhancedError};\n         Other ->\n-            {error, #{\n-                error_category => validation_error,\n-                transport_id => TransportId,\n-                transport_type => Type,\n-                error_type => unknown_validation_error,\n-                details => Other,\n-                timestamp => erlang:timestamp(),\n-                phase => 3,\n-                step => 7\n-            }}\n+            {error,\n+             #{error_category => validation_error,\n+               transport_id => TransportId,\n+               transport_type => Type,\n+               error_type => unknown_validation_error,\n+               details => Other,\n+               timestamp => erlang:timestamp(),\n+               phase => 3,\n+               step => 7}}\n     end.\n \n %% @doc Legacy validation function - now delegates to schema-based approach\n -spec validate_transport_config_by_type(atom(), map()) -> ok | {error, term()}.\n@@ -1021,9 +1067,11 @@\n %% Create a complete MCP server setup with TCP transport - Enhanced Phase 3 Implementation\n -spec start_tcp_setup(server_id(), map(), map()) ->\n                          {ok, #{server => pid(), transport => pid()}} | {error, term()}.\n start_tcp_setup(ServerId, ServerConfig, TcpConfig) ->\n-    logger:info(\"Setting up TCP server ~p with Phase 3 enhanced validation and error handling\", [ServerId]),\n+    logger:info(\"Setting up TCP server ~p with Phase 3 enhanced validation and \"\n+                \"error handling\",\n+                [ServerId]),\n \n     % Pre-flight checks before starting setup\n     case validate_setup_prerequisites(tcp) of\n         ok ->\n@@ -1049,25 +1097,32 @@\n                                     case validate_transport_binding(TransportId, ServerId) of\n                                         ok ->\n                                             case bind_transport_to_server(TransportId, ServerId) of\n                                                 ok ->\n-                                                    logger:info(\"TCP setup completed successfully for ~p (~s:~p) with enhanced features\",\n+                                                    logger:info(\"TCP setup completed successfully for ~p (~s:~p) with enhanced \"\n+                                                                \"features\",\n                                                                 [ServerId,\n-                                                                 maps:get(host, TcpConfig, \"localhost\"),\n+                                                                 maps:get(host,\n+                                                                          TcpConfig,\n+                                                                          \"localhost\"),\n                                                                  maps:get(port, TcpConfig, 8080)]),\n                                                     {ok,\n                                                      #{server => ServerPid,\n                                                        transport => TransportPid,\n                                                        transport_id => TransportId,\n                                                        config => TransportConfig,\n-                                                       setup_metadata => #{type => tcp,\n-                                                                           version => \"3.0\",\n-                                                                           binding_validated => true}}};\n+                                                       setup_metadata =>\n+                                                           #{type => tcp,\n+                                                             version => \"3.0\",\n+                                                             binding_validated => true}}};\n                                                 {error, BindError} ->\n                                                     logger:warning(\"TCP server ~p started but binding failed: ~p. Attempting recovery.\",\n                                                                    [ServerId, BindError]),\n                                                     % Attempt to recover by retrying the binding\n-                                                    case retry_transport_binding(TransportId, ServerId, 3) of\n+                                                    case retry_transport_binding(TransportId,\n+                                                                                 ServerId,\n+                                                                                 3)\n+                                                    of\n                                                         ok ->\n                                                             {ok,\n                                                              #{server => ServerPid,\n                                                                transport => TransportPid,\n@@ -1083,21 +1138,25 @@\n                                             end;\n                                         {error, BindingValidationError} ->\n                                             logger:error(\"TCP binding validation failed for ~p: ~p\",\n                                                          [ServerId, BindingValidationError]),\n-                                            cleanup_failed_setup(ServerId, tcp, BindingValidationError)\n+                                            cleanup_failed_setup(ServerId,\n+                                                                 tcp,\n+                                                                 BindingValidationError)\n                                     end;\n                                 {error, TransportError} ->\n                                     logger:error(\"TCP transport setup failed for ~p: ~p\",\n                                                  [ServerId, TransportError]),\n                                     cleanup_failed_setup(ServerId, tcp, TransportError)\n                             end;\n                         {error, ServerError} ->\n-                            logger:error(\"Server setup failed for TCP ~p: ~p\", [ServerId, ServerError]),\n+                            logger:error(\"Server setup failed for TCP ~p: ~p\",\n+                                         [ServerId, ServerError]),\n                             format_setup_error(ServerId, tcp, server_start_failed, ServerError)\n                     end;\n                 {error, ValidationError} ->\n-                    logger:error(\"TCP config validation failed for ~p: ~p\", [ServerId, ValidationError]),\n+                    logger:error(\"TCP config validation failed for ~p: ~p\",\n+                                 [ServerId, ValidationError]),\n                     format_validation_error(ServerId, tcp, ValidationError)\n             end;\n         {error, PrereqError} ->\n             logger:error(\"TCP setup prerequisites not met for ~p: ~p\", [ServerId, PrereqError]),\n@@ -1107,9 +1166,11 @@\n %% Create a complete MCP server setup with HTTP transport - Enhanced Phase 3 Implementation\n -spec start_http_setup(server_id(), map(), map()) ->\n                           {ok, #{server => pid(), transport => pid()}} | {error, term()}.\n start_http_setup(ServerId, ServerConfig, HttpConfig) ->\n-    logger:info(\"Setting up HTTP server ~p with Phase 3 enhanced validation and error handling\", [ServerId]),\n+    logger:info(\"Setting up HTTP server ~p with Phase 3 enhanced validation \"\n+                \"and error handling\",\n+                [ServerId]),\n \n     % Pre-flight checks before starting setup\n     case validate_setup_prerequisites(http) of\n         ok ->\n@@ -1136,9 +1197,10 @@\n                                     case validate_transport_binding(TransportId, ServerId) of\n                                         ok ->\n                                             case bind_transport_to_server(TransportId, ServerId) of\n                                                 ok ->\n-                                                    logger:info(\"HTTP setup completed successfully for ~p (~s) with enhanced features\",\n+                                                    logger:info(\"HTTP setup completed successfully for ~p (~s) with enhanced \"\n+                                                                \"features\",\n                                                                 [ServerId,\n                                                                  maps:get(url,\n                                                                           HttpConfig,\n                                                                           \"http://localhost:8000/mcp\")]),\n@@ -1146,17 +1208,24 @@\n                                                      #{server => ServerPid,\n                                                        transport => TransportPid,\n                                                        transport_id => TransportId,\n                                                        config => TransportConfig,\n-                                                       setup_metadata => #{type => http,\n-                                                                           version => \"3.0\",\n-                                                                           binding_validated => true,\n-                                                                           url => maps:get(url, HttpConfig, \"http://localhost:8000/mcp\")}}};\n+                                                       setup_metadata =>\n+                                                           #{type => http,\n+                                                             version => \"3.0\",\n+                                                             binding_validated => true,\n+                                                             url =>\n+                                                                 maps:get(url,\n+                                                                          HttpConfig,\n+                                                                          \"http://localhost:8000/mcp\")}}};\n                                                 {error, BindError} ->\n                                                     logger:warning(\"HTTP server ~p started but binding failed: ~p. Attempting recovery.\",\n                                                                    [ServerId, BindError]),\n                                                     % Attempt to recover by retrying the binding\n-                                                    case retry_transport_binding(TransportId, ServerId, 3) of\n+                                                    case retry_transport_binding(TransportId,\n+                                                                                 ServerId,\n+                                                                                 3)\n+                                                    of\n                                                         ok ->\n                                                             {ok,\n                                                              #{server => ServerPid,\n                                                                transport => TransportPid,\n@@ -1172,46 +1241,50 @@\n                                             end;\n                                         {error, BindingValidationError} ->\n                                             logger:error(\"HTTP binding validation failed for ~p: ~p\",\n                                                          [ServerId, BindingValidationError]),\n-                                            cleanup_failed_setup(ServerId, http, BindingValidationError)\n+                                            cleanup_failed_setup(ServerId,\n+                                                                 http,\n+                                                                 BindingValidationError)\n                                     end;\n                                 {error, TransportError} ->\n                                     logger:error(\"HTTP transport setup failed for ~p: ~p\",\n                                                  [ServerId, TransportError]),\n                                     cleanup_failed_setup(ServerId, http, TransportError)\n                             end;\n                         {error, ServerError} ->\n-                            logger:error(\"Server setup failed for HTTP ~p: ~p\", [ServerId, ServerError]),\n+                            logger:error(\"Server setup failed for HTTP ~p: ~p\",\n+                                         [ServerId, ServerError]),\n                             format_setup_error(ServerId, http, server_start_failed, ServerError)\n                     end;\n                 {error, ValidationError} ->\n-                    logger:error(\"HTTP config validation failed for ~p: ~p\", [ServerId, ValidationError]),\n+                    logger:error(\"HTTP config validation failed for ~p: ~p\",\n+                                 [ServerId, ValidationError]),\n                     format_validation_error(ServerId, http, ValidationError)\n             end;\n         {error, PrereqError} ->\n             logger:error(\"HTTP setup prerequisites not met for ~p: ~p\", [ServerId, PrereqError]),\n             format_setup_error(ServerId, http, prerequisites_failed, PrereqError)\n     end.\n \n %% @doc Retry transport binding with exponential backoff\n--spec retry_transport_binding(transport_id(), server_id(), non_neg_integer()) -> \n-    ok | {error, term()}.\n+-spec retry_transport_binding(transport_id(), server_id(), non_neg_integer()) ->\n+                                 ok | {error, term()}.\n retry_transport_binding(_TransportId, _ServerId, 0) ->\n     {error, max_retries_exceeded};\n retry_transport_binding(TransportId, ServerId, RetriesLeft) ->\n     case bind_transport_to_server(TransportId, ServerId) of\n         ok ->\n-            logger:info(\"Transport binding succeeded after retry: ~p -> ~p\", \n-                       [TransportId, ServerId]),\n+            logger:info(\"Transport binding succeeded after retry: ~p -> ~p\",\n+                        [TransportId, ServerId]),\n             ok;\n         {error, _Reason} when RetriesLeft > 1 ->\n             SleepTime = (4 - RetriesLeft) * 100, % 100, 200, 300ms\n             timer:sleep(SleepTime),\n             retry_transport_binding(TransportId, ServerId, RetriesLeft - 1);\n         {error, FinalReason} ->\n             logger:warning(\"Final retry failed for transport binding ~p -> ~p: ~p\",\n-                          [TransportId, ServerId, FinalReason]),\n+                           [TransportId, ServerId, FinalReason]),\n             {error, FinalReason}\n     end.\n \n %% Batch add multiple resources, tools, and prompts\n@@ -1387,9 +1460,8 @@\n         _Pid ->\n             ok\n     end.\n \n-\n %% Transport implementation helper\n -spec start_transport_impl(transport_id(), transport_type(), map()) ->\n                               {ok, pid()} | {error, term()}.\n start_transport_impl(TransportId, stdio, Config) ->\n@@ -1564,8 +1636,173 @@\n             ok\n     end.\n \n %%====================================================================\n+%% Configuration Validation Memory Storage - Phase 3 Implementation\n+%%====================================================================\n+\n+%% @doc Store validation data in coordination memory\n+-spec store_in_memory(string(), map()) -> ok.\n+store_in_memory(Key, Data) ->\n+    try\n+        case whereis(erlmcp_registry) of\n+            undefined ->\n+                %% Use basic memory storage for test environments\n+                put({validation_memory, Key}, Data),\n+                ok;\n+            _Pid ->\n+                %% Use registry-based storage in production\n+                erlmcp_registry:store_validation_data(Key, Data)\n+        end\n+    catch\n+        _:_ ->\n+            %% Fallback to process dictionary\n+            put({validation_memory, Key}, Data),\n+            ok\n+    end.\n+\n+%% @doc Store validation error in memory with detailed context\n+-spec store_validation_error(string(), term(), map()) -> ok.\n+store_validation_error(Key, Error, Config) ->\n+    ErrorData = #{\n+        error => Error,\n+        config => maps:without([password, secret, token], Config),\n+        timestamp => erlang:timestamp(),\n+        phase => 3,\n+        validation_type => error\n+    },\n+    store_in_memory(Key, ErrorData).\n+\n+%% @doc Store validation result in memory with detailed context\n+-spec store_validation_result(string(), atom(), term(), map()) -> ok.\n+store_validation_result(Key, Type, Result, Config) ->\n+    ResultData = #{\n+        transport_type => Type,\n+        result => case Result of\n+                      ok -> success;\n+                      {error, _} -> failure;\n+                      Other -> Other\n+                  end,\n+        detailed_result => Result,\n+        config_hash => erlang:phash2(Config),\n+        timestamp => erlang:timestamp(),\n+        phase => 3,\n+        validation_type => result\n+    },\n+    store_in_memory(Key, ResultData).\n+\n+%% @doc Store validation schemas in memory for documentation and introspection\n+-spec store_validation_schemas() -> ok.\n+store_validation_schemas() ->\n+    SchemaKey = \"phase3/config/validation\",\n+    Schemas = #{\n+        stdio => ?STDIO_CONFIG_SCHEMA,\n+        tcp => ?TCP_CONFIG_SCHEMA, \n+        http => ?HTTP_CONFIG_SCHEMA,\n+        metadata => #{\n+            version => \"1.0.0\",\n+            phase => 3,\n+            last_updated => erlang:timestamp(),\n+            supported_types => [stdio, tcp, http],\n+            validation_features => [\n+                schema_based,\n+                field_validators,\n+                comprehensive_errors,\n+                memory_coordination,\n+                type_specific_validation\n+            ]\n+        }\n+    },\n+    store_in_memory(SchemaKey, Schemas).\n+\n+%% @doc Get validation schemas from memory\n+-spec get_validation_schemas_from_memory() -> {ok, map()} | {error, term()}.\n+get_validation_schemas_from_memory() ->\n+    Key = \"phase3/config/validation\",\n+    try\n+        case get({validation_memory, Key}) of\n+            undefined ->\n+                %% Try to load from registry\n+                case whereis(erlmcp_registry) of\n+                    undefined ->\n+                        %% Initialize schemas if not found\n+                        store_validation_schemas(),\n+                        {ok, #{stdio => ?STDIO_CONFIG_SCHEMA,\n+                               tcp => ?TCP_CONFIG_SCHEMA,\n+                               http => ?HTTP_CONFIG_SCHEMA}};\n+                    _Pid ->\n+                        case erlmcp_registry:get_validation_data(Key) of\n+                            {ok, Data} -> {ok, Data};\n+                            {error, not_found} ->\n+                                store_validation_schemas(),\n+                                {ok, #{stdio => ?STDIO_CONFIG_SCHEMA,\n+                                       tcp => ?TCP_CONFIG_SCHEMA,\n+                                       http => ?HTTP_CONFIG_SCHEMA}};\n+                            Error -> Error\n+                        end\n+                end;\n+            Data ->\n+                {ok, Data}\n+        end\n+    catch\n+        _:Reason ->\n+            {error, {memory_access_failed, Reason}}\n+    end.\n+\n+%% @doc Initialize configuration validation system with coordination hooks\n+-spec initialize_config_validation() -> ok.\n+initialize_config_validation() ->\n+    %% Initialize schemas in memory\n+    store_validation_schemas(),\n+    %% Set up coordination hooks if available\n+    setup_coordination_hooks(),\n+    logger:info(\"Configuration validation system initialized with Phase 3 coordination\"),\n+    ok.\n+\n+%% @doc Setup coordination hooks for validation system\n+-spec setup_coordination_hooks() -> ok.\n+setup_coordination_hooks() ->\n+    try\n+        %% Store initial coordination data\n+        HookData = #{\n+            system => configuration_validation,\n+            phase => 3,\n+            capabilities => [schema_validation, memory_storage, error_tracking],\n+            initialized_at => erlang:timestamp()\n+        },\n+        store_in_memory(\"phase3/config/hooks\", HookData),\n+        ok\n+    catch\n+        _:_ -> ok  %% Non-critical failure\n+    end.\n+\n+%% @doc Validate transport configuration with full coordination support\n+-spec validate_transport_with_coordination(atom(), map()) -> ok | {error, term()}.\n+validate_transport_with_coordination(TransportType, Config) ->\n+    %% Store validation attempt with coordination context\n+    CoordKey = \"phase3/config/coordination/\" ++ atom_to_list(TransportType),\n+    CoordData = #{\n+        transport_type => TransportType,\n+        config_hash => erlang:phash2(Config),\n+        validation_start => erlang:timestamp(),\n+        coordination_enabled => true\n+    },\n+    store_in_memory(CoordKey, CoordData),\n+    \n+    %% Perform validation with enhanced error handling\n+    Result = validate_transport_config_with_schema(TransportType, Config),\n+    \n+    %% Update coordination data with result\n+    FinalCoordData = CoordData#{\n+        validation_end => erlang:timestamp(),\n+        result => Result,\n+        validation_completed => true\n+    },\n+    store_in_memory(CoordKey, FinalCoordData),\n+    \n+    Result.\n+\n+%%====================================================================\n %% Enhanced Error Handling Functions - Phase 3 Step 7\n %%====================================================================\n \n %% @doc Format transport error with context\n@@ -1873,119 +2110,116 @@\n         {ok, BasicInfo} ->\n             % Enhance with additional runtime information\n             Config = maps:get(config, BasicInfo, #{}),\n             Pid = maps:get(transport_pid, BasicInfo),\n-            \n+\n             % Get process information\n-            ProcessInfo = case is_process_alive(Pid) of\n-                true ->\n-                    #{\n-                        message_queue_len => element(2, process_info(Pid, message_queue_len)),\n-                        memory => element(2, process_info(Pid, memory)),\n-                        reductions => element(2, process_info(Pid, reductions)),\n-                        status => element(2, process_info(Pid, status))\n-                    };\n-                false ->\n-                    #{status => dead}\n-            end,\n-            \n+            ProcessInfo =\n+                case is_process_alive(Pid) of\n+                    true ->\n+                        #{message_queue_len => element(2, process_info(Pid, message_queue_len)),\n+                          memory => element(2, process_info(Pid, memory)),\n+                          reductions => element(2, process_info(Pid, reductions)),\n+                          status => element(2, process_info(Pid, status))};\n+                    false ->\n+                        #{status => dead}\n+                end,\n+\n             % Calculate uptime\n             StartedAt = maps:get(started_at, Config, erlang:timestamp()),\n             Now = erlang:timestamp(),\n             UptimeMs = timer:now_diff(Now, StartedAt) div 1000,\n-            \n-            EnhancedInfo = BasicInfo#{\n-                process_info => ProcessInfo,\n-                uptime_ms => UptimeMs,\n-                config_hash => erlang:phash2(Config),\n-                last_checked => Now,\n-                enhanced => true\n-            },\n-            \n+\n+            EnhancedInfo =\n+                BasicInfo#{process_info => ProcessInfo,\n+                           uptime_ms => UptimeMs,\n+                           config_hash => erlang:phash2(Config),\n+                           last_checked => Now,\n+                           enhanced => true},\n+\n             {ok, EnhancedInfo};\n         Error ->\n             Error\n     end.\n \n %% @doc Perform bulk operations on multiple transports\n--spec bulk_transport_operation(atom(), [transport_id()]) -> [{transport_id(), ok | {error, term()}}].\n+-spec bulk_transport_operation(atom(), [transport_id()]) ->\n+                                  [{transport_id(), ok | {error, term()}}].\n bulk_transport_operation(Operation, TransportIds) ->\n-    logger:info(\"Performing bulk transport operation ~p on ~p transports\", \n-               [Operation, length(TransportIds)]),\n-    \n-    Results = lists:map(fun(TransportId) ->\n-        Result = case Operation of\n-            stop ->\n-                stop_transport(TransportId);\n-            restart ->\n-                case stop_transport(TransportId) of\n-                    ok ->\n-                        timer:sleep(100), % Brief pause between stop and start\n-                        case get_transport_config(TransportId) of\n-                            {ok, Config} ->\n-                                Type = maps:get(type, Config, stdio),\n-                                start_transport(TransportId, Type, Config);\n-                            Error ->\n-                                Error\n-                        end;\n-                    Error ->\n-                        Error\n-                end;\n-            status ->\n-                get_enhanced_transport_status(TransportId);\n-            unbind ->\n-                unbind_transport(TransportId);\n-            _ ->\n-                {error, {unknown_operation, Operation}}\n-        end,\n-        {TransportId, Result}\n-    end, TransportIds),\n-    \n+    logger:info(\"Performing bulk transport operation ~p on ~p transports\",\n+                [Operation, length(TransportIds)]),\n+\n+    Results =\n+        lists:map(fun(TransportId) ->\n+                     Result =\n+                         case Operation of\n+                             stop -> stop_transport(TransportId);\n+                             restart ->\n+                                 case stop_transport(TransportId) of\n+                                     ok ->\n+                                         timer:sleep(100), % Brief pause between stop and start\n+                                         case get_transport_config(TransportId) of\n+                                             {ok, Config} ->\n+                                                 Type = maps:get(type, Config, stdio),\n+                                                 start_transport(TransportId, Type, Config);\n+                                             Error -> Error\n+                                         end;\n+                                     Error -> Error\n+                                 end;\n+                             status -> get_enhanced_transport_status(TransportId);\n+                             unbind -> unbind_transport(TransportId);\n+                             _ -> {error, {unknown_operation, Operation}}\n+                         end,\n+                     {TransportId, Result}\n+                  end,\n+                  TransportIds),\n+\n     % Log summary\n-    SuccessCount = length([R || {_, ok} = R <- Results]) + \n-                   length([R || {_, {ok, _}} = R <- Results]),\n+    SuccessCount =\n+        length([R || {_, ok} = R <- Results]) + length([R || {_, {ok, _}} = R <- Results]),\n     FailureCount = length(TransportIds) - SuccessCount,\n-    logger:info(\"Bulk operation ~p completed: ~p successes, ~p failures\", \n-               [Operation, SuccessCount, FailureCount]),\n-    \n+    logger:info(\"Bulk operation ~p completed: ~p successes, ~p failures\",\n+                [Operation, SuccessCount, FailureCount]),\n+\n     Results.\n \n %% @doc Clean up stale or orphaned transports\n -spec cleanup_stale_transports() -> {ok, map()} | {error, term()}.\n cleanup_stale_transports() ->\n     logger:info(\"Starting cleanup of stale transports\"),\n-    \n+\n     case list_transports() of\n         [] ->\n-            {ok, #{cleaned => 0, errors => 0, total_checked => 0}};\n+            {ok,\n+             #{cleaned => 0,\n+               errors => 0,\n+               total_checked => 0}};\n         Transports ->\n-            Results = lists:map(fun({TransportId, {Pid, Config}}) ->\n-                case is_transport_stale(TransportId, Pid, Config) of\n-                    true ->\n-                        logger:info(\"Cleaning up stale transport ~p\", [TransportId]),\n-                        case stop_transport(TransportId) of\n-                            ok ->\n-                                {TransportId, cleaned};\n-                            Error ->\n-                                {TransportId, {error, Error}}\n-                        end;\n-                    false ->\n-                        {TransportId, healthy}\n-                end\n-            end, Transports),\n-            \n+            Results =\n+                lists:map(fun({TransportId, {Pid, Config}}) ->\n+                             case is_transport_stale(TransportId, Pid, Config) of\n+                                 true ->\n+                                     logger:info(\"Cleaning up stale transport ~p\", [TransportId]),\n+                                     case stop_transport(TransportId) of\n+                                         ok -> {TransportId, cleaned};\n+                                         Error -> {TransportId, {error, Error}}\n+                                     end;\n+                                 false -> {TransportId, healthy}\n+                             end\n+                          end,\n+                          Transports),\n+\n             CleanedCount = length([R || {_, cleaned} = R <- Results]),\n             ErrorCount = length([R || {_, {error, _}} = R <- Results]),\n             HealthyCount = length([R || {_, healthy} = R <- Results]),\n-            \n-            Summary = #{\n-                cleaned => CleanedCount,\n-                errors => ErrorCount,\n-                healthy => HealthyCount,\n-                total_checked => length(Transports),\n-                details => Results\n-            },\n-            \n+\n+            Summary =\n+                #{cleaned => CleanedCount,\n+                  errors => ErrorCount,\n+                  healthy => HealthyCount,\n+                  total_checked => length(Transports),\n+                  details => Results},\n+\n             logger:info(\"Stale transport cleanup completed: ~p\", [Summary]),\n             {ok, Summary}\n     end.\n \n@@ -2002,20 +2236,126 @@\n             StartedAt = maps:get(started_at, Config, erlang:timestamp()),\n             Now = erlang:timestamp(),\n             UptimeSeconds = timer:now_diff(Now, StartedAt) div 1000000,\n             MaxIdleTime = maps:get(max_idle_seconds, Config, 3600), % 1 hour default\n-            \n+\n             case UptimeSeconds > MaxIdleTime of\n                 true ->\n                     % Check if transport has been active recently\n                     case process_info(Pid, message_queue_len) of\n                         {message_queue_len, 0} ->\n-                            logger:debug(\"Transport ~p is stale: idle for ~p seconds\", \n-                                        [TransportId, UptimeSeconds]),\n+                            logger:debug(\"Transport ~p is stale: idle for ~p seconds\",\n+                                         [TransportId, UptimeSeconds]),\n                             true;\n                         _ ->\n                             false\n                     end;\n                 false ->\n                     false\n             end\n     end.\n+\n+%%====================================================================\n+%% Phase 3 Enhanced Transport Health Validation\n+%%====================================================================\n+\n+%% @doc Validate transport health after startup\n+-spec validate_transport_health(transport_id(), pid()) -> ok | {error, term()}.\n+validate_transport_health(TransportId, Pid) ->\n+    case is_process_alive(Pid) of\n+        false ->\n+            {error, {transport_dead, TransportId}};\n+        true ->\n+            try\n+                % Check process state\n+                case process_info(Pid, status) of\n+                    {status, Status} when Status =:= running; Status =:= waiting ->\n+                        % Check message queue is not overloaded\n+                        case process_info(Pid, message_queue_len) of\n+                            {message_queue_len, QLen} when QLen < 1000 ->\n+                                % Basic health check passed\n+                                logger:debug(\"Transport ~p health check passed: status=~p, queue_len=~p\",\n+                                           [TransportId, Status, QLen]),\n+                                ok;\n+                            {message_queue_len, QLen} ->\n+                                logger:warning(\"Transport ~p has large message queue: ~p messages\",\n+                                             [TransportId, QLen]),\n+                                {error, {large_message_queue, QLen}}\n+                        end;\n+                    {status, Status} ->\n+                        logger:warning(\"Transport ~p in unusual status: ~p\", [TransportId, Status]),\n+                        {error, {unusual_status, Status}};\n+                    undefined ->\n+                        {error, {process_info_unavailable, TransportId}}\n+                end\n+            catch\n+                _:HError ->\n+                    {error, {health_check_failed, HError}}\n+            end\n+    end.\n+\n+%%====================================================================\n+%% Phase 3 Enhanced API Convenience Functions\n+%%====================================================================\n+\n+%% @doc Phase 3 Enhanced version of start_transport with comprehensive monitoring\n+-spec start_transport_enhanced(transport_id(), transport_type(), map()) ->\n+                               {ok, #{pid => pid(), config => map(), health => map()}} | {error, term()}.\n+start_transport_enhanced(TransportId, Type, Config) ->\n+    StartTime = erlang:timestamp(),\n+    \n+    case start_transport(TransportId, Type, Config) of\n+        {ok, Pid} ->\n+            % Gather comprehensive startup information\n+            case get_enhanced_transport_status(TransportId) of\n+                {ok, StatusInfo} ->\n+                    EndTime = erlang:timestamp(),\n+                    StartupDurationMs = timer:now_diff(EndTime, StartTime) div 1000,\n+                    \n+                    Result = #{pid => Pid,\n+                              config => maps:get(config, StatusInfo, Config),\n+                              health => maps:get(process_info, StatusInfo, #{}),\n+                              startup_time_ms => StartupDurationMs,\n+                              transport_id => TransportId,\n+                              phase => 3,\n+                              api_level => enhanced},\n+                    \n+                    logger:info(\"Phase 3 Enhanced transport ~p started successfully in ~pms\",\n+                              [TransportId, StartupDurationMs]),\n+                    {ok, Result};\n+                {error, StatusError} ->\n+                    logger:warning(\"Transport ~p started but status check failed: ~p\",\n+                                 [TransportId, StatusError]),\n+                    {ok, #{pid => Pid, transport_id => TransportId, status_warning => StatusError}}\n+            end;\n+        Error ->\n+            Error\n+    end.\n+\n+%% @doc Create transport with automatic retry and recovery\n+-spec start_transport_with_retry(transport_id(), transport_type(), map(), non_neg_integer()) ->\n+                                 {ok, pid()} | {error, term()}.\n+start_transport_with_retry(TransportId, Type, Config, MaxRetries) ->\n+    start_transport_with_retry(TransportId, Type, Config, MaxRetries, 1).\n+\n+-spec start_transport_with_retry(transport_id(), transport_type(), map(), \n+                                 non_neg_integer(), non_neg_integer()) ->\n+                                 {ok, pid()} | {error, term()}.\n+start_transport_with_retry(_TransportId, _Type, _Config, MaxRetries, Attempt) when Attempt > MaxRetries ->\n+    {error, max_retries_exceeded};\n+start_transport_with_retry(TransportId, Type, Config, MaxRetries, Attempt) ->\n+    case start_transport(TransportId, Type, Config) of\n+        {ok, Pid} ->\n+            logger:info(\"Transport ~p started successfully on attempt ~p\", [TransportId, Attempt]),\n+            {ok, Pid};\n+        {error, Reason} when Attempt < MaxRetries ->\n+            SleepTime = Attempt * 1000, % Progressive backoff: 1s, 2s, 3s...\n+            logger:info(\"Transport ~p start failed (attempt ~p/~p): ~p. Retrying in ~pms...\",\n+                       [TransportId, Attempt, MaxRetries, Reason, SleepTime]),\n+            timer:sleep(SleepTime),\n+            start_transport_with_retry(TransportId, Type, Config, MaxRetries, Attempt + 1);\n+        {error, Reason} ->\n+            logger:error(\"Transport ~p failed to start after ~p attempts: ~p\",\n+                        [TransportId, MaxRetries, Reason]),\n+            {error, {max_retries_exceeded, Reason}}\n+    end.\n+\n"
                },
                {
                    "date": 1756190592769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,8 @@\n %% Configuration API\n -export([get_server_config/1, update_server_config/2, get_transport_config/1,\n          update_transport_config/2, validate_transport_config/1, get_config_schema/1,\n          validate_config_field/3]).\n-\n %% Phase 3 configuration validation coordination API\n -export([store_validation_schemas/0, get_validation_schemas_from_memory/0,\n          validate_transport_with_coordination/2, initialize_config_validation/0]).\n %% Legacy compatibility for stdio server\n@@ -31,8 +30,15 @@\n          audit_transport_bindings/0, cleanup_failed_setup/3, validate_setup_prerequisites/1,\n          ensure_transport_supervisor/0, retry_transport_binding/3, get_enhanced_transport_status/1,\n          bulk_transport_operation/2, cleanup_stale_transports/0, validate_transport_health/2,\n          start_transport_enhanced/3, start_transport_with_retry/4]).\n+%% Step 7: Enhanced High-Level API Functions\n+-export([start_transport_preset/3, create_transport_from_template/3,\n+         quick_setup_with_validation/4, enhanced_transport_create/4,\n+         get_transport_health_status/1, validate_and_create_transport/3,\n+         get_transport_preset/1, get_config_template/1, apply_template_values/2,\n+         validate_transport_creation_context/3, comprehensive_transport_validation/2,\n+         format_comprehensive_validation_error/3, store_transport_metrics/2]).\n \n %% Types\n -type server_id() :: atom().\n -type transport_id() :: atom().\n@@ -126,19 +132,21 @@\n \n -spec start_transport(transport_id(), transport_type(), map()) ->\n                          {ok, pid()} | {error, term()}.\n start_transport(TransportId, Type, Config) ->\n-    logger:info(\"Starting transport ~p of type ~p with Phase 3 enhanced validation and management\",\n+    logger:info(\"Starting transport ~p of type ~p with Phase 3 enhanced validation \"\n+                \"and management\",\n                 [TransportId, Type]),\n \n     % Phase 3 Enhancement: Pre-flight validation and prerequisite checks\n     case validate_setup_prerequisites(Type) of\n         ok ->\n             % Enhanced validation using dedicated validation module with comprehensive error handling\n-            ConfigWithType = Config#{type => Type, \n-                                     phase => 3,\n-                                     api_version => \"3.0\",\n-                                     enhancement_level => high_level_api},\n+            ConfigWithType =\n+                Config#{type => Type,\n+                        phase => 3,\n+                        api_version => \"3.0\",\n+                        enhancement_level => high_level_api},\n             case erlmcp_transport_validation:validate_transport_config(Type, ConfigWithType) of\n                 ok ->\n                     % Ensure transport supervisor is available with enhanced startup\n                     case ensure_transport_supervisor() of\n@@ -159,18 +167,21 @@\n                                                                           TransportConfig)\n                                     of\n                                         ok ->\n                                             % Phase 3: Post-startup validation and health check\n-                                            case validate_transport_health(TransportId, TransportPid) of\n+                                            case validate_transport_health(TransportId,\n+                                                                           TransportPid)\n+                                            of\n                                                 ok ->\n-                                                    logger:info(\"Phase 3: Successfully started, registered and validated transport ~p (~p) with \"\n-                                                                \"enhanced features\",\n+                                                    logger:info(\"Phase 3: Successfully started, registered and validated transport \"\n+                                                                \"~p (~p) with enhanced features\",\n                                                                 [TransportId, Type]),\n                                                     {ok, TransportPid};\n                                                 {error, HealthError} ->\n                                                     logger:warning(\"Transport ~p started but health check failed: ~p\",\n                                                                    [TransportId, HealthError]),\n-                                                    {ok, TransportPid} % Still return success but log warning\n+                                                    {ok,\n+                                                     TransportPid} % Still return success but log warning\n                                             end;\n                                         {error, Reason} ->\n                                             logger:warning(\"Transport ~p started but registry registration failed: ~p\",\n                                                            [TransportId, Reason]),\n@@ -183,17 +194,21 @@\n                             end;\n                         {error, SupervisorError} ->\n                             logger:error(\"Transport supervisor unavailable for ~p (~p): ~p\",\n                                          [TransportId, Type, SupervisorError]),\n-                            format_setup_error(TransportId, Type, supervisor_unavailable, SupervisorError)\n+                            format_setup_error(TransportId,\n+                                               Type,\n+                                               supervisor_unavailable,\n+                                               SupervisorError)\n                     end;\n                 {error, ValidationError} ->\n                     logger:error(\"Transport config validation failed for ~p (~p): ~p\",\n                                  [TransportId, Type, ValidationError]),\n                     format_validation_error_enhanced(TransportId, Type, ValidationError)\n             end;\n         {error, PrereqError} ->\n-            logger:error(\"Transport prerequisites not met for ~p (~p): ~p\", [TransportId, Type, PrereqError]),\n+            logger:error(\"Transport prerequisites not met for ~p (~p): ~p\",\n+                         [TransportId, Type, PrereqError]),\n             format_setup_error(TransportId, Type, prerequisites_failed, PrereqError)\n     end.\n \n -spec stop_transport(transport_id()) -> ok | {error, term()}.\n@@ -570,22 +585,22 @@\n -spec validate_transport_config(map()) -> ok | {error, term()}.\n validate_transport_config(Config) ->\n     %% Store validation attempt in memory for coordination\n     ValidationKey = \"phase3/config/validation\",\n-    ValidationData = #{\n-        timestamp => erlang:timestamp(),\n-        config_hash => erlang:phash2(Config),\n-        validation_attempt => true,\n-        config_type => maps:get(type, Config, unknown)\n-    },\n+    ValidationData =\n+        #{timestamp => erlang:timestamp(),\n+          config_hash => erlang:phash2(Config),\n+          validation_attempt => true,\n+          config_type => maps:get(type, Config, unknown)},\n     store_in_memory(ValidationKey, ValidationData),\n-    \n+\n     case maps:get(type, Config, undefined) of\n         undefined ->\n-            ValidationError = format_validation_error(missing_required_field,\n-                                    type,\n-                                    \"Configuration must specify transport type. Valid types: stdio, \"\n-                                    \"tcp, http\"),\n+            ValidationError =\n+                format_validation_error(missing_required_field,\n+                                        type,\n+                                        \"Configuration must specify transport type. Valid types: stdio, \"\n+                                        \"tcp, http\"),\n             %% Log validation failure in memory\n             ErrorKey = \"phase3/config/validation/errors\",\n             store_validation_error(ErrorKey, ValidationError, Config),\n             ValidationError;\n@@ -1346,8 +1361,360 @@\n             Error\n     end.\n \n %%====================================================================\n+%% Step 7: Enhanced High-Level API Functions with Advanced Validation\n+%%====================================================================\n+\n+%% @doc Create transport using predefined preset configurations\n+-spec start_transport_preset(transport_id(), atom(), map()) -> {ok, pid()} | {error, term()}.\n+start_transport_preset(TransportId, PresetName, CustomConfig) ->\n+    case get_transport_preset(PresetName) of\n+        {ok, PresetConfig} ->\n+            MergedConfig = maps:merge(PresetConfig, CustomConfig),\n+            TransportType = maps:get(type, MergedConfig),\n+            enhanced_transport_create(TransportId, TransportType, MergedConfig, #{preset => PresetName});\n+        {error, _} = Error ->\n+            Error\n+    end.\n+\n+%% @doc Create transport from configuration template with validation\n+-spec create_transport_from_template(transport_id(), atom(), map()) -> {ok, pid()} | {error, term()}.\n+create_transport_from_template(TransportId, TemplateName, ConfigValues) ->\n+    case get_config_template(TemplateName) of\n+        {ok, Template} ->\n+            case apply_template_values(Template, ConfigValues) of\n+                {ok, Config} ->\n+                    TransportType = maps:get(type, Config),\n+                    enhanced_transport_create(TransportId, TransportType, Config, \n+                                            #{template => TemplateName});\n+                {error, _} = Error ->\n+                    Error\n+            end;\n+        {error, _} = Error ->\n+            Error\n+    end.\n+\n+%% @doc Enhanced transport creation with comprehensive validation and metadata\n+-spec enhanced_transport_create(transport_id(), transport_type(), map(), map()) -> \n+                               {ok, pid()} | {error, term()}.\n+enhanced_transport_create(TransportId, Type, Config, Metadata) ->\n+    StartTime = erlang:timestamp(),\n+    \n+    % Phase 1: Pre-creation validation\n+    case validate_transport_creation_context(TransportId, Type, Config) of\n+        ok ->\n+            % Phase 2: Enhanced configuration validation\n+            case validate_and_enhance_config(Type, Config) of\n+                {ok, EnhancedConfig} ->\n+                    % Phase 3: Create with comprehensive logging\n+                    logger:info(\"Creating enhanced transport ~p (~p) with metadata: ~p\",\n+                               [TransportId, Type, Metadata]),\n+                    \n+                    ConfigWithMetadata = EnhancedConfig#{metadata => Metadata,\n+                                                        created_at => StartTime,\n+                                                        api_version => \"3.0\",\n+                                                        enhancement_level => \"step_7\"},\n+                    \n+                    case start_transport(TransportId, Type, ConfigWithMetadata) of\n+                        {ok, TransportPid} ->\n+                            % Log successful creation with timing\n+                            EndTime = erlang:timestamp(),\n+                            Duration = timer:now_diff(EndTime, StartTime) / 1000, % milliseconds\n+                            \n+                            logger:info(\"Enhanced transport ~p created successfully in ~.2f ms\",\n+                                       [TransportId, Duration]),\n+                            \n+                            % Store creation metrics\n+                            store_transport_metrics(TransportId, #{creation_time => Duration,\n+                                                                  metadata => Metadata}),\n+                            {ok, TransportPid};\n+                        {error, _} = Error ->\n+                            Error\n+                    end;\n+                {error, _} = Error ->\n+                    Error\n+            end;\n+        {error, _} = Error ->\n+            Error\n+    end.\n+\n+%% @doc Quick setup with comprehensive validation for common patterns\n+-spec quick_setup_with_validation(server_id(), transport_type(), map(), map()) ->\n+                                  {ok, #{server => pid(), transport => pid()}} | {error, term()}.\n+quick_setup_with_validation(ServerId, TransportType, ServerConfig, TransportConfig) ->\n+    logger:info(\"Starting quick setup with validation for ~p (~p)\", [ServerId, TransportType]),\n+    \n+    % Validate all configurations upfront\n+    case validate_quick_setup_config(ServerId, TransportType, ServerConfig, TransportConfig) of\n+        ok ->\n+            case TransportType of\n+                stdio ->\n+                    start_stdio_setup(ServerId, ServerConfig);\n+                tcp ->\n+                    start_tcp_setup(ServerId, ServerConfig, TransportConfig);\n+                http ->\n+                    start_http_setup(ServerId, ServerConfig, TransportConfig);\n+                _ ->\n+                    {error, {unsupported_transport_type, TransportType}}\n+            end;\n+        {error, _} = Error ->\n+            Error\n+    end.\n+\n+%% @doc Validate and create transport with enhanced error reporting\n+-spec validate_and_create_transport(transport_id(), transport_type(), map()) ->\n+                                   {ok, pid()} | {error, term()}.\n+validate_and_create_transport(TransportId, Type, Config) ->\n+    case comprehensive_transport_validation(Type, Config) of\n+        {ok, ValidatedConfig} ->\n+            start_transport(TransportId, Type, ValidatedConfig);\n+        {error, ValidationErrors} ->\n+            format_comprehensive_validation_error(TransportId, Type, ValidationErrors)\n+    end.\n+\n+%% @doc Get transport health status with detailed diagnostics\n+-spec get_transport_health_status(transport_id()) -> {ok, map()} | {error, term()}.\n+get_transport_health_status(TransportId) ->\n+    case whereis(erlmcp_registry) of\n+        undefined ->\n+            {error, registry_not_available};\n+        _ ->\n+            case erlmcp_registry:find_transport(TransportId) of\n+                {ok, {TransportPid, Config}} ->\n+                    Health = #{\n+                        transport_id => TransportId,\n+                        pid => TransportPid,\n+                        alive => is_process_alive(TransportPid),\n+                        memory_usage => get_process_memory(TransportPid),\n+                        message_queue_len => get_process_queue_len(TransportPid),\n+                        config => maps:with([type, server_id, created_at], Config),\n+                        last_activity => maps:get(last_activity, Config, undefined),\n+                        status => case is_process_alive(TransportPid) of\n+                                    true -> healthy;\n+                                    false -> dead\n+                                  end\n+                    },\n+                    {ok, Health};\n+                {error, not_found} ->\n+                    {error, {transport_not_found, TransportId}}\n+            end\n+    end.\n+\n+%%====================================================================\n+%% Step 7: Enhanced Validation Functions\n+%%====================================================================\n+\n+%% @doc Validate transport creation context\n+-spec validate_transport_creation_context(transport_id(), transport_type(), map()) ->\n+                                         ok | {error, term()}.\n+validate_transport_creation_context(TransportId, Type, Config) ->\n+    Validations = [\n+        fun() -> validate_transport_id_uniqueness(TransportId) end,\n+        fun() -> validate_transport_type_support(Type) end,\n+        fun() -> validate_config_completeness(Config) end,\n+        fun() -> validate_system_readiness(Type) end\n+    ],\n+    \n+    run_validation_chain(Validations, {TransportId, Type}).\n+\n+%% @doc Comprehensive transport validation with detailed error context\n+-spec comprehensive_transport_validation(transport_type(), map()) -> \n+                                        {ok, map()} | {error, [term()]}.\n+comprehensive_transport_validation(Type, Config) ->\n+    ValidationSteps = [\n+        {schema_validation, fun() -> validate_against_schema(Type, Config) end},\n+        {prerequisite_check, fun() -> validate_setup_prerequisites(Type) end},\n+        {security_validation, fun() -> validate_security_config(Type, Config) end},\n+        {performance_validation, fun() -> validate_performance_config(Type, Config) end}\n+    ],\n+    \n+    case run_comprehensive_validations(ValidationSteps, Config) of\n+        {ok, EnhancedConfig} ->\n+            {ok, EnhancedConfig};\n+        {error, Errors} ->\n+            {error, Errors}\n+    end.\n+\n+%%====================================================================\n+%% Step 7: Configuration Templates and Presets\n+%%====================================================================\n+\n+%% @doc Get predefined transport configuration preset\n+-spec get_transport_preset(atom()) -> {ok, map()} | {error, term()}.\n+get_transport_preset(development_stdio) ->\n+    {ok, #{type => stdio,\n+           timeout => 5000,\n+           buffer_size => 1024,\n+           encoding => utf8,\n+           environment => development}};\n+get_transport_preset(production_tcp) ->\n+    {ok, #{type => tcp,\n+           host => \"0.0.0.0\",\n+           port => 8080,\n+           backlog => 100,\n+           timeout => 10000,\n+           nodelay => true,\n+           environment => production}};\n+get_transport_preset(secure_http) ->\n+    {ok, #{type => http,\n+           url => \"https://localhost:8443/mcp\",\n+           timeout => 15000,\n+           ssl => true,\n+           verify_ssl => true,\n+           max_redirects => 3,\n+           environment => production}};\n+get_transport_preset(PresetName) ->\n+    {error, {unknown_preset, PresetName}}.\n+\n+%% @doc Get configuration template\n+-spec get_config_template(atom()) -> {ok, map()} | {error, term()}.\n+get_config_template(basic_tcp) ->\n+    {ok, #{type => tcp,\n+           host => \"{{HOST}}\",\n+           port => \"{{PORT}}\",\n+           timeout => \"{{TIMEOUT|5000}}\",\n+           required_vars => [host, port],\n+           optional_vars => [timeout]}};\n+get_config_template(secure_http) ->\n+    {ok, #{type => http,\n+           url => \"{{PROTOCOL}}://{{HOST}}:{{PORT}}/{{PATH}}\",\n+           ssl => \"{{SSL|true}}\",\n+           timeout => \"{{TIMEOUT|10000}}\",\n+           required_vars => [protocol, host, port, path],\n+           optional_vars => [ssl, timeout]}};\n+get_config_template(TemplateName) ->\n+    {error, {unknown_template, TemplateName}}.\n+\n+%% @doc Apply values to configuration template\n+-spec apply_template_values(map(), map()) -> {ok, map()} | {error, term()}.\n+apply_template_values(Template, Values) ->\n+    RequiredVars = maps:get(required_vars, Template, []),\n+    \n+    % Check all required variables are provided\n+    case validate_required_template_vars(RequiredVars, Values) of\n+        ok ->\n+            try\n+                AppliedConfig = apply_template_substitution(Template, Values),\n+                {ok, maps:without([required_vars, optional_vars], AppliedConfig)}\n+            catch\n+                error:Reason ->\n+                    {error, {template_application_failed, Reason}}\n+            end;\n+        {error, _} = Error ->\n+            Error\n+    end.\n+\n+%%====================================================================\n+%% Step 7: Helper Functions for Enhanced Validation\n+%%====================================================================\n+\n+%% @doc Store transport creation metrics\n+-spec store_transport_metrics(transport_id(), map()) -> ok.\n+store_transport_metrics(TransportId, Metrics) ->\n+    try\n+        erlmcp_registry:store_transport_metadata(TransportId, Metrics)\n+    catch\n+        _:_ ->\n+            logger:warning(\"Failed to store metrics for transport ~p\", [TransportId])\n+    end,\n+    ok.\n+\n+%% @doc Format comprehensive validation error with detailed context\n+-spec format_comprehensive_validation_error(transport_id(), transport_type(), [term()]) ->\n+                                           {error, term()}.\n+format_comprehensive_validation_error(TransportId, Type, Errors) ->\n+    ErrorSummary = #{\n+        error_category => comprehensive_validation_failed,\n+        transport_id => TransportId,\n+        transport_type => Type,\n+        validation_errors => Errors,\n+        error_count => length(Errors),\n+        suggestions => generate_validation_suggestions(Type, Errors),\n+        timestamp => erlang:timestamp()\n+    },\n+    {error, ErrorSummary}.\n+\n+%% @doc Validate and enhance configuration with smart defaults\n+-spec validate_and_enhance_config(transport_type(), map()) -> {ok, map()} | {error, term()}.\n+validate_and_enhance_config(Type, Config) ->\n+    case add_smart_defaults(Type, Config) of\n+        {ok, ConfigWithDefaults} ->\n+            case perform_enhanced_validation(Type, ConfigWithDefaults) of\n+                ok ->\n+                    {ok, ConfigWithDefaults};\n+                {error, _} = Error ->\n+                    Error\n+            end;\n+        {error, _} = Error ->\n+            Error\n+    end.\n+\n+%% @doc Add smart defaults based on transport type\n+-spec add_smart_defaults(transport_type(), map()) -> {ok, map()} | {error, term()}.\n+add_smart_defaults(stdio, Config) ->\n+    Defaults = #{timeout => 5000, buffer_size => 1024, encoding => utf8},\n+    {ok, maps:merge(Defaults, Config)};\n+add_smart_defaults(tcp, Config) ->\n+    Defaults = #{host => \"localhost\", port => 8080, timeout => 10000, backlog => 100},\n+    {ok, maps:merge(Defaults, Config)};\n+add_smart_defaults(http, Config) ->\n+    Defaults = #{timeout => 15000, max_redirects => 3, verify_ssl => true},\n+    {ok, maps:merge(Defaults, Config)};\n+add_smart_defaults(Type, _Config) ->\n+    {error, {unknown_transport_type, Type}}.\n+\n+%% @doc Perform enhanced validation with multiple checks\n+-spec perform_enhanced_validation(transport_type(), map()) -> ok | {error, term()}.\n+perform_enhanced_validation(Type, Config) ->\n+    case erlmcp_transport_validation:validate_transport_config(Type, Config) of\n+        ok ->\n+            validate_security_and_performance(Type, Config);\n+        {error, _} = Error ->\n+            Error\n+    end.\n+\n+%% @doc Validate security and performance aspects\n+-spec validate_security_and_performance(transport_type(), map()) -> ok | {error, term()}.\n+validate_security_and_performance(http, Config) ->\n+    % Check SSL configuration for HTTP\n+    case maps:get(ssl, Config, false) of\n+        true ->\n+            case maps:get(verify_ssl, Config, true) of\n+                false ->\n+                    logger:warning(\"SSL verification disabled - security risk\");\n+                _ ->\n+                    ok\n+            end;\n+        false ->\n+            logger:info(\"HTTP transport without SSL - consider enabling for production\")\n+    end,\n+    \n+    % Check timeout values\n+    Timeout = maps:get(timeout, Config, 15000),\n+    if\n+        Timeout < 1000 ->\n+            {error, {timeout_too_low, Timeout}};\n+        Timeout > 60000 ->\n+            logger:warning(\"Very high timeout value: ~p ms\", [Timeout]);\n+        true ->\n+            ok\n+    end;\n+validate_security_and_performance(tcp, Config) ->\n+    % Check port ranges\n+    Port = maps:get(port, Config, 8080),\n+    if\n+        Port < 1024 ->\n+            logger:warning(\"Using privileged port ~p - ensure proper permissions\", [Port]);\n+        Port > 65535 ->\n+            {error, {invalid_port, Port}};\n+        true ->\n+            ok\n+    end;\n+validate_security_and_performance(_Type, _Config) ->\n+    ok.\n+\n+%%====================================================================\n %% Configuration Schema and Documentation API\n %%====================================================================\n \n %% @doc Get configuration schema for a transport type\n@@ -1662,57 +2029,56 @@\n \n %% @doc Store validation error in memory with detailed context\n -spec store_validation_error(string(), term(), map()) -> ok.\n store_validation_error(Key, Error, Config) ->\n-    ErrorData = #{\n-        error => Error,\n-        config => maps:without([password, secret, token], Config),\n-        timestamp => erlang:timestamp(),\n-        phase => 3,\n-        validation_type => error\n-    },\n+    ErrorData =\n+        #{error => Error,\n+          config => maps:without([password, secret, token], Config),\n+          timestamp => erlang:timestamp(),\n+          phase => 3,\n+          validation_type => error},\n     store_in_memory(Key, ErrorData).\n \n %% @doc Store validation result in memory with detailed context\n -spec store_validation_result(string(), atom(), term(), map()) -> ok.\n store_validation_result(Key, Type, Result, Config) ->\n-    ResultData = #{\n-        transport_type => Type,\n-        result => case Result of\n-                      ok -> success;\n-                      {error, _} -> failure;\n-                      Other -> Other\n-                  end,\n-        detailed_result => Result,\n-        config_hash => erlang:phash2(Config),\n-        timestamp => erlang:timestamp(),\n-        phase => 3,\n-        validation_type => result\n-    },\n+    ResultData =\n+        #{transport_type => Type,\n+          result =>\n+              case Result of\n+                  ok ->\n+                      success;\n+                  {error, _} ->\n+                      failure;\n+                  Other ->\n+                      Other\n+              end,\n+          detailed_result => Result,\n+          config_hash => erlang:phash2(Config),\n+          timestamp => erlang:timestamp(),\n+          phase => 3,\n+          validation_type => result},\n     store_in_memory(Key, ResultData).\n \n %% @doc Store validation schemas in memory for documentation and introspection\n -spec store_validation_schemas() -> ok.\n store_validation_schemas() ->\n     SchemaKey = \"phase3/config/validation\",\n-    Schemas = #{\n-        stdio => ?STDIO_CONFIG_SCHEMA,\n-        tcp => ?TCP_CONFIG_SCHEMA, \n-        http => ?HTTP_CONFIG_SCHEMA,\n-        metadata => #{\n-            version => \"1.0.0\",\n-            phase => 3,\n-            last_updated => erlang:timestamp(),\n-            supported_types => [stdio, tcp, http],\n-            validation_features => [\n-                schema_based,\n-                field_validators,\n-                comprehensive_errors,\n-                memory_coordination,\n-                type_specific_validation\n-            ]\n-        }\n-    },\n+    Schemas =\n+        #{stdio => ?STDIO_CONFIG_SCHEMA,\n+          tcp => ?TCP_CONFIG_SCHEMA,\n+          http => ?HTTP_CONFIG_SCHEMA,\n+          metadata =>\n+              #{version => \"1.0.0\",\n+                phase => 3,\n+                last_updated => erlang:timestamp(),\n+                supported_types => [stdio, tcp, http],\n+                validation_features =>\n+                    [schema_based,\n+                     field_validators,\n+                     comprehensive_errors,\n+                     memory_coordination,\n+                     type_specific_validation]}},\n     store_in_memory(SchemaKey, Schemas).\n \n %% @doc Get validation schemas from memory\n -spec get_validation_schemas_from_memory() -> {ok, map()} | {error, term()}.\n@@ -1725,20 +2091,24 @@\n                 case whereis(erlmcp_registry) of\n                     undefined ->\n                         %% Initialize schemas if not found\n                         store_validation_schemas(),\n-                        {ok, #{stdio => ?STDIO_CONFIG_SCHEMA,\n-                               tcp => ?TCP_CONFIG_SCHEMA,\n-                               http => ?HTTP_CONFIG_SCHEMA}};\n+                        {ok,\n+                         #{stdio => ?STDIO_CONFIG_SCHEMA,\n+                           tcp => ?TCP_CONFIG_SCHEMA,\n+                           http => ?HTTP_CONFIG_SCHEMA}};\n                     _Pid ->\n                         case erlmcp_registry:get_validation_data(Key) of\n-                            {ok, Data} -> {ok, Data};\n+                            {ok, Data} ->\n+                                {ok, Data};\n                             {error, not_found} ->\n                                 store_validation_schemas(),\n-                                {ok, #{stdio => ?STDIO_CONFIG_SCHEMA,\n-                                       tcp => ?TCP_CONFIG_SCHEMA,\n-                                       http => ?HTTP_CONFIG_SCHEMA}};\n-                            Error -> Error\n+                                {ok,\n+                                 #{stdio => ?STDIO_CONFIG_SCHEMA,\n+                                   tcp => ?TCP_CONFIG_SCHEMA,\n+                                   http => ?HTTP_CONFIG_SCHEMA}};\n+                            Error ->\n+                                Error\n                         end\n                 end;\n             Data ->\n                 {ok, Data}\n@@ -1762,44 +2132,42 @@\n -spec setup_coordination_hooks() -> ok.\n setup_coordination_hooks() ->\n     try\n         %% Store initial coordination data\n-        HookData = #{\n-            system => configuration_validation,\n-            phase => 3,\n-            capabilities => [schema_validation, memory_storage, error_tracking],\n-            initialized_at => erlang:timestamp()\n-        },\n+        HookData =\n+            #{system => configuration_validation,\n+              phase => 3,\n+              capabilities => [schema_validation, memory_storage, error_tracking],\n+              initialized_at => erlang:timestamp()},\n         store_in_memory(\"phase3/config/hooks\", HookData),\n         ok\n     catch\n-        _:_ -> ok  %% Non-critical failure\n+        _:_ ->\n+            ok  %% Non-critical failure\n     end.\n \n %% @doc Validate transport configuration with full coordination support\n -spec validate_transport_with_coordination(atom(), map()) -> ok | {error, term()}.\n validate_transport_with_coordination(TransportType, Config) ->\n     %% Store validation attempt with coordination context\n     CoordKey = \"phase3/config/coordination/\" ++ atom_to_list(TransportType),\n-    CoordData = #{\n-        transport_type => TransportType,\n-        config_hash => erlang:phash2(Config),\n-        validation_start => erlang:timestamp(),\n-        coordination_enabled => true\n-    },\n+    CoordData =\n+        #{transport_type => TransportType,\n+          config_hash => erlang:phash2(Config),\n+          validation_start => erlang:timestamp(),\n+          coordination_enabled => true},\n     store_in_memory(CoordKey, CoordData),\n-    \n+\n     %% Perform validation with enhanced error handling\n     Result = validate_transport_config_with_schema(TransportType, Config),\n-    \n+\n     %% Update coordination data with result\n-    FinalCoordData = CoordData#{\n-        validation_end => erlang:timestamp(),\n-        result => Result,\n-        validation_completed => true\n-    },\n+    FinalCoordData =\n+        CoordData#{validation_end => erlang:timestamp(),\n+                   result => Result,\n+                   validation_completed => true},\n     store_in_memory(CoordKey, FinalCoordData),\n-    \n+\n     Result.\n \n %%====================================================================\n %% Enhanced Error Handling Functions - Phase 3 Step 7\n@@ -2273,13 +2641,13 @@\n                         case process_info(Pid, message_queue_len) of\n                             {message_queue_len, QLen} when QLen < 1000 ->\n                                 % Basic health check passed\n                                 logger:debug(\"Transport ~p health check passed: status=~p, queue_len=~p\",\n-                                           [TransportId, Status, QLen]),\n+                                             [TransportId, Status, QLen]),\n                                 ok;\n                             {message_queue_len, QLen} ->\n                                 logger:warning(\"Transport ~p has large message queue: ~p messages\",\n-                                             [TransportId, QLen]),\n+                                               [TransportId, QLen]),\n                                 {error, {large_message_queue, QLen}}\n                         end;\n                     {status, Status} ->\n                         logger:warning(\"Transport ~p in unusual status: ~p\", [TransportId, Status]),\n@@ -2298,64 +2666,79 @@\n %%====================================================================\n \n %% @doc Phase 3 Enhanced version of start_transport with comprehensive monitoring\n -spec start_transport_enhanced(transport_id(), transport_type(), map()) ->\n-                               {ok, #{pid => pid(), config => map(), health => map()}} | {error, term()}.\n+                                  {ok,\n+                                   #{pid => pid(),\n+                                     config => map(),\n+                                     health => map()}} |\n+                                  {error, term()}.\n start_transport_enhanced(TransportId, Type, Config) ->\n     StartTime = erlang:timestamp(),\n-    \n+\n     case start_transport(TransportId, Type, Config) of\n         {ok, Pid} ->\n             % Gather comprehensive startup information\n             case get_enhanced_transport_status(TransportId) of\n                 {ok, StatusInfo} ->\n                     EndTime = erlang:timestamp(),\n                     StartupDurationMs = timer:now_diff(EndTime, StartTime) div 1000,\n-                    \n-                    Result = #{pid => Pid,\n-                              config => maps:get(config, StatusInfo, Config),\n-                              health => maps:get(process_info, StatusInfo, #{}),\n-                              startup_time_ms => StartupDurationMs,\n-                              transport_id => TransportId,\n-                              phase => 3,\n-                              api_level => enhanced},\n-                    \n+\n+                    Result =\n+                        #{pid => Pid,\n+                          config => maps:get(config, StatusInfo, Config),\n+                          health => maps:get(process_info, StatusInfo, #{}),\n+                          startup_time_ms => StartupDurationMs,\n+                          transport_id => TransportId,\n+                          phase => 3,\n+                          api_level => enhanced},\n+\n                     logger:info(\"Phase 3 Enhanced transport ~p started successfully in ~pms\",\n-                              [TransportId, StartupDurationMs]),\n+                                [TransportId, StartupDurationMs]),\n                     {ok, Result};\n                 {error, StatusError} ->\n                     logger:warning(\"Transport ~p started but status check failed: ~p\",\n-                                 [TransportId, StatusError]),\n-                    {ok, #{pid => Pid, transport_id => TransportId, status_warning => StatusError}}\n+                                   [TransportId, StatusError]),\n+                    {ok,\n+                     #{pid => Pid,\n+                       transport_id => TransportId,\n+                       status_warning => StatusError}}\n             end;\n         Error ->\n             Error\n     end.\n \n %% @doc Create transport with automatic retry and recovery\n--spec start_transport_with_retry(transport_id(), transport_type(), map(), non_neg_integer()) ->\n-                                 {ok, pid()} | {error, term()}.\n+-spec start_transport_with_retry(transport_id(),\n+                                 transport_type(),\n+                                 map(),\n+                                 non_neg_integer()) ->\n+                                    {ok, pid()} | {error, term()}.\n start_transport_with_retry(TransportId, Type, Config, MaxRetries) ->\n     start_transport_with_retry(TransportId, Type, Config, MaxRetries, 1).\n \n--spec start_transport_with_retry(transport_id(), transport_type(), map(), \n-                                 non_neg_integer(), non_neg_integer()) ->\n-                                 {ok, pid()} | {error, term()}.\n-start_transport_with_retry(_TransportId, _Type, _Config, MaxRetries, Attempt) when Attempt > MaxRetries ->\n+-spec start_transport_with_retry(transport_id(),\n+                                 transport_type(),\n+                                 map(),\n+                                 non_neg_integer(),\n+                                 non_neg_integer()) ->\n+                                    {ok, pid()} | {error, term()}.\n+start_transport_with_retry(_TransportId, _Type, _Config, MaxRetries, Attempt)\n+    when Attempt > MaxRetries ->\n     {error, max_retries_exceeded};\n start_transport_with_retry(TransportId, Type, Config, MaxRetries, Attempt) ->\n     case start_transport(TransportId, Type, Config) of\n         {ok, Pid} ->\n             logger:info(\"Transport ~p started successfully on attempt ~p\", [TransportId, Attempt]),\n             {ok, Pid};\n         {error, Reason} when Attempt < MaxRetries ->\n             SleepTime = Attempt * 1000, % Progressive backoff: 1s, 2s, 3s...\n-            logger:info(\"Transport ~p start failed (attempt ~p/~p): ~p. Retrying in ~pms...\",\n-                       [TransportId, Attempt, MaxRetries, Reason, SleepTime]),\n+            logger:info(\"Transport ~p start failed (attempt ~p/~p): ~p. Retrying in \"\n+                        \"~pms...\",\n+                        [TransportId, Attempt, MaxRetries, Reason, SleepTime]),\n             timer:sleep(SleepTime),\n             start_transport_with_retry(TransportId, Type, Config, MaxRetries, Attempt + 1);\n         {error, Reason} ->\n             logger:error(\"Transport ~p failed to start after ~p attempts: ~p\",\n-                        [TransportId, MaxRetries, Reason]),\n+                         [TransportId, MaxRetries, Reason]),\n             {error, {max_retries_exceeded, Reason}}\n     end.\n-\n"
                }
            ],
            "date": 1756188161125,
            "name": "Commit-0",
            "content": "-module(erlmcp).\n\n-include(\"erlmcp.hrl\").\n\n%% Application management API\n-export([\n    start_server/1, start_server/2, stop_server/1, list_servers/0,\n    start_transport/2, start_transport/3, stop_transport/1, list_transports/0,\n    bind_transport_to_server/2, unbind_transport/1\n]).\n\n%% Server operations API\n-export([\n    add_resource/3, add_resource/4,\n    add_tool/3, add_tool/4,\n    add_prompt/3, add_prompt/4\n]).\n\n%% Configuration API\n-export([\n    get_server_config/1, update_server_config/2,\n    get_transport_config/1, update_transport_config/2,\n    validate_transport_config/1, get_config_schema/1,\n    validate_config_field/3\n]).\n\n%% Legacy compatibility for stdio server\n-export([\n    start_stdio_server/0, start_stdio_server/1, stop_stdio_server/0\n]).\n\n%% Convenience functions\n-export([\n    start_stdio_setup/2, start_tcp_setup/3, start_http_setup/3,\n    setup_server_components/2, quick_stdio_server/3,\n    validate_transport_config/2, get_transport_bindings/0,\n    cleanup_transport_bindings/1, list_supported_transport_types/0,\n    get_config_examples/0\n]).\n\n%% Enhanced API functions - Phase 3 Step 7\n-export([\n    format_validation_error/3, format_transport_error/4, format_setup_error/4,\n    get_transport_binding_info/1, list_transport_bindings/0,\n    rebind_transport/2, validate_transport_binding/2,\n    audit_transport_bindings/0, cleanup_failed_setup/3\n]).\n\n%% Types\n-type server_id() :: atom().\n-type transport_id() :: atom().\n-type transport_type() :: stdio | tcp | http.\n\n-export_type([server_id/0, transport_id/0, transport_type/0]).\n\n%%====================================================================\n%% Application Management API - Updated for Phase 2\n%%====================================================================\n\n-spec start_server(server_id()) -> {ok, pid()} | {error, term()}.\nstart_server(ServerId) ->\n    start_server(ServerId, #{}).\n\n-spec start_server(server_id(), map()) -> {ok, pid()} | {error, term()}.\nstart_server(ServerId, Config) ->\n    % Ensure default capabilities if not provided\n    DefaultCaps = #mcp_server_capabilities{\n        resources = #mcp_capability{enabled = true},\n        tools = #mcp_capability{enabled = true},\n        prompts = #mcp_capability{enabled = true}\n    },\n    \n    % Merge with provided config\n    FinalConfig = case maps:get(capabilities, Config, undefined) of\n        undefined ->\n            Config#{capabilities => DefaultCaps};\n        _ ->\n            Config\n    end,\n    \n    % Start server using the refactored erlmcp_server\n    case start_server_process(ServerId, FinalConfig) of\n        {ok, ServerPid} ->\n            % Register with registry if available\n            case register_server_with_registry(ServerId, ServerPid, FinalConfig) of\n                ok -> \n                    logger:info(\"Started and registered server ~p\", [ServerId]),\n                    {ok, ServerPid};\n                {error, Reason} -> \n                    % Registration failed, but server started - log warning and continue\n                    logger:warning(\"Server ~p started but registry registration failed: ~p\", [ServerId, Reason]),\n                    {ok, ServerPid}\n            end;\n        {error, _} = Error ->\n            Error\n    end.\n\n-spec stop_server(server_id()) -> ok | {error, term()}.\nstop_server(ServerId) ->\n    % Try registry approach first\n    case whereis(erlmcp_registry) of\n        undefined ->\n            % No registry, try to find server process by registered name or other means\n            logger:warning(\"Registry not available for server ~p cleanup\", [ServerId]),\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_server(ServerId) of\n                {ok, {ServerPid, _Config}} ->\n                    erlmcp_registry:unregister_server(ServerId),\n                    case is_process_alive(ServerPid) of\n                        true -> \n                            erlmcp_server:stop(ServerPid),\n                            logger:info(\"Stopped server ~p\", [ServerId]),\n                            ok;\n                        false -> \n                            logger:info(\"Server ~p already stopped\", [ServerId]),\n                            ok\n                    end;\n                {error, not_found} ->\n                    logger:warning(\"Server ~p not found in registry\", [ServerId]),\n                    ok\n            end\n    end.\n\n-spec list_servers() -> [{server_id(), {pid(), map()}}].\nlist_servers() ->\n    case whereis(erlmcp_registry) of\n        undefined -> \n            logger:warning(\"Registry not available for listing servers\"),\n            [];\n        _ -> \n            erlmcp_registry:list_servers()\n    end.\n\n-spec start_transport(transport_id(), transport_type()) -> {ok, pid()} | {error, term()}.\nstart_transport(TransportId, Type) ->\n    start_transport(TransportId, Type, #{}).\n\n-spec start_transport(transport_id(), transport_type(), map()) -> {ok, pid()} | {error, term()}.\nstart_transport(TransportId, Type, Config) ->\n    logger:info(\"Starting transport ~p of type ~p with config validation\", [TransportId, Type]),\n    \n    % Enhanced validation using dedicated validation module\n    ConfigWithType = Config#{type => Type},\n    case erlmcp_transport_validation:validate_transport_config(Type, ConfigWithType) of\n        ok ->\n            case start_transport_impl(TransportId, Type, ConfigWithType) of\n                {ok, TransportPid} ->\n                    TransportConfig = ConfigWithType#{\n                        started_at => erlang:timestamp(),\n                        validation_passed => true\n                    },\n                    case register_transport_with_registry(TransportId, TransportPid, TransportConfig) of\n                        ok -> \n                            logger:info(\"Successfully started and registered transport ~p (~p) with validation\", \n                                      [TransportId, Type]),\n                            {ok, TransportPid};\n                        {error, Reason} ->\n                            logger:warning(\"Transport ~p started but registry registration failed: ~p\", \n                                         [TransportId, Reason]),\n                            {ok, TransportPid}\n                    end;\n                {error, Reason} ->\n                    logger:error(\"Failed to start transport ~p (~p): ~p\", [TransportId, Type, Reason]),\n                    erlmcp_transport_behavior:format_transport_error(TransportId, start_failed, Reason)\n            end;\n        {error, ValidationError} ->\n            logger:error(\"Transport config validation failed for ~p (~p): ~p\", \n                        [TransportId, Type, ValidationError]),\n            format_validation_error(TransportId, Type, ValidationError)\n    end.\n\n-spec stop_transport(transport_id()) -> ok | {error, term()}.\nstop_transport(TransportId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_transport(TransportId) of\n                {ok, {TransportPid, _Config}} ->\n                    erlmcp_registry:unregister_transport(TransportId),\n                    case is_process_alive(TransportPid) of\n                        true -> \n                            erlmcp_transport_stdio_new:close(TransportPid),\n                            logger:info(\"Stopped transport ~p\", [TransportId]),\n                            ok;\n                        false -> ok\n                    end;\n                {error, not_found} ->\n                    ok\n            end\n    end.\n\n-spec list_transports() -> [{transport_id(), {pid(), map()}}].\nlist_transports() ->\n    case whereis(erlmcp_registry) of\n        undefined -> [];\n        _ -> erlmcp_registry:list_transports()\n    end.\n\n-spec bind_transport_to_server(transport_id(), server_id()) -> ok | {error, term()}.\nbind_transport_to_server(TransportId, ServerId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            erlmcp_registry:bind_transport_to_server(TransportId, ServerId)\n    end.\n\n-spec unbind_transport(transport_id()) -> ok.\nunbind_transport(TransportId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            erlmcp_registry:unbind_transport(TransportId)\n    end.\n\n%%====================================================================\n%% Server Operations API - Updated for Registry-based Architecture\n%%====================================================================\n\n-spec add_resource(server_id(), binary(), fun()) -> ok | {error, term()}.\nadd_resource(ServerId, Uri, Handler) ->\n    add_resource(ServerId, Uri, Handler, #{}).\n\n-spec add_resource(server_id(), binary(), fun(), map()) -> ok | {error, term()}.\nadd_resource(ServerId, Uri, Handler, Options) ->\n    case find_server_process(ServerId) of\n        {ok, ServerPid} ->\n            case maps:get(template, Options, false) of\n                true ->\n                    Name = maps:get(name, Options, Uri),\n                    erlmcp_server:add_resource_template(ServerPid, Uri, Name, Handler);\n                false ->\n                    erlmcp_server:add_resource(ServerPid, Uri, Handler)\n            end;\n        {error, not_found} ->\n            {error, server_not_found}\n    end.\n\n-spec add_tool(server_id(), binary(), fun()) -> ok | {error, term()}.\nadd_tool(ServerId, Name, Handler) ->\n    add_tool(ServerId, Name, Handler, #{}).\n\n-spec add_tool(server_id(), binary(), fun(), map()) -> ok | {error, term()}.\nadd_tool(ServerId, Name, Handler, Options) ->\n    case find_server_process(ServerId) of\n        {ok, ServerPid} ->\n            case maps:get(schema, Options, undefined) of\n                undefined ->\n                    erlmcp_server:add_tool(ServerPid, Name, Handler);\n                Schema ->\n                    erlmcp_server:add_tool_with_schema(ServerPid, Name, Handler, Schema)\n            end;\n        {error, not_found} ->\n            {error, server_not_found}\n    end.\n\n-spec add_prompt(server_id(), binary(), fun()) -> ok | {error, term()}.\nadd_prompt(ServerId, Name, Handler) ->\n    add_prompt(ServerId, Name, Handler, #{}).\n\n-spec add_prompt(server_id(), binary(), fun(), map()) -> ok | {error, term()}.\nadd_prompt(ServerId, Name, Handler, Options) ->\n    case find_server_process(ServerId) of\n        {ok, ServerPid} ->\n            case maps:get(arguments, Options, undefined) of\n                undefined ->\n                    erlmcp_server:add_prompt(ServerPid, Name, Handler);\n                Arguments ->\n                    erlmcp_server:add_prompt_with_args(ServerPid, Name, Handler, Arguments)\n            end;\n        {error, not_found} ->\n            {error, server_not_found}\n    end.\n\n%%====================================================================\n%% Configuration API\n%%====================================================================\n\n-spec get_server_config(server_id()) -> {ok, map()} | {error, term()}.\nget_server_config(ServerId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_server(ServerId) of\n                {ok, {_ServerPid, Config}} ->\n                    {ok, Config};\n                {error, not_found} ->\n                    {error, server_not_found}\n            end\n    end.\n\n-spec update_server_config(server_id(), map()) -> ok | {error, term()}.\nupdate_server_config(ServerId, NewConfig) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_server(ServerId) of\n                {ok, {ServerPid, OldConfig}} ->\n                    UpdatedConfig = maps:merge(OldConfig, NewConfig),\n                    erlmcp_registry:register_server(ServerId, ServerPid, UpdatedConfig);\n                {error, not_found} ->\n                    {error, server_not_found}\n            end\n    end.\n\n-spec get_transport_config(transport_id()) -> {ok, map()} | {error, term()}.\nget_transport_config(TransportId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_transport(TransportId) of\n                {ok, {_TransportPid, Config}} ->\n                    {ok, Config};\n                {error, not_found} ->\n                    {error, transport_not_found}\n            end\n    end.\n\n-spec update_transport_config(transport_id(), map()) -> ok | {error, term()}.\nupdate_transport_config(TransportId, NewConfig) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_transport(TransportId) of\n                {ok, {TransportPid, OldConfig}} ->\n                    UpdatedConfig = maps:merge(OldConfig, NewConfig),\n                    % Validate the updated configuration\n                    case validate_transport_config(UpdatedConfig) of\n                        ok ->\n                            erlmcp_registry:register_transport(TransportId, TransportPid, UpdatedConfig);\n                        {error, ValidationError} ->\n                            {error, ValidationError}\n                    end;\n                {error, not_found} ->\n                    {error, transport_not_found}\n            end\n    end.\n\n%%====================================================================\n%% Configuration Validation API - Enhanced with Schema Support\n%%====================================================================\n\n%% @doc Configuration schema definitions for all transport types\n-define(STDIO_CONFIG_SCHEMA, #{\n    required_fields => [type],\n    optional_fields => [server_id, test_mode, buffer_size],\n    field_validators => #{\n        type => fun(stdio) -> ok; (_) -> {error, \"must be 'stdio'\"} end,\n        server_id => fun(Id) when is_atom(Id) -> ok; (_) -> {error, \"must be an atom\"} end,\n        test_mode => fun(Bool) when is_boolean(Bool) -> ok; (_) -> {error, \"must be boolean\"} end,\n        buffer_size => fun(Size) when is_integer(Size), Size > 0 -> ok; (_) -> {error, \"must be positive integer\"} end\n    },\n    description => \"STDIO transport configuration for direct process communication\"\n}).\n\n-define(TCP_CONFIG_SCHEMA, #{\n    required_fields => [type, host, port],\n    optional_fields => [keepalive, connect_timeout, max_reconnect_attempts, server_id, ssl, certfile, keyfile],\n    field_validators => #{\n        type => fun(tcp) -> ok; (_) -> {error, \"must be 'tcp'\"} end,\n        host => fun(H) when is_binary(H); is_list(H) -> \n            case iolist_size([H]) > 0 of\n                true -> ok;\n                false -> {error, \"cannot be empty\"}\n            end;\n            (_) -> {error, \"must be binary or string\"}\n        end,\n        port => fun(P) when is_integer(P), P >= 1, P =< 65535 -> ok;\n            (_) -> {error, \"must be integer between 1 and 65535\"}\n        end,\n        keepalive => fun(Bool) when is_boolean(Bool) -> ok; (_) -> {error, \"must be boolean\"} end,\n        connect_timeout => fun(T) when is_integer(T), T > 0 -> ok; (_) -> {error, \"must be positive integer (milliseconds)\"} end,\n        max_reconnect_attempts => fun(A) when is_integer(A), A >= 0 -> ok; (_) -> {error, \"must be non-negative integer\"} end,\n        ssl => fun(Bool) when is_boolean(Bool) -> ok; (_) -> {error, \"must be boolean\"} end,\n        certfile => fun(F) when is_list(F) -> \n            case filelib:is_file(F) of\n                true -> ok;\n                false -> {error, \"SSL certificate file does not exist\"}\n            end;\n            (_) -> {error, \"must be valid file path\"}\n        end,\n        keyfile => fun(F) when is_list(F) -> \n            case filelib:is_file(F) of\n                true -> ok;\n                false -> {error, \"SSL key file does not exist\"}\n            end;\n            (_) -> {error, \"must be valid file path\"}\n        end\n    },\n    description => \"TCP transport configuration for network communication\"\n}).\n\n-define(HTTP_CONFIG_SCHEMA, #{\n    required_fields => [type, url],\n    optional_fields => [method, headers, timeout, server_id, cors, max_body_size],\n    field_validators => #{\n        type => fun(http) -> ok; (_) -> {error, \"must be 'http'\"} end,\n        url => fun(U) when is_binary(U); is_list(U) -> \n            case validate_url_format(iolist_to_binary([U])) of\n                true -> ok;\n                false -> {error, \"must be valid HTTP/HTTPS URL\"}\n            end;\n            (_) -> {error, \"must be binary or string\"}\n        end,\n        method => fun(M) when M =:= get; M =:= post; M =:= put; M =:= delete; \n                             M =:= patch; M =:= head; M =:= options -> ok;\n            (_) -> {error, \"must be valid HTTP method (get|post|put|delete|patch|head|options)\"}\n        end,\n        headers => fun(H) when is_map(H) -> validate_http_headers(H);\n            (_) -> {error, \"must be a map of header name/value pairs\"}\n        end,\n        timeout => fun(T) when is_integer(T), T > 0 -> ok; (_) -> {error, \"must be positive integer (milliseconds)\"} end,\n        cors => fun(false) -> ok;\n                   (true) -> ok;\n                   (Origins) when is_list(Origins) -> \n                       try\n                           lists:foreach(fun\n                               (Origin) when is_binary(Origin); is_list(Origin) -> ok;\n                               (_) -> throw({error, \"CORS origins must be strings\"})\n                           end, Origins),\n                           ok\n                       catch\n                           throw:Error -> Error\n                       end;\n                   (_) -> {error, \"must be boolean or list of origin URLs\"}\n                end,\n        max_body_size => fun(Size) when is_integer(Size), Size > 0 -> ok; (_) -> {error, \"must be positive integer (bytes)\"} end\n    },\n    description => \"HTTP transport configuration for web-based communication\"\n}).\n\n%% @doc Validate transport configuration using schema-based approach\n-spec validate_transport_config(map()) -> ok | {error, term()}.\nvalidate_transport_config(Config) ->\n    case maps:get(type, Config, undefined) of\n        undefined ->\n            format_validation_error(missing_required_field, type, \n                \"Configuration must specify transport type. Valid types: stdio, tcp, http\");\n        Type ->\n            validate_transport_config_with_schema(Type, Config)\n    end.\n\n%% @doc Enhanced schema-based validation\n-spec validate_transport_config_with_schema(atom(), map()) -> ok | {error, term()}.\nvalidate_transport_config_with_schema(stdio, Config) ->\n    validate_config_against_schema(Config, ?STDIO_CONFIG_SCHEMA);\nvalidate_transport_config_with_schema(tcp, Config) ->\n    validate_config_against_schema(Config, ?TCP_CONFIG_SCHEMA);\nvalidate_transport_config_with_schema(http, Config) ->\n    validate_config_against_schema(Config, ?HTTP_CONFIG_SCHEMA);\nvalidate_transport_config_with_schema(Type, _Config) ->\n    format_validation_error(unknown_transport_type, Type, \n        \"Unknown transport type. Supported types: stdio, tcp, http\").\n\n%% @doc Generic schema validation\n-spec validate_config_against_schema(map(), map()) -> ok | {error, term()}.\nvalidate_config_against_schema(Config, Schema) ->\n    RequiredFields = maps:get(required_fields, Schema),\n    OptionalFields = maps:get(optional_fields, Schema),\n    FieldValidators = maps:get(field_validators, Schema),\n    Description = maps:get(description, Schema),\n    \n    case validate_schema_fields(Config, RequiredFields, OptionalFields) of\n        ok ->\n            validate_schema_field_values(Config, FieldValidators);\n        {error, {validation_error, ErrorType, Field}} ->\n            case ErrorType of\n                missing_required_field ->\n                    format_validation_error(ErrorType, Field, \n                        io_lib:format(\"Required field missing for ~s. Required fields: ~p\", \n                                     [Description, RequiredFields]));\n                unknown_field ->\n                    AllowedFields = RequiredFields ++ OptionalFields,\n                    format_validation_error(ErrorType, Field, \n                        io_lib:format(\"Unknown field for ~s. Allowed fields: ~p\", \n                                     [Description, AllowedFields]));\n                _ ->\n                    {error, {validation_error, ErrorType, Field}}\n            end;\n        Error ->\n            Error\n    end.\n\n%% @doc Validate schema field presence and allowed fields\n-spec validate_schema_fields(map(), [atom()], [atom()]) -> ok | {error, term()}.\nvalidate_schema_fields(Config, RequiredFields, OptionalFields) ->\n    case validate_required_fields(Config, RequiredFields) of\n        ok ->\n            AllowedFields = RequiredFields ++ OptionalFields,\n            validate_allowed_fields(Config, AllowedFields);\n        Error ->\n            Error\n    end.\n\n%% @doc Validate field values using validators\n-spec validate_schema_field_values(map(), map()) -> ok | {error, term()}.\nvalidate_schema_field_values(Config, FieldValidators) ->\n    try\n        maps:fold(fun(Field, Value, _Acc) ->\n            case maps:get(Field, FieldValidators, undefined) of\n                undefined -> ok; % Field not in schema validators, skip\n                Validator when is_function(Validator, 1) ->\n                    case Validator(Value) of\n                        ok -> ok;\n                        {error, Reason} ->\n                            throw({validation_error, invalid_field_value, Field, Reason})\n                    end\n            end\n        end, ok, Config),\n        ok\n    catch\n        throw:{validation_error, ErrorType, Field, Reason} ->\n            format_validation_error(ErrorType, Field, Reason)\n    end.\n\n%% @doc Format validation errors with helpful messages\n-spec format_validation_error(atom(), term(), string()) -> {error, term()}.\nformat_validation_error(ErrorType, Field, Reason) ->\n    FormattedReason = case io_lib:char_list(Reason) of\n        true -> Reason;\n        false -> io_lib:format(\"~p\", [Reason])\n    end,\n    {error, {\n        validation_error, \n        ErrorType, \n        Field, \n        lists:flatten(FormattedReason)\n    }}.\n\n%% @doc Legacy validation function - now delegates to schema-based approach\n-spec validate_transport_config_by_type(atom(), map()) -> ok | {error, term()}.\nvalidate_transport_config_by_type(Type, Config) ->\n    validate_transport_config_with_schema(Type, Config).\n\n\n%% @doc Helper function to validate required and optional fields\n-spec validate_fields(map(), [atom()], [atom()]) -> ok | {error, term()}.\nvalidate_fields(Config, RequiredFields, OptionalFields) ->\n    case validate_required_fields(Config, RequiredFields) of\n        ok ->\n            validate_allowed_fields(Config, RequiredFields ++ OptionalFields);\n        Error ->\n            Error\n    end.\n\n%% @doc Validate that all required fields are present\n-spec validate_required_fields(map(), [atom()]) -> ok | {error, term()}.\nvalidate_required_fields(Config, RequiredFields) ->\n    Missing = [Field || Field <- RequiredFields, not maps:is_key(Field, Config)],\n    case Missing of\n        [] ->\n            ok;\n        [Field] ->\n            {error, {validation_error, missing_required_field, Field}};\n        Fields ->\n            {error, {validation_error, missing_required_fields, Fields}}\n    end.\n\n%% @doc Validate that only allowed fields are present\n-spec validate_allowed_fields(map(), [atom()]) -> ok | {error, term()}.\nvalidate_allowed_fields(Config, AllowedFields) ->\n    ConfigFields = maps:keys(Config),\n    Unknown = [Field || Field <- ConfigFields, not lists:member(Field, AllowedFields)],\n    case Unknown of\n        [] ->\n            ok;\n        [Field] ->\n            {error, {validation_error, unknown_field, Field, \n                     io_lib:format(\"allowed fields: ~p\", [AllowedFields])}};\n        Fields ->\n            {error, {validation_error, unknown_fields, Fields,\n                     io_lib:format(\"allowed fields: ~p\", [AllowedFields])}}\n    end.\n\n%% @doc Validate TCP-specific fields\n-spec validate_tcp_fields(map()) -> ok | {error, term()}.\nvalidate_tcp_fields(Config) ->\n    % Validate host\n    case validate_host_field(maps:get(host, Config)) of\n        ok ->\n            % Validate port\n            case validate_port_field(maps:get(port, Config)) of\n                ok ->\n                    % Validate optional fields\n                    validate_tcp_optional_fields(Config);\n                Error ->\n                    Error\n            end;\n        Error ->\n            Error\n    end.\n\n%% @doc Validate TCP optional fields\n-spec validate_tcp_optional_fields(map()) -> ok | {error, term()}.\nvalidate_tcp_optional_fields(Config) ->\n    % Validate keepalive\n    case maps:get(keepalive, Config, undefined) of\n        undefined -> \n            % Continue to next validation\n            validate_tcp_connect_timeout(Config);\n        Boolean when is_boolean(Boolean) -> \n            % Continue to next validation\n            validate_tcp_connect_timeout(Config);\n        _ -> {error, {validation_error, invalid_field_type, keepalive, \"must be boolean\"}}\n    end.\n\n%% @doc Validate TCP connect_timeout field\n-spec validate_tcp_connect_timeout(map()) -> ok | {error, term()}.\nvalidate_tcp_connect_timeout(Config) ->\n    case maps:get(connect_timeout, Config, undefined) of\n        undefined -> \n            validate_tcp_max_reconnect(Config);\n        Timeout when is_integer(Timeout), Timeout > 0 -> \n            validate_tcp_max_reconnect(Config);\n        _ -> {error, {validation_error, invalid_field_type, connect_timeout, \"must be positive integer\"}}\n    end.\n\n%% @doc Validate TCP max_reconnect_attempts field\n-spec validate_tcp_max_reconnect(map()) -> ok | {error, term()}.\nvalidate_tcp_max_reconnect(Config) ->\n    case maps:get(max_reconnect_attempts, Config, undefined) of\n        undefined -> ok;\n        Attempts when is_integer(Attempts), Attempts >= 0 -> ok;\n        _ -> {error, {validation_error, invalid_field_type, max_reconnect_attempts, \"must be non-negative integer\"}}\n    end.\n\n%% @doc Validate HTTP-specific fields\n-spec validate_http_fields(map()) -> ok | {error, term()}.\nvalidate_http_fields(Config) ->\n    % Validate URL\n    case validate_url_field(maps:get(url, Config)) of\n        ok ->\n            validate_http_optional_fields(Config);\n        Error ->\n            Error\n    end.\n\n%% @doc Validate HTTP optional fields\n-spec validate_http_optional_fields(map()) -> ok | {error, term()}.\nvalidate_http_optional_fields(Config) ->\n    % Validate method\n    case maps:get(method, Config, get) of\n        Method when Method =:= get; Method =:= post; Method =:= put; Method =:= delete; \n                   Method =:= patch; Method =:= head; Method =:= options -> \n            validate_http_headers_field(Config);\n        _ -> {error, {validation_error, invalid_field_value, method, \"must be valid HTTP method\"}}\n    end.\n\n%% @doc Validate HTTP headers field\n-spec validate_http_headers_field(map()) -> ok | {error, term()}.\nvalidate_http_headers_field(Config) ->\n    case maps:get(headers, Config, undefined) of\n        undefined -> \n            validate_http_timeout_field(Config);\n        Headers when is_map(Headers) -> \n            case validate_http_headers(Headers) of\n                ok -> validate_http_timeout_field(Config);\n                Error -> Error\n            end;\n        _ -> {error, {validation_error, invalid_field_type, headers, \"must be a map\"}}\n    end.\n\n%% @doc Validate HTTP timeout field\n-spec validate_http_timeout_field(map()) -> ok | {error, term()}.\nvalidate_http_timeout_field(Config) ->\n    case maps:get(timeout, Config, undefined) of\n        undefined -> ok;\n        Timeout when is_integer(Timeout), Timeout > 0 -> ok;\n        _ -> {error, {validation_error, invalid_field_type, timeout, \"must be positive integer\"}}\n    end.\n\n%% @doc Validate HTTP headers map\n-spec validate_http_headers(map()) -> ok | {error, term()}.\nvalidate_http_headers(Headers) ->\n    try\n        maps:fold(fun(Key, Value, _Acc) ->\n            case {is_binary(Key) orelse is_list(Key), is_binary(Value) orelse is_list(Value)} of\n                {true, true} -> ok;\n                {false, _} -> throw({error, {validation_error, invalid_header_key, Key, \"must be binary or string\"}});\n                {_, false} -> throw({error, {validation_error, invalid_header_value, Value, \"must be binary or string\"}})\n            end\n        end, ok, Headers),\n        ok\n    catch\n        throw:Error -> Error\n    end.\n\n%% @doc Validate host field\n-spec validate_host_field(term()) -> ok | {error, term()}.\nvalidate_host_field(Host) when is_binary(Host) ->\n    case byte_size(Host) > 0 of\n        true -> ok;\n        false -> {error, {validation_error, invalid_field_value, host, \"cannot be empty\"}}\n    end;\nvalidate_host_field(Host) when is_list(Host) ->\n    case length(Host) > 0 of\n        true -> ok;\n        false -> {error, {validation_error, invalid_field_value, host, \"cannot be empty\"}}\n    end;\nvalidate_host_field(_) ->\n    {error, {validation_error, invalid_field_type, host, \"must be binary or string\"}}.\n\n%% @doc Validate port field\n-spec validate_port_field(term()) -> ok | {error, term()}.\nvalidate_port_field(Port) when is_integer(Port), Port > 0, Port =< 65535 ->\n    ok;\nvalidate_port_field(Port) when is_integer(Port) ->\n    {error, {validation_error, invalid_field_value, port, \"must be between 1 and 65535\"}};\nvalidate_port_field(_) ->\n    {error, {validation_error, invalid_field_type, port, \"must be integer\"}}.\n\n%% @doc Validate URL field\n-spec validate_url_field(term()) -> ok | {error, term()}.\nvalidate_url_field(Url) when is_binary(Url) ->\n    case validate_url_format(Url) of\n        true -> ok;\n        false -> {error, {validation_error, invalid_field_value, url, \"must be valid HTTP/HTTPS URL\"}}\n    end;\nvalidate_url_field(Url) when is_list(Url) ->\n    case validate_url_format(list_to_binary(Url)) of\n        true -> ok;\n        false -> {error, {validation_error, invalid_field_value, url, \"must be valid HTTP/HTTPS URL\"}}\n    end;\nvalidate_url_field(_) ->\n    {error, {validation_error, invalid_field_type, url, \"must be binary or string\"}}.\n\n%% @doc Simple URL format validation\n-spec validate_url_format(binary()) -> boolean().\nvalidate_url_format(Url) ->\n    case binary:split(Url, <<\"://\">>) of\n        [Scheme, _Rest] when Scheme =:= <<\"http\">>; Scheme =:= <<\"https\">> ->\n            byte_size(Url) > 10;  % Basic length check\n        _ ->\n            false\n    end.\n\n%%====================================================================\n%% Legacy Compatibility API - Enhanced for Phase 2\n%%====================================================================\n\n-spec start_stdio_server() -> {ok, pid()} | {error, term()}.\nstart_stdio_server() ->\n    start_stdio_server(#{}).\n\n-spec start_stdio_server(map()) -> {ok, pid()} | {error, term()}.\nstart_stdio_server(Options) ->\n    % Use the new architecture by default, fall back to legacy if needed\n    case is_new_architecture_available() of\n        true ->\n            % Use new registry-based approach\n            case start_stdio_setup(default_stdio_server, Options) of\n                {ok, #{server := ServerPid}} ->\n                    {ok, ServerPid};\n                {error, _} = Error ->\n                    % Fall back to legacy approach\n                    logger:warning(\"New stdio setup failed, falling back to legacy: ~p\", [Error]),\n                    start_legacy_stdio_server(Options)\n            end;\n        false ->\n            % Registry not available, use legacy approach\n            start_legacy_stdio_server(Options)\n    end.\n\n-spec stop_stdio_server() -> ok.\nstop_stdio_server() ->\n    % Try new architecture first\n    case is_new_architecture_available() of\n        true ->\n            _ = stop_transport(default_stdio_transport),\n            _ = stop_server(default_stdio_server),\n            % Also stop legacy server if it exists\n            stop_legacy_stdio_server(),\n            ok;\n        false ->\n            % Fall back to legacy approach\n            stop_legacy_stdio_server(),\n            ok\n    end.\n\n%%====================================================================\n%% Convenience Functions - Updated for Phase 2\n%%====================================================================\n\n%% Create a complete MCP server setup with stdio transport\n-spec start_stdio_setup(server_id(), map()) -> {ok, #{server => pid(), transport => pid()}} | {error, term()}.\nstart_stdio_setup(ServerId, Config) ->\n    case start_server(ServerId, Config) of\n        {ok, ServerPid} ->\n            TransportId = create_transport_id(ServerId, <<\"stdio\">>),\n            TransportConfig = #{server_id => ServerId},\n            case start_transport(TransportId, stdio, TransportConfig) of\n                {ok, TransportPid} ->\n                    % Ensure they're bound together\n                    case bind_transport_to_server(TransportId, ServerId) of\n                        ok ->\n                            {ok, #{server => ServerPid, transport => TransportPid}};\n                        {error, BindError} ->\n                            logger:warning(\"Server and transport started but binding failed: ~p\", [BindError]),\n                            {ok, #{server => ServerPid, transport => TransportPid}}\n                    end;\n                {error, TransportError} ->\n                    _ = stop_server(ServerId),\n                    {error, TransportError}\n            end;\n        {error, _} = ServerError ->\n            ServerError\n    end.\n\n%% Create a complete MCP server setup with TCP transport\n-spec start_tcp_setup(server_id(), map(), map()) -> {ok, #{server => pid(), transport => pid()}} | {error, term()}.\nstart_tcp_setup(ServerId, ServerConfig, TcpConfig) ->\n    logger:info(\"Setting up TCP server ~p with enhanced validation\", [ServerId]),\n    \n    % Enhanced validation with detailed error reporting\n    case erlmcp_transport_validation:validate_transport_config(tcp, TcpConfig) of\n        ok ->\n            case start_server(ServerId, ServerConfig) of\n                {ok, ServerPid} ->\n                    TransportId = create_transport_id(ServerId, <<\"tcp\">>),\n                    % Enhanced config with validation metadata\n                    TransportConfig = maps:merge(#{\n                        server_id => ServerId,\n                        transport_type => tcp,\n                        setup_type => convenience_function\n                    }, TcpConfig),\n                    \n                    case start_transport(TransportId, tcp, TransportConfig) of\n                        {ok, TransportPid} ->\n                            case bind_transport_to_server(TransportId, ServerId) of\n                                ok ->\n                                    logger:info(\"TCP setup completed successfully for ~p (~p:~p)\", \n                                              [ServerId, maps:get(host, TcpConfig, \"localhost\"), \n                                               maps:get(port, TcpConfig, 8080)]),\n                                    {ok, #{server => ServerPid, transport => TransportPid, \n                                          transport_id => TransportId, config => TransportConfig}};\n                                {error, BindError} ->\n                                    logger:warning(\"TCP server ~p started but binding failed: ~p\", \n                                                 [ServerId, BindError]),\n                                    {ok, #{server => ServerPid, transport => TransportPid,\n                                          transport_id => TransportId, binding_warning => BindError}}\n                            end;\n                        {error, TransportError} ->\n                            logger:error(\"TCP transport setup failed for ~p: ~p\", [ServerId, TransportError]),\n                            cleanup_failed_setup(ServerId, tcp, TransportError)\n                    end;\n                {error, ServerError} ->\n                    logger:error(\"Server setup failed for TCP ~p: ~p\", [ServerId, ServerError]),\n                    format_setup_error(ServerId, tcp, server_start_failed, ServerError)\n            end;\n        {error, ValidationError} ->\n            logger:error(\"TCP config validation failed for ~p: ~p\", [ServerId, ValidationError]),\n            format_validation_error(ServerId, tcp, ValidationError)\n    end.\n\n%% Create a complete MCP server setup with HTTP transport\n-spec start_http_setup(server_id(), map(), map()) -> {ok, #{server => pid(), transport => pid()}} | {error, term()}.\nstart_http_setup(ServerId, ServerConfig, HttpConfig) ->\n    logger:info(\"Setting up HTTP server ~p with enhanced validation\", [ServerId]),\n    \n    % Enhanced validation with detailed error reporting\n    case erlmcp_transport_validation:validate_transport_config(http, HttpConfig) of\n        ok ->\n            case start_server(ServerId, ServerConfig) of\n                {ok, ServerPid} ->\n                    TransportId = create_transport_id(ServerId, <<\"http\">>),\n                    % Enhanced config with validation metadata\n                    TransportConfig = maps:merge(#{\n                        server_id => ServerId,\n                        transport_type => http,\n                        setup_type => convenience_function\n                    }, HttpConfig),\n                    \n                    case start_transport(TransportId, http, TransportConfig) of\n                        {ok, TransportPid} ->\n                            case bind_transport_to_server(TransportId, ServerId) of\n                                ok ->\n                                    logger:info(\"HTTP setup completed successfully for ~p (~s)\", \n                                              [ServerId, maps:get(url, HttpConfig, \"http://localhost:8000/mcp\")]),\n                                    {ok, #{server => ServerPid, transport => TransportPid, \n                                          transport_id => TransportId, config => TransportConfig}};\n                                {error, BindError} ->\n                                    logger:warning(\"HTTP server ~p started but binding failed: ~p\", \n                                                 [ServerId, BindError]),\n                                    {ok, #{server => ServerPid, transport => TransportPid,\n                                          transport_id => TransportId, binding_warning => BindError}}\n                            end;\n                        {error, TransportError} ->\n                            logger:error(\"HTTP transport setup failed for ~p: ~p\", [ServerId, TransportError]),\n                            cleanup_failed_setup(ServerId, http, TransportError)\n                    end;\n                {error, ServerError} ->\n                    logger:error(\"Server setup failed for HTTP ~p: ~p\", [ServerId, ServerError]),\n                    format_setup_error(ServerId, http, server_start_failed, ServerError)\n            end;\n        {error, ValidationError} ->\n            logger:error(\"HTTP config validation failed for ~p: ~p\", [ServerId, ValidationError]),\n            format_validation_error(ServerId, http, ValidationError)\n    end.\n\n%% Batch add multiple resources, tools, and prompts\n-spec setup_server_components(server_id(), map()) -> ok | {error, term()}.\nsetup_server_components(ServerId, Components) ->\n    Resources = maps:get(resources, Components, []),\n    Tools = maps:get(tools, Components, []),\n    Prompts = maps:get(prompts, Components, []),\n    \n    try\n        % Add resources\n        lists:foreach(fun\n            ({Uri, Handler}) ->\n                ok = add_resource(ServerId, Uri, Handler);\n            ({Uri, Handler, Options}) ->\n                ok = add_resource(ServerId, Uri, Handler, Options)\n        end, Resources),\n        \n        % Add tools\n        lists:foreach(fun\n            ({Name, Handler}) ->\n                ok = add_tool(ServerId, Name, Handler);\n            ({Name, Handler, Options}) ->\n                ok = add_tool(ServerId, Name, Handler, Options)\n        end, Tools),\n        \n        % Add prompts\n        lists:foreach(fun\n            ({Name, Handler}) ->\n                ok = add_prompt(ServerId, Name, Handler);\n            ({Name, Handler, Options}) ->\n                ok = add_prompt(ServerId, Name, Handler, Options)\n        end, Prompts),\n        \n        ok\n    catch\n        error:{badmatch, {error, Reason}} ->\n            {error, Reason};\n        Class:Exception ->\n            {error, {Class, Exception}}\n    end.\n\n%% Quick way to create a complete stdio MCP server with components\n-spec quick_stdio_server(server_id(), map(), map()) -> {ok, #{server => pid(), transport => pid()}} | {error, term()}.\nquick_stdio_server(ServerId, ServerConfig, Components) ->\n    case start_stdio_setup(ServerId, ServerConfig) of\n        {ok, Result} ->\n            case setup_server_components(ServerId, Components) of\n                ok ->\n                    {ok, Result};\n                {error, SetupError} ->\n                    TransportId = create_transport_id(ServerId, <<\"stdio\">>),\n                    _ = stop_server(ServerId),\n                    _ = stop_transport(TransportId),\n                    {error, SetupError}\n            end;\n        {error, _} = Error ->\n            Error\n    end.\n\n%%====================================================================\n%% Configuration Schema and Documentation API\n%%====================================================================\n\n%% @doc Get configuration schema for a transport type\n-spec get_config_schema(atom()) -> {ok, map()} | {error, term()}.\nget_config_schema(stdio) -> {ok, ?STDIO_CONFIG_SCHEMA};\nget_config_schema(tcp) -> {ok, ?TCP_CONFIG_SCHEMA};\nget_config_schema(http) -> {ok, ?HTTP_CONFIG_SCHEMA};\nget_config_schema(Type) -> {error, {unknown_transport_type, Type}}.\n\n%% @doc Validate a single configuration field\n-spec validate_config_field(atom(), atom(), term()) -> ok | {error, term()}.\nvalidate_config_field(TransportType, Field, Value) ->\n    case get_config_schema(TransportType) of\n        {ok, Schema} ->\n            FieldValidators = maps:get(field_validators, Schema),\n            case maps:get(Field, FieldValidators, undefined) of\n                undefined ->\n                    {error, {unknown_field, Field, TransportType}};\n                Validator when is_function(Validator, 1) ->\n                    case Validator(Value) of\n                        ok -> ok;\n                        {error, Reason} -> \n                            format_validation_error(invalid_field_value, Field, Reason)\n                    end\n            end;\n        Error -> Error\n    end.\n\n%% @doc List all supported transport types\n-spec list_supported_transport_types() -> [atom()].\nlist_supported_transport_types() ->\n    [stdio, tcp, http].\n\n%% @doc Get example configurations for all transport types\n-spec get_config_examples() -> map().\nget_config_examples() ->\n    #{\n        stdio => #{\n            type => stdio,\n            server_id => my_server,\n            test_mode => false,\n            buffer_size => 8192\n        },\n        tcp => #{\n            type => tcp,\n            host => \"localhost\",\n            port => 8080,\n            keepalive => true,\n            connect_timeout => 5000,\n            max_reconnect_attempts => 3,\n            ssl => false\n        },\n        http => #{\n            type => http,\n            url => \"https://api.example.com/mcp\",\n            method => post,\n            headers => #{<<\"Content-Type\">> => <<\"application/json\">>},\n            timeout => 30000,\n            cors => true,\n            max_body_size => 1048576\n        }\n    }.\n\n%%====================================================================\n%% Enhanced API Functions - Phase 3\n%%====================================================================\n\n%% Transport implementation helper\n-spec start_transport_impl(transport_id(), transport_type(), map()) -> {ok, pid()} | {error, term()}.\nstart_transport_impl(TransportId, stdio, Config) ->\n    erlmcp_transport_stdio_new:start_link(TransportId, Config);\nstart_transport_impl(_TransportId, tcp, Config) ->\n    % Placeholder for TCP implementation\n    Port = maps:get(port, Config, 8080),\n    Host = maps:get(host, Config, \"localhost\"),\n    logger:info(\"TCP transport would start on ~s:~p\", [Host, Port]),\n    {error, {transport_not_implemented, tcp}};\nstart_transport_impl(_TransportId, http, Config) ->\n    % Placeholder for HTTP implementation\n    Port = maps:get(port, Config, 8000),\n    Path = maps:get(path, Config, \"/mcp\"),\n    logger:info(\"HTTP transport would start on port ~p path ~s\", [Port, Path]),\n    {error, {transport_not_implemented, http}};\nstart_transport_impl(_TransportId, Type, _Config) ->\n    {error, {unknown_transport_type, Type}}.\n\n%% Enhanced configuration validation (delegated to validation module)\n-spec validate_transport_config(transport_type(), map()) -> ok | {error, term()}.\nvalidate_transport_config(Type, Config) ->\n    % Delegate to validation module for comprehensive validation\n    erlmcp_transport_validation:validate_transport_config(Type, Config).\n\n%% Get all transport bindings\n-spec get_transport_bindings() -> [{transport_id(), server_id()}] | {error, term()}.\nget_transport_bindings() ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            try\n                Transports = erlmcp_registry:list_transports(),\n                Bindings = lists:filtermap(fun({TransportId, {_Pid, Config}}) ->\n                    case maps:get(server_id, Config, undefined) of\n                        undefined -> false;\n                        ServerId -> {true, {TransportId, ServerId}}\n                    end\n                end, Transports),\n                Bindings\n            catch\n                _:Error -> {error, Error}\n            end\n    end.\n\n%% Cleanup orphaned transport bindings\n-spec cleanup_transport_bindings(server_id()) -> ok | {error, term()}.\ncleanup_transport_bindings(ServerId) ->\n    case get_transport_bindings() of\n        {error, _} = Error -> Error;\n        Bindings ->\n            OrphanedTransports = [TId || {TId, SId} <- Bindings, SId =:= ServerId],\n            lists:foreach(fun(TransportId) ->\n                case unbind_transport(TransportId) of\n                    ok -> \n                        logger:info(\"Cleaned up orphaned transport binding: ~p\", [TransportId]);\n                    {error, Reason} -> \n                        logger:warning(\"Failed to cleanup transport binding ~p: ~p\", [TransportId, Reason])\n                end\n            end, OrphanedTransports),\n            ok\n    end.\n\n%%====================================================================\n%% Internal Helper Functions - Phase 2 Specific\n%%====================================================================\n\n-spec start_server_process(server_id(), map()) -> {ok, pid()} | {error, term()}.\nstart_server_process(ServerId, Config) ->\n    % Try supervisor approach first, fall back to direct start\n    case whereis(erlmcp_server_sup) of\n        undefined ->\n            % Supervisor not available, create server directly\n            Capabilities = maps:get(capabilities, Config, #mcp_server_capabilities{}),\n            erlmcp_server:start_link(ServerId, Capabilities);\n        _Pid ->\n            % Use supervisor\n            erlmcp_server_sup:start_child(ServerId, Config)\n    end.\n\n-spec register_server_with_registry(server_id(), pid(), map()) -> ok | {error, term()}.\nregister_server_with_registry(ServerId, ServerPid, Config) ->\n    case whereis(erlmcp_registry) of\n        undefined -> \n            % Registry not available - this is OK for some deployments\n            ok;\n        _ -> \n            erlmcp_registry:register_server(ServerId, ServerPid, Config)\n    end.\n\n-spec register_transport_with_registry(transport_id(), pid(), map()) -> ok | {error, term()}.\nregister_transport_with_registry(TransportId, TransportPid, Config) ->\n    case whereis(erlmcp_registry) of\n        undefined -> \n            ok; % Registry not available - this is OK\n        _ -> \n            erlmcp_registry:register_transport(TransportId, TransportPid, Config)\n    end.\n\n-spec find_server_process(server_id()) -> {ok, pid()} | {error, not_found}.\nfind_server_process(ServerId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            % Registry not available, try other approaches\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_server(ServerId) of\n                {ok, {ServerPid, _Config}} ->\n                    {ok, ServerPid};\n                {error, not_found} ->\n                    {error, not_found}\n            end\n    end.\n\n-spec is_new_architecture_available() -> boolean().\nis_new_architecture_available() ->\n    whereis(erlmcp_registry) =/= undefined andalso\n    whereis(erlmcp_server_sup) =/= undefined andalso\n    whereis(erlmcp_transport_sup) =/= undefined.\n\n-spec create_transport_id(server_id(), binary()) -> transport_id().\ncreate_transport_id(ServerId, Type) ->\n    binary_to_atom(<<(atom_to_binary(ServerId))/binary, \"_\", Type/binary>>, utf8).\n\n%%====================================================================\n%% Legacy Support Functions\n%%====================================================================\n\n-spec start_legacy_stdio_server(map()) -> {ok, pid()} | {error, term()}.\nstart_legacy_stdio_server(Options) ->\n    case erlmcp_stdio_server:start_link(Options) of\n        {ok, ServerPid} ->\n            % Register as default stdio server if registry is available\n            case whereis(erlmcp_registry) of\n                undefined -> \n                    {ok, ServerPid};\n                _ ->\n                    ServerConfig = #{\n                        capabilities => #mcp_server_capabilities{\n                            resources = #mcp_capability{enabled = true},\n                            tools = #mcp_capability{enabled = true},\n                            prompts = #mcp_capability{enabled = true}\n                        },\n                        options => Options,\n                        legacy => true\n                    },\n                    case erlmcp_registry:register_server(default_stdio_server, ServerPid, ServerConfig) of\n                        ok -> {ok, ServerPid};\n                        {error, already_registered} -> {ok, ServerPid};\n                        {error, Reason} -> \n                            logger:warning(\"Legacy server started but registration failed: ~p\", [Reason]),\n                            {ok, ServerPid}\n                    end\n            end;\n        Error -> Error\n    end.\n\n-spec stop_legacy_stdio_server() -> ok.\nstop_legacy_stdio_server() ->\n    case whereis(erlmcp_stdio_server) of\n        undefined -> ok;\n        _Pid -> \n            erlmcp_stdio_server:stop(),\n            ok\n    end.\n\n%%====================================================================\n%% Enhanced Error Handling Functions - Phase 3 Step 7\n%%====================================================================\n\n%% @doc Format transport error with context\n-spec format_transport_error(transport_id(), transport_type(), atom(), term()) -> \n    {error, term()}.\nformat_transport_error(TransportId, Type, ErrorType, Reason) ->\n    {error, #{\n        error_type => ErrorType,\n        transport_id => TransportId,\n        transport_type => Type,\n        reason => Reason,\n        suggestion => get_transport_suggestion(Type, ErrorType, Reason),\n        timestamp => erlang:timestamp()\n    }}.\n\n%% @doc Format setup error with context\n-spec format_setup_error(server_id(), transport_type(), atom(), term()) -> \n    {error, term()}.\nformat_setup_error(ServerId, Type, ErrorType, Reason) ->\n    {error, #{\n        error_type => ErrorType,\n        server_id => ServerId,\n        transport_type => Type,\n        reason => Reason,\n        suggestion => get_setup_suggestion(Type, ErrorType),\n        timestamp => erlang:timestamp()\n    }}.\n\n%% @doc Format validation error details\n-spec format_validation_details(term()) -> map().\nformat_validation_details({validation_error, ErrorType, Field, Message}) ->\n    #{\n        type => ErrorType,\n        field => Field,\n        message => Message,\n        severity => error\n    };\nformat_validation_details(Errors) when is_list(Errors) ->\n    #{\n        type => multiple_validation_errors,\n        errors => [format_validation_details(E) || E <- Errors],\n        severity => error\n    };\nformat_validation_details(Error) ->\n    #{\n        type => unknown_validation_error,\n        details => Error,\n        severity => error\n    }.\n\n%% @doc Get validation suggestion based on error\n-spec get_validation_suggestion(transport_type(), term()) -> string().\nget_validation_suggestion(tcp, {validation_error, missing_field, host, _}) ->\n    \"TCP transport requires 'host' field. Example: #{host => \\\"localhost\\\"}\";\nget_validation_suggestion(tcp, {validation_error, missing_field, port, _}) ->\n    \"TCP transport requires 'port' field. Example: #{port => 8080}\";\nget_validation_suggestion(tcp, {validation_error, invalid_value, port, _}) ->\n    \"TCP port must be between 1 and 65535. Example: #{port => 8080}\";\nget_validation_suggestion(http, {validation_error, missing_field, url, _}) ->\n    \"HTTP transport requires 'url' field. Example: #{url => \\\"http://localhost:8000/mcp\\\"}\";\nget_validation_suggestion(http, {validation_error, invalid_value, url, _}) ->\n    \"HTTP URL must be valid HTTP/HTTPS URL. Example: #{url => \\\"https://api.example.com/mcp\\\"}\";\nget_validation_suggestion(stdio, {validation_error, invalid_type, test_mode, _}) ->\n    \"STDIO test_mode must be boolean. Example: #{test_mode => true}\";\nget_validation_suggestion(_Type, Error) ->\n    io_lib:format(\"Check transport configuration documentation. Error: ~p\", [Error]).\n\n%% @doc Get transport suggestion based on error\n-spec get_transport_suggestion(transport_type(), atom(), term()) -> string().\nget_transport_suggestion(tcp, start_failed, {port_in_use, Port}) ->\n    io_lib:format(\"Port ~p is already in use. Try a different port number\", [Port]);\nget_transport_suggestion(tcp, start_failed, connection_refused) ->\n    \"Connection refused. Check if the target host is reachable and accepting connections\";\nget_transport_suggestion(http, start_failed, {port_in_use, Port}) ->\n    io_lib:format(\"HTTP port ~p is already in use. Try a different port\", [Port]);\nget_transport_suggestion(http, start_failed, invalid_url) ->\n    \"Invalid HTTP URL format. Use format: http://host:port/path or https://host:port/path\";\nget_transport_suggestion(stdio, start_failed, _Reason) ->\n    \"STDIO transport failed. Ensure standard input/output streams are available\";\nget_transport_suggestion(Type, ErrorType, Reason) ->\n    io_lib:format(\"Transport ~p failed with ~p: ~p. Check transport logs for details\", \n                  [Type, ErrorType, Reason]).\n\n%% @doc Get setup suggestion based on error\n-spec get_setup_suggestion(transport_type(), atom()) -> string().\nget_setup_suggestion(_Type, server_start_failed) ->\n    \"Server startup failed. Check server configuration and ensure required dependencies are available\";\nget_setup_suggestion(tcp, transport_start_failed) ->\n    \"TCP transport setup failed. Verify host/port availability and network configuration\";\nget_setup_suggestion(http, transport_start_failed) ->\n    \"HTTP transport setup failed. Check URL accessibility and server configuration\";\nget_setup_suggestion(Type, ErrorType) ->\n    io_lib:format(\"Setup failed for ~p transport with error ~p. Check system logs and configuration\", \n                  [Type, ErrorType]).\n\n%% @doc Clean up after failed setup\n-spec cleanup_failed_setup(server_id(), transport_type(), term()) -> {error, term()}.\ncleanup_failed_setup(ServerId, Type, TransportError) ->\n    logger:info(\"Cleaning up after failed ~p setup for server ~p\", [Type, ServerId]),\n    _ = stop_server(ServerId),\n    format_setup_error(ServerId, Type, transport_start_failed, TransportError).\n\n%%====================================================================\n%% Enhanced Transport Binding Management - Phase 3 Step 7\n%%====================================================================\n\n%% @doc Get detailed transport binding information\n-spec get_transport_binding_info(transport_id()) -> {ok, map()} | {error, term()}.\nget_transport_binding_info(TransportId) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            {error, registry_not_available};\n        _ ->\n            case erlmcp_registry:find_transport(TransportId) of\n                {ok, {TransportPid, Config}} ->\n                    ServerId = maps:get(server_id, Config, undefined),\n                    {ok, #{\n                        transport_id => TransportId,\n                        transport_pid => TransportPid,\n                        server_id => ServerId,\n                        transport_type => maps:get(type, Config, unknown),\n                        bound => ServerId =/= undefined,\n                        config => Config,\n                        status => get_process_status(TransportPid)\n                    }};\n                {error, not_found} ->\n                    {error, transport_not_found}\n            end\n    end.\n\n%% @doc List all transport bindings with detailed information\n-spec list_transport_bindings() -> [{transport_id(), map()}] | {error, term()}.\nlist_transport_bindings() ->\n    case get_transport_bindings() of\n        {error, _} = Error -> Error;\n        Bindings ->\n            DetailedBindings = lists:map(fun({TransportId, ServerId}) ->\n                case get_transport_binding_info(TransportId) of\n                    {ok, Info} -> {TransportId, Info#{server_id => ServerId}};\n                    {error, _} -> {TransportId, #{server_id => ServerId, status => unknown}}\n                end\n            end, Bindings),\n            DetailedBindings\n    end.\n\n%% @doc Force rebind transport to different server\n-spec rebind_transport(transport_id(), server_id()) -> ok | {error, term()}.\nrebind_transport(TransportId, NewServerId) ->\n    case unbind_transport(TransportId) of\n        ok ->\n            case bind_transport_to_server(TransportId, NewServerId) of\n                ok ->\n                    logger:info(\"Successfully rebound transport ~p to server ~p\", \n                              [TransportId, NewServerId]),\n                    ok;\n                {error, Reason} = Error ->\n                    logger:error(\"Failed to rebind transport ~p to server ~p: ~p\", \n                               [TransportId, NewServerId, Reason]),\n                    Error\n            end;\n        {error, Reason} = Error ->\n            logger:error(\"Failed to unbind transport ~p before rebinding: ~p\", \n                       [TransportId, Reason]),\n            Error\n    end.\n\n%% @doc Validate transport binding compatibility\n-spec validate_transport_binding(transport_id(), server_id()) -> ok | {error, term()}.\nvalidate_transport_binding(TransportId, ServerId) ->\n    case {get_transport_config(TransportId), get_server_config(ServerId)} of\n        {{ok, TransportConfig}, {ok, ServerConfig}} ->\n            TransportType = maps:get(type, TransportConfig, unknown),\n            ServerCapabilities = maps:get(capabilities, ServerConfig, #{}),\n            \n            case is_compatible_binding(TransportType, ServerCapabilities) of\n                true -> ok;\n                false -> {error, {incompatible_binding, \n                                 io_lib:format(\"Transport ~p not compatible with server ~p\", \n                                             [TransportType, ServerId])}}\n            end;\n        {{error, transport_not_found}, _} ->\n            {error, transport_not_found};\n        {_, {error, server_not_found}} ->\n            {error, server_not_found};\n        {Error, _} ->\n            Error\n    end.\n\n%% @doc Check if binding is compatible\n-spec is_compatible_binding(atom(), map()) -> boolean().\nis_compatible_binding(stdio, _ServerCapabilities) ->\n    true; % STDIO is compatible with all servers\nis_compatible_binding(tcp, ServerCapabilities) ->\n    % TCP requires network-capable server\n    maps:get(network_enabled, ServerCapabilities, true);\nis_compatible_binding(http, ServerCapabilities) ->\n    % HTTP requires web-capable server\n    maps:get(web_enabled, ServerCapabilities, true) andalso\n    maps:get(http_enabled, ServerCapabilities, true);\nis_compatible_binding(_Type, _Capabilities) ->\n    false.\n\n%% @doc Get process status\n-spec get_process_status(pid()) -> atom().\nget_process_status(Pid) ->\n    case is_process_alive(Pid) of\n        true -> \n            case process_info(Pid, status) of\n                {status, Status} -> Status;\n                undefined -> dead\n            end;\n        false -> dead\n    end.\n\n%% @doc Audit transport bindings for consistency\n-spec audit_transport_bindings() -> {ok, map()} | {error, term()}.\naudit_transport_bindings() ->\n    case list_transport_bindings() of\n        {error, _} = Error -> Error;\n        Bindings ->\n            Issues = lists:foldl(fun({TransportId, Info}, Acc) ->\n                case audit_single_binding(TransportId, Info) of\n                    [] -> Acc;\n                    BindingIssues -> [{TransportId, BindingIssues} | Acc]\n                end\n            end, [], Bindings),\n            \n            {ok, #{\n                total_bindings => length(Bindings),\n                healthy_bindings => length(Bindings) - length(Issues),\n                issues => Issues,\n                audit_time => erlang:timestamp()\n            }}\n    end.\n\n%% @doc Audit single binding\n-spec audit_single_binding(transport_id(), map()) -> [atom()].\naudit_single_binding(TransportId, Info) ->\n    Issues = [],\n    \n    % Check if transport process is alive\n    Issues1 = case maps:get(status, Info, unknown) of\n        dead -> [dead_transport | Issues];\n        _ -> Issues\n    end,\n    \n    % Check if server binding is valid\n    Issues2 = case maps:get(server_id, Info, undefined) of\n        undefined -> [unbound_transport | Issues1];\n        SrvId ->\n            case get_server_config(SrvId) of\n                {ok, _} -> Issues1;\n                {error, server_not_found} -> [orphaned_binding | Issues1];\n                {error, _} -> [server_unreachable | Issues1]\n            end\n    end,\n    \n    % Check transport type compatibility\n    Issues3 = case maps:get(server_id, Info, undefined) of\n        undefined -> Issues2;\n        ServerIdForBinding ->\n            case validate_transport_binding(TransportId, ServerIdForBinding) of\n                ok -> Issues2;\n                {error, {incompatible_binding, _}} -> [incompatible_binding | Issues2];\n                {error, _} -> [binding_validation_failed | Issues2]\n            end\n    end,\n    \n    Issues3.\n"
        }
    ]
}