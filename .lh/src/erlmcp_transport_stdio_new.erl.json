{
    "sourceFile": "src/erlmcp_transport_stdio_new.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1756186304603,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756187355519,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,40 +1,38 @@\n %%%-------------------------------------------------------------------\n %%% @doc\n %%% STDIO Transport Implementation\n-%%% \n+%%%\n %%% This module implements the standard input/output transport for MCP.\n %%% It provides bidirectional communication through stdin/stdout pipes.\n %%% @end\n %%%-------------------------------------------------------------------\n -module(erlmcp_transport_stdio_new).\n+\n -behaviour(gen_server).\n \n -include(\"erlmcp.hrl\").\n+\n -include_lib(\"kernel/include/logger.hrl\").\n \n %% API\n--export([\n-    start_link/2,\n-    send/2,\n-    close/1,\n-    get_info/1,\n-    trim_line/1\n-]).\n-\n+-export([start_link/2, send/2, close/1, get_info/1, trim_line/1]).\n %% gen_server callbacks\n--export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).\n+-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,\n+         code_change/3]).\n \n %% State record\n--record(state, {\n-    transport_id :: atom(),\n-    config :: map(),\n-    stdin_port :: port() | undefined,\n-    stdout_port :: port() | undefined,\n-    buffer :: binary(),\n-    registry_pid :: pid() | undefined,\n-    test_mode :: boolean()\n-}).\n+-record(state,\n+        {transport_id :: atom(),\n+         config :: map(),\n+         stdin_port :: port() | undefined,\n+         stdout_port :: port() | undefined,\n+         buffer :: binary(),\n+         registry_pid :: pid() | undefined,\n+         test_mode :: boolean(),\n+         server_id :: atom() | undefined,\n+         reader :: pid() | undefined,\n+         status :: connected | running | error}).\n \n -type state() :: #state{}.\n \n %%====================================================================\n@@ -53,12 +51,14 @@\n     send_data(State, Data);\n send(MapState, Data) when is_map(MapState) ->\n     % Allow tests to pass a map state\n     case maps:get(test_mode, MapState, true) of\n-        true -> ok;\n+        true ->\n+            ok;\n         false ->\n             case maps:get(stdout_port, MapState, undefined) of\n-                undefined -> {error, port_not_available};\n+                undefined ->\n+                    {error, port_not_available};\n                 Port when is_port(Port) ->\n                     send_data(map_to_state(MapState), Data)\n             end\n     end.\n@@ -74,18 +74,18 @@\n \n -spec get_info(pid() | state() | map()) -> map().\n get_info(Pid) when is_pid(Pid) ->\n     gen_server:call(Pid, get_info);\n-get_info(#state{transport_id = Id, config = Config, test_mode = TestMode}) ->\n-    #{\n-        transport_id => Id,\n-        type => stdio,\n-        config => Config,\n-        test_mode => TestMode,\n-        status => running\n-    };\n+get_info(#state{transport_id = Id,\n+                config = Config,\n+                test_mode = TestMode}) ->\n+    #{transport_id => Id,\n+      type => stdio,\n+      config => Config,\n+      test_mode => TestMode,\n+      status => connected};\n get_info(MapState) when is_map(MapState) ->\n-    MapState#{type => stdio, status => running}.\n+    MapState#{type => stdio, status => connected}.\n \n -spec trim_line(binary()) -> binary().\n trim_line(Line) ->\n     % Remove trailing newlines and carriage returns\n@@ -97,18 +97,21 @@\n \n -spec init([atom() | map()]) -> {ok, state()} | {error, term()}.\n init([TransportId, Config]) ->\n     ?LOG_INFO(\"Initializing STDIO transport ~p\", [TransportId]),\n-    \n+\n     TestMode = maps:get(test_mode, Config, false),\n-    \n-    State = #state{\n-        transport_id = TransportId,\n-        config = Config,\n-        buffer = <<>>,\n-        test_mode = TestMode\n-    },\n-    \n+\n+    State =\n+        #state{transport_id = TransportId,\n+               config = Config,\n+               buffer = <<>>,\n+               registry_pid = undefined,\n+               test_mode = TestMode,\n+               server_id = maps:get(server_id, Config, undefined),\n+               reader = undefined,\n+               status = case TestMode of true -> connected; false -> running end},\n+\n     case TestMode of\n         true ->\n             ?LOG_INFO(\"STDIO transport ~p initialized in test mode\", [TransportId]),\n             {ok, State};\n@@ -118,63 +121,64 @@\n                     register_with_registry(NewState),\n                     ?LOG_INFO(\"STDIO transport ~p initialized successfully\", [TransportId]),\n                     {ok, NewState};\n                 {error, Reason} = Error ->\n-                    ?LOG_ERROR(\"Failed to initialize STDIO transport ~p: ~p\", [TransportId, Reason]),\n+                    ?LOG_ERROR(\"Failed to initialize STDIO transport ~p: ~p\",\n+                               [TransportId, Reason]),\n                     Error\n             end\n     end;\n init(ConfigMap) when is_map(ConfigMap) ->\n     TransportId = maps:get(transport_id, ConfigMap, make_ref()),\n     init([TransportId, ConfigMap]).\n \n -spec handle_call(term(), {pid(), term()}, state()) ->\n-    {reply, term(), state()} | {noreply, state()} | {stop, term(), term(), state()}.\n+                     {reply, term(), state()} |\n+                     {noreply, state()} |\n+                     {stop, term(), term(), state()}.\n handle_call({send, Data}, _From, State) ->\n     case send_data(State, Data) of\n         ok ->\n             {reply, ok, State};\n         {error, Reason} = Error ->\n             ?LOG_ERROR(\"Failed to send data: ~p\", [Reason]),\n             {reply, Error, State}\n     end;\n-\n handle_call(close, _From, State) ->\n     NewState = close_ports(State),\n     {reply, ok, NewState};\n-\n handle_call(get_info, _From, State) ->\n     Info = get_info(State),\n     {reply, Info, State};\n-\n handle_call(get_state, _From, State) ->\n     {reply, {ok, state_to_map(State)}, State};\n-\n+handle_call({transport_call, get_buffer}, _From, State) ->\n+    {reply, {reply, {ok, State#state.buffer}, State}, State};\n+handle_call({transport_call, get_test_mode}, _From, State) ->\n+    {reply, {reply, {ok, State#state.test_mode}, State}, State};\n+handle_call({transport_call, get_reader_pid}, _From, State) ->\n+    {reply, {reply, {ok, State#state.reader}, State}, State};\n handle_call(_Request, _From, State) ->\n     {reply, {error, unknown_request}, State}.\n \n -spec handle_cast(term(), state()) -> {noreply, state()}.\n handle_cast({data, Data}, State) ->\n     NewState = handle_incoming_data(State, Data),\n     {noreply, NewState};\n-\n handle_cast(_Msg, State) ->\n     {noreply, State}.\n \n -spec handle_info(term(), state()) -> {noreply, state()} | {stop, term(), state()}.\n handle_info({stdin_port, {data, Data}}, State) ->\n     NewState = handle_incoming_data(State, Data),\n     {noreply, NewState};\n-\n handle_info({stdin_port, closed}, State) ->\n     ?LOG_WARNING(\"STDIN port closed for transport ~p\", [State#state.transport_id]),\n     {stop, stdin_closed, State};\n-\n handle_info({Port, {exit_status, Status}}, State) when is_port(Port) ->\n     ?LOG_WARNING(\"Port ~p exited with status ~p\", [Port, Status]),\n     NewState = handle_port_exit(State, Port),\n     {noreply, NewState};\n-\n handle_info(_Info, State) ->\n     {noreply, State}.\n \n -spec terminate(term(), state()) -> ok.\n@@ -226,28 +230,31 @@\n -spec handle_incoming_data(state(), binary()) -> state().\n handle_incoming_data(#state{buffer = Buffer} = State, NewData) ->\n     UpdatedBuffer = <<Buffer/binary, NewData/binary>>,\n     {ProcessedLines, RemainingBuffer} = extract_lines(UpdatedBuffer),\n-    \n+\n     % Process each complete line\n     lists:foreach(fun(Line) ->\n-        TrimmedLine = trim_line(Line),\n-        case TrimmedLine of\n-            <<>> -> ok; % Skip empty lines\n-            _ -> process_message(State, TrimmedLine)\n-        end\n-    end, ProcessedLines),\n-    \n+                     TrimmedLine = trim_line(Line),\n+                     case TrimmedLine of\n+                         <<>> -> ok; % Skip empty lines\n+                         _ -> process_message(State, TrimmedLine)\n+                     end\n+                  end,\n+                  ProcessedLines),\n+\n     State#state{buffer = RemainingBuffer}.\n \n -spec extract_lines(binary()) -> {[binary()], binary()}.\n extract_lines(Buffer) ->\n     extract_lines(Buffer, [], <<>>).\n \n extract_lines(<<>>, Lines, CurrentLine) ->\n     case CurrentLine of\n-        <<>> -> {lists:reverse(Lines), <<>>};\n-        _ -> {lists:reverse(Lines), CurrentLine}\n+        <<>> ->\n+            {lists:reverse(Lines), <<>>};\n+        _ ->\n+            {lists:reverse(Lines), CurrentLine}\n     end;\n extract_lines(<<$\\n, Rest/binary>>, Lines, CurrentLine) ->\n     extract_lines(Rest, [CurrentLine | Lines], <<>>);\n extract_lines(<<Char, Rest/binary>>, Lines, CurrentLine) ->\n@@ -262,15 +269,17 @@\n \n -spec close_ports(state()) -> state().\n close_ports(#state{stdin_port = StdinPort, stdout_port = StdoutPort} = State) ->\n     case StdinPort of\n-        undefined -> ok;\n-        Port when is_port(Port) -> \n+        undefined ->\n+            ok;\n+        Port when is_port(Port) ->\n             catch port_close(Port)\n     end,\n     case StdoutPort of\n-        undefined -> ok;\n-        Port2 when is_port(Port2) -> \n+        undefined ->\n+            ok;\n+        Port2 when is_port(Port2) ->\n             catch port_close(Port2)\n     end,\n     State#state{stdin_port = undefined, stdout_port = undefined}.\n \n@@ -303,14 +312,14 @@\n     end.\n \n %% Convert internal record state to a map for tests/externals\n state_to_map(#state{transport_id = Id,\n-                   config = Config,\n-                   stdin_port = Stdin,\n-                   stdout_port = Stdout,\n-                   buffer = Buffer,\n-                   registry_pid = RegistryPid,\n-                   test_mode = TestMode}) ->\n+                    config = Config,\n+                    stdin_port = Stdin,\n+                    stdout_port = Stdout,\n+                    buffer = Buffer,\n+                    registry_pid = RegistryPid,\n+                    test_mode = TestMode}) ->\n     #{transport_id => Id,\n       config => Config,\n       stdin_port => Stdin,\n       stdout_port => Stdout,\n@@ -340,5 +349,5 @@\n                 {error, Reason} ->\n                     ?LOG_WARNING(\"Failed to unregister transport ~p: ~p\", [TransportId, Reason]),\n                     ok\n             end\n-    end.\n\\ No newline at end of file\n+    end.\n"
                },
                {
                    "date": 1756188161135,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,10 @@\n \n -include_lib(\"kernel/include/logger.hrl\").\n \n %% API\n--export([start_link/2, send/2, close/1, get_info/1, trim_line/1, handle_transport_call/2]).\n+-export([start_link/2, send/2, close/1, get_info/1, trim_line/1,\n+         handle_transport_call/2]).\n %% gen_server callbacks\n -export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,\n          code_change/3]).\n \n@@ -61,12 +62,14 @@\n         {transport_id :: atom(),\n          server_id :: atom() | undefined,\n          config :: map(),\n          %% Transport-specific fields below this line\n-         connection :: #{stdin_port => port() | undefined,\n-                        stdout_port => port() | undefined,\n-                        reader => pid() | undefined,\n-                        status => connected | running | error | disconnected} | undefined,\n+         connection ::\n+             #{stdin_port => port() | undefined,\n+               stdout_port => port() | undefined,\n+               reader => pid() | undefined,\n+               status => connected | running | error | disconnected} |\n+             undefined,\n          buffer = <<>> :: binary(),\n          registry_pid :: pid() | undefined,\n          test_mode :: boolean()}).\n \n@@ -115,15 +118,21 @@\n     gen_server:call(Pid, get_info);\n get_info(#state{transport_id = Id,\n                 config = Config,\n                 connection = Connection,\n-                test_mode = TestMode} = State) ->\n-    ConnectionState = case Connection of\n-        #{status := Status} -> Status;\n-        undefined when TestMode -> connected;\n-        undefined -> disconnected;\n-        _ -> connected\n-    end,\n+                test_mode = TestMode} =\n+             State) ->\n+    ConnectionState =\n+        case Connection of\n+            #{status := Status} ->\n+                Status;\n+            undefined when TestMode ->\n+                connected;\n+            undefined ->\n+                disconnected;\n+            _ ->\n+                connected\n+        end,\n     #{type => stdio,\n       version => <<\"1.0.0\">>,\n       capabilities => [bidirectional, message_framing, test_mode],\n       connection_state => ConnectionState,\n@@ -131,31 +140,37 @@\n       transport_id => Id,\n       config => Config,\n       test_mode => TestMode};\n get_info(MapState) when is_map(MapState) ->\n-    MapState#{type => stdio, \n+    MapState#{type => stdio,\n               version => <<\"1.0.0\">>,\n               capabilities => [bidirectional, message_framing],\n               connection_state => connected,\n               statistics => #{messages_sent => 0, messages_received => 0}}.\n \n--spec handle_transport_call(term(), state()) -> \n-    {reply, term(), state()} | {error, term()}.\n+-spec handle_transport_call(term(), state()) ->\n+                               {reply, term(), state()} | {error, term()}.\n handle_transport_call(get_buffer, State) ->\n     {reply, {ok, State#state.buffer}, State};\n handle_transport_call(get_test_mode, State) ->\n     {reply, {ok, State#state.test_mode}, State};\n handle_transport_call(get_reader_pid, #state{connection = Connection} = State) ->\n-    Reader = case Connection of\n-        #{reader := Pid} -> Pid;\n-        _ -> undefined\n-    end,\n+    Reader =\n+        case Connection of\n+            #{reader := Pid} ->\n+                Pid;\n+            _ ->\n+                undefined\n+        end,\n     {reply, {ok, Reader}, State};\n handle_transport_call(get_connection_status, #state{connection = Connection} = State) ->\n-    Status = case Connection of\n-        #{status := S} -> S;\n-        _ -> disconnected\n-    end,\n+    Status =\n+        case Connection of\n+            #{status := S} ->\n+                S;\n+            _ ->\n+                disconnected\n+        end,\n     {reply, {ok, Status}, State};\n handle_transport_call(reset_statistics, State) ->\n     %% In a full implementation, this would reset message counters\n     {reply, ok, State};\n@@ -291,17 +306,26 @@\n %%====================================================================\n \n -spec init_ports(state()) -> {ok, state()} | {error, term()}.\n init_ports(#state{test_mode = true} = State) ->\n-    ?LOG_DEBUG(\"STDIO transport ~p: skipping port initialization in test mode\", [State#state.transport_id]),\n-    Connection = #{stdin_port => undefined, stdout_port => undefined, reader => undefined, status => connected},\n+    ?LOG_DEBUG(\"STDIO transport ~p: skipping port initialization in test mode\",\n+               [State#state.transport_id]),\n+    Connection =\n+        #{stdin_port => undefined,\n+          stdout_port => undefined,\n+          reader => undefined,\n+          status => connected},\n     {ok, State#state{connection = Connection}};\n init_ports(State) ->\n     try\n         ?LOG_DEBUG(\"STDIO transport ~p: initializing ports\", [State#state.transport_id]),\n         % For now, use simple port setup - this can be enhanced later\n         % In a full implementation, this would create actual stdin/stdout ports\n-        Connection = #{stdin_port => undefined, stdout_port => undefined, reader => undefined, status => running},\n+        Connection =\n+            #{stdin_port => undefined,\n+              stdout_port => undefined,\n+              reader => undefined,\n+              status => running},\n         {ok, State#state{connection = Connection}}\n     catch\n         Class:Reason:Stacktrace ->\n             ?LOG_ERROR(\"Failed to initialize ports: ~p:~p~n~p\", [Class, Reason, Stacktrace]),\n@@ -309,20 +333,24 @@\n     end.\n \n -spec send_data(state(), binary() | string()) -> ok | {error, term()}.\n send_data(#state{test_mode = true} = State, Data) ->\n-    ?LOG_DEBUG(\"STDIO transport ~p: sending data in test mode: ~p\", [State#state.transport_id, Data]),\n+    ?LOG_DEBUG(\"STDIO transport ~p: sending data in test mode: ~p\",\n+               [State#state.transport_id, Data]),\n     ok;\n send_data(#state{connection = #{stdout_port := undefined}}, _Data) ->\n     {error, port_not_available};\n-send_data(#state{connection = #{stdout_port := Port}} = State, Data) when is_binary(Data), is_port(Port) ->\n+send_data(#state{connection = #{stdout_port := Port}} = State, Data)\n+    when is_binary(Data), is_port(Port) ->\n     try\n-        ?LOG_DEBUG(\"STDIO transport ~p: sending ~p bytes\", [State#state.transport_id, byte_size(Data)]),\n+        ?LOG_DEBUG(\"STDIO transport ~p: sending ~p bytes\",\n+                   [State#state.transport_id, byte_size(Data)]),\n         port_command(Port, Data),\n         ok\n     catch\n         Class:Reason ->\n-            ?LOG_ERROR(\"STDIO transport ~p: send failed ~p:~p\", [State#state.transport_id, Class, Reason]),\n+            ?LOG_ERROR(\"STDIO transport ~p: send failed ~p:~p\",\n+                       [State#state.transport_id, Class, Reason]),\n             {error, {send_failed, Class, Reason}}\n     end;\n send_data(#state{connection = undefined}, _Data) ->\n     {error, connection_not_initialized};\n@@ -330,24 +358,26 @@\n     send_data(State, list_to_binary(Data)).\n \n -spec handle_incoming_data(state(), binary()) -> state().\n handle_incoming_data(#state{buffer = Buffer} = State, NewData) ->\n-    ?LOG_DEBUG(\"STDIO transport ~p: received ~p bytes, buffer has ~p bytes\", \n+    ?LOG_DEBUG(\"STDIO transport ~p: received ~p bytes, buffer has ~p bytes\",\n                [State#state.transport_id, byte_size(NewData), byte_size(Buffer)]),\n     UpdatedBuffer = <<Buffer/binary, NewData/binary>>,\n     {ProcessedLines, RemainingBuffer} = extract_lines(UpdatedBuffer),\n \n-    ?LOG_DEBUG(\"STDIO transport ~p: extracted ~p complete lines, ~p bytes remaining\", \n+    ?LOG_DEBUG(\"STDIO transport ~p: extracted ~p complete lines, ~p bytes remaining\",\n                [State#state.transport_id, length(ProcessedLines), byte_size(RemainingBuffer)]),\n \n     % Process each complete line\n     lists:foreach(fun(Line) ->\n                      TrimmedLine = trim_line(Line),\n                      case TrimmedLine of\n-                         <<>> -> \n-                             ?LOG_DEBUG(\"STDIO transport ~p: skipping empty line\", [State#state.transport_id]);\n-                         _ -> \n-                             ?LOG_DEBUG(\"STDIO transport ~p: processing message: ~p\", [State#state.transport_id, TrimmedLine]),\n+                         <<>> ->\n+                             ?LOG_DEBUG(\"STDIO transport ~p: skipping empty line\",\n+                                        [State#state.transport_id]);\n+                         _ ->\n+                             ?LOG_DEBUG(\"STDIO transport ~p: processing message: ~p\",\n+                                        [State#state.transport_id, TrimmedLine]),\n                              process_message(State, TrimmedLine)\n                      end\n                   end,\n                   ProcessedLines),\n@@ -385,16 +415,18 @@\n             case StdinPort of\n                 undefined ->\n                     ok;\n                 Port when is_port(Port) ->\n-                    ?LOG_DEBUG(\"STDIO transport ~p: closing stdin port\", [State#state.transport_id]),\n+                    ?LOG_DEBUG(\"STDIO transport ~p: closing stdin port\",\n+                               [State#state.transport_id]),\n                     catch port_close(Port)\n             end,\n             case StdoutPort of\n                 undefined ->\n                     ok;\n                 Port2 when is_port(Port2) ->\n-                    ?LOG_DEBUG(\"STDIO transport ~p: closing stdout port\", [State#state.transport_id]),\n+                    ?LOG_DEBUG(\"STDIO transport ~p: closing stdout port\",\n+                               [State#state.transport_id]),\n                     catch port_close(Port2)\n             end;\n         _ ->\n             ?LOG_DEBUG(\"STDIO transport ~p: no ports to close\", [State#state.transport_id])\n@@ -442,37 +474,51 @@\n                     connection = Connection,\n                     buffer = Buffer,\n                     registry_pid = RegistryPid,\n                     test_mode = TestMode}) ->\n-    BaseMap = #{transport_id => Id,\n-                server_id => ServerId,\n-                config => Config,\n-                connection => Connection,\n-                buffer => Buffer,\n-                registry_pid => RegistryPid,\n-                test_mode => TestMode},\n+    BaseMap =\n+        #{transport_id => Id,\n+          server_id => ServerId,\n+          config => Config,\n+          connection => Connection,\n+          buffer => Buffer,\n+          registry_pid => RegistryPid,\n+          test_mode => TestMode},\n     %% Add legacy fields for backward compatibility\n     case Connection of\n-        #{stdin_port := Stdin, stdout_port := Stdout, reader := Reader, status := Status} ->\n-            BaseMap#{stdin_port => Stdin, stdout_port => Stdout, reader => Reader, status => Status};\n+        #{stdin_port := Stdin,\n+          stdout_port := Stdout,\n+          reader := Reader,\n+          status := Status} ->\n+            BaseMap#{stdin_port => Stdin,\n+                     stdout_port => Stdout,\n+                     reader => Reader,\n+                     status => Status};\n         _ ->\n-            BaseMap#{stdin_port => undefined, stdout_port => undefined, reader => undefined, status => disconnected}\n+            BaseMap#{stdin_port => undefined,\n+                     stdout_port => undefined,\n+                     reader => undefined,\n+                     status => disconnected}\n     end.\n \n map_to_state(Map) when is_map(Map) ->\n     %% Try to build connection from either new or legacy format\n-    Connection = case maps:get(connection, Map, undefined) of\n-        undefined ->\n-            %% Build from legacy fields for backward compatibility\n-            #{stdin_port => maps:get(stdin_port, Map, undefined),\n-              stdout_port => maps:get(stdout_port, Map, undefined),\n-              reader => maps:get(reader, Map, undefined),\n-              status => maps:get(status, Map, connected)};\n-        Conn when is_map(Conn) ->\n-            Conn;\n-        _ ->\n-            #{stdin_port => undefined, stdout_port => undefined, reader => undefined, status => disconnected}\n-    end,\n+    Connection =\n+        case maps:get(connection, Map, undefined) of\n+            undefined ->\n+                %% Build from legacy fields for backward compatibility\n+                #{stdin_port => maps:get(stdin_port, Map, undefined),\n+                  stdout_port => maps:get(stdout_port, Map, undefined),\n+                  reader => maps:get(reader, Map, undefined),\n+                  status => maps:get(status, Map, connected)};\n+            Conn when is_map(Conn) ->\n+                Conn;\n+            _ ->\n+                #{stdin_port => undefined,\n+                  stdout_port => undefined,\n+                  reader => undefined,\n+                  status => disconnected}\n+        end,\n     #state{transport_id = maps:get(transport_id, Map, undefined),\n            server_id = maps:get(server_id, Map, undefined),\n            config = maps:get(config, Map, #{}),\n            connection = Connection,\n"
                }
            ],
            "date": 1756186304603,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @doc\n%%% STDIO Transport Implementation\n%%% \n%%% This module implements the standard input/output transport for MCP.\n%%% It provides bidirectional communication through stdin/stdout pipes.\n%%% @end\n%%%-------------------------------------------------------------------\n-module(erlmcp_transport_stdio_new).\n-behaviour(gen_server).\n\n-include(\"erlmcp.hrl\").\n-include_lib(\"kernel/include/logger.hrl\").\n\n%% API\n-export([\n    start_link/2,\n    send/2,\n    close/1,\n    get_info/1,\n    trim_line/1\n]).\n\n%% gen_server callbacks\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).\n\n%% State record\n-record(state, {\n    transport_id :: atom(),\n    config :: map(),\n    stdin_port :: port() | undefined,\n    stdout_port :: port() | undefined,\n    buffer :: binary(),\n    registry_pid :: pid() | undefined,\n    test_mode :: boolean()\n}).\n\n-type state() :: #state{}.\n\n%%====================================================================\n%% API Functions\n%%====================================================================\n\n-spec start_link(atom(), map()) -> {ok, pid()} | {error, term()}.\nstart_link(TransportId, Config) ->\n    ?LOG_INFO(\"Starting STDIO transport: ~p with config: ~p\", [TransportId, Config]),\n    gen_server:start_link(?MODULE, [TransportId, Config], []).\n\n-spec send(pid() | state() | map(), binary() | string()) -> ok | {error, term()}.\nsend(Pid, Data) when is_pid(Pid) ->\n    gen_server:call(Pid, {send, Data});\nsend(#state{} = State, Data) ->\n    send_data(State, Data);\nsend(MapState, Data) when is_map(MapState) ->\n    % Allow tests to pass a map state\n    case maps:get(test_mode, MapState, true) of\n        true -> ok;\n        false ->\n            case maps:get(stdout_port, MapState, undefined) of\n                undefined -> {error, port_not_available};\n                Port when is_port(Port) ->\n                    send_data(map_to_state(MapState), Data)\n            end\n    end.\n\n-spec close(pid() | state() | map()) -> ok.\nclose(Pid) when is_pid(Pid) ->\n    gen_server:call(Pid, close);\nclose(#state{} = State) ->\n    close_ports(State);\nclose(MapState) when is_map(MapState) ->\n    close_ports(map_to_state(MapState)),\n    ok.\n\n-spec get_info(pid() | state() | map()) -> map().\nget_info(Pid) when is_pid(Pid) ->\n    gen_server:call(Pid, get_info);\nget_info(#state{transport_id = Id, config = Config, test_mode = TestMode}) ->\n    #{\n        transport_id => Id,\n        type => stdio,\n        config => Config,\n        test_mode => TestMode,\n        status => running\n    };\nget_info(MapState) when is_map(MapState) ->\n    MapState#{type => stdio, status => running}.\n\n-spec trim_line(binary()) -> binary().\ntrim_line(Line) ->\n    % Remove trailing newlines and carriage returns\n    re:replace(Line, \"[\\r\\n]+$\", \"\", [global, {return, binary}]).\n\n%%====================================================================\n%% gen_server callbacks\n%%====================================================================\n\n-spec init([atom() | map()]) -> {ok, state()} | {error, term()}.\ninit([TransportId, Config]) ->\n    ?LOG_INFO(\"Initializing STDIO transport ~p\", [TransportId]),\n    \n    TestMode = maps:get(test_mode, Config, false),\n    \n    State = #state{\n        transport_id = TransportId,\n        config = Config,\n        buffer = <<>>,\n        test_mode = TestMode\n    },\n    \n    case TestMode of\n        true ->\n            ?LOG_INFO(\"STDIO transport ~p initialized in test mode\", [TransportId]),\n            {ok, State};\n        false ->\n            case init_ports(State) of\n                {ok, NewState} ->\n                    register_with_registry(NewState),\n                    ?LOG_INFO(\"STDIO transport ~p initialized successfully\", [TransportId]),\n                    {ok, NewState};\n                {error, Reason} = Error ->\n                    ?LOG_ERROR(\"Failed to initialize STDIO transport ~p: ~p\", [TransportId, Reason]),\n                    Error\n            end\n    end;\ninit(ConfigMap) when is_map(ConfigMap) ->\n    TransportId = maps:get(transport_id, ConfigMap, make_ref()),\n    init([TransportId, ConfigMap]).\n\n-spec handle_call(term(), {pid(), term()}, state()) ->\n    {reply, term(), state()} | {noreply, state()} | {stop, term(), term(), state()}.\nhandle_call({send, Data}, _From, State) ->\n    case send_data(State, Data) of\n        ok ->\n            {reply, ok, State};\n        {error, Reason} = Error ->\n            ?LOG_ERROR(\"Failed to send data: ~p\", [Reason]),\n            {reply, Error, State}\n    end;\n\nhandle_call(close, _From, State) ->\n    NewState = close_ports(State),\n    {reply, ok, NewState};\n\nhandle_call(get_info, _From, State) ->\n    Info = get_info(State),\n    {reply, Info, State};\n\nhandle_call(get_state, _From, State) ->\n    {reply, {ok, state_to_map(State)}, State};\n\nhandle_call(_Request, _From, State) ->\n    {reply, {error, unknown_request}, State}.\n\n-spec handle_cast(term(), state()) -> {noreply, state()}.\nhandle_cast({data, Data}, State) ->\n    NewState = handle_incoming_data(State, Data),\n    {noreply, NewState};\n\nhandle_cast(_Msg, State) ->\n    {noreply, State}.\n\n-spec handle_info(term(), state()) -> {noreply, state()} | {stop, term(), state()}.\nhandle_info({stdin_port, {data, Data}}, State) ->\n    NewState = handle_incoming_data(State, Data),\n    {noreply, NewState};\n\nhandle_info({stdin_port, closed}, State) ->\n    ?LOG_WARNING(\"STDIN port closed for transport ~p\", [State#state.transport_id]),\n    {stop, stdin_closed, State};\n\nhandle_info({Port, {exit_status, Status}}, State) when is_port(Port) ->\n    ?LOG_WARNING(\"Port ~p exited with status ~p\", [Port, Status]),\n    NewState = handle_port_exit(State, Port),\n    {noreply, NewState};\n\nhandle_info(_Info, State) ->\n    {noreply, State}.\n\n-spec terminate(term(), state()) -> ok.\nterminate(Reason, State) ->\n    ?LOG_INFO(\"Terminating STDIO transport ~p: ~p\", [State#state.transport_id, Reason]),\n    close_ports(State),\n    unregister_from_registry(State),\n    ok.\n\n-spec code_change(term(), state(), term()) -> {ok, state()}.\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\n%%====================================================================\n%% Internal functions\n%%====================================================================\n\n-spec init_ports(state()) -> {ok, state()} | {error, term()}.\ninit_ports(#state{test_mode = true} = State) ->\n    {ok, State};\ninit_ports(State) ->\n    try\n        % For now, use simple port setup - this can be enhanced later\n        % In test mode, we don't actually create ports\n        {ok, State}\n    catch\n        Class:Reason:Stacktrace ->\n            ?LOG_ERROR(\"Failed to initialize ports: ~p:~p~n~p\", [Class, Reason, Stacktrace]),\n            {error, {port_init_failed, Reason}}\n    end.\n\n-spec send_data(state(), binary() | string()) -> ok | {error, term()}.\nsend_data(#state{test_mode = true}, _Data) ->\n    % In test mode, just pretend to send\n    ok;\nsend_data(#state{stdout_port = undefined}, _Data) ->\n    {error, port_not_available};\nsend_data(#state{stdout_port = Port}, Data) when is_binary(Data) ->\n    try\n        port_command(Port, Data),\n        ok\n    catch\n        Class:Reason ->\n            {error, {send_failed, Class, Reason}}\n    end;\nsend_data(State, Data) when is_list(Data) ->\n    send_data(State, list_to_binary(Data)).\n\n-spec handle_incoming_data(state(), binary()) -> state().\nhandle_incoming_data(#state{buffer = Buffer} = State, NewData) ->\n    UpdatedBuffer = <<Buffer/binary, NewData/binary>>,\n    {ProcessedLines, RemainingBuffer} = extract_lines(UpdatedBuffer),\n    \n    % Process each complete line\n    lists:foreach(fun(Line) ->\n        TrimmedLine = trim_line(Line),\n        case TrimmedLine of\n            <<>> -> ok; % Skip empty lines\n            _ -> process_message(State, TrimmedLine)\n        end\n    end, ProcessedLines),\n    \n    State#state{buffer = RemainingBuffer}.\n\n-spec extract_lines(binary()) -> {[binary()], binary()}.\nextract_lines(Buffer) ->\n    extract_lines(Buffer, [], <<>>).\n\nextract_lines(<<>>, Lines, CurrentLine) ->\n    case CurrentLine of\n        <<>> -> {lists:reverse(Lines), <<>>};\n        _ -> {lists:reverse(Lines), CurrentLine}\n    end;\nextract_lines(<<$\\n, Rest/binary>>, Lines, CurrentLine) ->\n    extract_lines(Rest, [CurrentLine | Lines], <<>>);\nextract_lines(<<Char, Rest/binary>>, Lines, CurrentLine) ->\n    extract_lines(Rest, Lines, <<CurrentLine/binary, Char>>).\n\n-spec process_message(state(), binary()) -> ok.\nprocess_message(#state{transport_id = TransportId}, Message) ->\n    ?LOG_DEBUG(\"Processing message on transport ~p: ~p\", [TransportId, Message]),\n    % Here we would normally parse JSON-RPC and route to appropriate handler\n    % For now, just log the message\n    ok.\n\n-spec close_ports(state()) -> state().\nclose_ports(#state{stdin_port = StdinPort, stdout_port = StdoutPort} = State) ->\n    case StdinPort of\n        undefined -> ok;\n        Port when is_port(Port) -> \n            catch port_close(Port)\n    end,\n    case StdoutPort of\n        undefined -> ok;\n        Port2 when is_port(Port2) -> \n            catch port_close(Port2)\n    end,\n    State#state{stdin_port = undefined, stdout_port = undefined}.\n\n-spec handle_port_exit(state(), port()) -> state().\nhandle_port_exit(#state{stdin_port = Port} = State, Port) ->\n    ?LOG_WARNING(\"STDIN port exited\"),\n    State#state{stdin_port = undefined};\nhandle_port_exit(#state{stdout_port = Port} = State, Port) ->\n    ?LOG_WARNING(\"STDOUT port exited\"),\n    State#state{stdout_port = undefined};\nhandle_port_exit(State, _Port) ->\n    State.\n\n-spec register_with_registry(state()) -> ok.\nregister_with_registry(#state{transport_id = TransportId, config = Config}) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            ?LOG_WARNING(\"Registry not available for transport ~p\", [TransportId]),\n            ok;\n        _RegistryPid ->\n            TransportConfig = Config#{type => stdio},\n            case erlmcp_registry:register_transport(TransportId, self(), TransportConfig) of\n                ok ->\n                    ?LOG_DEBUG(\"Registered transport ~p with registry\", [TransportId]),\n                    ok;\n                {error, Reason} ->\n                    ?LOG_ERROR(\"Failed to register transport ~p: ~p\", [TransportId, Reason]),\n                    ok\n            end\n    end.\n\n%% Convert internal record state to a map for tests/externals\nstate_to_map(#state{transport_id = Id,\n                   config = Config,\n                   stdin_port = Stdin,\n                   stdout_port = Stdout,\n                   buffer = Buffer,\n                   registry_pid = RegistryPid,\n                   test_mode = TestMode}) ->\n    #{transport_id => Id,\n      config => Config,\n      stdin_port => Stdin,\n      stdout_port => Stdout,\n      buffer => Buffer,\n      registry_pid => RegistryPid,\n      test_mode => TestMode}.\n\nmap_to_state(Map) when is_map(Map) ->\n    #state{transport_id = maps:get(transport_id, Map, undefined),\n           config = maps:get(config, Map, #{}),\n           stdin_port = maps:get(stdin_port, Map, undefined),\n           stdout_port = maps:get(stdout_port, Map, undefined),\n           buffer = maps:get(buffer, Map, <<>>),\n           registry_pid = maps:get(registry_pid, Map, undefined),\n           test_mode = maps:get(test_mode, Map, true)}.\n\n-spec unregister_from_registry(state()) -> ok.\nunregister_from_registry(#state{transport_id = TransportId}) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            ok;\n        _RegistryPid ->\n            case erlmcp_registry:unregister_transport(TransportId) of\n                ok ->\n                    ?LOG_DEBUG(\"Unregistered transport ~p from registry\", [TransportId]),\n                    ok;\n                {error, Reason} ->\n                    ?LOG_WARNING(\"Failed to unregister transport ~p: ~p\", [TransportId, Reason]),\n                    ok\n            end\n    end."
        }
    ]
}