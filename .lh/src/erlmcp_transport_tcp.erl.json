{
    "sourceFile": "src/erlmcp_transport_tcp.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1756189861169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756190041243,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n %%% TCP Transport Implementation for Erlang MCP\n %%%\n %%% This module implements a robust TCP transport that follows the standard\n %%% gen_server pattern and the erlmcp_transport_behavior specification.\n-%%% \n+%%%\n %%% Key features:\n %%% - Automatic registry integration\n %%% - Connection management with reconnection logic\n %%% - Comprehensive error handling and recovery\n@@ -17,64 +17,50 @@\n %%%-------------------------------------------------------------------\n -module(erlmcp_transport_tcp).\n \n -behaviour(gen_server).\n--behaviour(erlmcp_transport_behavior).\n \n -include(\"erlmcp.hrl\").\n+\n -include_lib(\"kernel/include/logger.hrl\").\n \n %% API exports\n--export([\n-    start_link/2,\n-    send/2,\n-    close/1,\n-    get_info/1,\n-    handle_transport_call/2\n-]).\n+-export([start_link/2, send/2, close/1, get_info/1, handle_transport_call/2]).\n \n %% Transport behavior callbacks (implemented as required)\n %% Note: These are the same functions exported in the API section\n \n %% gen_server callbacks\n--export([\n-    init/1, \n-    handle_call/3, \n-    handle_cast/2, \n-    handle_info/2,\n-    terminate/2, \n-    code_change/3\n-]).\n+-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,\n+         code_change/3]).\n \n %% State record as specified in the plan (lines 262-272)\n--record(state, {\n-    transport_id :: atom(),\n-    server_id :: atom() | undefined,\n-    config :: map(),\n-    socket :: gen_tcp:socket() | undefined,\n-    host :: inet:hostname(),\n-    port :: inet:port_number(),\n-    buffer = <<>> :: binary(),\n-    connected = false :: boolean(),\n-    reconnect_timer :: reference() | undefined,\n-    reconnect_attempts = 0 :: non_neg_integer(),\n-    max_reconnect_attempts = infinity :: pos_integer() | infinity,\n-    socket_opts :: [gen_tcp:connect_option()],\n-    stats :: map()\n-}).\n+-record(state,\n+        {transport_id :: atom(),\n+         server_id :: atom() | undefined,\n+         config :: map(),\n+         socket :: gen_tcp:socket() | undefined,\n+         host :: inet:hostname(),\n+         port :: inet:port_number(),\n+         buffer = <<>> :: binary(),\n+         connected = false :: boolean(),\n+         reconnect_timer :: reference() | undefined,\n+         reconnect_attempts = 0 :: non_neg_integer(),\n+         max_reconnect_attempts = infinity :: pos_integer() | infinity,\n+         socket_opts :: [gen_tcp:connect_option()],\n+         stats :: map()}).\n \n -type state() :: #state{}.\n--type tcp_config() :: #{\n-    host := inet:hostname() | inet:ip_address(),\n-    port := inet:port_number(),\n-    server_id => atom(),\n-    connect_timeout => timeout(),\n-    keepalive => boolean(),\n-    nodelay => boolean(),\n-    buffer_size => pos_integer(),\n-    max_reconnect_attempts => pos_integer() | infinity,\n-    test_mode => boolean()\n-}.\n+-type tcp_config() ::\n+    #{host := inet:hostname() | inet:ip_address(),\n+      port := inet:port_number(),\n+      server_id => atom(),\n+      connect_timeout => timeout(),\n+      keepalive => boolean(),\n+      nodelay => boolean(),\n+      buffer_size => pos_integer(),\n+      max_reconnect_attempts => pos_integer() | infinity,\n+      test_mode => boolean()}.\n \n %% Default configuration values\n -define(DEFAULT_CONNECT_TIMEOUT, 5000).\n -define(DEFAULT_BUFFER_SIZE, 65536).\n@@ -113,13 +99,23 @@\n get_info(#state{} = State) ->\n     do_get_info(State).\n \n %% @doc Handle transport-specific calls\n--spec handle_transport_call(term(), state()) -> {reply, term(), state()} | {error, term()}.\n+-spec handle_transport_call(term(), state()) ->\n+                               {reply, term(), state()} | {error, term()}.\n handle_transport_call(get_socket, #state{socket = Socket} = State) ->\n     {reply, {ok, Socket}, State};\n-handle_transport_call(get_connection, #state{host = Host, port = Port, connected = Conn} = State) ->\n-    {reply, {ok, #{host => Host, port => Port, connected => Conn}}, State};\n+handle_transport_call(get_connection,\n+                      #state{host = Host,\n+                             port = Port,\n+                             connected = Conn} =\n+                          State) ->\n+    {reply,\n+     {ok,\n+      #{host => Host,\n+        port => Port,\n+        connected => Conn}},\n+     State};\n handle_transport_call(get_stats, #state{stats = Stats} = State) ->\n     {reply, {ok, Stats}, State};\n handle_transport_call(reconnect, State) ->\n     NewState = cancel_reconnect_timer(State),\n@@ -138,15 +134,12 @@\n %% gen_server Callbacks\n %%====================================================================\n \n %% @doc Initialize the gen_server process\n--spec init(list()) -> \n-    {ok, state()} | \n-    {error, term()} | \n-    {stop, term()}.\n+-spec init(list()) -> {ok, state()} | {error, term()} | {stop, term()}.\n init([TransportId, Config]) ->\n     process_flag(trap_exit, true),\n-    \n+\n     case internal_init(TransportId, Config) of\n         {ok, State} ->\n             %% Schedule initial connection attempt\n             self() ! attempt_connection,\n@@ -157,10 +150,11 @@\n     end.\n \n %% @doc Handle synchronous calls\n -spec handle_call(term(), {pid(), term()}, state()) ->\n-    {reply, term(), state()} | {noreply, state()} | {stop, term(), term(), state()}.\n-\n+                     {reply, term(), state()} |\n+                     {noreply, state()} |\n+                     {stop, term(), term(), state()}.\n handle_call({send, Data}, _From, State) ->\n     case do_send(State, Data) of\n         ok ->\n             NewStats = update_stats(State#state.stats, messages_sent, 1),\n@@ -168,81 +162,68 @@\n         {error, Reason} ->\n             NewStats = update_stats(State#state.stats, errors, 1),\n             {reply, {error, Reason}, State#state{stats = NewStats}}\n     end;\n-\n handle_call(close, _From, State) ->\n     ok = do_close(State),\n-    NewState = State#state{\n-        socket = undefined,\n-        connected = false,\n-        buffer = <<>>\n-    },\n+    NewState =\n+        State#state{socket = undefined,\n+                    connected = false,\n+                    buffer = <<>>},\n     {reply, ok, NewState};\n-\n handle_call(get_info, _From, State) ->\n     Info = do_get_info(State),\n     {reply, Info, State};\n-\n handle_call({transport_call, Request}, _From, State) ->\n     case handle_transport_call(Request, State) of\n-        {reply, Reply, NewState} -> {reply, {reply, Reply, NewState}, NewState};\n-        {error, Reason} -> {reply, {error, Reason}, State}\n+        {reply, Reply, NewState} ->\n+            {reply, {reply, Reply, NewState}, NewState};\n+        {error, Reason} ->\n+            {reply, {error, Reason}, State}\n     end;\n-\n handle_call(reconnect, _From, State) ->\n     %% Force reconnection by canceling timer and scheduling immediate attempt\n     NewState = cancel_reconnect_timer(State),\n     self() ! attempt_connection,\n     {reply, ok, NewState#state{reconnect_attempts = 0}};\n-\n handle_call(get_state, _From, State) ->\n     %% For testing and debugging\n     {reply, {ok, State}, State};\n-\n handle_call(_Request, _From, State) ->\n     {reply, {error, unknown_request}, State}.\n \n %% @doc Handle asynchronous casts\n -spec handle_cast(term(), state()) -> {noreply, state()}.\n-\n handle_cast(_Msg, State) ->\n     {noreply, State}.\n \n %% @doc Handle process messages\n--spec handle_info(term(), state()) -> \n-    {noreply, state()} | {stop, term(), state()}.\n-\n+-spec handle_info(term(), state()) -> {noreply, state()} | {stop, term(), state()}.\n %% Connection attempt\n handle_info(attempt_connection, State) ->\n     NewState = attempt_connection(State),\n     {noreply, NewState};\n-\n %% Reconnection timer fired\n handle_info(reconnect, State) ->\n     NewState = State#state{reconnect_timer = undefined},\n     FinalState = attempt_connection(NewState),\n     {noreply, FinalState};\n-\n %% Incoming TCP data\n handle_info({tcp, Socket, Data}, #state{socket = Socket} = State) ->\n     NewState = handle_tcp_data(State, Data),\n     %% Set socket back to active mode\n     inet:setopts(Socket, [{active, once}]),\n     {noreply, NewState};\n-\n %% TCP connection closed\n handle_info({tcp_closed, Socket}, #state{socket = Socket} = State) ->\n     ?LOG_INFO(\"TCP connection closed for transport ~p\", [State#state.transport_id]),\n     NewState = handle_disconnect(State, tcp_closed),\n     {noreply, NewState};\n-\n %% TCP error\n handle_info({tcp_error, Socket, Reason}, #state{socket = Socket} = State) ->\n     ?LOG_ERROR(\"TCP error for transport ~p: ~p\", [State#state.transport_id, Reason]),\n     NewState = handle_disconnect(State, {tcp_error, Reason}),\n     {noreply, NewState};\n-\n %% Response from server to send back to client\n handle_info({mcp_response, ServerId, Message}, State) ->\n     case State#state.server_id of\n         ServerId ->\n@@ -250,37 +231,36 @@\n                 ok ->\n                     NewStats = update_stats(State#state.stats, messages_sent, 1),\n                     {noreply, State#state{stats = NewStats}};\n                 {error, SendReason} ->\n-                    ?LOG_WARNING(\"Failed to send response on transport ~p: ~p\", \n-                                [State#state.transport_id, SendReason]),\n+                    ?LOG_WARNING(\"Failed to send response on transport ~p: ~p\",\n+                                 [State#state.transport_id, SendReason]),\n                     NewStats = update_stats(State#state.stats, errors, 1),\n                     {noreply, State#state{stats = NewStats}}\n             end;\n         _ ->\n-            ?LOG_WARNING(\"Received response from unexpected server ~p on transport ~p\", \n-                        [ServerId, State#state.transport_id]),\n+            ?LOG_WARNING(\"Received response from unexpected server ~p on transport ~p\",\n+                         [ServerId, State#state.transport_id]),\n             {noreply, State}\n     end;\n-\n %% Unknown message\n handle_info(_Info, State) ->\n     {noreply, State}.\n \n %% @doc Clean shutdown\n -spec terminate(term(), state()) -> ok.\n terminate(Reason, State) ->\n     ?LOG_INFO(\"Terminating TCP transport ~p: ~p\", [State#state.transport_id, Reason]),\n-    \n+\n     %% Unregister from registry\n     erlmcp_transport_behavior:unregister_from_registry(State#state.transport_id),\n-    \n+\n     %% Cancel reconnect timer\n     cancel_reconnect_timer(State),\n-    \n+\n     %% Close socket\n     do_close(State),\n-    \n+\n     ok.\n \n %% @doc Handle code changes\n -spec code_change(term(), state(), term()) -> {ok, state()}.\n@@ -294,56 +274,56 @@\n %% @doc Internal initialization logic shared between behavior and gen_server\n -spec internal_init(atom(), tcp_config()) -> {ok, state()} | {error, term()}.\n internal_init(TransportId, Config) ->\n     ?LOG_INFO(\"Initializing TCP transport ~p\", [TransportId]),\n-    \n+\n     %% Validate required configuration\n     case validate_config(Config) of\n         ok ->\n             Host = maps:get(host, Config),\n             Port = maps:get(port, Config),\n             ServerId = maps:get(server_id, Config, undefined),\n-            MaxReconnectAttempts = maps:get(max_reconnect_attempts, Config, \n-                                          ?DEFAULT_MAX_RECONNECT_ATTEMPTS),\n-            \n+            MaxReconnectAttempts =\n+                maps:get(max_reconnect_attempts, Config, ?DEFAULT_MAX_RECONNECT_ATTEMPTS),\n+\n             %% Build socket options\n             SocketOpts = build_socket_options(Config),\n-            \n+\n             %% Initialize statistics\n-            Stats = #{\n-                messages_sent => 0,\n-                messages_received => 0,\n-                bytes_sent => 0,\n-                bytes_received => 0,\n-                errors => 0,\n-                connection_time => undefined,\n-                last_message_time => undefined,\n-                reconnect_count => 0\n-            },\n-            \n-            State = #state{\n-                transport_id = TransportId,\n-                server_id = ServerId,\n-                config = Config,\n-                socket = undefined,\n-                host = Host,\n-                port = Port,\n-                buffer = <<>>,\n-                connected = false,\n-                reconnect_timer = undefined,\n-                reconnect_attempts = 0,\n-                max_reconnect_attempts = MaxReconnectAttempts,\n-                socket_opts = SocketOpts,\n-                stats = Stats\n-            },\n-            \n+            Stats =\n+                #{messages_sent => 0,\n+                  messages_received => 0,\n+                  bytes_sent => 0,\n+                  bytes_received => 0,\n+                  errors => 0,\n+                  connection_time => undefined,\n+                  last_message_time => undefined,\n+                  reconnect_count => 0},\n+\n+            State =\n+                #state{transport_id = TransportId,\n+                       server_id = ServerId,\n+                       config = Config,\n+                       socket = undefined,\n+                       host = Host,\n+                       port = Port,\n+                       buffer = <<>>,\n+                       connected = false,\n+                       reconnect_timer = undefined,\n+                       reconnect_attempts = 0,\n+                       max_reconnect_attempts = MaxReconnectAttempts,\n+                       socket_opts = SocketOpts,\n+                       stats = Stats},\n+\n             %% Register with registry (always attempt; no-op if unavailable)\n             case register_with_registry(State) of\n                 ok ->\n-                    ?LOG_INFO(\"TCP transport ~p initialized and registry registration attempted\", [TransportId]),\n+                    ?LOG_INFO(\"TCP transport ~p initialized and registry registration attempted\",\n+                              [TransportId]),\n                     {ok, State};\n                 {error, Reason} ->\n-                    ?LOG_WARNING(\"TCP transport ~p could not register with registry: ~p\", [TransportId, Reason]),\n+                    ?LOG_WARNING(\"TCP transport ~p could not register with registry: ~p\",\n+                                 [TransportId, Reason]),\n                     {ok, State}\n             end;\n         {error, Reason} ->\n             {error, {invalid_config, Reason}}\n@@ -356,10 +336,11 @@\n     case check_required_fields(Config, RequiredFields) of\n         ok ->\n             %% Validate host and port types\n             case {maps:get(host, Config), maps:get(port, Config)} of\n-                {Host, Port} when (is_list(Host) orelse is_tuple(Host)), \n-                                  is_integer(Port), Port > 0, Port =< 65535 ->\n+                {Host, Port}\n+                    when is_list(Host) orelse is_tuple(Host), is_integer(Port), Port > 0,\n+                         Port =< 65535 ->\n                     ok;\n                 _ ->\n                     {error, invalid_host_or_port}\n             end;\n@@ -370,88 +351,89 @@\n %% @doc Check required fields are present\n -spec check_required_fields(map(), [atom()]) -> ok | {error, term()}.\n check_required_fields(Config, RequiredFields) ->\n     case [Field || Field <- RequiredFields, not maps:is_key(Field, Config)] of\n-        [] -> ok;\n-        MissingFields -> {error, {missing_required_fields, MissingFields}}\n+        [] ->\n+            ok;\n+        MissingFields ->\n+            {error, {missing_required_fields, MissingFields}}\n     end.\n \n %% @doc Register transport with the registry\n -spec register_with_registry(state()) -> ok | {error, term()}.\n register_with_registry(#state{transport_id = TransportId, config = Config}) ->\n-    TransportConfig = Config#{\n-        type => tcp,\n-        pid => self(),\n-        started_at => erlang:system_time(millisecond)\n-    },\n+    TransportConfig =\n+        Config#{type => tcp,\n+                pid => self(),\n+                started_at => erlang:system_time(millisecond)},\n     erlmcp_transport_behavior:register_with_registry(TransportId, self(), TransportConfig).\n \n %% @doc Build socket connection options\n -spec build_socket_options(tcp_config()) -> [gen_tcp:connect_option()].\n build_socket_options(Config) ->\n-    BaseOpts = [\n-        binary,\n-        {active, once},  % We'll control flow with inet:setopts\n-        {packet, 0},     % Raw TCP, we'll handle framing\n-        {reuseaddr, true},\n-        {send_timeout, 5000},\n-        {send_timeout_close, true}\n-    ],\n-    \n+    BaseOpts =\n+        [binary,\n+         {active, once},  % We'll control flow with inet:setopts\n+         {packet, 0},     % Raw TCP, we'll handle framing\n+         {reuseaddr, true},\n+         {send_timeout, 5000},\n+         {send_timeout_close, true}],\n+\n     %% Add optional settings\n-    OptionalOpts = lists:foldl(fun({ConfigKey, SocketOpt}, Acc) ->\n-        case maps:get(ConfigKey, Config, undefined) of\n-            undefined -> Acc;\n-            Value -> [{SocketOpt, Value} | Acc]\n-        end\n-    end, BaseOpts, [\n-        {keepalive, keepalive},\n-        {nodelay, nodelay}\n-    ]),\n-    \n+    OptionalOpts =\n+        lists:foldl(fun({ConfigKey, SocketOpt}, Acc) ->\n+                       case maps:get(ConfigKey, Config, undefined) of\n+                           undefined -> Acc;\n+                           Value -> [{SocketOpt, Value} | Acc]\n+                       end\n+                    end,\n+                    BaseOpts,\n+                    [{keepalive, keepalive}, {nodelay, nodelay}]),\n+\n     %% Set buffer sizes\n     BufferSize = maps:get(buffer_size, Config, ?DEFAULT_BUFFER_SIZE),\n     [{recbuf, BufferSize}, {sndbuf, BufferSize} | OptionalOpts].\n \n %% @doc Attempt to establish TCP connection\n -spec attempt_connection(state()) -> state().\n attempt_connection(#state{reconnect_attempts = Attempts,\n-                         max_reconnect_attempts = MaxAttempts,\n-                         transport_id = TransportId} = State)\n-  when is_integer(MaxAttempts), Attempts >= MaxAttempts ->\n-    ?LOG_ERROR(\"Maximum reconnection attempts (~p) reached for transport ~p\", \n-              [MaxAttempts, TransportId]),\n+                          max_reconnect_attempts = MaxAttempts,\n+                          transport_id = TransportId} =\n+                       State)\n+    when is_integer(MaxAttempts), Attempts >= MaxAttempts ->\n+    ?LOG_ERROR(\"Maximum reconnection attempts (~p) reached for transport ~p\",\n+               [MaxAttempts, TransportId]),\n     State;\n+attempt_connection(#state{host = Host,\n+                          port = Port,\n+                          socket_opts = SocketOpts,\n+                          transport_id = TransportId,\n+                          config = Config} =\n+                       State) ->\n+    ConnectTimeout = maps:get(connect_timeout, Config, ?DEFAULT_CONNECT_TIMEOUT),\n \n-attempt_connection(#state{host = Host, port = Port, socket_opts = SocketOpts,\n-                         transport_id = TransportId, config = Config} = State) ->\n-    ConnectTimeout = maps:get(connect_timeout, Config, ?DEFAULT_CONNECT_TIMEOUT),\n-    \n-    ?LOG_INFO(\"Attempting TCP connection to ~s:~p for transport ~p (attempt ~p)\", \n+    ?LOG_INFO(\"Attempting TCP connection to ~s:~p for transport ~p (attempt \"\n+              \"~p)\",\n               [Host, Port, TransportId, State#state.reconnect_attempts + 1]),\n-    \n+\n     case gen_tcp:connect(Host, Port, SocketOpts, ConnectTimeout) of\n         {ok, Socket} ->\n             ?LOG_INFO(\"TCP connection established for transport ~p\", [TransportId]),\n-            \n+\n             %% Update connection statistics\n             CurrentTime = erlang:system_time(millisecond),\n-            NewStats = (State#state.stats)#{\n-                connection_time => CurrentTime,\n-                reconnect_count => State#state.reconnect_attempts\n-            },\n-            \n-            State#state{\n-                socket = Socket,\n-                connected = true,\n-                reconnect_attempts = 0,\n-                buffer = <<>>,\n-                reconnect_timer = undefined,\n-                stats = NewStats\n-            };\n+            NewStats =\n+                (State#state.stats)#{connection_time => CurrentTime,\n+                                     reconnect_count => State#state.reconnect_attempts},\n+\n+            State#state{socket = Socket,\n+                        connected = true,\n+                        reconnect_attempts = 0,\n+                        buffer = <<>>,\n+                        reconnect_timer = undefined,\n+                        stats = NewStats};\n         {error, Reason} ->\n-            ?LOG_WARNING(\"TCP connection failed for transport ~p: ~p\", \n-                        [TransportId, Reason]),\n+            ?LOG_WARNING(\"TCP connection failed for transport ~p: ~p\", [TransportId, Reason]),\n             schedule_reconnect(State, Reason)\n     end.\n \n %% @doc Handle TCP connection disconnect\n@@ -460,47 +442,46 @@\n     State;\n handle_disconnect(#state{socket = Socket} = State, Reason) ->\n     %% Close the socket\n     case Socket of\n-        undefined -> ok;\n-        _ -> catch gen_tcp:close(Socket)\n+        undefined ->\n+            ok;\n+        _ ->\n+            catch gen_tcp:close(Socket)\n     end,\n-    \n+\n     %% Update state and schedule reconnect\n-    DisconnectedState = State#state{\n-        socket = undefined,\n-        connected = false,\n-        buffer = <<>>\n-    },\n-    \n+    DisconnectedState =\n+        State#state{socket = undefined,\n+                    connected = false,\n+                    buffer = <<>>},\n+\n     schedule_reconnect(DisconnectedState, Reason).\n \n %% @doc Schedule reconnection attempt with exponential backoff\n -spec schedule_reconnect(state(), term()) -> state().\n-schedule_reconnect(#state{reconnect_timer = Timer} = State, _Reason) when Timer =/= undefined ->\n+schedule_reconnect(#state{reconnect_timer = Timer} = State, _Reason)\n+    when Timer =/= undefined ->\n     %% Already have a reconnect timer scheduled\n     State;\n-schedule_reconnect(#state{reconnect_attempts = Attempts, \n-                         transport_id = TransportId} = State, _Reason) ->\n+schedule_reconnect(#state{reconnect_attempts = Attempts, transport_id = TransportId} =\n+                       State,\n+                   _Reason) ->\n     %% Calculate backoff delay\n     Delay = calculate_backoff(Attempts),\n     NewAttempts = Attempts + 1,\n-    \n+\n     ?LOG_INFO(\"Scheduling reconnection in ~p ms (attempt ~p) for transport ~p\",\n               [Delay, NewAttempts, TransportId]),\n-    \n+\n     Timer = erlang:send_after(Delay, self(), reconnect),\n-    \n-    State#state{\n-        reconnect_timer = Timer,\n-        reconnect_attempts = NewAttempts\n-    }.\n \n+    State#state{reconnect_timer = Timer, reconnect_attempts = NewAttempts}.\n+\n %% @doc Calculate exponential backoff with jitter\n -spec calculate_backoff(non_neg_integer()) -> pos_integer().\n calculate_backoff(Attempts) ->\n-    BaseDelay = min(?INITIAL_RECONNECT_DELAY * (1 bsl Attempts),\n-                    ?MAX_RECONNECT_DELAY),\n+    BaseDelay = min(?INITIAL_RECONNECT_DELAY * (1 bsl Attempts), ?MAX_RECONNECT_DELAY),\n     Jitter = rand:uniform(BaseDelay div 4),\n     BaseDelay + Jitter.\n \n %% @doc Cancel active reconnect timer\n@@ -508,56 +489,66 @@\n cancel_reconnect_timer(#state{reconnect_timer = undefined} = State) ->\n     State;\n cancel_reconnect_timer(#state{reconnect_timer = Timer} = State) ->\n     case erlang:cancel_timer(Timer) of\n-        false -> \n+        false ->\n             %% Timer already fired, drain the message\n-            receive reconnect -> ok after 0 -> ok end;\n-        _ -> ok\n+            receive\n+                reconnect ->\n+                    ok\n+            after 0 ->\n+                ok\n+            end;\n+        _ ->\n+            ok\n     end,\n     State#state{reconnect_timer = undefined}.\n \n %% @doc Handle incoming TCP data\n -spec handle_tcp_data(state(), binary()) -> state().\n-handle_tcp_data(#state{buffer = Buffer, transport_id = TransportId, \n-                      server_id = ServerId, stats = Stats} = State, Data) ->\n+handle_tcp_data(#state{buffer = Buffer,\n+                       transport_id = TransportId,\n+                       server_id = ServerId,\n+                       stats = Stats} =\n+                    State,\n+                Data) ->\n     %% Update receive statistics\n     DataSize = byte_size(Data),\n-    NewStats = Stats#{\n-        bytes_received => maps:get(bytes_received, Stats, 0) + DataSize,\n-        last_message_time => erlang:system_time(millisecond)\n-    },\n-    \n+    NewStats =\n+        Stats#{bytes_received => maps:get(bytes_received, Stats, 0) + DataSize,\n+               last_message_time => erlang:system_time(millisecond)},\n+\n     %% Accumulate data in buffer\n     NewBuffer = <<Buffer/binary, Data/binary>>,\n-    \n+\n     %% Extract complete messages (line-based framing)\n-    {Messages, RemainingBuffer} = erlmcp_transport_behavior:extract_message_lines(<<>>, NewBuffer),\n-    \n+    {Messages, RemainingBuffer} =\n+        erlmcp_transport_behavior:extract_message_lines(<<>>, NewBuffer),\n+\n     %% Route complete messages to server via registry\n-    FinalStats = lists:foldl(fun(Message, StatsAcc) ->\n-        TrimmedMessage = erlmcp_transport_behavior:trim_message_line(Message),\n-        case byte_size(TrimmedMessage) of\n-            0 -> StatsAcc;  % Skip empty messages\n-            _ ->\n-                case ServerId of\n-                    undefined ->\n-                        ?LOG_WARNING(\"Cannot route message from transport ~p: no server bound\", \n-                                   [TransportId]);\n-                    _ ->\n-                        erlmcp_transport_behavior:handle_transport_message(TransportId, TrimmedMessage)\n-                end,\n-                StatsAcc#{\n-                    messages_received => maps:get(messages_received, StatsAcc, 0) + 1\n-                }\n-        end\n-    end, NewStats, Messages),\n-    \n-    State#state{\n-        buffer = RemainingBuffer,\n-        stats = FinalStats\n-    }.\n+    FinalStats =\n+        lists:foldl(fun(Message, StatsAcc) ->\n+                       TrimmedMessage = erlmcp_transport_behavior:trim_message_line(Message),\n+                       case byte_size(TrimmedMessage) of\n+                           0 -> StatsAcc;  % Skip empty messages\n+                           _ ->\n+                               case ServerId of\n+                                   undefined ->\n+                                       ?LOG_WARNING(\"Cannot route message from transport ~p: no server bound\",\n+                                                    [TransportId]);\n+                                   _ ->\n+                                       erlmcp_transport_behavior:handle_transport_message(TransportId,\n+                                                                                          TrimmedMessage)\n+                               end,\n+                               StatsAcc#{messages_received =>\n+                                             maps:get(messages_received, StatsAcc, 0) + 1}\n+                       end\n+                    end,\n+                    NewStats,\n+                    Messages),\n \n+    State#state{buffer = RemainingBuffer, stats = FinalStats}.\n+\n %% @doc Send data through the transport\n -spec do_send(state(), iodata()) -> ok | {error, term()}.\n do_send(#state{config = #{test_mode := true}}, _Data) ->\n     %% In test mode, just simulate successful send\n@@ -588,38 +579,42 @@\n     ok.\n \n %% @doc Get transport information\n -spec do_get_info(state()) -> map().\n-do_get_info(#state{transport_id = TransportId, config = Config, \n-                  host = Host, port = Port, connected = Connected,\n-                  reconnect_attempts = Attempts, stats = Stats}) ->\n+do_get_info(#state{transport_id = TransportId,\n+                   config = Config,\n+                   host = Host,\n+                   port = Port,\n+                   connected = Connected,\n+                   reconnect_attempts = Attempts,\n+                   stats = Stats}) ->\n     TestMode = maps:get(test_mode, Config, false),\n-    #{\n-        transport_id => TransportId,\n-        type => tcp,\n-        test_mode => TestMode,\n-        status => case TestMode of\n-            true -> running;  % In test mode, always report running\n-            false -> case Connected of\n-                true -> connected;\n-                false when Attempts > 0 -> connecting;\n-                false -> disconnected\n-            end\n-        end,\n-        config => maps:without([password, secret, token], Config),\n-        connection => #{\n-            host => Host,\n+    #{transport_id => TransportId,\n+      type => tcp,\n+      test_mode => TestMode,\n+      status =>\n+          case TestMode of\n+              true ->\n+                  running;  % In test mode, always report running\n+              false ->\n\\ No newline at end of file\n+                  case Connected of\n+                      true ->\n+                          connected;\n+                      false when Attempts > 0 ->\n+                          connecting;\n+                      false ->\n+                          disconnected\n+                  end\n+          end,\n+      config => maps:without([password, secret, token], Config),\n+      connection =>\n+          #{host => Host,\n             port => Port,\n             connected => Connected,\n-            reconnect_attempts => Attempts\n-        },\n-        statistics => Stats\n-    }.\n+            reconnect_attempts => Attempts},\n+      statistics => Stats}.\n \n %% @doc Update transport statistics\n -spec update_stats(map(), atom(), non_neg_integer()) -> map().\n update_stats(Stats, Key, Increment) ->\n     CurrentValue = maps:get(Key, Stats, 0),\n-    Stats#{\n-        Key => CurrentValue + Increment,\n-        last_updated => erlang:system_time(millisecond)\n-    }.\n+    Stats#{Key => CurrentValue + Increment, last_updated => erlang:system_time(millisecond)}.\n"
                },
                {
                    "date": 1756190131043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -616,5 +616,5 @@\n %% @doc Update transport statistics\n -spec update_stats(map(), atom(), non_neg_integer()) -> map().\n update_stats(Stats, Key, Increment) ->\n     CurrentValue = maps:get(Key, Stats, 0),\n-    Stats#{Key => CurrentValue + Increment, last_updated => erlang:system_time(millisecond)}.\n\\ No newline at end of file\n+    Stats#{Key => CurrentValue + Increment, last_updated => erlang:system_time(millisecond)}.\n"
                },
                {
                    "date": 1756190592773,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,18 +17,19 @@\n %%%-------------------------------------------------------------------\n -module(erlmcp_transport_tcp).\n \n -behaviour(gen_server).\n+-behaviour(erlmcp_transport_behavior).\n \n -include(\"erlmcp.hrl\").\n \n -include_lib(\"kernel/include/logger.hrl\").\n \n %% API exports\n -export([start_link/2, send/2, close/1, get_info/1, handle_transport_call/2]).\n \n-%% Transport behavior callbacks (implemented as required)\n-%% Note: These are the same functions exported in the API section\n+%% Transport behavior callbacks (implementing erlmcp_transport_behavior)  \n+%% Note: init/1 callback conflicts with gen_server, so we provide transport_init/1 instead\n \n %% gen_server callbacks\n -export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,\n          code_change/3]).\n@@ -123,18 +124,20 @@\n     {reply, ok, NewState#state{reconnect_attempts = 0}};\n handle_transport_call(_Unknown, State) ->\n     {error, unknown_request}.\n \n+\n %%====================================================================\n-%% Transport Behavior Callbacks\n+%% gen_server Callbacks\n %%====================================================================\n \n-%% Note: Transport behavior callbacks are implemented as part of the API functions\n-\n %%====================================================================\n-%% gen_server Callbacks\n+%% Transport Behavior Callbacks\n %%====================================================================\n \n+%% Note: The transport behavior init/1 callback is handled via internal_init/2 \n+%% to avoid conflicts with gen_server:init/1 callback\n+\n %% @doc Initialize the gen_server process\n -spec init(list()) -> {ok, state()} | {error, term()} | {stop, term()}.\n init([TransportId, Config]) ->\n     process_flag(trap_exit, true),\n@@ -328,11 +331,23 @@\n         {error, Reason} ->\n             {error, {invalid_config, Reason}}\n     end.\n \n-%% @doc Validate transport configuration\n+%% @doc Validate transport configuration using comprehensive schema\n -spec validate_config(tcp_config()) -> ok | {error, term()}.\n validate_config(Config) ->\n+    case erlmcp_config_validation:validate_transport_config(tcp, tcp, Config) of\n+        ok -> \n+            ok;\n+        {error, ValidationErrors} ->\n+            % Convert validation errors to legacy format for compatibility\n+            FirstError = hd(ValidationErrors),\n+            ErrorMessage = maps:get(message, FirstError, <<\"Configuration validation failed\">>),\n+            {error, {validation_failed, ErrorMessage, ValidationErrors}}\n+    end.\n+\n+%% @private Legacy validation (kept for reference)\n+validate_config_legacy(Config) ->\n     RequiredFields = [host, port],\n     case check_required_fields(Config, RequiredFields) of\n         ok ->\n             %% Validate host and port types\n@@ -502,16 +517,40 @@\n             ok\n     end,\n     State#state{reconnect_timer = undefined}.\n \n-%% @doc Handle incoming TCP data\n+%% @doc Handle incoming TCP data with enhanced buffer management\n -spec handle_tcp_data(state(), binary()) -> state().\n handle_tcp_data(#state{buffer = Buffer,\n                        transport_id = TransportId,\n                        server_id = ServerId,\n-                       stats = Stats} =\n+                       stats = Stats,\n+                       config = Config} =\n                     State,\n                 Data) ->\n+    %% Check buffer size limits to prevent memory exhaustion\n+    BufferLimit = maps:get(buffer_size, Config, ?DEFAULT_BUFFER_SIZE),\n+    NewBufferSize = byte_size(Buffer) + byte_size(Data),\n+    \n+    case NewBufferSize > BufferLimit of\n+        true ->\n+            ?LOG_WARNING(\"Buffer overflow on transport ~p: ~p bytes, dropping oldest data\", \n+                         [TransportId, NewBufferSize]),\n+            %% Keep only the newest data to prevent memory issues\n+            TruncatedBuffer = binary:part(Buffer, max(0, byte_size(Buffer) - BufferLimit div 2), \n+                                          min(byte_size(Buffer), BufferLimit div 2)),\n+            handle_tcp_data_internal(State#state{buffer = TruncatedBuffer}, Data);\n+        false ->\n+            handle_tcp_data_internal(State, Data)\n+    end.\n+\n+%% @private Internal TCP data handling\n+-spec handle_tcp_data_internal(state(), binary()) -> state().\n+handle_tcp_data_internal(#state{buffer = Buffer,\n+                                transport_id = TransportId,\n+                                server_id = ServerId,\n+                                stats = Stats} = State,\n+                         Data) ->\n     %% Update receive statistics\n     DataSize = byte_size(Data),\n     NewStats =\n         Stats#{bytes_received => maps:get(bytes_received, Stats, 0) + DataSize,\n@@ -535,10 +574,15 @@\n                                    undefined ->\n                                        ?LOG_WARNING(\"Cannot route message from transport ~p: no server bound\",\n                                                     [TransportId]);\n                                    _ ->\n-                                       erlmcp_transport_behavior:handle_transport_message(TransportId,\n-                                                                                          TrimmedMessage)\n+                                       case erlmcp_transport_behavior:handle_transport_message(TransportId,\n+                                                                                          TrimmedMessage) of\n+                                           ok -> ok;\n+                                           {error, Reason} ->\n+                                               ?LOG_ERROR(\"Failed to route message from transport ~p: ~p\",\n+                                                          [TransportId, Reason])\n+                                       end\n                                end,\n                                StatsAcc#{messages_received =>\n                                              maps:get(messages_received, StatsAcc, 0) + 1}\n                        end\n@@ -547,28 +591,56 @@\n                     Messages),\n \n     State#state{buffer = RemainingBuffer, stats = FinalStats}.\n \n-%% @doc Send data through the transport\n+%% @doc Send data through the transport with enhanced error handling\n -spec do_send(state(), iodata()) -> ok | {error, term()}.\n do_send(#state{config = #{test_mode := true}}, _Data) ->\n     %% In test mode, just simulate successful send\n     ok;\n do_send(#state{connected = false}, _Data) ->\n     {error, not_connected};\n do_send(#state{socket = undefined}, _Data) ->\n     {error, not_connected};\n-do_send(#state{socket = Socket, stats = _Stats}, Data) ->\n+do_send(#state{socket = Socket, \n+               transport_id = TransportId,\n+               stats = Stats} = State, Data) ->\n     %% Frame message with newline for line-based protocol\n     FramedData = [Data, \"\\n\"],\n+    DataSize = iolist_size(FramedData),\n+    \n     case gen_tcp:send(Socket, FramedData) of\n         ok ->\n+            %% Update send statistics\n+            UpdatedStats = Stats#{\n+                bytes_sent => maps:get(bytes_sent, Stats, 0) + DataSize,\n+                last_message_time => erlang:system_time(millisecond)\n+            },\n+            %% Update state (note: this returns ok, state update handled by caller)\n             ok;\n-        {error, Reason} ->\n-            %% Connection might be broken, let the error handling deal with it\n-            {error, {tcp_send_failed, Reason}}\n+        {error, Reason} = Error ->\n+            ?LOG_ERROR(\"TCP send failed on transport ~p: ~p\", [TransportId, Reason]),\n+            %% Check if this indicates a connection problem\n+            case is_connection_error(Reason) of\n+                true ->\n+                    %% Trigger reconnection\n+                    self() ! {tcp_error, Socket, Reason},\n+                    Error;\n+                false ->\n+                    %% Just a send error, don't trigger reconnection\n+                    {error, {tcp_send_failed, Reason}}\n+            end\n     end.\n \n+%% @private Check if error indicates connection problem\n+-spec is_connection_error(term()) -> boolean().\n+is_connection_error(closed) -> true;\n+is_connection_error(econnreset) -> true;\n+is_connection_error(econnaborted) -> true;\n+is_connection_error(enotconn) -> true;\n+is_connection_error(epipe) -> true;\n+is_connection_error(_) -> false.\n+\n %% @doc Close the transport\n -spec do_close(state()) -> ok.\n do_close(#state{socket = undefined}) ->\n     ok;\n@@ -577,42 +649,59 @@\n     ok;\n do_close(_State) ->\n     ok.\n \n-%% @doc Get transport information\n+%% @doc Get transport information with enhanced metrics\n -spec do_get_info(state()) -> map().\n do_get_info(#state{transport_id = TransportId,\n                    config = Config,\n                    host = Host,\n                    port = Port,\n                    connected = Connected,\n                    reconnect_attempts = Attempts,\n+                   reconnect_timer = Timer,\n                    stats = Stats}) ->\n     TestMode = maps:get(test_mode, Config, false),\n+    CurrentTime = erlang:system_time(millisecond),\n+    \n+    Status = case TestMode of\n+        true ->\n+            running;  % In test mode, always report running\n+        false ->\n+            case Connected of\n+                true ->\n+                    connected;\n+                false when Timer =/= undefined ->\n+                    reconnecting;\n+                false when Attempts > 0 ->\n+                    connecting;\n+                false ->\n+                    disconnected\n+            end\n+    end,\n+    \n+    ConnectionInfo = #{\n+        host => Host,\n+        port => Port,\n+        connected => Connected,\n+        reconnect_attempts => Attempts,\n+        reconnecting => Timer =/= undefined,\n+        uptime => case maps:get(connection_time, Stats, undefined) of\n+            undefined -> 0;\n+            ConnTime -> max(0, CurrentTime - ConnTime)\n+        end\n+    },\n+    \n     #{transport_id => TransportId,\n       type => tcp,\n       test_mode => TestMode,\n-      status =>\n-          case TestMode of\n-              true ->\n-                  running;  % In test mode, always report running\n-              false ->\n-                  case Connected of\n-                      true ->\n-                          connected;\n-                      false when Attempts > 0 ->\n-                          connecting;\n-                      false ->\n-                          disconnected\n-                  end\n-          end,\n+      status => Status,\n       config => maps:without([password, secret, token], Config),\n-      connection =>\n-          #{host => Host,\n-            port => Port,\n-            connected => Connected,\n-            reconnect_attempts => Attempts},\n-      statistics => Stats}.\n+      connection => ConnectionInfo,\n+      statistics => Stats#{\n+          current_buffer_size => 0,  % Could be enhanced to track actual buffer size\n+          total_reconnects => maps:get(reconnect_count, Stats, 0)\n+      }}.\n \n %% @doc Update transport statistics\n -spec update_stats(map(), atom(), non_neg_integer()) -> map().\n update_stats(Stats, Key, Increment) ->\n"
                }
            ],
            "date": 1756189861169,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @doc\n%%% TCP Transport Implementation for Erlang MCP\n%%%\n%%% This module implements a robust TCP transport that follows the standard\n%%% gen_server pattern and the erlmcp_transport_behavior specification.\n%%% \n%%% Key features:\n%%% - Automatic registry integration\n%%% - Connection management with reconnection logic\n%%% - Comprehensive error handling and recovery\n%%% - Buffer management for message framing\n%%% - Supervisor integration ready\n%%% - Production-quality connection lifecycle management\n%%%\n%%% @end\n%%%-------------------------------------------------------------------\n-module(erlmcp_transport_tcp).\n\n-behaviour(gen_server).\n-behaviour(erlmcp_transport_behavior).\n\n-include(\"erlmcp.hrl\").\n-include_lib(\"kernel/include/logger.hrl\").\n\n%% API exports\n-export([\n    start_link/2,\n    send/2,\n    close/1,\n    get_info/1,\n    handle_transport_call/2\n]).\n\n%% Transport behavior callbacks (implemented as required)\n%% Note: These are the same functions exported in the API section\n\n%% gen_server callbacks\n-export([\n    init/1, \n    handle_call/3, \n    handle_cast/2, \n    handle_info/2,\n    terminate/2, \n    code_change/3\n]).\n\n%% State record as specified in the plan (lines 262-272)\n-record(state, {\n    transport_id :: atom(),\n    server_id :: atom() | undefined,\n    config :: map(),\n    socket :: gen_tcp:socket() | undefined,\n    host :: inet:hostname(),\n    port :: inet:port_number(),\n    buffer = <<>> :: binary(),\n    connected = false :: boolean(),\n    reconnect_timer :: reference() | undefined,\n    reconnect_attempts = 0 :: non_neg_integer(),\n    max_reconnect_attempts = infinity :: pos_integer() | infinity,\n    socket_opts :: [gen_tcp:connect_option()],\n    stats :: map()\n}).\n\n-type state() :: #state{}.\n-type tcp_config() :: #{\n    host := inet:hostname() | inet:ip_address(),\n    port := inet:port_number(),\n    server_id => atom(),\n    connect_timeout => timeout(),\n    keepalive => boolean(),\n    nodelay => boolean(),\n    buffer_size => pos_integer(),\n    max_reconnect_attempts => pos_integer() | infinity,\n    test_mode => boolean()\n}.\n\n%% Default configuration values\n-define(DEFAULT_CONNECT_TIMEOUT, 5000).\n-define(DEFAULT_BUFFER_SIZE, 65536).\n-define(DEFAULT_MAX_RECONNECT_ATTEMPTS, infinity).\n-define(INITIAL_RECONNECT_DELAY, 1000).\n-define(MAX_RECONNECT_DELAY, 60000).\n\n%%====================================================================\n%% API Functions\n%%====================================================================\n\n%% @doc Start the TCP transport process\n-spec start_link(atom(), tcp_config()) -> {ok, pid()} | {error, term()}.\nstart_link(TransportId, Config) ->\n    ?LOG_INFO(\"Starting TCP transport: ~p\", [TransportId]),\n    gen_server:start_link(?MODULE, [TransportId, Config], []).\n\n%% @doc Send data through the transport\n-spec send(pid() | state(), iodata()) -> ok | {error, term()}.\nsend(Pid, Data) when is_pid(Pid) ->\n    gen_server:call(Pid, {send, Data});\nsend(#state{} = State, Data) ->\n    do_send(State, Data).\n\n%% @doc Close the transport connection\n-spec close(pid() | state()) -> ok.\nclose(Pid) when is_pid(Pid) ->\n    gen_server:call(Pid, close);\nclose(#state{} = State) ->\n    do_close(State).\n\n%% @doc Get transport information\n-spec get_info(pid() | state()) -> map().\nget_info(Pid) when is_pid(Pid) ->\n    gen_server:call(Pid, get_info);\nget_info(#state{} = State) ->\n    do_get_info(State).\n\n%% @doc Handle transport-specific calls\n-spec handle_transport_call(term(), state()) -> {reply, term(), state()} | {error, term()}.\nhandle_transport_call(get_socket, #state{socket = Socket} = State) ->\n    {reply, {ok, Socket}, State};\nhandle_transport_call(get_connection, #state{host = Host, port = Port, connected = Conn} = State) ->\n    {reply, {ok, #{host => Host, port => Port, connected => Conn}}, State};\nhandle_transport_call(get_stats, #state{stats = Stats} = State) ->\n    {reply, {ok, Stats}, State};\nhandle_transport_call(reconnect, State) ->\n    NewState = cancel_reconnect_timer(State),\n    self() ! attempt_connection,\n    {reply, ok, NewState#state{reconnect_attempts = 0}};\nhandle_transport_call(_Unknown, State) ->\n    {error, unknown_request}.\n\n%%====================================================================\n%% Transport Behavior Callbacks\n%%====================================================================\n\n%% Note: Transport behavior callbacks are implemented as part of the API functions\n\n%%====================================================================\n%% gen_server Callbacks\n%%====================================================================\n\n%% @doc Initialize the gen_server process\n-spec init(list()) -> \n    {ok, state()} | \n    {error, term()} | \n    {stop, term()}.\ninit([TransportId, Config]) ->\n    process_flag(trap_exit, true),\n    \n    case internal_init(TransportId, Config) of\n        {ok, State} ->\n            %% Schedule initial connection attempt\n            self() ! attempt_connection,\n            {ok, State};\n        {error, Reason} ->\n            ?LOG_ERROR(\"Failed to initialize TCP transport ~p: ~p\", [TransportId, Reason]),\n            {stop, Reason}\n    end.\n\n%% @doc Handle synchronous calls\n-spec handle_call(term(), {pid(), term()}, state()) ->\n    {reply, term(), state()} | {noreply, state()} | {stop, term(), term(), state()}.\n\nhandle_call({send, Data}, _From, State) ->\n    case do_send(State, Data) of\n        ok ->\n            NewStats = update_stats(State#state.stats, messages_sent, 1),\n            {reply, ok, State#state{stats = NewStats}};\n        {error, Reason} ->\n            NewStats = update_stats(State#state.stats, errors, 1),\n            {reply, {error, Reason}, State#state{stats = NewStats}}\n    end;\n\nhandle_call(close, _From, State) ->\n    ok = do_close(State),\n    NewState = State#state{\n        socket = undefined,\n        connected = false,\n        buffer = <<>>\n    },\n    {reply, ok, NewState};\n\nhandle_call(get_info, _From, State) ->\n    Info = do_get_info(State),\n    {reply, Info, State};\n\nhandle_call({transport_call, Request}, _From, State) ->\n    case handle_transport_call(Request, State) of\n        {reply, Reply, NewState} -> {reply, {reply, Reply, NewState}, NewState};\n        {error, Reason} -> {reply, {error, Reason}, State}\n    end;\n\nhandle_call(reconnect, _From, State) ->\n    %% Force reconnection by canceling timer and scheduling immediate attempt\n    NewState = cancel_reconnect_timer(State),\n    self() ! attempt_connection,\n    {reply, ok, NewState#state{reconnect_attempts = 0}};\n\nhandle_call(get_state, _From, State) ->\n    %% For testing and debugging\n    {reply, {ok, State}, State};\n\nhandle_call(_Request, _From, State) ->\n    {reply, {error, unknown_request}, State}.\n\n%% @doc Handle asynchronous casts\n-spec handle_cast(term(), state()) -> {noreply, state()}.\n\nhandle_cast(_Msg, State) ->\n    {noreply, State}.\n\n%% @doc Handle process messages\n-spec handle_info(term(), state()) -> \n    {noreply, state()} | {stop, term(), state()}.\n\n%% Connection attempt\nhandle_info(attempt_connection, State) ->\n    NewState = attempt_connection(State),\n    {noreply, NewState};\n\n%% Reconnection timer fired\nhandle_info(reconnect, State) ->\n    NewState = State#state{reconnect_timer = undefined},\n    FinalState = attempt_connection(NewState),\n    {noreply, FinalState};\n\n%% Incoming TCP data\nhandle_info({tcp, Socket, Data}, #state{socket = Socket} = State) ->\n    NewState = handle_tcp_data(State, Data),\n    %% Set socket back to active mode\n    inet:setopts(Socket, [{active, once}]),\n    {noreply, NewState};\n\n%% TCP connection closed\nhandle_info({tcp_closed, Socket}, #state{socket = Socket} = State) ->\n    ?LOG_INFO(\"TCP connection closed for transport ~p\", [State#state.transport_id]),\n    NewState = handle_disconnect(State, tcp_closed),\n    {noreply, NewState};\n\n%% TCP error\nhandle_info({tcp_error, Socket, Reason}, #state{socket = Socket} = State) ->\n    ?LOG_ERROR(\"TCP error for transport ~p: ~p\", [State#state.transport_id, Reason]),\n    NewState = handle_disconnect(State, {tcp_error, Reason}),\n    {noreply, NewState};\n\n%% Response from server to send back to client\nhandle_info({mcp_response, ServerId, Message}, State) ->\n    case State#state.server_id of\n        ServerId ->\n            case do_send(State, Message) of\n                ok ->\n                    NewStats = update_stats(State#state.stats, messages_sent, 1),\n                    {noreply, State#state{stats = NewStats}};\n                {error, SendReason} ->\n                    ?LOG_WARNING(\"Failed to send response on transport ~p: ~p\", \n                                [State#state.transport_id, SendReason]),\n                    NewStats = update_stats(State#state.stats, errors, 1),\n                    {noreply, State#state{stats = NewStats}}\n            end;\n        _ ->\n            ?LOG_WARNING(\"Received response from unexpected server ~p on transport ~p\", \n                        [ServerId, State#state.transport_id]),\n            {noreply, State}\n    end;\n\n%% Unknown message\nhandle_info(_Info, State) ->\n    {noreply, State}.\n\n%% @doc Clean shutdown\n-spec terminate(term(), state()) -> ok.\nterminate(Reason, State) ->\n    ?LOG_INFO(\"Terminating TCP transport ~p: ~p\", [State#state.transport_id, Reason]),\n    \n    %% Unregister from registry\n    erlmcp_transport_behavior:unregister_from_registry(State#state.transport_id),\n    \n    %% Cancel reconnect timer\n    cancel_reconnect_timer(State),\n    \n    %% Close socket\n    do_close(State),\n    \n    ok.\n\n%% @doc Handle code changes\n-spec code_change(term(), state(), term()) -> {ok, state()}.\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\n%%====================================================================\n%% Internal Functions\n%%====================================================================\n\n%% @doc Internal initialization logic shared between behavior and gen_server\n-spec internal_init(atom(), tcp_config()) -> {ok, state()} | {error, term()}.\ninternal_init(TransportId, Config) ->\n    ?LOG_INFO(\"Initializing TCP transport ~p\", [TransportId]),\n    \n    %% Validate required configuration\n    case validate_config(Config) of\n        ok ->\n            Host = maps:get(host, Config),\n            Port = maps:get(port, Config),\n            ServerId = maps:get(server_id, Config, undefined),\n            MaxReconnectAttempts = maps:get(max_reconnect_attempts, Config, \n                                          ?DEFAULT_MAX_RECONNECT_ATTEMPTS),\n            \n            %% Build socket options\n            SocketOpts = build_socket_options(Config),\n            \n            %% Initialize statistics\n            Stats = #{\n                messages_sent => 0,\n                messages_received => 0,\n                bytes_sent => 0,\n                bytes_received => 0,\n                errors => 0,\n                connection_time => undefined,\n                last_message_time => undefined,\n                reconnect_count => 0\n            },\n            \n            State = #state{\n                transport_id = TransportId,\n                server_id = ServerId,\n                config = Config,\n                socket = undefined,\n                host = Host,\n                port = Port,\n                buffer = <<>>,\n                connected = false,\n                reconnect_timer = undefined,\n                reconnect_attempts = 0,\n                max_reconnect_attempts = MaxReconnectAttempts,\n                socket_opts = SocketOpts,\n                stats = Stats\n            },\n            \n            %% Register with registry (always attempt; no-op if unavailable)\n            case register_with_registry(State) of\n                ok ->\n                    ?LOG_INFO(\"TCP transport ~p initialized and registry registration attempted\", [TransportId]),\n                    {ok, State};\n                {error, Reason} ->\n                    ?LOG_WARNING(\"TCP transport ~p could not register with registry: ~p\", [TransportId, Reason]),\n                    {ok, State}\n            end;\n        {error, Reason} ->\n            {error, {invalid_config, Reason}}\n    end.\n\n%% @doc Validate transport configuration\n-spec validate_config(tcp_config()) -> ok | {error, term()}.\nvalidate_config(Config) ->\n    RequiredFields = [host, port],\n    case check_required_fields(Config, RequiredFields) of\n        ok ->\n            %% Validate host and port types\n            case {maps:get(host, Config), maps:get(port, Config)} of\n                {Host, Port} when (is_list(Host) orelse is_tuple(Host)), \n                                  is_integer(Port), Port > 0, Port =< 65535 ->\n                    ok;\n                _ ->\n                    {error, invalid_host_or_port}\n            end;\n        Error ->\n            Error\n    end.\n\n%% @doc Check required fields are present\n-spec check_required_fields(map(), [atom()]) -> ok | {error, term()}.\ncheck_required_fields(Config, RequiredFields) ->\n    case [Field || Field <- RequiredFields, not maps:is_key(Field, Config)] of\n        [] -> ok;\n        MissingFields -> {error, {missing_required_fields, MissingFields}}\n    end.\n\n%% @doc Register transport with the registry\n-spec register_with_registry(state()) -> ok | {error, term()}.\nregister_with_registry(#state{transport_id = TransportId, config = Config}) ->\n    TransportConfig = Config#{\n        type => tcp,\n        pid => self(),\n        started_at => erlang:system_time(millisecond)\n    },\n    erlmcp_transport_behavior:register_with_registry(TransportId, self(), TransportConfig).\n\n%% @doc Build socket connection options\n-spec build_socket_options(tcp_config()) -> [gen_tcp:connect_option()].\nbuild_socket_options(Config) ->\n    BaseOpts = [\n        binary,\n        {active, once},  % We'll control flow with inet:setopts\n        {packet, 0},     % Raw TCP, we'll handle framing\n        {reuseaddr, true},\n        {send_timeout, 5000},\n        {send_timeout_close, true}\n    ],\n    \n    %% Add optional settings\n    OptionalOpts = lists:foldl(fun({ConfigKey, SocketOpt}, Acc) ->\n        case maps:get(ConfigKey, Config, undefined) of\n            undefined -> Acc;\n            Value -> [{SocketOpt, Value} | Acc]\n        end\n    end, BaseOpts, [\n        {keepalive, keepalive},\n        {nodelay, nodelay}\n    ]),\n    \n    %% Set buffer sizes\n    BufferSize = maps:get(buffer_size, Config, ?DEFAULT_BUFFER_SIZE),\n    [{recbuf, BufferSize}, {sndbuf, BufferSize} | OptionalOpts].\n\n%% @doc Attempt to establish TCP connection\n-spec attempt_connection(state()) -> state().\nattempt_connection(#state{reconnect_attempts = Attempts,\n                         max_reconnect_attempts = MaxAttempts,\n                         transport_id = TransportId} = State)\n  when is_integer(MaxAttempts), Attempts >= MaxAttempts ->\n    ?LOG_ERROR(\"Maximum reconnection attempts (~p) reached for transport ~p\", \n              [MaxAttempts, TransportId]),\n    State;\n\nattempt_connection(#state{host = Host, port = Port, socket_opts = SocketOpts,\n                         transport_id = TransportId, config = Config} = State) ->\n    ConnectTimeout = maps:get(connect_timeout, Config, ?DEFAULT_CONNECT_TIMEOUT),\n    \n    ?LOG_INFO(\"Attempting TCP connection to ~s:~p for transport ~p (attempt ~p)\", \n              [Host, Port, TransportId, State#state.reconnect_attempts + 1]),\n    \n    case gen_tcp:connect(Host, Port, SocketOpts, ConnectTimeout) of\n        {ok, Socket} ->\n            ?LOG_INFO(\"TCP connection established for transport ~p\", [TransportId]),\n            \n            %% Update connection statistics\n            CurrentTime = erlang:system_time(millisecond),\n            NewStats = (State#state.stats)#{\n                connection_time => CurrentTime,\n                reconnect_count => State#state.reconnect_attempts\n            },\n            \n            State#state{\n                socket = Socket,\n                connected = true,\n                reconnect_attempts = 0,\n                buffer = <<>>,\n                reconnect_timer = undefined,\n                stats = NewStats\n            };\n        {error, Reason} ->\n            ?LOG_WARNING(\"TCP connection failed for transport ~p: ~p\", \n                        [TransportId, Reason]),\n            schedule_reconnect(State, Reason)\n    end.\n\n%% @doc Handle TCP connection disconnect\n-spec handle_disconnect(state(), term()) -> state().\nhandle_disconnect(#state{socket = undefined} = State, _Reason) ->\n    State;\nhandle_disconnect(#state{socket = Socket} = State, Reason) ->\n    %% Close the socket\n    case Socket of\n        undefined -> ok;\n        _ -> catch gen_tcp:close(Socket)\n    end,\n    \n    %% Update state and schedule reconnect\n    DisconnectedState = State#state{\n        socket = undefined,\n        connected = false,\n        buffer = <<>>\n    },\n    \n    schedule_reconnect(DisconnectedState, Reason).\n\n%% @doc Schedule reconnection attempt with exponential backoff\n-spec schedule_reconnect(state(), term()) -> state().\nschedule_reconnect(#state{reconnect_timer = Timer} = State, _Reason) when Timer =/= undefined ->\n    %% Already have a reconnect timer scheduled\n    State;\nschedule_reconnect(#state{reconnect_attempts = Attempts, \n                         transport_id = TransportId} = State, _Reason) ->\n    %% Calculate backoff delay\n    Delay = calculate_backoff(Attempts),\n    NewAttempts = Attempts + 1,\n    \n    ?LOG_INFO(\"Scheduling reconnection in ~p ms (attempt ~p) for transport ~p\",\n              [Delay, NewAttempts, TransportId]),\n    \n    Timer = erlang:send_after(Delay, self(), reconnect),\n    \n    State#state{\n        reconnect_timer = Timer,\n        reconnect_attempts = NewAttempts\n    }.\n\n%% @doc Calculate exponential backoff with jitter\n-spec calculate_backoff(non_neg_integer()) -> pos_integer().\ncalculate_backoff(Attempts) ->\n    BaseDelay = min(?INITIAL_RECONNECT_DELAY * (1 bsl Attempts),\n                    ?MAX_RECONNECT_DELAY),\n    Jitter = rand:uniform(BaseDelay div 4),\n    BaseDelay + Jitter.\n\n%% @doc Cancel active reconnect timer\n-spec cancel_reconnect_timer(state()) -> state().\ncancel_reconnect_timer(#state{reconnect_timer = undefined} = State) ->\n    State;\ncancel_reconnect_timer(#state{reconnect_timer = Timer} = State) ->\n    case erlang:cancel_timer(Timer) of\n        false -> \n            %% Timer already fired, drain the message\n            receive reconnect -> ok after 0 -> ok end;\n        _ -> ok\n    end,\n    State#state{reconnect_timer = undefined}.\n\n%% @doc Handle incoming TCP data\n-spec handle_tcp_data(state(), binary()) -> state().\nhandle_tcp_data(#state{buffer = Buffer, transport_id = TransportId, \n                      server_id = ServerId, stats = Stats} = State, Data) ->\n    %% Update receive statistics\n    DataSize = byte_size(Data),\n    NewStats = Stats#{\n        bytes_received => maps:get(bytes_received, Stats, 0) + DataSize,\n        last_message_time => erlang:system_time(millisecond)\n    },\n    \n    %% Accumulate data in buffer\n    NewBuffer = <<Buffer/binary, Data/binary>>,\n    \n    %% Extract complete messages (line-based framing)\n    {Messages, RemainingBuffer} = erlmcp_transport_behavior:extract_message_lines(<<>>, NewBuffer),\n    \n    %% Route complete messages to server via registry\n    FinalStats = lists:foldl(fun(Message, StatsAcc) ->\n        TrimmedMessage = erlmcp_transport_behavior:trim_message_line(Message),\n        case byte_size(TrimmedMessage) of\n            0 -> StatsAcc;  % Skip empty messages\n            _ ->\n                case ServerId of\n                    undefined ->\n                        ?LOG_WARNING(\"Cannot route message from transport ~p: no server bound\", \n                                   [TransportId]);\n                    _ ->\n                        erlmcp_transport_behavior:handle_transport_message(TransportId, TrimmedMessage)\n                end,\n                StatsAcc#{\n                    messages_received => maps:get(messages_received, StatsAcc, 0) + 1\n                }\n        end\n    end, NewStats, Messages),\n    \n    State#state{\n        buffer = RemainingBuffer,\n        stats = FinalStats\n    }.\n\n%% @doc Send data through the transport\n-spec do_send(state(), iodata()) -> ok | {error, term()}.\ndo_send(#state{config = #{test_mode := true}}, _Data) ->\n    %% In test mode, just simulate successful send\n    ok;\ndo_send(#state{connected = false}, _Data) ->\n    {error, not_connected};\ndo_send(#state{socket = undefined}, _Data) ->\n    {error, not_connected};\ndo_send(#state{socket = Socket, stats = _Stats}, Data) ->\n    %% Frame message with newline for line-based protocol\n    FramedData = [Data, \"\\n\"],\n    case gen_tcp:send(Socket, FramedData) of\n        ok ->\n            ok;\n        {error, Reason} ->\n            %% Connection might be broken, let the error handling deal with it\n            {error, {tcp_send_failed, Reason}}\n    end.\n\n%% @doc Close the transport\n-spec do_close(state()) -> ok.\ndo_close(#state{socket = undefined}) ->\n    ok;\ndo_close(#state{socket = Socket}) when Socket =/= undefined ->\n    catch gen_tcp:close(Socket),\n    ok;\ndo_close(_State) ->\n    ok.\n\n%% @doc Get transport information\n-spec do_get_info(state()) -> map().\ndo_get_info(#state{transport_id = TransportId, config = Config, \n                  host = Host, port = Port, connected = Connected,\n                  reconnect_attempts = Attempts, stats = Stats}) ->\n    TestMode = maps:get(test_mode, Config, false),\n    #{\n        transport_id => TransportId,\n        type => tcp,\n        test_mode => TestMode,\n        status => case TestMode of\n            true -> running;  % In test mode, always report running\n            false -> case Connected of\n                true -> connected;\n                false when Attempts > 0 -> connecting;\n                false -> disconnected\n            end\n        end,\n        config => maps:without([password, secret, token], Config),\n        connection => #{\n            host => Host,\n            port => Port,\n            connected => Connected,\n            reconnect_attempts => Attempts\n        },\n        statistics => Stats\n    }.\n\n%% @doc Update transport statistics\n-spec update_stats(map(), atom(), non_neg_integer()) -> map().\nupdate_stats(Stats, Key, Increment) ->\n    CurrentValue = maps:get(Key, Stats, 0),\n    Stats#{\n        Key => CurrentValue + Increment,\n        last_updated => erlang:system_time(millisecond)\n    }."
        }
    ]
}