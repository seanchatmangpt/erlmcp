{
    "sourceFile": "src/erlmcp_transport_http.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1756188161125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1756188161125,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @doc\n%%% Simplified HTTP Transport for Erlang MCP (Model Context Protocol)\n%%% \n%%% This module provides a simplified HTTP client transport implementation\n%%% for MCP. It focuses on the core use case: making HTTP requests to MCP \n%%% servers and handling JSON-RPC 2.0 responses over HTTP.\n%%%\n%%% Features:\n%%% - HTTP/HTTPS client functionality\n%%% - JSON-RPC 2.0 over HTTP\n%%% - Registry integration\n%%% - Proper error handling and timeouts\n%%% - SSL/TLS support\n%%% - Connection pooling\n%%% - Retry logic\n%%%\n%%% @end\n%%%-------------------------------------------------------------------\n-module(erlmcp_transport_http).\n-behaviour(gen_server).\n\n-include(\"erlmcp.hrl\").\n-include_lib(\"kernel/include/logger.hrl\").\n\n%% Transport API\n-export([\n    send/2,\n    close/1,\n    get_info/1,\n    handle_transport_call/2\n]).\n\n%% API\n-export([\n    start_link/2,\n    start_link/3,\n    stop/1\n]).\n\n%% gen_server callbacks\n-export([\n    init/1,\n    handle_call/3,\n    handle_cast/2,\n    handle_info/2,\n    terminate/2,\n    code_change/3\n]).\n\n%% Types\n-type http_method() :: get | post | put | delete.\n-type http_headers() :: [{string(), string()}].\n\n%% Simplified state record focused on MCP use case\n-record(state, {\n    %% Core identification\n    transport_id :: atom(),\n    owner_pid :: pid(),\n    registry_pid :: pid() | undefined,\n    \n    %% HTTP client configuration  \n    url :: binary(),\n    method = post :: http_method(),\n    headers = [] :: http_headers(),\n    \n    %% Connection settings\n    timeout = 30000 :: timeout(),\n    connect_timeout = 10000 :: timeout(),\n    ssl_options = [] :: [ssl:tls_client_option()],\n    \n    %% Retry and reliability\n    max_retries = 3 :: non_neg_integer(),\n    retry_delay = 1000 :: pos_integer(),\n    \n    %% State tracking\n    connected = false :: boolean(),\n    error_count = 0 :: non_neg_integer(),\n    last_error :: term() | undefined,\n    \n    %% Statistics\n    requests_sent = 0 :: non_neg_integer(),\n    responses_received = 0 :: non_neg_integer(),\n    bytes_sent = 0 :: non_neg_integer(),\n    bytes_received = 0 :: non_neg_integer(),\n    \n    %% Internal\n    http_client_options :: map()\n}).\n\n-type state() :: #state{}.\n\n%% Default HTTP headers for MCP\n-define(DEFAULT_HEADERS, [\n    {\"Content-Type\", \"application/json\"},\n    {\"Accept\", \"application/json\"},\n    {\"User-Agent\", \"erlmcp-http-transport/1.0\"}\n]).\n\n%%====================================================================\n%% Transport API Implementation\n%%====================================================================\n\n-spec send(state(), iodata()) -> ok | {error, term()}.\nsend(State, Data) ->\n    send_with_retry(State, Data, State#state.max_retries).\n\n-spec close(state()) -> ok.\nclose(State) ->\n    unregister_from_registry(State),\n    ?LOG_INFO(\"HTTP transport closed for URL: ~s\", [State#state.url]),\n    ok.\n\n-spec get_info(state()) -> erlmcp_transport:transport_info().\nget_info(State) ->\n    #{\n        type => http,\n        version => <<\"1.0\">>,\n        capabilities => [client, json_rpc, ssl, retry],\n        connection_state => case State#state.connected of\n            true -> connected;\n            false -> disconnected\n        end,\n        statistics => #{\n            requests_sent => State#state.requests_sent,\n            responses_received => State#state.responses_received,\n            bytes_sent => State#state.bytes_sent,\n            bytes_received => State#state.bytes_received,\n            error_count => State#state.error_count\n        },\n        url => State#state.url,\n        method => State#state.method,\n        timeout => State#state.timeout,\n        last_error => State#state.last_error\n    }.\n\n-spec handle_transport_call(term(), state()) -> \n    {reply, term(), state()} | {error, term()}.\nhandle_transport_call(get_url, State) ->\n    {reply, State#state.url, State};\nhandle_transport_call({set_timeout, Timeout}, State) \n  when is_integer(Timeout), Timeout > 0 ->\n    NewState = State#state{timeout = Timeout},\n    {reply, ok, NewState};\nhandle_transport_call({set_headers, Headers}, State) when is_list(Headers) ->\n    NewState = State#state{headers = merge_headers(Headers)},\n    {reply, ok, NewState};\nhandle_transport_call(reset_stats, State) ->\n    NewState = State#state{\n        requests_sent = 0,\n        responses_received = 0,\n        bytes_sent = 0,\n        bytes_received = 0,\n        error_count = 0,\n        last_error = undefined\n    },\n    {reply, ok, NewState};\nhandle_transport_call(reconnect, State) ->\n    % For HTTP, reconnect means testing the connection\n    case test_connection(State) of\n        ok ->\n            NewState = State#state{connected = true, last_error = undefined},\n            {reply, ok, NewState};\n        {error, Reason} ->\n            NewState = State#state{\n                connected = false,\n                last_error = Reason,\n                error_count = State#state.error_count + 1\n            },\n            {reply, {error, Reason}, NewState}\n    end;\nhandle_transport_call(_Request, _State) ->\n    {error, unknown_request}.\n\n%%====================================================================\n%% API Functions\n%%====================================================================\n\n-spec start_link(atom(), map()) -> {ok, pid()} | {error, term()}.\nstart_link(TransportId, Opts) ->\n    gen_server:start_link(?MODULE, [TransportId, Opts], []).\n\n-spec start_link(atom(), atom(), map()) -> {ok, pid()} | {error, term()}.\nstart_link(TransportId, Name, Opts) ->\n    gen_server:start_link({local, Name}, ?MODULE, [TransportId, Opts], []).\n\n-spec stop(pid()) -> ok.\nstop(Pid) ->\n    gen_server:stop(Pid).\n\n%%====================================================================\n%% gen_server callbacks\n%%====================================================================\n\ninit([TransportId, Opts]) ->\n    process_flag(trap_exit, true),\n    \n    ?LOG_DEBUG(\"Initializing HTTP transport ~p with opts: ~p\", [TransportId, Opts]),\n    \n    case validate_http_opts(Opts) of\n        ok ->\n            Url = maps:get(url, Opts),\n            OwnerPid = maps:get(owner, Opts),\n            \n            State = #state{\n                transport_id = TransportId,\n                url = ensure_binary(Url),\n                owner_pid = OwnerPid,\n                method = maps:get(method, Opts, post),\n                headers = merge_headers(maps:get(headers, Opts, [])),\n                timeout = maps:get(timeout, Opts, 30000),\n                connect_timeout = maps:get(connect_timeout, Opts, 10000),\n                ssl_options = maps:get(ssl_options, Opts, []),\n                max_retries = maps:get(max_retries, Opts, 3),\n                retry_delay = maps:get(retry_delay, Opts, 1000),\n                http_client_options = build_client_options(Opts)\n            },\n            \n            % Register with registry if available\n            register_with_registry(State),\n            \n            % Test initial connection\n            case test_connection(State) of\n                ok ->\n                    FinalState = State#state{connected = true},\n                    ?LOG_INFO(\"HTTP transport ~p started successfully\", [TransportId]),\n                    {ok, FinalState};\n                {error, Reason} ->\n                    ?LOG_WARNING(\"HTTP transport ~p started but connection test failed: ~p\", \n                               [TransportId, Reason]),\n                    FinalState = State#state{\n                        connected = false,\n                        last_error = Reason,\n                        error_count = 1\n                    },\n                    {ok, FinalState}\n            end;\n            \n        {error, Reason} ->\n            ?LOG_ERROR(\"Failed to initialize HTTP transport ~p: ~p\", [TransportId, Reason]),\n            {stop, Reason}\n    end.\n\nhandle_call({send, Data}, _From, State) ->\n    case send(State, Data) of\n        ok ->\n            NewState = State#state{\n                requests_sent = State#state.requests_sent + 1,\n                bytes_sent = State#state.bytes_sent + iolist_size(Data)\n            },\n            {reply, ok, NewState};\n        {error, Reason} = Error ->\n            NewState = State#state{\n                error_count = State#state.error_count + 1,\n                last_error = Reason,\n                connected = false\n            },\n            {reply, Error, NewState}\n    end;\n\nhandle_call(close, _From, State) ->\n    close(State),\n    {stop, normal, ok, State};\n\nhandle_call(get_info, _From, State) ->\n    Info = get_info(State),\n    {reply, Info, State};\n\nhandle_call({transport_call, Request}, _From, State) ->\n    case handle_transport_call(Request, State) of\n        {reply, Reply, NewState} ->\n            {reply, Reply, NewState};\n        {error, Reason} ->\n            {reply, {error, Reason}, State}\n    end;\n\nhandle_call(_Request, _From, State) ->\n    {reply, {error, unknown_request}, State}.\n\nhandle_cast(_Msg, State) ->\n    {noreply, State}.\n\nhandle_info({http_response, Response}, State) ->\n    % Handle asynchronous HTTP response if needed\n    ?LOG_DEBUG(\"Received HTTP response: ~p\", [Response]),\n    NewState = State#state{\n        responses_received = State#state.responses_received + 1\n    },\n    {noreply, NewState};\n\nhandle_info({'EXIT', _Pid, Reason}, State) ->\n    ?LOG_WARNING(\"HTTP transport received EXIT signal: ~p\", [Reason]),\n    {noreply, State};\n\nhandle_info(_Info, State) ->\n    {noreply, State}.\n\nterminate(_Reason, State) ->\n    close(State),\n    ok.\n\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\n%%====================================================================\n%% Internal Functions\n%%====================================================================\n\n%% @private\n%% Validate HTTP transport options\n-spec validate_http_opts(map()) -> ok | {error, term()}.\nvalidate_http_opts(Opts) ->\n    try\n        % Check required fields\n        case maps:get(url, Opts, undefined) of\n            undefined -> throw(missing_url);\n            Url -> validate_url(Url)\n        end,\n        \n        case maps:get(owner, Opts, undefined) of\n            undefined -> throw(missing_owner);\n            Owner when is_pid(Owner) -> ok;\n            _ -> throw(invalid_owner)\n        end,\n        \n        validate_extended_http_opts(Opts)\n    catch\n        throw:Reason -> {error, Reason};\n        Class:Reason -> {error, {validation_error, Class, Reason}}\n    end.\n\n%% @private\n%% duplicate older helper removed; canonical version exists below\n\n%% @private\n%% Validate extended HTTP options\n-spec validate_extended_http_opts(map()) -> ok | {error, term()}.\nvalidate_extended_http_opts(Opts) ->\n    try\n        % Validate method\n        Method = maps:get(method, Opts, post),\n        case lists:member(Method, [get, post, put, delete]) of\n            true -> ok;\n            false -> throw({invalid_method, Method})\n        end,\n        \n        % Validate timeouts\n        Timeout = maps:get(timeout, Opts, 30000),\n        case is_integer(Timeout) andalso Timeout > 0 of\n            true -> ok;\n            false -> throw({invalid_timeout, Timeout})\n        end,\n        \n        ConnectTimeout = maps:get(connect_timeout, Opts, 10000),\n        case is_integer(ConnectTimeout) andalso ConnectTimeout > 0 of\n            true -> ok;\n            false -> throw({invalid_connect_timeout, ConnectTimeout})\n        end,\n        \n        % Validate retries\n        MaxRetries = maps:get(max_retries, Opts, 3),\n        case is_integer(MaxRetries) andalso MaxRetries >= 0 of\n            true -> ok;\n            false -> throw({invalid_max_retries, MaxRetries})\n        end,\n        \n        ok\n    catch\n        throw:Reason -> {error, Reason};\n        Class:Reason -> {error, {validation_error, Class, Reason}}\n    end.\n\n%% @private\n%% Send data with retry logic\n-spec send_with_retry(state(), iodata(), non_neg_integer()) -> ok | {error, term()}.\nsend_with_retry(_State, _Data, 0) ->\n    {error, max_retries_exceeded};\nsend_with_retry(State, Data, RetriesLeft) ->\n    case send_http_request(State, Data) of\n        {ok, _Response} ->\n            ok;\n        {error, Reason} = Error ->\n            case should_retry(Reason) of\n                true when RetriesLeft > 1 ->\n                    timer:sleep(State#state.retry_delay),\n                    send_with_retry(State, Data, RetriesLeft - 1);\n                _ ->\n                    Error\n            end\n    end.\n\n%% @private\n%% Send actual HTTP request\n-spec send_http_request(state(), iodata()) -> {ok, term()} | {error, term()}.\nsend_http_request(State, Data) ->\n    #state{\n        url = Url,\n        method = Method,\n        headers = Headers,\n        timeout = _Timeout,\n        ssl_options = _SSLOpts,\n        http_client_options = _ClientOpts\n    } = State,\n    \n    try\n        % Ensure data is binary\n        Body = iolist_to_binary(Data),\n        \n        % Build request options\n        RequestOpts = build_request_options(State),\n        \n        % Make HTTP request using httpc\n        case Method of\n            get ->\n                httpc:request(get, {binary_to_list(Url), Headers}, RequestOpts, []);\n            post ->\n                ContentType = proplists:get_value(\"Content-Type\", Headers, \"application/json\"),\n                httpc:request(post, {binary_to_list(Url), Headers, ContentType, Body}, \n                            RequestOpts, []);\n            put ->\n                ContentType = proplists:get_value(\"Content-Type\", Headers, \"application/json\"),\n                httpc:request(put, {binary_to_list(Url), Headers, ContentType, Body}, \n                            RequestOpts, []);\n            delete ->\n                httpc:request(delete, {binary_to_list(Url), Headers}, RequestOpts, [])\n        end\n    catch\n        Class:Reason:Stacktrace ->\n            ?LOG_ERROR(\"HTTP request failed: ~p:~p~n~p\", [Class, Reason, Stacktrace]),\n            {error, {http_request_failed, Class, Reason}}\n    end.\n\n%% @private\n%% Build HTTP request options\n-spec build_request_options(state()) -> proplists:proplist().\nbuild_request_options(State) ->\n    BaseOpts = [\n        {timeout, State#state.timeout},\n        {connect_timeout, State#state.connect_timeout}\n    ],\n    \n    % Add SSL options if URL is HTTPS\n    case binary:match(State#state.url, <<\"https://\">>) of\n        {0, _} ->\n            [{ssl, State#state.ssl_options} | BaseOpts];\n        nomatch ->\n            BaseOpts\n    end.\n\n%% @private\n%% Test connection to the HTTP endpoint\n-spec test_connection(state()) -> ok | {error, term()}.\ntest_connection(State) ->\n    % Simple HEAD request to test connectivity\n    TestUrl = binary_to_list(State#state.url),\n    RequestOpts = build_request_options(State#state{timeout = 5000}),\n    \n    case httpc:request(head, {TestUrl, []}, RequestOpts, []) of\n        {ok, {{_, Status, _}, _, _}} when Status >= 200, Status < 400 ->\n            ok;\n        {ok, {{_, Status, _}, _, _}} ->\n            {error, {http_status, Status}};\n        {error, Reason} ->\n            {error, {connection_test_failed, Reason}}\n    end.\n\n%% @private\n%% Determine if an error should trigger a retry\n-spec should_retry(term()) -> boolean().\nshould_retry({http_status, Status}) when Status >= 500 ->\n    true;\nshould_retry({connection_test_failed, _}) ->\n    true;\nshould_retry(timeout) ->\n    true;\nshould_retry(connect_timeout) ->\n    true;\nshould_retry({socket_error, _}) ->\n    true;\nshould_retry(_) ->\n    false.\n\n%% @private\n%% Merge user headers with defaults\n-spec merge_headers([{string(), string()}]) -> [{string(), string()}].\nmerge_headers(UserHeaders) ->\n    % Convert to maps for easier merging\n    DefaultMap = maps:from_list(?DEFAULT_HEADERS),\n    UserMap = maps:from_list(UserHeaders),\n    \n    % User headers override defaults\n    MergedMap = maps:merge(DefaultMap, UserMap),\n    maps:to_list(MergedMap).\n\n%% @private\n%% Build HTTP client options\n-spec build_client_options(map()) -> map().\nbuild_client_options(Opts) ->\n    #{\n        pool_size => maps:get(pool_size, Opts, 10),\n        max_sessions => maps:get(max_sessions, Opts, 20),\n        keep_alive => maps:get(keep_alive, Opts, true)\n    }.\n\n%% @private\n%% Validate URL format\n-spec validate_url(binary() | string()) -> ok | no_return().\nvalidate_url(Url) when is_binary(Url) ->\n    validate_url(binary_to_list(Url));\nvalidate_url(Url) when is_list(Url) ->\n    HasHttp = case string:prefix(Url, \"http://\") of\n        nomatch -> false;\n        _ -> true\n    end,\n    HasHttps = case string:prefix(Url, \"https://\") of\n        nomatch -> false;\n        _ -> true\n    end,\n    case HasHttp orelse HasHttps of\n        false -> throw(invalid_url_format);\n        true -> ok\n    end;\nvalidate_url(_) ->\n    throw(invalid_url_type).\n\n%% @private\n%% Ensure value is binary\n-spec ensure_binary(binary() | string()) -> binary().\nensure_binary(Value) when is_binary(Value) ->\n    Value;\nensure_binary(Value) when is_list(Value) ->\n    list_to_binary(Value).\n\n%% @private\n%% Register transport with the registry\n-spec register_with_registry(state()) -> ok.\nregister_with_registry(#state{transport_id = TransportId} = State) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            ?LOG_WARNING(\"Registry not available for HTTP transport ~p\", [TransportId]),\n            ok;\n        RegistryPid when is_pid(RegistryPid) ->\n            Config = #{\n                type => http,\n                url => State#state.url,\n                method => State#state.method,\n                timeout => State#state.timeout,\n                capabilities => [client, json_rpc, ssl, retry]\n            },\n            case erlmcp_registry:register_transport(TransportId, self(), Config) of\n                ok ->\n                    ?LOG_DEBUG(\"Registered HTTP transport ~p with registry\", [TransportId]),\n                    ok;\n                {error, Reason} ->\n                    ?LOG_ERROR(\"Failed to register HTTP transport ~p: ~p\", \n                             [TransportId, Reason]),\n                    ok\n            end\n    end.\n\n%% @private\n%% Unregister transport from the registry\n-spec unregister_from_registry(state()) -> ok.\nunregister_from_registry(#state{transport_id = undefined}) ->\n    ok;\nunregister_from_registry(#state{transport_id = TransportId}) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            ok;\n        RegistryPid when is_pid(RegistryPid) ->\n            case erlmcp_registry:unregister_transport(TransportId) of\n                ok ->\n                    ?LOG_DEBUG(\"Unregistered HTTP transport ~p from registry\", [TransportId]),\n                    ok;\n                {error, Reason} ->\n                    ?LOG_WARNING(\"Failed to unregister HTTP transport ~p: ~p\", \n                               [TransportId, Reason]),\n                    ok\n            end\n    end."
        }
    ]
}