{
    "sourceFile": "src/erlmcp_transport_http.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1756188161125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756189288924,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,298 +1,217 @@\n %%%-------------------------------------------------------------------\n %%% @doc\n %%% Simplified HTTP Transport for Erlang MCP (Model Context Protocol)\n-%%% \n+%%%\n %%% This module provides a simplified HTTP client transport implementation\n-%%% for MCP. It focuses on the core use case: making HTTP requests to MCP \n+%%% for MCP. It focuses on the core use case: making HTTP requests to MCP\n %%% servers and handling JSON-RPC 2.0 responses over HTTP.\n %%%\n %%% Features:\n %%% - HTTP/HTTPS client functionality\n %%% - JSON-RPC 2.0 over HTTP\n %%% - Registry integration\n %%% - Proper error handling and timeouts\n %%% - SSL/TLS support\n-%%% - Connection pooling\n %%% - Retry logic\n %%%\n %%% @end\n %%%-------------------------------------------------------------------\n -module(erlmcp_transport_http).\n+\n -behaviour(gen_server).\n+%% NOTE: We implement erlmcp_transport_behavior interface manually to avoid init/1 conflict\n+%% This module provides both gen_server functionality and transport behavior compliance\n \n -include(\"erlmcp.hrl\").\n -include_lib(\"kernel/include/logger.hrl\").\n \n-%% Transport API\n--export([\n-    send/2,\n-    close/1,\n-    get_info/1,\n-    handle_transport_call/2\n-]).\n-\n+%% erlmcp_transport_behavior interface (manual implementation)\n+-export([send/2, close/1, get_info/1, handle_transport_call/2]).\n %% API\n--export([\n-    start_link/2,\n-    start_link/3,\n-    stop/1\n-]).\n-\n+-export([start_link/2, stop/1]).\n %% gen_server callbacks\n--export([\n-    init/1,\n-    handle_call/3,\n-    handle_cast/2,\n-    handle_info/2,\n-    terminate/2,\n-    code_change/3\n-]).\n+-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,\n+         code_change/3]).\n \n-%% Types\n--type http_method() :: get | post | put | delete.\n--type http_headers() :: [{string(), string()}].\n-\n-%% Simplified state record focused on MCP use case\n+%% Simplified state record from the plan\n -record(state, {\n-    %% Core identification\n     transport_id :: atom(),\n-    owner_pid :: pid(),\n-    registry_pid :: pid() | undefined,\n-    \n-    %% HTTP client configuration  \n-    url :: binary(),\n-    method = post :: http_method(),\n-    headers = [] :: http_headers(),\n-    \n-    %% Connection settings\n-    timeout = 30000 :: timeout(),\n-    connect_timeout = 10000 :: timeout(),\n-    ssl_options = [] :: [ssl:tls_client_option()],\n-    \n-    %% Retry and reliability\n-    max_retries = 3 :: non_neg_integer(),\n-    retry_delay = 1000 :: pos_integer(),\n-    \n-    %% State tracking\n-    connected = false :: boolean(),\n-    error_count = 0 :: non_neg_integer(),\n-    last_error :: term() | undefined,\n-    \n-    %% Statistics\n-    requests_sent = 0 :: non_neg_integer(),\n-    responses_received = 0 :: non_neg_integer(),\n-    bytes_sent = 0 :: non_neg_integer(),\n-    bytes_received = 0 :: non_neg_integer(),\n-    \n-    %% Internal\n-    http_client_options :: map()\n+    server_id :: atom(),\n+    config :: map(),\n+    url :: string(),\n+    headers :: [{string(), string()}],\n+    http_options :: [term()],\n+    request_options :: [term()]\n }).\n \n--type state() :: #state{}.\n-\n %% Default HTTP headers for MCP\n--define(DEFAULT_HEADERS, [\n-    {\"Content-Type\", \"application/json\"},\n-    {\"Accept\", \"application/json\"},\n-    {\"User-Agent\", \"erlmcp-http-transport/1.0\"}\n-]).\n+-define(DEFAULT_HEADERS,\n+        [{\"Content-Type\", \"application/json\"},\n+         {\"Accept\", \"application/json\"},\n+         {\"User-Agent\", \"erlmcp-http-transport/1.0\"}]).\n \n %%====================================================================\n-%% Transport API Implementation\n+%% erlmcp_transport_behavior callbacks\n %%====================================================================\n \n--spec send(state(), iodata()) -> ok | {error, term()}.\n+%% @doc Initialize the HTTP transport (behavior callback)\n+-spec init([map()]) -> {ok, #state{}} | {stop, term()}.\n+init([Config]) ->\n+    process_flag(trap_exit, true),\n+    case do_transport_init(Config) of\n+        {ok, State} ->\n+            {ok, State};\n+        {error, Reason} ->\n+            {stop, Reason}\n+    end.\n+\n+%% @private\n+%% Internal transport initialization\n+-spec do_transport_init(map()) -> {ok, #state{}} | {error, term()}.\n+do_transport_init(Config) ->\n+    ?LOG_DEBUG(\"Initializing HTTP transport with config: ~p\", [Config]),\n+    \n+    case validate_http_config(Config) of\n+        ok ->\n+            TransportId = maps:get(transport_id, Config),\n+            ServerId = maps:get(server_id, Config, TransportId),\n+            Url = maps:get(url, Config),\n+            Headers = merge_headers(maps:get(headers, Config, [])),\n+            HttpOptions = build_http_options(Config),\n+            RequestOptions = build_request_options(Config),\n+            \n+            State = #state{\n+                transport_id = TransportId,\n+                server_id = ServerId,\n+                config = Config,\n+                url = ensure_string(Url),\n+                headers = Headers,\n+                http_options = HttpOptions,\n+                request_options = RequestOptions\n+            },\n+            \n+            % Register with registry\n+            register_with_registry(State),\n+            \n+            ?LOG_INFO(\"HTTP transport ~p initialized for URL: ~s\", [TransportId, State#state.url]),\n+            {ok, State};\n+        {error, Reason} ->\n+            ?LOG_ERROR(\"Failed to initialize HTTP transport: ~p\", [Reason]),\n+            {error, Reason}\n+    end.\n+\n+%% @doc Send data through HTTP transport\n+-spec send(#state{}, iodata()) -> ok | {error, term()}.\n send(State, Data) ->\n-    send_with_retry(State, Data, State#state.max_retries).\n+    ?LOG_DEBUG(\"Sending HTTP request to ~s\", [State#state.url]),\n+    \n+    try\n+        Body = iolist_to_binary(Data),\n+        \n+        case httpc:request(post,\n+                          {State#state.url, State#state.headers, \"application/json\", Body},\n+                          State#state.http_options,\n+                          State#state.request_options) of\n+            {ok, {{_, Status, _}, _Headers, _ResponseBody}} when Status >= 200, Status < 300 ->\n+                ?LOG_DEBUG(\"HTTP request successful, status: ~p\", [Status]),\n+                % For MCP HTTP transport, we typically don't process the response here\n+                % as it's handled by the calling process\n+                ok;\n+            {ok, {{_, Status, _}, _Headers, _ResponseBody}} ->\n+                ?LOG_WARNING(\"HTTP request failed with status: ~p\", [Status]),\n+                {error, {http_status, Status}};\n+            {error, Reason} ->\n+                ?LOG_ERROR(\"HTTP request failed: ~p\", [Reason]),\n+                {error, {http_error, Reason}}\n+        end\n+    catch\n+        Class:ErrorReason:Stacktrace ->\n+            ?LOG_ERROR(\"HTTP request exception: ~p:~p~n~p\", [Class, ErrorReason, Stacktrace]),\n+            {error, {request_exception, Class, ErrorReason}}\n+    end.\n \n--spec close(state()) -> ok.\n+%% @doc Close the HTTP transport\n+-spec close(#state{}) -> ok.\n close(State) ->\n     unregister_from_registry(State),\n-    ?LOG_INFO(\"HTTP transport closed for URL: ~s\", [State#state.url]),\n+    ?LOG_INFO(\"HTTP transport ~p closed\", [State#state.transport_id]),\n     ok.\n \n--spec get_info(state()) -> erlmcp_transport:transport_info().\n+%% @doc Get transport information\n+-spec get_info(#state{}) -> erlmcp_transport_behavior:transport_info().\n get_info(State) ->\n-    #{\n-        type => http,\n-        version => <<\"1.0\">>,\n-        capabilities => [client, json_rpc, ssl, retry],\n-        connection_state => case State#state.connected of\n-            true -> connected;\n-            false -> disconnected\n-        end,\n-        statistics => #{\n-            requests_sent => State#state.requests_sent,\n-            responses_received => State#state.responses_received,\n-            bytes_sent => State#state.bytes_sent,\n-            bytes_received => State#state.bytes_received,\n-            error_count => State#state.error_count\n-        },\n-        url => State#state.url,\n-        method => State#state.method,\n-        timeout => State#state.timeout,\n-        last_error => State#state.last_error\n-    }.\n+    #{transport_id => State#state.transport_id,\n+      type => http,\n+      status => running,\n+      config => maps:without([password, secret, token], State#state.config),\n+      statistics => #{messages_sent => 0,\n+                      messages_received => 0,\n+                      bytes_sent => 0,\n+                      bytes_received => 0,\n+                      errors => 0,\n+                      connection_time => erlang:system_time(millisecond),\n+                      last_message_time => erlang:system_time(millisecond)}}.\n \n--spec handle_transport_call(term(), state()) -> \n-    {reply, term(), state()} | {error, term()}.\n+%% @doc Handle transport-specific calls\n+-spec handle_transport_call(term(), #state{}) -> {reply, term(), #state{}} | {error, term()}.\n handle_transport_call(get_url, State) ->\n     {reply, State#state.url, State};\n-handle_transport_call({set_timeout, Timeout}, State) \n-  when is_integer(Timeout), Timeout > 0 ->\n-    NewState = State#state{timeout = Timeout},\n-    {reply, ok, NewState};\n handle_transport_call({set_headers, Headers}, State) when is_list(Headers) ->\n-    NewState = State#state{headers = merge_headers(Headers)},\n+    NewHeaders = merge_headers(Headers),\n+    NewState = State#state{headers = NewHeaders},\n     {reply, ok, NewState};\n-handle_transport_call(reset_stats, State) ->\n-    NewState = State#state{\n-        requests_sent = 0,\n-        responses_received = 0,\n-        bytes_sent = 0,\n-        bytes_received = 0,\n-        error_count = 0,\n-        last_error = undefined\n-    },\n-    {reply, ok, NewState};\n-handle_transport_call(reconnect, State) ->\n-    % For HTTP, reconnect means testing the connection\n-    case test_connection(State) of\n-        ok ->\n-            NewState = State#state{connected = true, last_error = undefined},\n-            {reply, ok, NewState};\n-        {error, Reason} ->\n-            NewState = State#state{\n-                connected = false,\n-                last_error = Reason,\n-                error_count = State#state.error_count + 1\n-            },\n-            {reply, {error, Reason}, NewState}\n-    end;\n handle_transport_call(_Request, _State) ->\n     {error, unknown_request}.\n \n %%====================================================================\n %% API Functions\n %%====================================================================\n \n -spec start_link(atom(), map()) -> {ok, pid()} | {error, term()}.\n-start_link(TransportId, Opts) ->\n-    gen_server:start_link(?MODULE, [TransportId, Opts], []).\n+start_link(TransportId, Config) ->\n+    FinalConfig = Config#{transport_id => TransportId},\n+    gen_server:start_link(?MODULE, [FinalConfig], []).\n \n--spec start_link(atom(), atom(), map()) -> {ok, pid()} | {error, term()}.\n-start_link(TransportId, Name, Opts) ->\n-    gen_server:start_link({local, Name}, ?MODULE, [TransportId, Opts], []).\n-\n -spec stop(pid()) -> ok.\n stop(Pid) ->\n     gen_server:stop(Pid).\n \n %%====================================================================\n %% gen_server callbacks\n %%====================================================================\n \n-init([TransportId, Opts]) ->\n-    process_flag(trap_exit, true),\n-    \n-    ?LOG_DEBUG(\"Initializing HTTP transport ~p with opts: ~p\", [TransportId, Opts]),\n-    \n-    case validate_http_opts(Opts) of\n-        ok ->\n-            Url = maps:get(url, Opts),\n-            OwnerPid = maps:get(owner, Opts),\n-            \n-            State = #state{\n-                transport_id = TransportId,\n-                url = ensure_binary(Url),\n-                owner_pid = OwnerPid,\n-                method = maps:get(method, Opts, post),\n-                headers = merge_headers(maps:get(headers, Opts, [])),\n-                timeout = maps:get(timeout, Opts, 30000),\n-                connect_timeout = maps:get(connect_timeout, Opts, 10000),\n-                ssl_options = maps:get(ssl_options, Opts, []),\n-                max_retries = maps:get(max_retries, Opts, 3),\n-                retry_delay = maps:get(retry_delay, Opts, 1000),\n-                http_client_options = build_client_options(Opts)\n-            },\n-            \n-            % Register with registry if available\n-            register_with_registry(State),\n-            \n-            % Test initial connection\n-            case test_connection(State) of\n-                ok ->\n-                    FinalState = State#state{connected = true},\n-                    ?LOG_INFO(\"HTTP transport ~p started successfully\", [TransportId]),\n-                    {ok, FinalState};\n-                {error, Reason} ->\n-                    ?LOG_WARNING(\"HTTP transport ~p started but connection test failed: ~p\", \n-                               [TransportId, Reason]),\n-                    FinalState = State#state{\n-                        connected = false,\n-                        last_error = Reason,\n-                        error_count = 1\n-                    },\n-                    {ok, FinalState}\n-            end;\n-            \n-        {error, Reason} ->\n-            ?LOG_ERROR(\"Failed to initialize HTTP transport ~p: ~p\", [TransportId, Reason]),\n-            {stop, Reason}\n-    end.\n+%% Note: init/1 is already implemented above for both gen_server and transport behavior\n \n handle_call({send, Data}, _From, State) ->\n     case send(State, Data) of\n         ok ->\n-            NewState = State#state{\n-                requests_sent = State#state.requests_sent + 1,\n-                bytes_sent = State#state.bytes_sent + iolist_size(Data)\n-            },\n-            {reply, ok, NewState};\n-        {error, Reason} = Error ->\n-            NewState = State#state{\n-                error_count = State#state.error_count + 1,\n-                last_error = Reason,\n-                connected = false\n-            },\n-            {reply, Error, NewState}\n+            {reply, ok, State};\n+        {error, _Reason} = Error ->\n+            {reply, Error, State}\n     end;\n-\n handle_call(close, _From, State) ->\n     close(State),\n     {stop, normal, ok, State};\n-\n handle_call(get_info, _From, State) ->\n     Info = get_info(State),\n     {reply, Info, State};\n-\n handle_call({transport_call, Request}, _From, State) ->\n     case handle_transport_call(Request, State) of\n         {reply, Reply, NewState} ->\n             {reply, Reply, NewState};\n         {error, Reason} ->\n             {reply, {error, Reason}, State}\n     end;\n-\n handle_call(_Request, _From, State) ->\n     {reply, {error, unknown_request}, State}.\n \n handle_cast(_Msg, State) ->\n     {noreply, State}.\n \n-handle_info({http_response, Response}, State) ->\n-    % Handle asynchronous HTTP response if needed\n-    ?LOG_DEBUG(\"Received HTTP response: ~p\", [Response]),\n-    NewState = State#state{\n-        responses_received = State#state.responses_received + 1\n-    },\n-    {noreply, NewState};\n-\n handle_info({'EXIT', _Pid, Reason}, State) ->\n     ?LOG_WARNING(\"HTTP transport received EXIT signal: ~p\", [Reason]),\n     {noreply, State};\n-\n handle_info(_Info, State) ->\n     {noreply, State}.\n \n terminate(_Reason, State) ->\n@@ -306,204 +225,112 @@\n %% Internal Functions\n %%====================================================================\n \n %% @private\n-%% Validate HTTP transport options\n--spec validate_http_opts(map()) -> ok | {error, term()}.\n-validate_http_opts(Opts) ->\n+%% Validate HTTP transport configuration\n+-spec validate_http_config(map()) -> ok | {error, term()}.\n+validate_http_config(Config) ->\n     try\n         % Check required fields\n-        case maps:get(url, Opts, undefined) of\n-            undefined -> throw(missing_url);\n-            Url -> validate_url(Url)\n+        case maps:get(transport_id, Config, undefined) of\n+            undefined ->\n+                throw(missing_transport_id);\n+            Id when is_atom(Id) ->\n+                ok;\n+            _ ->\n+                throw(invalid_transport_id)\n         end,\n-        \n-        case maps:get(owner, Opts, undefined) of\n-            undefined -> throw(missing_owner);\n-            Owner when is_pid(Owner) -> ok;\n-            _ -> throw(invalid_owner)\n+\n+        case maps:get(url, Config, undefined) of\n+            undefined ->\n+                throw(missing_url);\n+            Url ->\n+                validate_url(Url)\n         end,\n-        \n-        validate_extended_http_opts(Opts)\n+\n+        % Validate optional fields\n+        validate_optional_config(Config)\n     catch\n-        throw:Reason -> {error, Reason};\n-        Class:Reason -> {error, {validation_error, Class, Reason}}\n+        throw:Reason ->\n+            {error, Reason};\n+        Class:Reason ->\n+            {error, {validation_error, Class, Reason}}\n     end.\n \n %% @private\n-%% duplicate older helper removed; canonical version exists below\n-\n-%% @private\n-%% Validate extended HTTP options\n--spec validate_extended_http_opts(map()) -> ok | {error, term()}.\n-validate_extended_http_opts(Opts) ->\n+%% Validate optional configuration fields\n+-spec validate_optional_config(map()) -> ok | {error, term()}.\n+validate_optional_config(Config) ->\n     try\n-        % Validate method\n-        Method = maps:get(method, Opts, post),\n-        case lists:member(Method, [get, post, put, delete]) of\n-            true -> ok;\n-            false -> throw({invalid_method, Method})\n+        % Validate timeout if present\n+        case maps:get(timeout, Config, undefined) of\n+            undefined -> ok;\n+            Timeout when is_integer(Timeout), Timeout > 0 -> ok;\n+            _ -> throw({invalid_timeout, maps:get(timeout, Config)})\n         end,\n-        \n-        % Validate timeouts\n-        Timeout = maps:get(timeout, Opts, 30000),\n-        case is_integer(Timeout) andalso Timeout > 0 of\n-            true -> ok;\n-            false -> throw({invalid_timeout, Timeout})\n+\n+        % Validate headers if present\n+        case maps:get(headers, Config, undefined) of\n+            undefined -> ok;\n+            Headers when is_list(Headers) -> ok;\n+            _ -> throw({invalid_headers, maps:get(headers, Config)})\n         end,\n-        \n-        ConnectTimeout = maps:get(connect_timeout, Opts, 10000),\n-        case is_integer(ConnectTimeout) andalso ConnectTimeout > 0 of\n-            true -> ok;\n-            false -> throw({invalid_connect_timeout, ConnectTimeout})\n-        end,\n-        \n-        % Validate retries\n-        MaxRetries = maps:get(max_retries, Opts, 3),\n-        case is_integer(MaxRetries) andalso MaxRetries >= 0 of\n-            true -> ok;\n-            false -> throw({invalid_max_retries, MaxRetries})\n-        end,\n-        \n+\n         ok\n     catch\n-        throw:Reason -> {error, Reason};\n-        Class:Reason -> {error, {validation_error, Class, Reason}}\n+        throw:Reason ->\n+            {error, Reason}\n     end.\n \n %% @private\n-%% Send data with retry logic\n--spec send_with_retry(state(), iodata(), non_neg_integer()) -> ok | {error, term()}.\n-send_with_retry(_State, _Data, 0) ->\n-    {error, max_retries_exceeded};\n-send_with_retry(State, Data, RetriesLeft) ->\n-    case send_http_request(State, Data) of\n-        {ok, _Response} ->\n-            ok;\n-        {error, Reason} = Error ->\n-            case should_retry(Reason) of\n-                true when RetriesLeft > 1 ->\n-                    timer:sleep(State#state.retry_delay),\n-                    send_with_retry(State, Data, RetriesLeft - 1);\n-                _ ->\n-                    Error\n-            end\n-    end.\n+%% Merge user headers with defaults\n+-spec merge_headers([{string(), string()}]) -> [{string(), string()}].\n+merge_headers(UserHeaders) ->\n+    % Convert to maps for easier merging\n+    DefaultMap = maps:from_list(?DEFAULT_HEADERS),\n+    UserMap = maps:from_list(UserHeaders),\n \n-%% @private\n-%% Send actual HTTP request\n--spec send_http_request(state(), iodata()) -> {ok, term()} | {error, term()}.\n-send_http_request(State, Data) ->\n-    #state{\n-        url = Url,\n-        method = Method,\n-        headers = Headers,\n-        timeout = _Timeout,\n-        ssl_options = _SSLOpts,\n-        http_client_options = _ClientOpts\n-    } = State,\n-    \n-    try\n-        % Ensure data is binary\n-        Body = iolist_to_binary(Data),\n-        \n-        % Build request options\n-        RequestOpts = build_request_options(State),\n-        \n-        % Make HTTP request using httpc\n-        case Method of\n-            get ->\n-                httpc:request(get, {binary_to_list(Url), Headers}, RequestOpts, []);\n-            post ->\n-                ContentType = proplists:get_value(\"Content-Type\", Headers, \"application/json\"),\n-                httpc:request(post, {binary_to_list(Url), Headers, ContentType, Body}, \n-                            RequestOpts, []);\n-            put ->\n-                ContentType = proplists:get_value(\"Content-Type\", Headers, \"application/json\"),\n-                httpc:request(put, {binary_to_list(Url), Headers, ContentType, Body}, \n-                            RequestOpts, []);\n-            delete ->\n-                httpc:request(delete, {binary_to_list(Url), Headers}, RequestOpts, [])\n-        end\n-    catch\n-        Class:Reason:Stacktrace ->\n-            ?LOG_ERROR(\"HTTP request failed: ~p:~p~n~p\", [Class, Reason, Stacktrace]),\n-            {error, {http_request_failed, Class, Reason}}\n-    end.\n+    % User headers override defaults\n+    MergedMap = maps:merge(DefaultMap, UserMap),\n+    maps:to_list(MergedMap).\n \n %% @private\n-%% Build HTTP request options\n--spec build_request_options(state()) -> proplists:proplist().\n-build_request_options(State) ->\n+%% Build HTTP options\n+-spec build_http_options(map()) -> [term()].\n+build_http_options(Config) ->\n     BaseOpts = [\n-        {timeout, State#state.timeout},\n-        {connect_timeout, State#state.connect_timeout}\n+        {timeout, maps:get(timeout, Config, 30000)},\n+        {connect_timeout, maps:get(connect_timeout, Config, 10000)}\n     ],\n     \n     % Add SSL options if URL is HTTPS\n-    case binary:match(State#state.url, <<\"https://\">>) of\n-        {0, _} ->\n-            [{ssl, State#state.ssl_options} | BaseOpts];\n-        nomatch ->\n+    Url = maps:get(url, Config),\n+    case is_https_url(Url) of\n+        true ->\n+            SslOpts = maps:get(ssl_options, Config, []),\n+            [{ssl, SslOpts} | BaseOpts];\n+        false ->\n             BaseOpts\n     end.\n \n %% @private\n-%% Test connection to the HTTP endpoint\n--spec test_connection(state()) -> ok | {error, term()}.\n-test_connection(State) ->\n-    % Simple HEAD request to test connectivity\n-    TestUrl = binary_to_list(State#state.url),\n-    RequestOpts = build_request_options(State#state{timeout = 5000}),\n-    \n-    case httpc:request(head, {TestUrl, []}, RequestOpts, []) of\n-        {ok, {{_, Status, _}, _, _}} when Status >= 200, Status < 400 ->\n-            ok;\n-        {ok, {{_, Status, _}, _, _}} ->\n-            {error, {http_status, Status}};\n-        {error, Reason} ->\n-            {error, {connection_test_failed, Reason}}\n-    end.\n+%% Build request options\n+-spec build_request_options(map()) -> [term()].\n+build_request_options(_Config) ->\n+    [{body_format, binary}].\n \n %% @private\n-%% Determine if an error should trigger a retry\n--spec should_retry(term()) -> boolean().\n-should_retry({http_status, Status}) when Status >= 500 ->\n-    true;\n-should_retry({connection_test_failed, _}) ->\n-    true;\n-should_retry(timeout) ->\n-    true;\n-should_retry(connect_timeout) ->\n-    true;\n-should_retry({socket_error, _}) ->\n-    true;\n-should_retry(_) ->\n-    false.\n+%% Check if URL is HTTPS\n+-spec is_https_url(binary() | string()) -> boolean().\n+is_https_url(Url) when is_binary(Url) ->\n+    is_https_url(binary_to_list(Url));\n+is_https_url(Url) when is_list(Url) ->\n+    case string:prefix(Url, \"https://\") of\n+        nomatch -> false;\n+        _ -> true\n+    end.\n \n %% @private\n-%% Merge user headers with defaults\n--spec merge_headers([{string(), string()}]) -> [{string(), string()}].\n-merge_headers(UserHeaders) ->\n-    % Convert to maps for easier merging\n-    DefaultMap = maps:from_list(?DEFAULT_HEADERS),\n-    UserMap = maps:from_list(UserHeaders),\n-    \n-    % User headers override defaults\n-    MergedMap = maps:merge(DefaultMap, UserMap),\n-    maps:to_list(MergedMap).\n-\n-%% @private\n-%% Build HTTP client options\n--spec build_client_options(map()) -> map().\n-build_client_options(Opts) ->\n-    #{\n-        pool_size => maps:get(pool_size, Opts, 10),\n-        max_sessions => maps:get(max_sessions, Opts, 20),\n-        keep_alive => maps:get(keep_alive, Opts, true)\n-    }.\n-\n-%% @private\n %% Validate URL format\n -spec validate_url(binary() | string()) -> ok | no_return().\n validate_url(Url) when is_binary(Url) ->\n     validate_url(binary_to_list(Url));\n@@ -523,47 +350,43 @@\n validate_url(_) ->\n     throw(invalid_url_type).\n \n %% @private\n-%% Ensure value is binary\n--spec ensure_binary(binary() | string()) -> binary().\n-ensure_binary(Value) when is_binary(Value) ->\n-    Value;\n-ensure_binary(Value) when is_list(Value) ->\n-    list_to_binary(Value).\n+%% Ensure value is string\n+-spec ensure_string(binary() | string()) -> string().\n+ensure_string(Value) when is_binary(Value) ->\n+    binary_to_list(Value);\n+ensure_string(Value) when is_list(Value) ->\n+    Value.\n \n %% @private\n %% Register transport with the registry\n--spec register_with_registry(state()) -> ok.\n-register_with_registry(#state{transport_id = TransportId} = State) ->\n+-spec register_with_registry(#state{}) -> ok.\n+register_with_registry(#state{transport_id = TransportId, config = Config}) ->\n     case whereis(erlmcp_registry) of\n         undefined ->\n             ?LOG_WARNING(\"Registry not available for HTTP transport ~p\", [TransportId]),\n             ok;\n         RegistryPid when is_pid(RegistryPid) ->\n-            Config = #{\n+            TransportConfig = #{\n                 type => http,\n-                url => State#state.url,\n-                method => State#state.method,\n-                timeout => State#state.timeout,\n-                capabilities => [client, json_rpc, ssl, retry]\n+                url => maps:get(url, Config),\n+                timeout => maps:get(timeout, Config, 30000),\n+                capabilities => [client, json_rpc, ssl]\n             },\n-            case erlmcp_registry:register_transport(TransportId, self(), Config) of\n+            case erlmcp_registry:register_transport(TransportId, self(), TransportConfig) of\n                 ok ->\n                     ?LOG_DEBUG(\"Registered HTTP transport ~p with registry\", [TransportId]),\n                     ok;\n                 {error, Reason} ->\n-                    ?LOG_ERROR(\"Failed to register HTTP transport ~p: ~p\", \n-                             [TransportId, Reason]),\n+                    ?LOG_ERROR(\"Failed to register HTTP transport ~p: ~p\", [TransportId, Reason]),\n                     ok\n             end\n     end.\n \n %% @private\n %% Unregister transport from the registry\n--spec unregister_from_registry(state()) -> ok.\n-unregister_from_registry(#state{transport_id = undefined}) ->\n-    ok;\n+-spec unregister_from_registry(#state{}) -> ok.\n unregister_from_registry(#state{transport_id = TransportId}) ->\n     case whereis(erlmcp_registry) of\n         undefined ->\n             ok;\n@@ -572,9 +395,9 @@\n                 ok ->\n                     ?LOG_DEBUG(\"Unregistered HTTP transport ~p from registry\", [TransportId]),\n                     ok;\n                 {error, Reason} ->\n-                    ?LOG_WARNING(\"Failed to unregister HTTP transport ~p: ~p\", \n-                               [TransportId, Reason]),\n+                    ?LOG_WARNING(\"Failed to unregister HTTP transport ~p: ~p\",\n+                                 [TransportId, Reason]),\n                     ok\n             end\n     end.\n\\ No newline at end of file\n"
                },
                {
                    "date": 1756189616246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,9 +156,9 @@\n \n %% @doc Handle transport-specific calls\n -spec handle_transport_call(term(), #state{}) ->\n                                {reply, term(), #state{}} | {error, term()}.\n-handle_transport_call(get_url, State) ->\n+eandle_transport_call(get_url, State) ->\n     {reply, State#state.url, State};\n handle_transport_call({set_headers, Headers}, State) when is_list(Headers) ->\n     NewHeaders = merge_headers(Headers),\n     NewState = State#state{headers = NewHeaders},\n"
                }
            ],
            "date": 1756188161125,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @doc\n%%% Simplified HTTP Transport for Erlang MCP (Model Context Protocol)\n%%% \n%%% This module provides a simplified HTTP client transport implementation\n%%% for MCP. It focuses on the core use case: making HTTP requests to MCP \n%%% servers and handling JSON-RPC 2.0 responses over HTTP.\n%%%\n%%% Features:\n%%% - HTTP/HTTPS client functionality\n%%% - JSON-RPC 2.0 over HTTP\n%%% - Registry integration\n%%% - Proper error handling and timeouts\n%%% - SSL/TLS support\n%%% - Connection pooling\n%%% - Retry logic\n%%%\n%%% @end\n%%%-------------------------------------------------------------------\n-module(erlmcp_transport_http).\n-behaviour(gen_server).\n\n-include(\"erlmcp.hrl\").\n-include_lib(\"kernel/include/logger.hrl\").\n\n%% Transport API\n-export([\n    send/2,\n    close/1,\n    get_info/1,\n    handle_transport_call/2\n]).\n\n%% API\n-export([\n    start_link/2,\n    start_link/3,\n    stop/1\n]).\n\n%% gen_server callbacks\n-export([\n    init/1,\n    handle_call/3,\n    handle_cast/2,\n    handle_info/2,\n    terminate/2,\n    code_change/3\n]).\n\n%% Types\n-type http_method() :: get | post | put | delete.\n-type http_headers() :: [{string(), string()}].\n\n%% Simplified state record focused on MCP use case\n-record(state, {\n    %% Core identification\n    transport_id :: atom(),\n    owner_pid :: pid(),\n    registry_pid :: pid() | undefined,\n    \n    %% HTTP client configuration  \n    url :: binary(),\n    method = post :: http_method(),\n    headers = [] :: http_headers(),\n    \n    %% Connection settings\n    timeout = 30000 :: timeout(),\n    connect_timeout = 10000 :: timeout(),\n    ssl_options = [] :: [ssl:tls_client_option()],\n    \n    %% Retry and reliability\n    max_retries = 3 :: non_neg_integer(),\n    retry_delay = 1000 :: pos_integer(),\n    \n    %% State tracking\n    connected = false :: boolean(),\n    error_count = 0 :: non_neg_integer(),\n    last_error :: term() | undefined,\n    \n    %% Statistics\n    requests_sent = 0 :: non_neg_integer(),\n    responses_received = 0 :: non_neg_integer(),\n    bytes_sent = 0 :: non_neg_integer(),\n    bytes_received = 0 :: non_neg_integer(),\n    \n    %% Internal\n    http_client_options :: map()\n}).\n\n-type state() :: #state{}.\n\n%% Default HTTP headers for MCP\n-define(DEFAULT_HEADERS, [\n    {\"Content-Type\", \"application/json\"},\n    {\"Accept\", \"application/json\"},\n    {\"User-Agent\", \"erlmcp-http-transport/1.0\"}\n]).\n\n%%====================================================================\n%% Transport API Implementation\n%%====================================================================\n\n-spec send(state(), iodata()) -> ok | {error, term()}.\nsend(State, Data) ->\n    send_with_retry(State, Data, State#state.max_retries).\n\n-spec close(state()) -> ok.\nclose(State) ->\n    unregister_from_registry(State),\n    ?LOG_INFO(\"HTTP transport closed for URL: ~s\", [State#state.url]),\n    ok.\n\n-spec get_info(state()) -> erlmcp_transport:transport_info().\nget_info(State) ->\n    #{\n        type => http,\n        version => <<\"1.0\">>,\n        capabilities => [client, json_rpc, ssl, retry],\n        connection_state => case State#state.connected of\n            true -> connected;\n            false -> disconnected\n        end,\n        statistics => #{\n            requests_sent => State#state.requests_sent,\n            responses_received => State#state.responses_received,\n            bytes_sent => State#state.bytes_sent,\n            bytes_received => State#state.bytes_received,\n            error_count => State#state.error_count\n        },\n        url => State#state.url,\n        method => State#state.method,\n        timeout => State#state.timeout,\n        last_error => State#state.last_error\n    }.\n\n-spec handle_transport_call(term(), state()) -> \n    {reply, term(), state()} | {error, term()}.\nhandle_transport_call(get_url, State) ->\n    {reply, State#state.url, State};\nhandle_transport_call({set_timeout, Timeout}, State) \n  when is_integer(Timeout), Timeout > 0 ->\n    NewState = State#state{timeout = Timeout},\n    {reply, ok, NewState};\nhandle_transport_call({set_headers, Headers}, State) when is_list(Headers) ->\n    NewState = State#state{headers = merge_headers(Headers)},\n    {reply, ok, NewState};\nhandle_transport_call(reset_stats, State) ->\n    NewState = State#state{\n        requests_sent = 0,\n        responses_received = 0,\n        bytes_sent = 0,\n        bytes_received = 0,\n        error_count = 0,\n        last_error = undefined\n    },\n    {reply, ok, NewState};\nhandle_transport_call(reconnect, State) ->\n    % For HTTP, reconnect means testing the connection\n    case test_connection(State) of\n        ok ->\n            NewState = State#state{connected = true, last_error = undefined},\n            {reply, ok, NewState};\n        {error, Reason} ->\n            NewState = State#state{\n                connected = false,\n                last_error = Reason,\n                error_count = State#state.error_count + 1\n            },\n            {reply, {error, Reason}, NewState}\n    end;\nhandle_transport_call(_Request, _State) ->\n    {error, unknown_request}.\n\n%%====================================================================\n%% API Functions\n%%====================================================================\n\n-spec start_link(atom(), map()) -> {ok, pid()} | {error, term()}.\nstart_link(TransportId, Opts) ->\n    gen_server:start_link(?MODULE, [TransportId, Opts], []).\n\n-spec start_link(atom(), atom(), map()) -> {ok, pid()} | {error, term()}.\nstart_link(TransportId, Name, Opts) ->\n    gen_server:start_link({local, Name}, ?MODULE, [TransportId, Opts], []).\n\n-spec stop(pid()) -> ok.\nstop(Pid) ->\n    gen_server:stop(Pid).\n\n%%====================================================================\n%% gen_server callbacks\n%%====================================================================\n\ninit([TransportId, Opts]) ->\n    process_flag(trap_exit, true),\n    \n    ?LOG_DEBUG(\"Initializing HTTP transport ~p with opts: ~p\", [TransportId, Opts]),\n    \n    case validate_http_opts(Opts) of\n        ok ->\n            Url = maps:get(url, Opts),\n            OwnerPid = maps:get(owner, Opts),\n            \n            State = #state{\n                transport_id = TransportId,\n                url = ensure_binary(Url),\n                owner_pid = OwnerPid,\n                method = maps:get(method, Opts, post),\n                headers = merge_headers(maps:get(headers, Opts, [])),\n                timeout = maps:get(timeout, Opts, 30000),\n                connect_timeout = maps:get(connect_timeout, Opts, 10000),\n                ssl_options = maps:get(ssl_options, Opts, []),\n                max_retries = maps:get(max_retries, Opts, 3),\n                retry_delay = maps:get(retry_delay, Opts, 1000),\n                http_client_options = build_client_options(Opts)\n            },\n            \n            % Register with registry if available\n            register_with_registry(State),\n            \n            % Test initial connection\n            case test_connection(State) of\n                ok ->\n                    FinalState = State#state{connected = true},\n                    ?LOG_INFO(\"HTTP transport ~p started successfully\", [TransportId]),\n                    {ok, FinalState};\n                {error, Reason} ->\n                    ?LOG_WARNING(\"HTTP transport ~p started but connection test failed: ~p\", \n                               [TransportId, Reason]),\n                    FinalState = State#state{\n                        connected = false,\n                        last_error = Reason,\n                        error_count = 1\n                    },\n                    {ok, FinalState}\n            end;\n            \n        {error, Reason} ->\n            ?LOG_ERROR(\"Failed to initialize HTTP transport ~p: ~p\", [TransportId, Reason]),\n            {stop, Reason}\n    end.\n\nhandle_call({send, Data}, _From, State) ->\n    case send(State, Data) of\n        ok ->\n            NewState = State#state{\n                requests_sent = State#state.requests_sent + 1,\n                bytes_sent = State#state.bytes_sent + iolist_size(Data)\n            },\n            {reply, ok, NewState};\n        {error, Reason} = Error ->\n            NewState = State#state{\n                error_count = State#state.error_count + 1,\n                last_error = Reason,\n                connected = false\n            },\n            {reply, Error, NewState}\n    end;\n\nhandle_call(close, _From, State) ->\n    close(State),\n    {stop, normal, ok, State};\n\nhandle_call(get_info, _From, State) ->\n    Info = get_info(State),\n    {reply, Info, State};\n\nhandle_call({transport_call, Request}, _From, State) ->\n    case handle_transport_call(Request, State) of\n        {reply, Reply, NewState} ->\n            {reply, Reply, NewState};\n        {error, Reason} ->\n            {reply, {error, Reason}, State}\n    end;\n\nhandle_call(_Request, _From, State) ->\n    {reply, {error, unknown_request}, State}.\n\nhandle_cast(_Msg, State) ->\n    {noreply, State}.\n\nhandle_info({http_response, Response}, State) ->\n    % Handle asynchronous HTTP response if needed\n    ?LOG_DEBUG(\"Received HTTP response: ~p\", [Response]),\n    NewState = State#state{\n        responses_received = State#state.responses_received + 1\n    },\n    {noreply, NewState};\n\nhandle_info({'EXIT', _Pid, Reason}, State) ->\n    ?LOG_WARNING(\"HTTP transport received EXIT signal: ~p\", [Reason]),\n    {noreply, State};\n\nhandle_info(_Info, State) ->\n    {noreply, State}.\n\nterminate(_Reason, State) ->\n    close(State),\n    ok.\n\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\n%%====================================================================\n%% Internal Functions\n%%====================================================================\n\n%% @private\n%% Validate HTTP transport options\n-spec validate_http_opts(map()) -> ok | {error, term()}.\nvalidate_http_opts(Opts) ->\n    try\n        % Check required fields\n        case maps:get(url, Opts, undefined) of\n            undefined -> throw(missing_url);\n            Url -> validate_url(Url)\n        end,\n        \n        case maps:get(owner, Opts, undefined) of\n            undefined -> throw(missing_owner);\n            Owner when is_pid(Owner) -> ok;\n            _ -> throw(invalid_owner)\n        end,\n        \n        validate_extended_http_opts(Opts)\n    catch\n        throw:Reason -> {error, Reason};\n        Class:Reason -> {error, {validation_error, Class, Reason}}\n    end.\n\n%% @private\n%% duplicate older helper removed; canonical version exists below\n\n%% @private\n%% Validate extended HTTP options\n-spec validate_extended_http_opts(map()) -> ok | {error, term()}.\nvalidate_extended_http_opts(Opts) ->\n    try\n        % Validate method\n        Method = maps:get(method, Opts, post),\n        case lists:member(Method, [get, post, put, delete]) of\n            true -> ok;\n            false -> throw({invalid_method, Method})\n        end,\n        \n        % Validate timeouts\n        Timeout = maps:get(timeout, Opts, 30000),\n        case is_integer(Timeout) andalso Timeout > 0 of\n            true -> ok;\n            false -> throw({invalid_timeout, Timeout})\n        end,\n        \n        ConnectTimeout = maps:get(connect_timeout, Opts, 10000),\n        case is_integer(ConnectTimeout) andalso ConnectTimeout > 0 of\n            true -> ok;\n            false -> throw({invalid_connect_timeout, ConnectTimeout})\n        end,\n        \n        % Validate retries\n        MaxRetries = maps:get(max_retries, Opts, 3),\n        case is_integer(MaxRetries) andalso MaxRetries >= 0 of\n            true -> ok;\n            false -> throw({invalid_max_retries, MaxRetries})\n        end,\n        \n        ok\n    catch\n        throw:Reason -> {error, Reason};\n        Class:Reason -> {error, {validation_error, Class, Reason}}\n    end.\n\n%% @private\n%% Send data with retry logic\n-spec send_with_retry(state(), iodata(), non_neg_integer()) -> ok | {error, term()}.\nsend_with_retry(_State, _Data, 0) ->\n    {error, max_retries_exceeded};\nsend_with_retry(State, Data, RetriesLeft) ->\n    case send_http_request(State, Data) of\n        {ok, _Response} ->\n            ok;\n        {error, Reason} = Error ->\n            case should_retry(Reason) of\n                true when RetriesLeft > 1 ->\n                    timer:sleep(State#state.retry_delay),\n                    send_with_retry(State, Data, RetriesLeft - 1);\n                _ ->\n                    Error\n            end\n    end.\n\n%% @private\n%% Send actual HTTP request\n-spec send_http_request(state(), iodata()) -> {ok, term()} | {error, term()}.\nsend_http_request(State, Data) ->\n    #state{\n        url = Url,\n        method = Method,\n        headers = Headers,\n        timeout = _Timeout,\n        ssl_options = _SSLOpts,\n        http_client_options = _ClientOpts\n    } = State,\n    \n    try\n        % Ensure data is binary\n        Body = iolist_to_binary(Data),\n        \n        % Build request options\n        RequestOpts = build_request_options(State),\n        \n        % Make HTTP request using httpc\n        case Method of\n            get ->\n                httpc:request(get, {binary_to_list(Url), Headers}, RequestOpts, []);\n            post ->\n                ContentType = proplists:get_value(\"Content-Type\", Headers, \"application/json\"),\n                httpc:request(post, {binary_to_list(Url), Headers, ContentType, Body}, \n                            RequestOpts, []);\n            put ->\n                ContentType = proplists:get_value(\"Content-Type\", Headers, \"application/json\"),\n                httpc:request(put, {binary_to_list(Url), Headers, ContentType, Body}, \n                            RequestOpts, []);\n            delete ->\n                httpc:request(delete, {binary_to_list(Url), Headers}, RequestOpts, [])\n        end\n    catch\n        Class:Reason:Stacktrace ->\n            ?LOG_ERROR(\"HTTP request failed: ~p:~p~n~p\", [Class, Reason, Stacktrace]),\n            {error, {http_request_failed, Class, Reason}}\n    end.\n\n%% @private\n%% Build HTTP request options\n-spec build_request_options(state()) -> proplists:proplist().\nbuild_request_options(State) ->\n    BaseOpts = [\n        {timeout, State#state.timeout},\n        {connect_timeout, State#state.connect_timeout}\n    ],\n    \n    % Add SSL options if URL is HTTPS\n    case binary:match(State#state.url, <<\"https://\">>) of\n        {0, _} ->\n            [{ssl, State#state.ssl_options} | BaseOpts];\n        nomatch ->\n            BaseOpts\n    end.\n\n%% @private\n%% Test connection to the HTTP endpoint\n-spec test_connection(state()) -> ok | {error, term()}.\ntest_connection(State) ->\n    % Simple HEAD request to test connectivity\n    TestUrl = binary_to_list(State#state.url),\n    RequestOpts = build_request_options(State#state{timeout = 5000}),\n    \n    case httpc:request(head, {TestUrl, []}, RequestOpts, []) of\n        {ok, {{_, Status, _}, _, _}} when Status >= 200, Status < 400 ->\n            ok;\n        {ok, {{_, Status, _}, _, _}} ->\n            {error, {http_status, Status}};\n        {error, Reason} ->\n            {error, {connection_test_failed, Reason}}\n    end.\n\n%% @private\n%% Determine if an error should trigger a retry\n-spec should_retry(term()) -> boolean().\nshould_retry({http_status, Status}) when Status >= 500 ->\n    true;\nshould_retry({connection_test_failed, _}) ->\n    true;\nshould_retry(timeout) ->\n    true;\nshould_retry(connect_timeout) ->\n    true;\nshould_retry({socket_error, _}) ->\n    true;\nshould_retry(_) ->\n    false.\n\n%% @private\n%% Merge user headers with defaults\n-spec merge_headers([{string(), string()}]) -> [{string(), string()}].\nmerge_headers(UserHeaders) ->\n    % Convert to maps for easier merging\n    DefaultMap = maps:from_list(?DEFAULT_HEADERS),\n    UserMap = maps:from_list(UserHeaders),\n    \n    % User headers override defaults\n    MergedMap = maps:merge(DefaultMap, UserMap),\n    maps:to_list(MergedMap).\n\n%% @private\n%% Build HTTP client options\n-spec build_client_options(map()) -> map().\nbuild_client_options(Opts) ->\n    #{\n        pool_size => maps:get(pool_size, Opts, 10),\n        max_sessions => maps:get(max_sessions, Opts, 20),\n        keep_alive => maps:get(keep_alive, Opts, true)\n    }.\n\n%% @private\n%% Validate URL format\n-spec validate_url(binary() | string()) -> ok | no_return().\nvalidate_url(Url) when is_binary(Url) ->\n    validate_url(binary_to_list(Url));\nvalidate_url(Url) when is_list(Url) ->\n    HasHttp = case string:prefix(Url, \"http://\") of\n        nomatch -> false;\n        _ -> true\n    end,\n    HasHttps = case string:prefix(Url, \"https://\") of\n        nomatch -> false;\n        _ -> true\n    end,\n    case HasHttp orelse HasHttps of\n        false -> throw(invalid_url_format);\n        true -> ok\n    end;\nvalidate_url(_) ->\n    throw(invalid_url_type).\n\n%% @private\n%% Ensure value is binary\n-spec ensure_binary(binary() | string()) -> binary().\nensure_binary(Value) when is_binary(Value) ->\n    Value;\nensure_binary(Value) when is_list(Value) ->\n    list_to_binary(Value).\n\n%% @private\n%% Register transport with the registry\n-spec register_with_registry(state()) -> ok.\nregister_with_registry(#state{transport_id = TransportId} = State) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            ?LOG_WARNING(\"Registry not available for HTTP transport ~p\", [TransportId]),\n            ok;\n        RegistryPid when is_pid(RegistryPid) ->\n            Config = #{\n                type => http,\n                url => State#state.url,\n                method => State#state.method,\n                timeout => State#state.timeout,\n                capabilities => [client, json_rpc, ssl, retry]\n            },\n            case erlmcp_registry:register_transport(TransportId, self(), Config) of\n                ok ->\n                    ?LOG_DEBUG(\"Registered HTTP transport ~p with registry\", [TransportId]),\n                    ok;\n                {error, Reason} ->\n                    ?LOG_ERROR(\"Failed to register HTTP transport ~p: ~p\", \n                             [TransportId, Reason]),\n                    ok\n            end\n    end.\n\n%% @private\n%% Unregister transport from the registry\n-spec unregister_from_registry(state()) -> ok.\nunregister_from_registry(#state{transport_id = undefined}) ->\n    ok;\nunregister_from_registry(#state{transport_id = TransportId}) ->\n    case whereis(erlmcp_registry) of\n        undefined ->\n            ok;\n        RegistryPid when is_pid(RegistryPid) ->\n            case erlmcp_registry:unregister_transport(TransportId) of\n                ok ->\n                    ?LOG_DEBUG(\"Unregistered HTTP transport ~p from registry\", [TransportId]),\n                    ok;\n                {error, Reason} ->\n                    ?LOG_WARNING(\"Failed to unregister HTTP transport ~p: ~p\", \n                               [TransportId, Reason]),\n                    ok\n            end\n    end."
        }
    ]
}