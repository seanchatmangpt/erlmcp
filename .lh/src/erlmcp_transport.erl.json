{
    "sourceFile": "src/erlmcp_transport.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1756188802720,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756190116841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -793,10 +793,10 @@\n                         NewStats = increment_error_statistics(maps:get(statistics, State, #{})),\n                         {error, {send_failed, Reason}, State#{statistics => NewStats}}\n                 end\n             catch\n-                Class:ExceptionReason:Stack ->\n-                    {error, {transport_callback_error, {Class, ExceptionReason, Stack}}, State}\n+                Class:CReason:CStack ->\n+                    {error, {transport_callback_error, {Class, CReason, CStack}}, State}\n             end;\n         _ ->\n             {error, {wrong_server_id, ServerId}, State}\n     end;\n"
                },
                {
                    "date": 1756190131041,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -793,10 +793,10 @@\n                         NewStats = increment_error_statistics(maps:get(statistics, State, #{})),\n                         {error, {send_failed, Reason}, State#{statistics => NewStats}}\n                 end\n             catch\n-                Class:ExceptionReason:Stack ->\n-                    {error, {transport_callback_error, {Class, ExceptionReason, Stack}}, State}\n+                Class:CReason:CStack ->\n+                    {error, {transport_callback_error, {Class, CReason, CStack}}, State}\n             end;\n         _ ->\n             {error, {wrong_server_id, ServerId}, State}\n     end;\n"
                }
            ],
            "date": 1756188802720,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @doc\n%%% Transport Behavior Interface for Erlang MCP (Model Context Protocol)\n%%%\n%%% This module defines the behavior interface that all transport modules\n%%% must implement. It provides a standardized API for different transport\n%%% mechanisms including stdio, TCP, HTTP, and WebSocket.\n%%%\n%%% == Core Responsibilities ==\n%%% \n%%% 1. **Transport Abstraction**: Provides a uniform interface across\n%%%    different transport mechanisms\n%%% 2. **Message Framing**: Handles protocol-specific message framing\n%%% 3. **Connection Management**: Manages connection lifecycle and state\n%%% 4. **Error Handling**: Provides consistent error reporting\n%%%\n%%% == Transport Message Flow ==\n%%%\n%%% ```\n%%% Client/Server -> Transport:send/2 -> Network -> Transport:receive\n%%%                     |                            |\n%%%                     v                            v\n%%%               Message Encoding            Message Decoding\n%%%                     |                            |\n%%%                     v                            v\n%%%                Network Protocol         {transport_message, Data}\n%%% ```\n%%%\n%%% == Standard Message Format ==\n%%%\n%%% All transport messages follow the MCP JSON-RPC 2.0 format:\n%%%\n%%% ```erlang\n%%% #{<<\"jsonrpc\">> => <<\"2.0\">>,\n%%%   <<\"id\">> => Id,           % null | binary() | integer()\n%%%   <<\"method\">> => Method,   % binary()\n%%%   <<\"params\">> => Params}   % map() | list() | undefined\n%%% ```\n%%%\n%%% == Implementation Guide ==\n%%%\n%%% Transport modules must implement the core callbacks:\n%%%\n%%% ```erlang\n%%% -module(my_transport).\n%%% -behaviour(erlmcp_transport).\n%%%\n%%% %% Required callbacks\n%%% init(Opts) -> {ok, State} | {error, Reason}.\n%%% send(State, Message) -> ok | {error, Reason}.\n%%% close(State) -> ok.\n%%%\n%%% %% Optional callbacks\n%%% get_info(State) -> #{atom() => term()}.\n%%% handle_transport_call(Request, State) -> \n%%%     {reply, Reply, NewState} | {error, Reason}.\n%%% ```\n%%%\n%%% @end\n%%%-------------------------------------------------------------------\n-module(erlmcp_transport).\n\n-include(\"erlmcp.hrl\").\n\n%% =============================================================================\n%% Type Definitions\n%% =============================================================================\n\n%% @doc Transport implementation state\n%% This is an opaque term maintained by each transport implementation\n-type transport_state() :: term().\n\n%% @doc Transport configuration options\n%% Each transport defines its own option schema\n-type transport_opts() :: \n    stdio_opts() | tcp_opts() | http_opts() | websocket_opts() | \n    #{atom() => term()}.\n\n%% @doc Standard transport message format\n%% All messages sent through transports must follow this structure\n-type transport_message() :: #{binary() => term()}.\n\n%% @doc Standard transport messages sent to the registry\n%% These are the message types that transports send to notify about events\n-type transport_event_message() :: \n    {transport_data, Data :: binary()} |\n    {transport_connected, Info :: map()} |\n    {transport_disconnected, Reason :: term()} |\n    {transport_error, Type :: atom(), Reason :: term()}.\n\n%% @doc Transport information map\n%% Contains metadata about transport capabilities and state\n-type transport_info() :: #{\n    type => stdio | tcp | http | websocket | custom,\n    status => connected | disconnected | connecting | error,\n    peer => term(),\n    version => binary(),\n    capabilities => [atom()],\n    connection_state => connected | disconnected | connecting | error,\n    statistics => #{atom() => non_neg_integer()},\n    transport_id => atom(),\n    started_at => non_neg_integer(),\n    last_activity => non_neg_integer()\n}.\n\n%% @doc Transport-specific option types\n-type stdio_opts() :: #{\n    owner := pid(),\n    test_mode => boolean()\n}.\n\n-type tcp_opts() :: #{\n    host := inet:hostname() | inet:ip_address(),\n    port := inet:port_number(),\n    owner := pid(),\n    connect_timeout => timeout(),\n    keepalive => boolean(),\n    nodelay => boolean(),\n    buffer_size => pos_integer(),\n    max_reconnect_attempts => pos_integer() | infinity\n}.\n\n-type http_opts() :: #{\n    url := binary() | string(),\n    owner := pid(),\n    method => get | post,\n    headers => [{string() | binary(), string() | binary()}],\n    timeout => timeout(),\n    connect_timeout => timeout(),\n    max_retries => non_neg_integer(),\n    retry_delay => pos_integer(),\n    ssl_options => [ssl:tls_client_option()],\n    pool_size => pos_integer()\n}.\n\n-type websocket_opts() :: #{\n    url := binary() | string(),\n    owner := pid(),\n    protocols => [binary()],\n    headers => [{string() | binary(), string() | binary()}],\n    connect_timeout => timeout(),\n    ping_interval => timeout(),\n    ssl_options => [ssl:tls_client_option()]\n}.\n\n%% =============================================================================\n%% Callback Definitions\n%% =============================================================================\n\n%% @doc Initialize the transport with transport ID and configuration (recommended)\n%% \n%% This callback is called when the transport is started. It should:\n%% - Validate the provided options\n%% - Initialize the transport-specific state\n%% - Establish initial connections if required\n%% - Return the initial transport state\n%%\n%% @param TransportId Unique identifier for this transport instance\n%% @param Config Transport-specific configuration options\n%% @returns {ok, State} on success, {error, Reason} on failure\n-callback init(TransportId :: atom(), Config :: transport_opts()) -> \n    {ok, State :: transport_state()} | \n    {error, Reason :: term()}.\n\n%% @doc Send a message through the transport\n%%\n%% This callback handles message transmission. It should:\n%% - Encode the message according to transport protocol\n%% - Handle transport-specific framing\n%% - Manage connection state and errors\n%% - Provide appropriate error reporting\n%%\n%% @param State Current transport state\n%% @param Data Message data to send (JSON-encoded binary or iodata)\n%% @returns ok on success, {error, Reason} on failure\n-callback send(State :: transport_state(), Data :: iodata()) -> \n    ok | \n    {error, Reason :: term()}.\n\n%% @doc Close the transport and clean up resources\n%%\n%% This callback is called during transport shutdown. It should:\n%% - Close any open connections\n%% - Clean up resources (sockets, processes, etc.)\n%% - Ensure graceful termination\n%%\n%% @param State Current transport state\n%% @returns ok (always succeeds)\n-callback close(State :: transport_state()) -> \n    ok.\n\n%% @doc Get transport information and statistics (Optional)\n%%\n%% This optional callback provides introspection into transport state.\n%% Useful for monitoring, debugging, and health checks.\n%% \n%% The returned information should include:\n%% - type: Transport type (stdio, tcp, http, websocket, custom)\n%% - status: Current connection status \n%% - peer: Peer information (if applicable)\n%% - version: Transport version/protocol information\n%% - capabilities: List of supported features\n%% - statistics: Performance metrics and counters\n%% - transport_id: Unique transport identifier\n%% - started_at: Timestamp when transport was initialized\n%% - last_activity: Timestamp of last message activity\n%%\n%% @param State Current transport state\n%% @returns Map containing transport information\n-callback get_info(State :: transport_state()) -> \n    transport_info().\n\n%% @doc Handle transport-specific calls (Optional)\n%%\n%% This optional callback allows transports to handle custom requests.\n%% Useful for transport-specific operations like reconnection, \n%% configuration updates, or advanced features.\n%%\n%% @param Request Transport-specific request term\n%% @param State Current transport state  \n%% @returns {reply, Reply, NewState} or {error, Reason}\n-callback handle_transport_call(Request :: term(), State :: transport_state()) -> \n    {reply, Reply :: term(), NewState :: transport_state()} |\n    {error, Reason :: term()}.\n\n%% Specify optional callbacks\n%% New implementations should use init/2\n-optional_callbacks([\n    init/2,\n    get_info/1,\n    handle_transport_call/2\n]).\n\n%% =============================================================================\n%% Type Exports\n%% =============================================================================\n\n-export_type([\n    transport_state/0,\n    transport_opts/0,\n    transport_message/0,\n    transport_event_message/0,\n    transport_info/0,\n    stdio_opts/0,\n    tcp_opts/0,\n    http_opts/0,\n    websocket_opts/0\n]).\n\n%% =============================================================================\n%% Function Exports\n%% =============================================================================\n\n-export([\n    validate_message/1,\n    validate_transport_opts/2,\n    validate_transport_config/3,\n    validate_transport_event_message/1,\n    create_message/3,\n    create_notification/2,\n    create_response/2,\n    create_error_response/4,\n    create_transport_data_message/1,\n    create_transport_connected_message/1,\n    create_transport_disconnected_message/1,\n    create_transport_error_message/2\n]).\n\n%% =============================================================================\n%% API Functions \n%% =============================================================================\n\n%% @doc Validate a transport message format\n%% @param Message The message to validate\n%% @returns ok if valid, {error, Reason} if invalid\n-spec validate_message(term()) -> ok | {error, term()}.\nvalidate_message(Message) when is_map(Message) ->\n    case validate_json_rpc_fields(Message) of\n        ok -> validate_message_content(Message);\n        Error -> Error\n    end;\nvalidate_message(_) ->\n    {error, {invalid_message, not_a_map}}.\n\n%% @doc Validate a transport event message format\n%% @param Message The transport event message to validate\n%% @returns ok if valid, {error, Reason} if invalid\n-spec validate_transport_event_message(transport_event_message()) -> ok | {error, term()}.\nvalidate_transport_event_message({transport_data, Data}) when is_binary(Data) ->\n    ok;\nvalidate_transport_event_message({transport_connected, Info}) when is_map(Info) ->\n    ok;\nvalidate_transport_event_message({transport_disconnected, _Reason}) ->\n    ok;\nvalidate_transport_event_message({transport_error, Type, _Reason}) when is_atom(Type) ->\n    ok;\nvalidate_transport_event_message(_) ->\n    {error, invalid_transport_event_message}.\n\n%% @doc Validate transport options\n%% @param Type Transport type\n%% @param Opts Options to validate\n%% @returns ok if valid, {error, Reason} if invalid\n-spec validate_transport_opts(atom(), transport_opts()) -> ok | {error, term()}.\nvalidate_transport_opts(stdio, Opts) ->\n    validate_stdio_opts(Opts);\nvalidate_transport_opts(tcp, Opts) ->\n    validate_tcp_opts(Opts);\nvalidate_transport_opts(http, Opts) ->\n    validate_http_opts(Opts);\nvalidate_transport_opts(websocket, Opts) ->\n    validate_websocket_opts(Opts);\nvalidate_transport_opts(Type, _Opts) ->\n    {error, {unsupported_transport_type, Type}}.\n\n%% @doc Validate transport configuration for a specific transport ID\n%% @param TransportId Unique transport identifier\n%% @param Type Transport type\n%% @param Config Configuration map\n%% @returns ok if valid, {error, Reason} if invalid\n-spec validate_transport_config(atom(), atom(), map()) -> ok | {error, term()}.\nvalidate_transport_config(_TransportId, Type, Config) when is_map(Config) ->\n    validate_transport_opts(Type, Config);\nvalidate_transport_config(_TransportId, _Type, _Config) ->\n    {error, invalid_config_format}.\n\n%% @doc Create a standard transport message\n%% @param Method JSON-RPC method name\n%% @param Params Method parameters\n%% @param Id Request ID (optional)\n%% @returns Standard transport message map\n-spec create_message(binary(), json_rpc_params(), json_rpc_id()) -> \n    transport_message().\ncreate_message(Method, Params, Id) when is_binary(Method) ->\n    Base = #{\n        ?JSONRPC_FIELD_JSONRPC => ?JSONRPC_VERSION,\n        ?JSONRPC_FIELD_METHOD => Method\n    },\n    WithId = case Id of\n        undefined -> Base;\n        _ -> Base#{?JSONRPC_FIELD_ID => Id}\n    end,\n    case Params of\n        undefined -> WithId;\n        _ -> WithId#{?JSONRPC_FIELD_PARAMS => Params}\n    end.\n\n%% @doc Create a notification message (no ID)\n%% @param Method JSON-RPC method name\n%% @param Params Method parameters\n%% @returns Standard notification message map\n-spec create_notification(binary(), json_rpc_params()) -> transport_message().\ncreate_notification(Method, Params) ->\n    create_message(Method, Params, undefined).\n\n%% @doc Create a response message\n%% @param Id Request ID\n%% @param Result Response result\n%% @returns Standard response message map\n-spec create_response(json_rpc_id(), term()) -> transport_message().\ncreate_response(Id, Result) ->\n    #{\n        ?JSONRPC_FIELD_JSONRPC => ?JSONRPC_VERSION,\n        ?JSONRPC_FIELD_ID => Id,\n        ?JSONRPC_FIELD_RESULT => Result\n    }.\n\n%% @doc Create an error response message\n%% @param Id Request ID\n%% @param Code Error code\n%% @param Message Error message\n%% @param Data Additional error data (optional)\n%% @returns Standard error response message map\n-spec create_error_response(json_rpc_id(), integer(), binary(), term()) ->\n    transport_message().\ncreate_error_response(Id, Code, Message, Data) ->\n    Error = case Data of\n        undefined ->\n            #{\n                ?JSONRPC_ERROR_FIELD_CODE => Code,\n                ?JSONRPC_ERROR_FIELD_MESSAGE => Message\n            };\n        _ ->\n            #{\n                ?JSONRPC_ERROR_FIELD_CODE => Code,\n                ?JSONRPC_ERROR_FIELD_MESSAGE => Message,\n                ?JSONRPC_ERROR_FIELD_DATA => Data\n            }\n    end,\n    #{\n        ?JSONRPC_FIELD_JSONRPC => ?JSONRPC_VERSION,\n        ?JSONRPC_FIELD_ID => Id,\n        ?JSONRPC_FIELD_ERROR => Error\n    }.\n\n%% @doc Create a transport data event message\n%% @param Data Binary data received from transport\n%% @returns Transport data event message\n-spec create_transport_data_message(binary()) -> transport_event_message().\ncreate_transport_data_message(Data) when is_binary(Data) ->\n    {transport_data, Data}.\n\n%% @doc Create a transport connected event message\n%% @param Info Connection information map\n%% @returns Transport connected event message\n-spec create_transport_connected_message(map()) -> transport_event_message().\ncreate_transport_connected_message(Info) when is_map(Info) ->\n    {transport_connected, Info}.\n\n%% @doc Create a transport disconnected event message\n%% @param Reason Disconnection reason\n%% @returns Transport disconnected event message\n-spec create_transport_disconnected_message(term()) -> transport_event_message().\ncreate_transport_disconnected_message(Reason) ->\n    {transport_disconnected, Reason}.\n\n%% @doc Create a transport error event message\n%% @param Type Error type atom\n%% @param Reason Error reason\n%% @returns Transport error event message\n-spec create_transport_error_message(atom(), term()) -> transport_event_message().\ncreate_transport_error_message(Type, Reason) when is_atom(Type) ->\n    {transport_error, Type, Reason}.\n\n%% @doc Create a basic transport info structure\n%% @param Type Transport type\n%% @param TransportId Unique transport identifier\n%% @returns Basic transport info map\n-spec create_transport_info(atom(), atom()) -> transport_info().\ncreate_transport_info(Type, TransportId) ->\n    Now = erlang:system_time(millisecond),\n    #{\n        type => Type,\n        status => connecting,\n        peer => undefined,\n        version => <<\"1.0\">>,\n        capabilities => [],\n        connection_state => connecting,\n        statistics => #{\n            messages_sent => 0,\n            messages_received => 0,\n            bytes_sent => 0,\n            bytes_received => 0,\n            errors => 0\n        },\n        transport_id => TransportId,\n        started_at => Now,\n        last_activity => Now\n    }.\n\n%% @doc Create a transport info structure with additional options\n%% @param Type Transport type\n%% @param TransportId Unique transport identifier\n%% @param Opts Additional options map\n%% @returns Enhanced transport info map\n-spec create_transport_info(atom(), atom(), map()) -> transport_info().\ncreate_transport_info(Type, TransportId, Opts) when is_map(Opts) ->\n    BaseInfo = create_transport_info(Type, TransportId),\n    maps:merge(BaseInfo, Opts).\n\n%% @doc Update transport info with current activity timestamp\n%% @param Info Current transport info map\n%% @returns Updated transport info map with current timestamp\n-spec update_transport_activity(transport_info()) -> transport_info().\nupdate_transport_activity(Info) when is_map(Info) ->\n    Info#{last_activity => erlang:system_time(millisecond)}.\n\n%% @doc Validate transport info structure\n%% @param Info Transport info map to validate\n%% @returns ok if valid, {error, Reason} if invalid\n-spec validate_transport_info(transport_info()) -> ok | {error, term()}.\nvalidate_transport_info(Info) when is_map(Info) ->\n    RequiredFields = [type, status, transport_id, started_at, last_activity],\n    case validate_required_info_fields(Info, RequiredFields) of\n        ok -> validate_info_field_values(Info);\n        Error -> Error\n    end;\nvalidate_transport_info(_) ->\n    {error, invalid_transport_info_format}.\n\n%% =============================================================================\n%% Validation Helper Functions (Private)\n%% =============================================================================\n\n%% @private\n%% Validate JSON-RPC message fields\n-spec validate_json_rpc_fields(map()) -> ok | {error, term()}.\nvalidate_json_rpc_fields(#{?JSONRPC_FIELD_JSONRPC := Version}) ->\n    case Version of\n        ?JSONRPC_VERSION -> ok;\n        _ -> {error, {invalid_jsonrpc_version, Version}}\n    end;\nvalidate_json_rpc_fields(_) ->\n    {error, missing_jsonrpc_version}.\n\n%% @private  \n%% Validate message content structure\n-spec validate_message_content(map()) -> ok | {error, term()}.\nvalidate_message_content(#{?JSONRPC_FIELD_METHOD := Method}) \n  when is_binary(Method) ->\n    ok;\nvalidate_message_content(#{?JSONRPC_FIELD_RESULT := _}) ->\n    ok;\nvalidate_message_content(#{?JSONRPC_FIELD_ERROR := Error}) \n  when is_map(Error) ->\n    validate_error_structure(Error);\nvalidate_message_content(_) ->\n    {error, invalid_message_structure}.\n\n%% @private\n%% Validate error object structure\n-spec validate_error_structure(map()) -> ok | {error, term()}.\nvalidate_error_structure(#{?JSONRPC_ERROR_FIELD_CODE := Code,\n                          ?JSONRPC_ERROR_FIELD_MESSAGE := Message})\n  when is_integer(Code), is_binary(Message) ->\n    ok;\nvalidate_error_structure(_) ->\n    {error, invalid_error_structure}.\n\n%% @private\n%% Validate stdio transport options\n-spec validate_stdio_opts(map()) -> ok | {error, term()}.\nvalidate_stdio_opts(#{owner := Owner}) when is_pid(Owner) ->\n    ok;\nvalidate_stdio_opts(#{}) ->\n    {error, missing_owner_pid};\nvalidate_stdio_opts(_) ->\n    {error, invalid_stdio_opts}.\n\n%% @private\n%% Validate TCP transport options\n-spec validate_tcp_opts(map()) -> ok | {error, term()}.\nvalidate_tcp_opts(#{host := Host, port := Port, owner := Owner})\n  when is_pid(Owner), is_integer(Port), Port > 0, Port =< 65535 ->\n    case validate_host(Host) of\n        ok -> ok;\n        Error -> Error\n    end;\nvalidate_tcp_opts(#{}) ->\n    {error, missing_required_tcp_opts};\nvalidate_tcp_opts(_) ->\n    {error, invalid_tcp_opts}.\n\n%% @private\n%% Validate HTTP transport options\n-spec validate_http_opts(map()) -> ok | {error, term()}.\nvalidate_http_opts(#{url := Url, owner := Owner}) \n  when is_pid(Owner) ->\n    case validate_url(Url) of\n        ok -> ok;\n        Error -> Error\n    end;\nvalidate_http_opts(#{}) ->\n    {error, missing_required_http_opts};\nvalidate_http_opts(_) ->\n    {error, invalid_http_opts}.\n\n%% @private\n%% Validate WebSocket transport options  \n-spec validate_websocket_opts(map()) -> ok | {error, term()}.\nvalidate_websocket_opts(#{url := Url, owner := Owner})\n  when is_pid(Owner) ->\n    case validate_ws_url(Url) of\n        ok -> ok;\n        Error -> Error\n    end;\nvalidate_websocket_opts(#{}) ->\n    {error, missing_required_websocket_opts};\nvalidate_websocket_opts(_) ->\n    {error, invalid_websocket_opts}.\n\n%% @private\n%% Validate host specification\n-spec validate_host(term()) -> ok | {error, term()}.\nvalidate_host(Host) when is_list(Host) -> ok;\nvalidate_host(Host) when is_binary(Host) -> ok;\nvalidate_host({A, B, C, D}) when \n    is_integer(A), A >= 0, A =< 255,\n    is_integer(B), B >= 0, B =< 255,\n    is_integer(C), C >= 0, C =< 255,\n    is_integer(D), D >= 0, D =< 255 -> ok;\nvalidate_host({A, B, C, D, E, F, G, H}) when\n    is_integer(A), A >= 0, A =< 65535,\n    is_integer(B), B >= 0, B =< 65535,\n    is_integer(C), C >= 0, C =< 65535,\n    is_integer(D), D >= 0, D =< 65535,\n    is_integer(E), E >= 0, E =< 65535,\n    is_integer(F), F >= 0, F =< 65535,\n    is_integer(G), G >= 0, G =< 65535,\n    is_integer(H), H >= 0, H =< 65535 -> ok;\nvalidate_host(_) -> {error, invalid_host}.\n\n%% @private\n%% Validate HTTP URL\n-spec validate_url(term()) -> ok | {error, term()}.\nvalidate_url(Url) when is_binary(Url) ->\n    validate_url(binary_to_list(Url));\nvalidate_url(Url) when is_list(Url) ->\n    case string:prefix(Url, \"http://\") orelse string:prefix(Url, \"https://\") of\n        nomatch -> {error, invalid_http_url};\n        _ -> ok\n    end;\nvalidate_url(_) -> {error, invalid_url_format}.\n\n%% @private\n%% Validate WebSocket URL\n-spec validate_ws_url(term()) -> ok | {error, term()}.\nvalidate_ws_url(Url) when is_binary(Url) ->\n    validate_ws_url(binary_to_list(Url));\nvalidate_ws_url(Url) when is_list(Url) ->\n    case string:prefix(Url, \"ws://\") orelse string:prefix(Url, \"wss://\") of\n        nomatch -> {error, invalid_websocket_url};\n        _ -> ok\n    end;\nvalidate_ws_url(_) -> {error, invalid_url_format}.\n\n%% @private\n%% Validate required transport info fields\n-spec validate_required_info_fields(map(), [atom()]) -> ok | {error, term()}.\nvalidate_required_info_fields(_Info, []) ->\n    ok;\nvalidate_required_info_fields(Info, [Field|Rest]) ->\n    case maps:is_key(Field, Info) of\n        true -> validate_required_info_fields(Info, Rest);\n        false -> {error, {missing_transport_info_field, Field}}\n    end.\n\n%% @private\n%% Validate transport info field values\n-spec validate_info_field_values(map()) -> ok | {error, term()}.\nvalidate_info_field_values(#{type := Type, status := Status, transport_id := Id,\n                           started_at := Started, last_activity := Activity}) ->\n    case validate_transport_type(Type) of\n        ok ->\n            case validate_transport_status(Status) of\n                ok ->\n                    case is_atom(Id) of\n                        true ->\n                            case is_integer(Started) andalso is_integer(Activity) \n                                 andalso Started > 0 andalso Activity > 0 of\n                                true -> ok;\n                                false -> {error, invalid_timestamp}\n                            end;\n                        false -> {error, invalid_transport_id}\n                    end;\n                Error -> Error\n            end;\n        Error -> Error\n    end;\nvalidate_info_field_values(_) ->\n    {error, incomplete_transport_info}.\n\n%% @private\n%% Validate transport type\n-spec validate_transport_type(atom()) -> ok | {error, term()}.\nvalidate_transport_type(Type) when Type =:= stdio; Type =:= tcp; \n                                   Type =:= http; Type =:= websocket;\n                                   Type =:= custom ->\n    ok;\nvalidate_transport_type(_) ->\n    {error, invalid_transport_type}.\n\n%% @private\n%% Validate transport status\n-spec validate_transport_status(atom()) -> ok | {error, term()}.\nvalidate_transport_status(Status) when Status =:= connected; Status =:= disconnected;\n                                        Status =:= connecting; Status =:= error ->\n    ok;\nvalidate_transport_status(_) ->\n    {error, invalid_transport_status}."
        }
    ]
}