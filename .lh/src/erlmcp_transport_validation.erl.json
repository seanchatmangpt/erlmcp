{
    "sourceFile": "src/erlmcp_transport_validation.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1756188161125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1756188161125,
            "name": "Commit-0",
            "content": "%% @doc Transport Validation Module\n%% Provides comprehensive validation for transport configurations\n%% with detailed error reporting and type-specific checks.\n%%\n%% Features:\n%% - Type-specific validation for stdio, tcp, and http transports\n%% - Field presence and format validation\n%% - Enhanced error messages with context\n%% - Integration with main API validation flow\n-module(erlmcp_transport_validation).\n\n%% API\n-export([validate_transport_config/2, validate_transport_config/1, validate_field/3,\n         get_validation_errors/1, is_valid_transport_type/1, get_required_fields/1,\n         get_optional_fields/1]).\n\n-include(\"erlmcp.hrl\").\n\n%% Types\n-type transport_type() :: stdio | tcp | http | websocket | custom.\n-type validation_error() :: {validation_error, atom(), term(), string()}.\n-type validation_result() :: ok | {error, validation_error() | [validation_error()]}.\n\n-export_type([transport_type/0, validation_error/0, validation_result/0]).\n\n%%====================================================================\n%% API Functions\n%%====================================================================\n\n%% @doc Validate transport configuration with type\n-spec validate_transport_config(atom(), map()) -> validation_result().\nvalidate_transport_config(Type, Config) ->\n    validate_transport_config(Config#{type => Type}).\n\n%% @doc Validate transport configuration (expects type in config)\n-spec validate_transport_config(map()) -> validation_result().\nvalidate_transport_config(Config) ->\n    case maps:get(type, Config, undefined) of\n        undefined ->\n            {error, {validation_error, missing_field, type, \"Transport type is required\"}};\n        Type ->\n            case is_valid_transport_type(Type) of\n                true ->\n                    validate_transport_by_type(Type, Config);\n                false ->\n                    ValidTypes = [stdio, tcp, http],\n                    {error,\n                     {validation_error,\n                      invalid_type,\n                      Type,\n                      io_lib:format(\"Unknown transport type. Valid types: ~p\", [ValidTypes])}}\n            end\n    end.\n\n%% @doc Validate a specific field with context\n-spec validate_field(atom(), term(), map()) -> ok | {error, validation_error()}.\nvalidate_field(type, Value, _Context) ->\n    case is_valid_transport_type(Value) of\n        true ->\n            ok;\n        false ->\n            {error, {validation_error, invalid_type, Value, \"Must be one of: stdio, tcp, http\"}}\n    end;\nvalidate_field(host, Value, _Context) ->\n    validate_host_field(Value);\nvalidate_field(port, Value, _Context) ->\n    validate_port_field(Value);\nvalidate_field(url, Value, _Context) ->\n    validate_url_field(Value);\nvalidate_field(server_id, Value, _Context) ->\n    case is_atom(Value) of\n        true ->\n            ok;\n        false ->\n            {error, {validation_error, invalid_type, server_id, \"Server ID must be an atom\"}}\n    end;\nvalidate_field(enabled, Value, _Context) ->\n    case is_boolean(Value) of\n        true ->\n            ok;\n        false ->\n            {error, {validation_error, invalid_type, enabled, \"Enabled flag must be boolean\"}}\n    end;\nvalidate_field(timeout, Value, _Context) ->\n    case is_integer(Value) andalso Value > 0 of\n        true ->\n            ok;\n        false ->\n            {error, {validation_error, invalid_value, timeout, \"Timeout must be positive integer\"}}\n    end;\nvalidate_field(Field, _Value, _Context) ->\n    {error, {validation_error, unknown_field, Field, \"Unknown field\"}}.\n\n%% @doc Get accumulated validation errors from config\n-spec get_validation_errors(map()) -> [validation_error()].\nget_validation_errors(Config) ->\n    case validate_transport_config(Config) of\n        ok ->\n            [];\n        {error, Error} when is_tuple(Error) ->\n            [Error];\n        {error, Errors} when is_list(Errors) ->\n            Errors\n    end.\n\n%% @doc Check if transport type is valid\n-spec is_valid_transport_type(term()) -> boolean().\nis_valid_transport_type(stdio) ->\n    true;\nis_valid_transport_type(tcp) ->\n    true;\nis_valid_transport_type(http) ->\n    true;\nis_valid_transport_type(_) ->\n    false.\n\n%% @doc Get required fields for transport type\n-spec get_required_fields(atom()) -> [atom()].\nget_required_fields(stdio) ->\n    [type];\nget_required_fields(tcp) ->\n    [type, host, port];\nget_required_fields(http) ->\n    [type, url];\nget_required_fields(_) ->\n    [].\n\n%% @doc Get optional fields for transport type\n-spec get_optional_fields(atom()) -> [atom()].\nget_optional_fields(stdio) ->\n    [server_id, buffer_size, timeout, test_mode];\nget_optional_fields(tcp) ->\n    [server_id, keepalive, connect_timeout, max_reconnect_attempts, ssl, certfile, keyfile];\nget_optional_fields(http) ->\n    [server_id, method, headers, timeout, cors, max_content_length];\nget_optional_fields(_) ->\n    [].\n\n%%====================================================================\n%% Internal Functions\n%%====================================================================\n\n%% @doc Validate transport configuration by type\n-spec validate_transport_by_type(atom(), map()) -> validation_result().\nvalidate_transport_by_type(Type, Config) ->\n    RequiredFields = get_required_fields(Type),\n    OptionalFields = get_optional_fields(Type),\n    AllowedFields = RequiredFields ++ OptionalFields,\n\n    case validate_field_presence(Config, RequiredFields) of\n        ok ->\n            case validate_field_allowance(Config, AllowedFields) of\n                ok ->\n                    validate_field_values(Type, Config);\n                Error ->\n                    Error\n            end;\n        Error ->\n            Error\n    end.\n\n%% @doc Validate required fields are present\n-spec validate_field_presence(map(), [atom()]) -> validation_result().\nvalidate_field_presence(Config, RequiredFields) ->\n    MissingFields = [Field || Field <- RequiredFields, not maps:is_key(Field, Config)],\n    case MissingFields of\n        [] ->\n            ok;\n        [Field] ->\n            {error, {validation_error, missing_field, Field, \"Required field is missing\"}};\n        Fields ->\n            {error,\n             {validation_error,\n              missing_fields,\n              Fields,\n              io_lib:format(\"Required fields are missing: ~p\", [Fields])}}\n    end.\n\n%% @doc Validate only allowed fields are present\n-spec validate_field_allowance(map(), [atom()]) -> validation_result().\nvalidate_field_allowance(Config, AllowedFields) ->\n    ConfigFields = maps:keys(Config),\n    UnknownFields = [Field || Field <- ConfigFields, not lists:member(Field, AllowedFields)],\n    case UnknownFields of\n        [] ->\n            ok;\n        [Field] ->\n            {error,\n             {validation_error,\n              unknown_field,\n              Field,\n              io_lib:format(\"Unknown field. Allowed: ~p\", [AllowedFields])}};\n        Fields ->\n            {error,\n             {validation_error,\n              unknown_fields,\n              Fields,\n              io_lib:format(\"Unknown fields: ~p. Allowed: ~p\", [Fields, AllowedFields])}}\n    end.\n\n%% @doc Validate field values based on transport type\n-spec validate_field_values(atom(), map()) -> validation_result().\nvalidate_field_values(stdio, Config) ->\n    validate_stdio_fields(Config);\nvalidate_field_values(tcp, Config) ->\n    validate_tcp_fields(Config);\nvalidate_field_values(http, Config) ->\n    validate_http_fields(Config).\n\n%% @doc Validate STDIO-specific fields\n-spec validate_stdio_fields(map()) -> validation_result().\nvalidate_stdio_fields(Config) ->\n    Validations =\n        [validate_optional_field(buffer_size, Config, fun validate_buffer_size/1),\n         validate_optional_field(timeout, Config, fun validate_timeout/1),\n         validate_optional_field(test_mode, Config, fun validate_boolean_field/1),\n         validate_optional_field(server_id, Config, fun validate_server_id/1)],\n    collect_validation_results(Validations).\n\n%% @doc Validate TCP-specific fields\n-spec validate_tcp_fields(map()) -> validation_result().\nvalidate_tcp_fields(Config) ->\n    Validations =\n        [validate_field(host, maps:get(host, Config), Config),\n         validate_field(port, maps:get(port, Config), Config),\n         validate_optional_field(keepalive, Config, fun validate_boolean_field/1),\n         validate_optional_field(connect_timeout, Config, fun validate_timeout/1),\n         validate_optional_field(max_reconnect_attempts, Config, fun validate_non_negative_int/1),\n         validate_optional_field(ssl, Config, fun validate_ssl_config/1),\n         validate_optional_field(server_id, Config, fun validate_server_id/1)],\n    collect_validation_results(Validations).\n\n%% @doc Validate HTTP-specific fields\n-spec validate_http_fields(map()) -> validation_result().\nvalidate_http_fields(Config) ->\n    Validations =\n        [validate_field(url, maps:get(url, Config), Config),\n         validate_optional_field(method, Config, fun validate_http_method/1),\n         validate_optional_field(headers, Config, fun validate_http_headers/1),\n         validate_optional_field(timeout, Config, fun validate_timeout/1),\n         validate_optional_field(cors, Config, fun validate_cors_config/1),\n         validate_optional_field(max_content_length, Config, fun validate_positive_int/1),\n         validate_optional_field(server_id, Config, fun validate_server_id/1)],\n    collect_validation_results(Validations).\n\n%% @doc Validate optional field if present\n-spec validate_optional_field(atom(), map(), fun((term()) -> validation_result())) ->\n                                 validation_result().\nvalidate_optional_field(Field, Config, ValidatorFun) ->\n    case maps:get(Field, Config, undefined) of\n        undefined ->\n            ok;\n        Value ->\n            case ValidatorFun(Value) of\n                ok ->\n                    ok;\n                {error, {validation_error, ErrorType, _, Message}} ->\n                    {error, {validation_error, ErrorType, Field, Message}};\n                {error, Error} ->\n                    {error, {validation_error, invalid_value, Field, io_lib:format(\"~p\", [Error])}}\n            end\n    end.\n\n%% @doc Collect and combine validation results\n-spec collect_validation_results([validation_result()]) -> validation_result().\ncollect_validation_results(Results) ->\n    Errors = [Error || {error, Error} <- Results],\n    case Errors of\n        [] ->\n            ok;\n        [SingleError] ->\n            {error, SingleError};\n        MultipleErrors ->\n            {error, MultipleErrors}\n    end.\n\n%%====================================================================\n%% Field Validation Functions\n%%====================================================================\n\n%% @doc Validate host field\n-spec validate_host_field(term()) -> validation_result().\nvalidate_host_field(Host) when is_binary(Host) ->\n    case byte_size(Host) > 0 of\n        true ->\n            ok;\n        false ->\n            {error, {validation_error, invalid_value, host, \"Host cannot be empty\"}}\n    end;\nvalidate_host_field(Host) when is_list(Host) ->\n    case length(Host) > 0 of\n        true ->\n            ok;\n        false ->\n            {error, {validation_error, invalid_value, host, \"Host cannot be empty\"}}\n    end;\nvalidate_host_field(_) ->\n    {error, {validation_error, invalid_type, host, \"Host must be string or binary\"}}.\n\n%% @doc Validate port field\n-spec validate_port_field(term()) -> validation_result().\nvalidate_port_field(Port) when is_integer(Port), Port > 0, Port =< 65535 ->\n    ok;\nvalidate_port_field(Port) when is_integer(Port) ->\n    {error, {validation_error, invalid_value, port, \"Port must be between 1 and 65535\"}};\nvalidate_port_field(_) ->\n    {error, {validation_error, invalid_type, port, \"Port must be integer\"}}.\n\n%% @doc Validate URL field\n-spec validate_url_field(term()) -> validation_result().\nvalidate_url_field(Url) when is_binary(Url) ->\n    case validate_url_format(Url) of\n        true ->\n            ok;\n        false ->\n            {error, {validation_error, invalid_value, url, \"Must be valid HTTP/HTTPS URL\"}}\n    end;\nvalidate_url_field(Url) when is_list(Url) ->\n    case validate_url_format(list_to_binary(Url)) of\n        true ->\n            ok;\n        false ->\n            {error, {validation_error, invalid_value, url, \"Must be valid HTTP/HTTPS URL\"}}\n    end;\nvalidate_url_field(_) ->\n    {error, {validation_error, invalid_type, url, \"URL must be string or binary\"}}.\n\n%% @doc Simple URL format validation\n-spec validate_url_format(binary()) -> boolean().\nvalidate_url_format(Url) ->\n    case binary:split(Url, <<\"://\">>) of\n        [Scheme, Rest] when Scheme =:= <<\"http\">>; Scheme =:= <<\"https\">> ->\n            byte_size(Rest) > 0;\n        _ ->\n            false\n    end.\n\n%% @doc Validate buffer size\n-spec validate_buffer_size(term()) -> validation_result().\nvalidate_buffer_size(Size) when is_integer(Size), Size > 0 ->\n    ok;\nvalidate_buffer_size(_) ->\n    {error, {validation_error, invalid_type, buffer_size, \"Must be positive integer\"}}.\n\n%% @doc Validate timeout value\n-spec validate_timeout(term()) -> validation_result().\nvalidate_timeout(Timeout) when is_integer(Timeout), Timeout > 0 ->\n    ok;\nvalidate_timeout(infinity) ->\n    ok;\nvalidate_timeout(_) ->\n    {error,\n     {validation_error, invalid_value, timeout, \"Must be positive integer or 'infinity'\"}}.\n\n%% @doc Validate boolean field\n-spec validate_boolean_field(term()) -> validation_result().\nvalidate_boolean_field(Value) when is_boolean(Value) ->\n    ok;\nvalidate_boolean_field(_) ->\n    {error, {validation_error, invalid_type, boolean, \"Must be boolean\"}}.\n\n%% @doc Validate server ID\n-spec validate_server_id(term()) -> validation_result().\nvalidate_server_id(ServerId) when is_atom(ServerId) ->\n    ok;\nvalidate_server_id(_) ->\n    {error, {validation_error, invalid_type, server_id, \"Must be atom\"}}.\n\n%% @doc Validate non-negative integer\n-spec validate_non_negative_int(term()) -> validation_result().\nvalidate_non_negative_int(Value) when is_integer(Value), Value >= 0 ->\n    ok;\nvalidate_non_negative_int(_) ->\n    {error,\n     {validation_error, invalid_value, non_negative_int, \"Must be non-negative integer\"}}.\n\n%% @doc Validate positive integer\n-spec validate_positive_int(term()) -> validation_result().\nvalidate_positive_int(Value) when is_integer(Value), Value > 0 ->\n    ok;\nvalidate_positive_int(_) ->\n    {error, {validation_error, invalid_value, positive_int, \"Must be positive integer\"}}.\n\n%% @doc Validate SSL configuration\n-spec validate_ssl_config(term()) -> validation_result().\nvalidate_ssl_config(false) ->\n    ok;\nvalidate_ssl_config(true) ->\n    ok;\nvalidate_ssl_config(Config) when is_map(Config) ->\n    RequiredSslFields = [certfile, keyfile],\n    case validate_field_presence(Config, RequiredSslFields) of\n        ok ->\n            validate_ssl_file_fields(Config);\n        Error ->\n            Error\n    end;\nvalidate_ssl_config(_) ->\n    {error, {validation_error, invalid_type, ssl, \"Must be boolean or SSL config map\"}}.\n\n%% @doc Validate SSL file fields\n-spec validate_ssl_file_fields(map()) -> validation_result().\nvalidate_ssl_file_fields(Config) ->\n    Validations =\n        [validate_file_field(certfile, maps:get(certfile, Config)),\n         validate_file_field(keyfile, maps:get(keyfile, Config))],\n    collect_validation_results(Validations).\n\n%% @doc Validate file field\n-spec validate_file_field(atom(), term()) -> validation_result().\nvalidate_file_field(Field, Path) when is_list(Path); is_binary(Path) ->\n    case filelib:is_file(Path) of\n        true ->\n            ok;\n        false ->\n            {error,\n             {validation_error, file_not_found, Field, io_lib:format(\"File not found: ~s\", [Path])}}\n    end;\nvalidate_file_field(Field, _) ->\n    {error, {validation_error, invalid_type, Field, \"Must be valid file path\"}}.\n\n%% @doc Validate HTTP method\n-spec validate_http_method(term()) -> validation_result().\nvalidate_http_method(Method)\n    when Method =:= get;\n         Method =:= post;\n         Method =:= put;\n         Method =:= delete;\n         Method =:= patch;\n         Method =:= head;\n         Method =:= options ->\n    ok;\nvalidate_http_method(_) ->\n    ValidMethods = [get, post, put, delete, patch, head, options],\n    {error,\n     {validation_error,\n      invalid_value,\n      http_method,\n      io_lib:format(\"Must be one of: ~p\", [ValidMethods])}}.\n\n%% @doc Validate HTTP headers\n-spec validate_http_headers(term()) -> validation_result().\nvalidate_http_headers(Headers) when is_map(Headers) ->\n    try\n        maps:fold(fun(Key, Value, _Acc) ->\n                     case {is_valid_header_key(Key), is_valid_header_value(Value)} of\n                         {true, true} -> ok;\n                         {false, _} -> throw({invalid_header_key, Key});\n                         {_, false} -> throw({invalid_header_value, Value})\n                     end\n                  end,\n                  ok,\n                  Headers),\n        ok\n    catch\n        {invalid_header_key, Key} ->\n            {error,\n             {validation_error, invalid_header_key, Key, \"Header key must be string or binary\"}};\n        {invalid_header_value, Value} ->\n            {error,\n             {validation_error,\n              invalid_header_value,\n              Value,\n              \"Header value must be string or binary\"}}\n    end;\nvalidate_http_headers(_) ->\n    {error, {validation_error, invalid_type, headers, \"Must be map\"}}.\n\n%% @doc Check if header key is valid\n-spec is_valid_header_key(term()) -> boolean().\nis_valid_header_key(Key) when is_binary(Key); is_list(Key) ->\n    true;\nis_valid_header_key(_) ->\n    false.\n\n%% @doc Check if header value is valid\n-spec is_valid_header_value(term()) -> boolean().\nis_valid_header_value(Value) when is_binary(Value); is_list(Value) ->\n    true;\nis_valid_header_value(_) ->\n    false.\n\n%% @doc Validate CORS configuration\n-spec validate_cors_config(term()) -> validation_result().\nvalidate_cors_config(false) ->\n    ok;\nvalidate_cors_config(true) ->\n    ok;\nvalidate_cors_config(Origins) when is_list(Origins) ->\n    try\n        lists:foreach(fun(Origin) ->\n                         case is_list(Origin) orelse is_binary(Origin) of\n                             true -> ok;\n                             false -> throw({invalid_origin, Origin})\n                         end\n                      end,\n                      Origins),\n        ok\n    catch\n        {invalid_origin, Origin} ->\n            {error,\n             {validation_error, invalid_origin, Origin, \"CORS origin must be string or binary\"}}\n    end;\nvalidate_cors_config(_) ->\n    {error,\n     {validation_error, invalid_type, cors, \"Must be boolean or list of origin strings\"}}.\n"
        }
    ]
}